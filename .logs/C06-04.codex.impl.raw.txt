Status: DONE

Summary of changes:
- Centralized uninstall logic in `src/Plugin/Uninstall.php`, expanded option cleanup, and added multisite-aware site iteration helpers.
- Updated `uninstall.php` to delegate to the new uninstall helper.
- Documented multisite activation/upgrade/uninstall expectations in `docs/MULTISITE.md` and expanded FAQ guidance in `docs/FAQ.md`.
- Added unit tests for uninstall option key coverage and multisite helper behavior in `tests/Unit/Plugin/UninstallTest.php`.

How to verify (exact commands):
- No verification commands provided.

Risks / follow-ups:
- Uninstall still iterates all sites on multisite; large networks may take longer (documented in `docs/MULTISITE.md`).

Next steps:
1) Run `vendor/bin/phpunit` if you want to exercise the new unit tests.

OpenAI Codex v0.87.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/agentwp
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019bd25d-51b7-7933-aa52-0a5a95f107ce
--------
user
You are implementing task C06-04 in this git repository.

1) Read the spec: .plans/C06-04.md
2) Read handoff/context: .t2/handoff/C06-04.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: 
- test: 

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers
exec
/bin/zsh -lc ls in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 41ms:
agentwp.php
assets
composer.json
composer.lock
docker
docker-compose.demo.yml
docker-compose.yml
docs
includes
languages
node_modules
package-lock.json
package.json
phpcs.xml
phpstan
phpstan.neon
phpunit.xml.dist
plan_tasks.csv
playwright.config.cjs
react
exec
/bin/zsh -lc 'cat .plans/C06-04.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
# C06-04 — Multisite behavior documentation + audit

Document network activation/upgrade/uninstall expectations and audit `uninstall.php` for multisite correctness. Add tests where feasible (e.g., option key lists, helper behavior under mocked multisite).
exec
/bin/zsh -lc 'cat .t2/handoff/C06-04.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
# Handoff: C06-04

Created: 2026-01-18T18:28:09.756611Z

Spec: .plans/C06-04.md

thinking
**Searching for uninstall script and multisite docs**
exec
/bin/zsh -lc 'rg "multisite|network" -n uninstall.php src includes docs tests' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 64ms:
uninstall.php:73:if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
uninstall.php:90:if ( is_multisite() ) {
src/Plugin.php:228:		if ( is_multisite() ) {
docs/compatibility.md:32:- AgentWP supports multisite when WooCommerce is active on the target site.
docs/compatibility.md:41:Extended checks (conflict plugins, caching headers, multisite):
docs/FAQ.md:33:## 11) Can I use AgentWP on multisite?
tests/e2e/woocommerce-mount.spec.js:14:    await page.waitForLoadState('networkidle');
tests/e2e/woocommerce-mount.spec.js:25:    await page.waitForLoadState('networkidle');
tests/e2e/woocommerce-mount.spec.js:35:    await page.waitForLoadState('networkidle');
tests/e2e/woocommerce-mount.spec.js:45:    await page.waitForLoadState('networkidle');
tests/e2e/woocommerce-mount.spec.js:56:    await page.waitForLoadState('networkidle');
tests/e2e/woocommerce-mount.spec.js:75:    await page.waitForLoadState('networkidle');
tests/e2e/woocommerce-mount.spec.js:102:    await page.waitForLoadState('networkidle');
tests/e2e/woocommerce-mount.spec.js:115:    await page.waitForLoadState('networkidle');
docs/OPERATIONAL-KNOBS.md:154:- On multisite, purge times are jittered per site to avoid simultaneous load spikes.
docs/API.md:67:| `agentwp_network_error` | Network connectivity issue |
docs/ARCHITECTURE-IMPROVEMENT-PLAN.md:149:  - Document network activation expectations
docs/ARCHITECTURE-IMPROVEMENT-PLAN.md:150:  - Ensure uninstall/cleanup remains correct per-site and network-wide
src/Error/Handler.php:11:	const TYPE_NETWORK    = 'network_error';
tests/bootstrap.php:151:if ( ! function_exists( 'is_multisite' ) ) {

thinking
**Opening uninstall script for audit**
exec
/bin/zsh -lc 'cat uninstall.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * Plugin uninstall cleanup.
 *
 * @package AgentWP
 */

if ( ! defined( 'WP_UNINSTALL_PLUGIN' ) ) {
	exit;
}

global $wpdb;

if ( ! $wpdb ) {
	return;
}

/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */

$option_keys = array(

thinking
**Auditing multisite uninstall logic**

Noted indentation issues but confirmed uninstall loops multisite sites and cleans options/tables. Next, I'll verify correct $wpdb->prefix handling on blog switch and check if plugin creates any network-wide tables needing special cleanup.
exec
/bin/zsh -lc 'rg "agentwp_usage|agentwp_search_index" -n src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
src/Billing/UsageTracker.php:17:	const TABLE          = 'agentwp_usage';
src/Billing/UsageTracker.php:19:	const VERSION_OPTION = 'agentwp_usage_version';
src/Billing/UsageTracker.php:21:	const PURGE_HOOK     = 'agentwp_usage_purge';
src/Billing/UsageTracker.php:22:	const PURGE_LAST_RUN_OPTION = 'agentwp_usage_purge_last_run';
src/Search/Index.php:16:	const TABLE           = 'agentwp_search_index';
src/Search/Index.php:18:	const VERSION_OPTION  = 'agentwp_search_index_version';
src/Search/Index.php:19:	const STATE_OPTION    = 'agentwp_search_index_state';
src/Search/Index.php:22:	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
src/Plugin/SettingsManager.php:29:	public const OPTION_USAGE_STATS        = 'agentwp_usage_stats';
exec
/bin/zsh -lc "sed -n '1,240p' src/Billing/UsageTracker.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Track OpenAI usage and costs.
 *
 * @package AgentWP
 */

namespace AgentWP\Billing;

use AgentWP\AI\Model;
use AgentWP\Config\AgentWPConfig;
use DateInterval;
use DateTimeImmutable;
use DateTimeZone;

class UsageTracker {
	const TABLE          = 'agentwp_usage';
	const VERSION        = '1.0';
	const VERSION_OPTION = 'agentwp_usage_version';
	const TOKEN_SCALE    = 1000000;

thinking
**Reviewing uninstall options**

I'm checking the list of agentwp_ options to ensure uninstall handles new options like usage purge timestamps and search index backfill, which aren't currently included.
exec
/bin/zsh -lc 'rg "agentwp_[a-z0-9_]+" -n src includes | head -n 200' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/Plugin/SettingsManager.php:22:	public const OPTION_SETTINGS           = 'agentwp_settings';
src/Plugin/SettingsManager.php:23:	public const OPTION_API_KEY            = 'agentwp_api_key';
src/Plugin/SettingsManager.php:24:	public const OPTION_API_KEY_LAST4      = 'agentwp_api_key_last4';
src/Plugin/SettingsManager.php:25:	public const OPTION_DEMO_API_KEY       = 'agentwp_demo_api_key';
src/Plugin/SettingsManager.php:26:	public const OPTION_DEMO_API_KEY_LAST4 = 'agentwp_demo_api_key_last4';
src/Plugin/SettingsManager.php:27:	public const OPTION_BUDGET_LIMIT       = 'agentwp_budget_limit';
src/Plugin/SettingsManager.php:28:	public const OPTION_DRAFT_TTL          = 'agentwp_draft_ttl_minutes';
src/Plugin/SettingsManager.php:29:	public const OPTION_USAGE_STATS        = 'agentwp_usage_stats';
src/Plugin/SettingsManager.php:30:	public const OPTION_MEMORY_LIMIT       = 'agentwp_memory_limit';
src/Plugin/SettingsManager.php:31:	public const OPTION_MEMORY_TTL         = 'agentwp_memory_ttl';
src/Billing/UsageTracker.php:17:	const TABLE          = 'agentwp_usage';
src/Billing/UsageTracker.php:19:	const VERSION_OPTION = 'agentwp_usage_version';
src/Billing/UsageTracker.php:21:	const PURGE_HOOK     = 'agentwp_usage_purge';
src/Billing/UsageTracker.php:22:	const PURGE_LAST_RUN_OPTION = 'agentwp_usage_purge_last_run';
src/Billing/UsageTracker.php:30:	 * Configurable via 'agentwp_config_usage_retention_days' filter.
src/Billing/UsageTracker.php:41:	 * Configurable via 'agentwp_config_usage_query_max_rows' filter.
src/Billing/UsageTracker.php:227:		// Configurable via 'agentwp_config_usage_query_max_rows' filter.
src/Plugin/SchemaManager.php:31:	const OPTION_SCHEMA_VERSION = 'agentwp_schema_version';
src/Plugin/ThemeManager.php:18:	public const THEME_META_KEY = 'agentwp_theme_preference';
src/Plugin/Upgrader.php:26:	const OPTION_INSTALLED_VERSION = 'agentwp_installed_version';

thinking
**Auditing uninstall and scheduled hooks**

Noticed some important option keys and scheduled hooks missing from uninstall cleanup, including usage purge and search backfill. Planning to verify scheduling in Search/Index code and check multisite correctness, plus review activation and uninstall docs for necessary updates. Next, inspecting Plugin.php for activation handling.
exec
/bin/zsh -lc "sed -n '1,260p' src/Plugin.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 31ms:
<?php
/**
 * Core plugin bootstrap.
 *
 * @package AgentWP
 */

namespace AgentWP;

use AgentWP\Container\Container;
use AgentWP\Container\ContainerInterface;
use AgentWP\Container\ServiceProvider;
use AgentWP\Plugin\SettingsManager;
use AgentWP\Providers\CoreServiceProvider;
use AgentWP\Providers\InfrastructureServiceProvider;
use AgentWP\Providers\IntentServiceProvider;
use AgentWP\Providers\RestServiceProvider;
use AgentWP\Providers\ServicesServiceProvider;

class Plugin {

thinking
**Checking activation scope**

Noticed the current activation only affects the single site by adding options; next I'll check for any network-wide activation hooks in the main plugin file.
exec
/bin/zsh -lc 'rg "register_activation_hook|register_deactivation_hook|register_uninstall_hook" -n agentwp.php src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 60ms:
agentwp.php:49:register_activation_hook( __FILE__, array( 'AgentWP\\Plugin', 'activate' ) );
agentwp.php:50:register_deactivation_hook( __FILE__, array( 'AgentWP\\Plugin', 'deactivate' ) );

thinking
**Clarifying multisite activation behavior**

I'm confirming network activation runs once without parameters, so no built-in network-wide hook support. I'll update documentation to clarify activation expectations and audit uninstall and options handling for multisite compatibility. Next, I'll inspect option keys via add_option to ensure comprehensive cleanup.
exec
/bin/zsh -lc "rg \"add_option\\(|update_option\\(|delete_option\\(|get_option\\(\" -n src includes | rg \"agentwp_\"" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
src/Infrastructure/WordPressOptions.php:60:		$value = get_option( $this->prefixKey( $key ), '__agentwp_not_found__' );

thinking
**Inspecting settings and options classes**
exec
/bin/zsh -lc "sed -n '1,220p' src/Plugin/SettingsManager.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
<?php
/**
 * Settings manager.
 *
 * @package AgentWP\Plugin
 */

namespace AgentWP\Plugin;

use AgentWP\Config\AgentWPConfig;
use AgentWP\Contracts\OptionsInterface;
use AgentWP\Security\ApiKeyStorage;

/**
 * Manages plugin settings and defaults.
 */
class SettingsManager {

	/**
	 * Option keys.

thinking
**Reviewing uninstall cleanup scope**

I'm identifying that uninstall should remove several keys including memory_limit, memory_ttl, schema_version, usage_purge_last_run, and search_index_backfill_heartbeat, and now I'll check options managed by SchemaManager for further cleanup targets.
exec
/bin/zsh -lc "sed -n '1,220p' src/Plugin/SchemaManager.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Centralized schema management for database tables.
 *
 * @package AgentWP\Plugin
 */

namespace AgentWP\Plugin;

use AgentWP\Billing\UsageTracker;
use AgentWP\Search\Index;

/**
 * Manages database schema creation and upgrades.
 *
 * This class provides a single entry point for all schema operations,
 * ensuring tables are created/upgraded consistently during:
 * - First-time plugin activation (via activate())
 * - Plugin upgrades (via Upgrader steps)
 * - Runtime fallback (via ensure_tables())

thinking
**Noticing missing uninstall option**

The uninstall process lacks the schema version option; next, I'll check the Search/Index areas for any related options or hooks that might handle this.
exec
/bin/zsh -lc "sed -n '1,220p' src/Search/Index.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * Search index management.
 *
 * @package AgentWP
 */

namespace AgentWP\Search;

use AgentWP\Config\AgentWPConfig;
use AgentWP\Plugin;

// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching -- Custom search index relies on direct SQL; caching/invalidation is managed by the index lifecycle.

class Index {
	const TABLE           = 'agentwp_search_index';
	const VERSION         = '1.0';
	const VERSION_OPTION  = 'agentwp_search_index_version';
	const STATE_OPTION    = 'agentwp_search_index_state';
	const BACKFILL_HOOK   = 'agentwp_search_backfill';

thinking
**Assessing uninstall cleanup scope**

I'm reviewing how uninstall clears schedules and options, noticing it deletes transients by prefix and should also clear cron hooks and locks; I'll check option updates across the code and explore the WordPressOptions infrastructure next.
exec
/bin/zsh -lc "sed -n '1,200p' src/Infrastructure/WordPressOptions.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
<?php
/**
 * WordPress options adapter.
 *
 * @package AgentWP\Infrastructure
 */

namespace AgentWP\Infrastructure;

use AgentWP\Contracts\OptionsInterface;

/**
 * Wraps WordPress options functions.
 */
final class WordPressOptions implements OptionsInterface {

	/**
	 * Option name prefix.
	 *
	 * @var string

thinking
**Clarifying option key usage**

I found that option keys in SettingsManager use plain keys without prefixes, while WordPressOptions may use prefixes for other stored options; next, I'll search for new WordPressOptions usage to see where prefixed keys apply.
exec
/bin/zsh -lc 'rg "WordPressOptions" -n src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
src/Infrastructure/WordPressOptions.php:15:final class WordPressOptions implements OptionsInterface {
src/Infrastructure/WordPressOptions.php:25:	 * Create a new WordPressOptions.
src/Providers/CoreServiceProvider.php:14:use AgentWP\Infrastructure\WordPressOptions;
src/Providers/CoreServiceProvider.php:69:			fn() => new WordPressOptions( '' ) // No prefix - use raw option names.
exec
/bin/zsh -lc "sed -n '1,120p' src/Providers/CoreServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Core service provider.
 *
 * @package AgentWP\Providers
 */

namespace AgentWP\Providers;

use AgentWP\Container\ServiceProvider;
use AgentWP\Contracts\HooksInterface;
use AgentWP\Contracts\OptionsInterface;
use AgentWP\Contracts\WPUserFunctionsInterface;
use AgentWP\Infrastructure\WordPressOptions;
use AgentWP\Infrastructure\WPFunctions;
use AgentWP\Intent\HandlerRegistry;
use AgentWP\Intent\ContextProviders\UserContextProvider;
use AgentWP\Intent\ContextProviders\OrderContextProvider;
use AgentWP\Intent\ContextProviders\StoreContextProvider;
use AgentWP\Plugin\AdminMenuManager;

thinking
**Identifying missing uninstall options**

I found that schema version, memory limit, TTL, usage purge last run, and possibly usage purge schedule are missing from uninstall options, while order cache version and installed version are included; next, I'll locate additional option keys like agentwp_order_cache_version to ensure thorough cleanup.
exec
/bin/zsh -lc 'rg "agentwp_order_cache_version|order_cache" -n src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
src/Services/OrderSearch/OrderQueryService.php:44:	private const VERSION_OPTION = 'order_cache_version';
exec
/bin/zsh -lc "sed -n '1,120p' src/Services/OrderSearch/OrderQueryService.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * Order query service.
 *
 * @package AgentWP\Services\OrderSearch
 */

namespace AgentWP\Services\OrderSearch;

use AgentWP\Config\AgentWPConfig;
use AgentWP\Contracts\CacheInterface;
use AgentWP\Contracts\OptionsInterface;
use AgentWP\Contracts\OrderRepositoryInterface;
use AgentWP\Contracts\TransientCacheInterface;
use AgentWP\DTO\OrderDTO;
use AgentWP\DTO\OrderQuery;
use AgentWP\DTO\OrderQuerySummaryDTO;
use AgentWP\DTO\OrderSearchResultsDTO;
use AgentWP\DTO\ServiceResult;


thinking
**Investigating option key prefix inconsistency**

I've found the version option key uses 'order_cache_version' without a prefix, while the uninstall list includes 'agentwp_order_cache_version', indicating inconsistency that might cause uninstall cleanup issues; next, I'll search all references to 'order_cache_version' to confirm the actual usage.
exec
/bin/zsh -lc 'rg "order_cache_version" -n src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
src/Services/OrderSearch/OrderQueryService.php:44:	private const VERSION_OPTION = 'order_cache_version';


thinking
**Identifying uninstall option key inconsistency**

I found the uninstall list uses a prefixed key that likely isn't used, while the actual option key is unprefixed, suggesting a bug. Next, I'll prepare to include both keys safely in uninstall and consider adding helper functions and unit tests to better isolate and verify uninstall cleanup, especially for multisite correctness.
thinking
**Planning uninstall refactor for testability**

I'm considering extracting the uninstall option keys and multisite cleanup into a new class or helper for unit testing, then requiring it in the procedural uninstall.php to avoid globals. Next, I'll check composer autoload to confirm if new classes can load cleanly.
exec
/bin/zsh -lc 'cat composer.json' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
{
  "name": "agentwp/agentwp",
  "description": "AgentWP WordPress plugin.",
  "type": "wordpress-plugin",
  "license": "GPL-2.0-or-later",
  "autoload": {
    "psr-4": {
      "AgentWP\\": "src/"
    }
  },
  "require": {
    "php": ">=8.0",
    "yethee/tiktoken": "^0.1.2"
  },
  "require-dev": {
    "10up/wp_mock": "^1.0",
    "automattic/vipwpcs": "^3.0",
    "dealerdirect/phpcodesniffer-composer-installer": "^1.0",
    "mockery/mockery": "^1.6",
    "phpstan/phpstan": "^1.10",


thinking
**Analyzing uninstall.php autoload constraints**

Uninstall.php runs without autoloading and WordPress loads it directly, so requiring vendor/autoload.php there is risky and may be unavailable. To enable testing, helper functions should live inside uninstall.php but be separate from side-effect code, allowing safe inclusion after defining the necessary constant, avoiding unintended deletions during tests.
thinking
**Refactoring uninstall to use class with manual require**

Planning to move uninstall logic into a static class in src, then have uninstall.php manually require that class file and call its run method—avoiding autoload dependencies. This keeps uninstall safe and testable by letting tests load the class while mocking WP functions as needed.
exec
/bin/zsh -lc "sed -n '1,220p' tests/bootstrap.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
<?php
/**
 * PHPUnit bootstrap for AgentWP.
 */

// Suppress deprecation warnings (WP_Mock compatibility with PHP 8.4).
error_reporting( E_ALL & ~E_DEPRECATED );

require dirname( __DIR__ ) . '/vendor/autoload.php';

if ( ! class_exists( 'WP_Error' ) ) {
	class WP_Error {
		private $errors = array();
		private $error_data = array();

		public function __construct( $code = '', $message = '', $data = '' ) {
			if ( ! empty( $code ) ) {
				$this->add( $code, $message, $data );
			}
		}

thinking
**Inspecting test mocking approaches**

I identified that WP_Mock is not included in the bootstrap, but some tests use Mockery; next, I'll examine the unit test structure to understand mocking strategies.
exec
/bin/zsh -lc 'ls tests/Unit/Plugin' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 37ms:
SchemaManagerTest.php
SettingsManagerMemoryTest.php
UpgraderBehaviorTest.php
UpgraderMigrationTest.php
UpgraderTest.php

thinking
**Planning tests for new class**

Considering adding tests for the new Uninstall class and checking test style by reviewing SchemaManagerTest as a reference.
exec
/bin/zsh -lc "sed -n '1,220p' tests/Unit/Plugin/SchemaManagerTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * SchemaManager unit tests.
 *
 * @package AgentWP\Tests\Unit\Plugin
 */

namespace AgentWP\Tests\Unit\Plugin;

use AgentWP\Billing\UsageTracker;
use AgentWP\Plugin\SchemaManager;
use AgentWP\Search\Index;
use AgentWP\Tests\TestCase;
use ReflectionClass;

/**
 * Unit tests for SchemaManager.
 *
 * Tests validate the schema management functionality including:
 * - Option naming conventions

thinking
**Reviewing test structure**

I'll examine the existing test case that may use WP_Mock to understand current test styles and prepare to add new class tests for the Uninstall helper accordingly.
exec
/bin/zsh -lc "sed -n '1,200p' tests/TestCase.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Base test case for AgentWP.
 */

namespace AgentWP\Tests;

use WP_Mock\Tools\TestCase as WP_Mock_TestCase;

class TestCase extends WP_Mock_TestCase {
}


thinking
**Planning uninstall helper design**

I'm outlining a new uninstall class with methods to list option keys and handle cleanup, aiming for unified per-site and network option handling. I'll include multisite-aware cleanup logic controllable for testing by mocking multisite conditions.
thinking
**Designing testable multisite cleanup**

I'm planning to add a static `run()` method to orchestrate cleanup using injected or abstracted multisite checks for easier testing. I'll create a method to get site IDs for cleanup that can be reliably mocked, avoiding unmockable native calls like `function_exists`.
exec
/bin/zsh -lc 'rg "multisite" -n src/Plugin' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
src/Plugin/Upgrader.php:226:	 * Run upgrades on all sites in a multisite network.
src/Plugin/Upgrader.php:237:		if ( ! is_multisite() ) {
src/Plugin/Upgrader.php:250:			// phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog -- Required for multisite upgrade.


thinking
**Planning uninstall helper design**

I'm considering implementing uninstall logic in a dedicated class with methods for multisite checks and site ID retrieval, factoring in testability challenges around mocking built-in functions like `function_exists` and `is_multisite`. Next, I'll explore WP_Mock's capabilities for overriding these functions to enable effective testing.
thinking
**Designing uninstall class with testable multisite detection**

I'm outlining an uninstall class that uses optional callables for multisite detection and site retrieval to avoid mocking built-in functions in tests while safely handling multisite vs single-site environments. The `run` method will loop over sites if multisite and clean up options, user meta, and scheduled hooks accordingly, with careful checks for required WP functions to avoid errors.
exec
/bin/zsh -lc 'rg "agentwp_" -n src/Plugin src/Services src/Billing src/Search | rg "option|OPTION"' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
src/Search/Index.php:18:	const VERSION_OPTION  = 'agentwp_search_index_version';
src/Search/Index.php:19:	const STATE_OPTION    = 'agentwp_search_index_state';
src/Search/Index.php:22:	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
src/Billing/UsageTracker.php:19:	const VERSION_OPTION = 'agentwp_usage_version';
src/Billing/UsageTracker.php:22:	const PURGE_LAST_RUN_OPTION = 'agentwp_usage_purge_last_run';
src/Plugin/SettingsManager.php:22:	public const OPTION_SETTINGS           = 'agentwp_settings';
src/Plugin/SettingsManager.php:23:	public const OPTION_API_KEY            = 'agentwp_api_key';
src/Plugin/SettingsManager.php:24:	public const OPTION_API_KEY_LAST4      = 'agentwp_api_key_last4';
src/Plugin/SettingsManager.php:25:	public const OPTION_DEMO_API_KEY       = 'agentwp_demo_api_key';
src/Plugin/SettingsManager.php:26:	public const OPTION_DEMO_API_KEY_LAST4 = 'agentwp_demo_api_key_last4';
src/Plugin/SettingsManager.php:27:	public const OPTION_BUDGET_LIMIT       = 'agentwp_budget_limit';
src/Plugin/SettingsManager.php:28:	public const OPTION_DRAFT_TTL          = 'agentwp_draft_ttl_minutes';
src/Plugin/SettingsManager.php:29:	public const OPTION_USAGE_STATS        = 'agentwp_usage_stats';
src/Plugin/SettingsManager.php:30:	public const OPTION_MEMORY_LIMIT       = 'agentwp_memory_limit';
src/Plugin/SettingsManager.php:31:	public const OPTION_MEMORY_TTL         = 'agentwp_memory_ttl';
src/Plugin/SchemaManager.php:31:	const OPTION_SCHEMA_VERSION = 'agentwp_schema_version';
src/Plugin/Upgrader.php:26:	const OPTION_INSTALLED_VERSION = 'agentwp_installed_version';

thinking
**Verifying inclusion of order cache in deletions**

I'm checking if order_cache_version should be included in option deletions and if uninstall cleans up its transients, noting the order cache uses transients with a plugin-specific prefix likely matching those already deleted. I'll verify the transient prefix to confirm.
exec
/bin/zsh -lc "sed -n '1,220p' src/Infrastructure/WordPressTransientCache.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * WordPress transient cache adapter.
 *
 * @package AgentWP\Infrastructure
 */

namespace AgentWP\Infrastructure;

use AgentWP\Config\AgentWPConfig;
use AgentWP\Contracts\TransientCacheInterface;
use AgentWP\Plugin;

/**
 * Wraps WordPress transient functions.
 */
final class WordPressTransientCache implements TransientCacheInterface {

	/**
	 * Key prefix.

thinking
**Planning uninstall and multisite improvements**

I'm updating the uninstall option list to centralize options in the Uninstall class and add tests, while auditing multisite handling to ensure per-site and network-level cleanup is correct. I'll also clarify network activation and uninstall expectations in docs, deciding between updating FAQ, creating a new multisite doc, or enhancing operational docs.
exec
/bin/zsh -lc 'rg "activation|upgrade|uninstall|deactivate" -n docs README.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
docs/voice-mode-report.md:4:Voice mode is feasible for V1.2 as a proof-of-concept using the Web Speech API. A push-to-talk button is reliable in Chromium-based browsers, while wake-word activation is possible only after a user gesture and cannot run as a true background listener. Recommendation: **Go** for a limited POC that is opt-in, uses push-to-talk by default, and treats wake-word as best-effort.
docs/CHANGELOG.md:13:- This is the authoritative current version for shipped functionality. It includes all changes previously listed under “Unreleased,” and the upgrade steps through **0.1.2** are part of this release.
docs/ARCHITECTURE-IMPROVEMENT-PLAN.md:93:Deliverable: clear release history + predictable upgrades.
docs/ARCHITECTURE-IMPROVEMENT-PLAN.md:149:  - Document network activation expectations
docs/ARCHITECTURE-IMPROVEMENT-PLAN.md:150:  - Ensure uninstall/cleanup remains correct per-site and network-wide
docs/ARCHITECTURE.md:9:| `agentwp.php` | Plugin entrypoint: constants, autoloader, activation hooks |
docs/ARCHITECTURE.md:38:        HOOKS[Activation/deactivation hooks]
docs/ARCHITECTURE.md:112:   - Registers activation/deactivation hooks
docs/ARCHITECTURE.md:439:- `agentwp.php`: Main plugin bootstrap, activation/deactivation hooks.
docs/adr/0006-search-index-architecture.md:17:1. **Plugin activation**: `Plugin::activate()` calls `Search\Index::activate()`
docs/adr/0006-search-index-architecture.md:37:- Retain static design for activation/lifecycle hooks (WordPress convention)
docs/adr/0006-search-index-architecture.md:49:| **WordPress conventions** | ✅ Matches WP patterns for activation hooks | ❌ Requires adapter for activation context |
docs/adr/0006-search-index-architecture.md:58:1. **Activation timing**: `Plugin::activate()` runs during plugin activation hook, before the container is reliably available. Static methods guarantee execution.
docs/adr/0006-search-index-architecture.md:161:3. **Schema validation**: Verify table structure matches expected schema after activation
docs/adr/0006-search-index-architecture.md:203:This adapter could then be registered in the container for controllers that need injection, while preserving the static implementation for activation/lifecycle scenarios.

thinking
**Planning doc update**

I'm considering adding a new section about network activation and multisite to docs/FAQ.md for clearer guidance.
exec
/bin/zsh -lc "sed -n '1,220p' docs/FAQ.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
# AgentWP FAQ

## 1) What is AgentWP?
AgentWP is an AI command deck for WooCommerce that turns natural-language requests into actions and insights.

## 2) Do I need an OpenAI API key?
Yes. AgentWP uses your own OpenAI API key (BYOK) for all AI features.

## 3) Where is my API key stored?
The key is encrypted and stored in `wp_options` using WordPress salts for encryption.

## 4) Is my store data sent to OpenAI?
Only the data needed to fulfill a request is sent, and only when you run a command. No data is sent without a prompt.

## 5) Which WordPress and WooCommerce versions are supported?
Minimum requirements are WordPress 6.4+, WooCommerce 8.0+, and PHP 8.0+.

## 6) Why do I see “missing nonce” errors?
Requests to the REST API require the `X-WP-Nonce` header. Refresh the admin screen to get a new nonce.


thinking
**Clarifying plugin activation and initialization**

I'm noting that network activation marks the plugin network-wide but options and tables are created per site on first run or init, not during activation. I'll verify this by searching where the schema initialization method is called to confirm lazy setup behavior.
exec
/bin/zsh -lc 'rg "ensure_tables" -n src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
src/Plugin/SchemaManager.php:20: * - Runtime fallback (via ensure_tables())
src/Plugin/SchemaManager.php:81:	public static function ensure_tables(): void {

thinking
**Clarifying table creation and option initialization**

Tables are created both on activation/upgrade and at runtime via init hooks, so network activation doesn't pre-create tables on each site but ensures creation at first admin request. Options typically use defaults and may be created on first access or save, making network activation safe without pre-creating all site options; this should be documented. Next, I'll verify how network upgrades are triggered through the upgrader.
exec
/bin/zsh -lc "sed -n '1,260p' src/Plugin/Upgrader.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Plugin upgrader for version-based migrations.
 *
 * @package AgentWP\Plugin
 */

namespace AgentWP\Plugin;

/**
 * Manages plugin upgrades and version-based migrations.
 *
 * Runs upgrade steps when the installed version differs from the current version.
 * All upgrade steps are idempotent and safe to re-run.
 *
 * Usage:
 * - Call Upgrader::init() early in boot (plugins_loaded hook)
 * - Add new upgrade steps in get_upgrade_steps() when needed
 * - Each step runs only once when upgrading from a lower version
 */



thinking
**Documenting multisite upgrade and uninstall behavior**

I'll add details about how network upgrades run per-site on visit or via admin calls, note plugin activation limits on multisite, explain uninstall's per-site cleaning and potential load on large networks, and plan a new multisite docs file plus an FAQ update.
thinking
**Designing new uninstall class with comprehensive option cleanup**

I'm creating a static Uninstall class encapsulating option key lists, per-site and network cleanup, multisite site ID detection, and scheduled hook clearing, to replace procedural uninstall.php; this improves maintainability and enables precise tests for option keys and multisite handling.
thinking
**Finalizing uninstall class and multisite docs plan**

I'm completing the Uninstall class with multisite-aware option, transient, and scheduled hook cleanup, updating uninstall.php to call it safely, and preparing a detailed `docs/MULTISITE.md` explaining activation, upgrades, and uninstall behavior and linking it from the FAQ.
file update
A /Users/ahmedyounis/Documents/Projects/agentwp/src/Plugin/Uninstall.php
<?php
/**
 * Uninstall cleanup helpers.
 *
 * @package AgentWP\Plugin
 */

namespace AgentWP\Plugin;

/**
 * Handles uninstall cleanup for single-site and multisite.
 */
final class Uninstall {

	/**
	 * Option keys to remove on uninstall.
	 *
	 * @var string[]
	 */
	public const OPTION_KEYS = array(
		'agentwp_settings',
		'agentwp_api_key',
		'agentwp_api_key_last4',
		'agentwp_demo_api_key',
		'agentwp_demo_api_key_last4',
		'agentwp_budget_limit',
		'agentwp_draft_ttl_minutes',
		'agentwp_usage_stats',
		'agentwp_memory_limit',
		'agentwp_memory_ttl',
		'agentwp_usage_version',
		'agentwp_usage_purge_last_run',
		'agentwp_search_index_version',
		'agentwp_search_index_state',
		'agentwp_search_index_backfill_heartbeat',
		'agentwp_schema_version',
		'agentwp_installed_version',
		'order_cache_version',
		'agentwp_order_cache_version',
	);

	/**
	 * Run uninstall cleanup.
	 *
	 * @return void
	 */
	public static function run(): void {
		global $wpdb;

		if ( ! $wpdb ) {
			return;
		}

		$option_keys = self::get_option_keys();
		$site_ids    = self::get_site_ids();

		if ( ! empty( $site_ids ) ) {
			foreach ( $site_ids as $site_id ) {
				switch_to_blog( (int) $site_id );
				self::cleanup_site( $option_keys );
				restore_current_blog();
			}
		} else {
			self::cleanup_site( $option_keys );
		}

		self::cleanup_user_meta();

		if ( self::is_multisite_enabled() ) {
			self::cleanup_network_options( $option_keys );
		}
	}

	/**
	 * Get option keys to remove on uninstall.
	 *
	 * @return string[]
	 */
	public static function get_option_keys(): array {
		return self::OPTION_KEYS;
	}

	/**
	 * Resolve site IDs for multisite cleanup.
	 *
	 * @param callable|null $is_multisite Optional multisite checker.
	 * @param callable|null $get_sites Optional site list fetcher.
	 * @param callable|null $can_switch Optional switch guard checker.
	 * @return int[]
	 */
	public static function get_site_ids(
		?callable $is_multisite = null,
		?callable $get_sites = null,
		?callable $can_switch = null
	): array {
		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
		if ( ! $is_multisite || ! $is_multisite() ) {
			return array();
		}

		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
		if ( ! $get_sites ) {
			return array();
		}

		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
		if ( ! $can_switch() ) {
			return array();
		}

		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
		if ( ! is_array( $site_ids ) ) {
			return array();
		}

		return array_map( 'intval', $site_ids );
	}

	/**
	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
	 *
	 * @param array $option_keys Option keys to delete.
	 * @return void
	 */
	private static function cleanup_site( array $option_keys ): void {
		global $wpdb;

		if ( ! $wpdb ) {
			return;
		}

		foreach ( $option_keys as $key ) {
			delete_option( $key );
		}

		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
		}

		if ( function_exists( 'as_unschedule_all_actions' ) ) {
			as_unschedule_all_actions( 'agentwp_bulk_process' );
		}

		$usage_table  = $wpdb->prefix . 'agentwp_usage';
		$search_table = $wpdb->prefix . 'agentwp_search_index';

		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );

		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
		$wpdb->query(
			$wpdb->prepare(
				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
				"_transient_{$transient_like}",
				"_transient_timeout_{$transient_like}"
			)
		);
		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
	}

	/**
	 * Remove AgentWP user meta values.
	 *
	 * @return void
	 */
	private static function cleanup_user_meta(): void {
		if ( function_exists( 'delete_metadata' ) ) {
			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
		}
	}

	/**
	 * Remove network-level options and transients.
	 *
	 * @param array $option_keys Option keys to delete.
	 * @return void
	 */
	private static function cleanup_network_options( array $option_keys ): void {
		global $wpdb;

		if ( ! $wpdb ) {
			return;
		}

		foreach ( $option_keys as $key ) {
			delete_site_option( $key );
		}

		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
		$wpdb->query(
			$wpdb->prepare(
				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
				"_site_transient_{$transient_like}",
				"_site_transient_timeout_{$transient_like}"
			)
		);
		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
	}

	/**
	 * Check if multisite functions are available and enabled.
	 *
	 * @return bool
	 */
	private static function is_multisite_enabled(): bool {
		return function_exists( 'is_multisite' ) && is_multisite();
	}

	/**
	 * Check if blog switching functions are available.
	 *
	 * @return bool
	 */
	private static function can_switch_blogs(): bool {
		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
	}
}
apply_patch(auto_approved=true) exited 0 in 36ms:
Success. Updated the following files:
A src/Plugin/Uninstall.php
file update:
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}

file update:
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}


thinking
**Updating uninstall script**

I'm preparing to modify uninstall.php to call the new class for uninstallation, applying the patch to integrate this change.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/uninstall.php
@@ -11,95 +11,11 @@
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M uninstall.php
file update:
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */

file update:
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */


thinking
**Designing comprehensive uninstall tests**

I'm outlining unit tests to verify option keys include expected unique strings and that the get_site_ids method handles multisite scenarios correctly using closures for simulating conditions. Next, I'll implement these tests in a new test file following the established style.
file update
A /Users/ahmedyounis/Documents/Projects/agentwp/tests/Unit/Plugin/UninstallTest.php
<?php
/**
 * Uninstall helper unit tests.
 *
 * @package AgentWP\Tests\Unit\Plugin
 */

namespace AgentWP\Tests\Unit\Plugin;

use AgentWP\Plugin\Uninstall;
use AgentWP\Tests\TestCase;

/**
 * Unit tests for uninstall helpers.
 */
class UninstallTest extends TestCase {

	public function test_option_keys_include_expected_values(): void {
		$keys = Uninstall::get_option_keys();

		$expected = array(
			'agentwp_settings',
			'agentwp_api_key',
			'agentwp_api_key_last4',
			'agentwp_demo_api_key',
			'agentwp_demo_api_key_last4',
			'agentwp_budget_limit',
			'agentwp_draft_ttl_minutes',
			'agentwp_usage_stats',
			'agentwp_memory_limit',
			'agentwp_memory_ttl',
			'agentwp_usage_version',
			'agentwp_usage_purge_last_run',
			'agentwp_search_index_version',
			'agentwp_search_index_state',
			'agentwp_search_index_backfill_heartbeat',
			'agentwp_schema_version',
			'agentwp_installed_version',
			'order_cache_version',
		);

		$missing = array_diff( $expected, $keys );

		$this->assertSame( array(), $missing );
	}

	public function test_option_keys_are_unique_non_empty_strings(): void {
		$keys = Uninstall::get_option_keys();

		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );

		foreach ( $keys as $key ) {
			$this->assertIsString( $key );
			$this->assertNotSame( '', $key );
		}
	}

	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
		$ids = Uninstall::get_site_ids( fn() => false );

		$this->assertSame( array(), $ids );
	}

	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
		$ids = Uninstall::get_site_ids(
			fn() => true,
			fn() => array( 1, 2 ),
			fn() => false
		);

		$this->assertSame( array(), $ids );
	}

	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
		$ids = Uninstall::get_site_ids(
			fn() => true,
			fn() => array( '1', 2, 3 ),
			fn() => true
		);

		$this->assertSame( array( 1, 2, 3 ), $ids );
	}
}
apply_patch(auto_approved=true) exited 0 in 46ms:
Success. Updated the following files:
A tests/Unit/Plugin/UninstallTest.php
file update:
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */

file update:
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */


thinking
**Adding new multisite documentation**
file update
A /Users/ahmedyounis/Documents/Projects/agentwp/docs/MULTISITE.md
#!/usr/bin/env markdown
# Multisite Expectations

AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.

## Activation
- Network activation is supported, but WordPress calls the activation hook only once for the current site.
- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.

## Upgrades
- Upgrades run per-site the next time the plugin loads on that site.
- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
- Upgrade steps are idempotent, so re-running them on a site is safe.

## Uninstall
- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
- Network-level options and site transients are removed after per-site cleanup.
apply_patch(auto_approved=true) exited 0 in 58ms:
Success. Updated the following files:
A docs/MULTISITE.md
file update:
diff --git a/docs/MULTISITE.md b/docs/MULTISITE.md
new file mode 100644
index 0000000000000000000000000000000000000000..7953dd2cd608d024f4e96a0b5ccc4d6ae5386b9f
--- /dev/null
+++ b/docs/MULTISITE.md
@@ -0,0 +1,20 @@
+#!/usr/bin/env markdown
+# Multisite Expectations
+
+AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.
+
+## Activation
+- Network activation is supported, but WordPress calls the activation hook only once for the current site.
+- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
+- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
+- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.
+
+## Upgrades
+- Upgrades run per-site the next time the plugin loads on that site.
+- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
+- Upgrade steps are idempotent, so re-running them on a site is safe.
+
+## Uninstall
+- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
+- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
+- Network-level options and site transients are removed after per-site cleanup.
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */

file update:
diff --git a/docs/MULTISITE.md b/docs/MULTISITE.md
new file mode 100644
index 0000000000000000000000000000000000000000..7953dd2cd608d024f4e96a0b5ccc4d6ae5386b9f
--- /dev/null
+++ b/docs/MULTISITE.md
@@ -0,0 +1,20 @@
+#!/usr/bin/env markdown
+# Multisite Expectations
+
+AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.
+
+## Activation
+- Network activation is supported, but WordPress calls the activation hook only once for the current site.
+- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
+- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
+- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.
+
+## Upgrades
+- Upgrades run per-site the next time the plugin loads on that site.
+- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
+- Upgrade steps are idempotent, so re-running them on a site is safe.
+
+## Uninstall
+- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
+- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
+- Network-level options and site transients are removed after per-site cleanup.
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */


thinking
**Removing unnecessary file header**

Decided to remove the uncommon "#!/usr/bin/env markdown" line to keep consistency with other docs since it isn't typically present.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/MULTISITE.md
@@ -1,2 +1 @@
-#!/usr/bin/env markdown
 # Multisite Expectations
apply_patch(auto_approved=true) exited 0 in 55ms:
Success. Updated the following files:
M docs/MULTISITE.md
file update:
diff --git a/docs/MULTISITE.md b/docs/MULTISITE.md
new file mode 100644
index 0000000000000000000000000000000000000000..54d542cde0dd2e45196a1861e26f7d3aa04e883e
--- /dev/null
+++ b/docs/MULTISITE.md
@@ -0,0 +1,19 @@
+# Multisite Expectations
+
+AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.
+
+## Activation
+- Network activation is supported, but WordPress calls the activation hook only once for the current site.
+- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
+- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
+- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.
+
+## Upgrades
+- Upgrades run per-site the next time the plugin loads on that site.
+- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
+- Upgrade steps are idempotent, so re-running them on a site is safe.
+
+## Uninstall
+- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
+- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
+- Network-level options and site transients are removed after per-site cleanup.
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */

file update:
diff --git a/docs/MULTISITE.md b/docs/MULTISITE.md
new file mode 100644
index 0000000000000000000000000000000000000000..54d542cde0dd2e45196a1861e26f7d3aa04e883e
--- /dev/null
+++ b/docs/MULTISITE.md
@@ -0,0 +1,19 @@
+# Multisite Expectations
+
+AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.
+
+## Activation
+- Network activation is supported, but WordPress calls the activation hook only once for the current site.
+- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
+- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
+- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.
+
+## Upgrades
+- Upgrades run per-site the next time the plugin loads on that site.
+- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
+- Upgrade steps are idempotent, so re-running them on a site is safe.
+
+## Uninstall
+- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
+- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
+- Network-level options and site transients are removed after per-site cleanup.
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */


thinking
**Updating FAQ question 11 wording**

I'm refining FAQ 11 to clarify multisite usage and activation steps without including raw URLs, opting for a file path reference instead.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/FAQ.md
@@ -33,3 +33,3 @@
 ## 11) Can I use AgentWP on multisite?
-Yes. Network-activate the plugin and enable it on sites with WooCommerce installed.
+Yes. Network-activate the plugin and enable it on sites with WooCommerce installed. Activation and upgrades run per site, so visit each site once (or run a network upgrade) to initialize tables and defaults. See `docs/MULTISITE.md` for lifecycle details.
 
apply_patch(auto_approved=true) exited 0 in 49ms:
Success. Updated the following files:
M docs/FAQ.md
file update:
diff --git a/docs/FAQ.md b/docs/FAQ.md
index d55e33c8ecbd82ef81e43a59fc1b8686337aab8f..3a85d1bd090ad81655ec55aa0f0ddc0f7553b898
--- a/docs/FAQ.md
+++ b/docs/FAQ.md
@@ -31,7 +31,7 @@
 Open Settings and choose between `gpt-4o` and `gpt-4o-mini`.
 
 ## 11) Can I use AgentWP on multisite?
-Yes. Network-activate the plugin and enable it on sites with WooCommerce installed.
+Yes. Network-activate the plugin and enable it on sites with WooCommerce installed. Activation and upgrades run per site, so visit each site once (or run a network upgrade) to initialize tables and defaults. See `docs/MULTISITE.md` for lifecycle details.
 
 ## 12) The AgentWP menu is missing. Why?
 Only users with the `manage_woocommerce` capability can access the menu. Check your role permissions.
diff --git a/docs/MULTISITE.md b/docs/MULTISITE.md
new file mode 100644
index 0000000000000000000000000000000000000000..54d542cde0dd2e45196a1861e26f7d3aa04e883e
--- /dev/null
+++ b/docs/MULTISITE.md
@@ -0,0 +1,19 @@
+# Multisite Expectations
+
+AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.
+
+## Activation
+- Network activation is supported, but WordPress calls the activation hook only once for the current site.
+- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
+- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
+- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.
+
+## Upgrades
+- Upgrades run per-site the next time the plugin loads on that site.
+- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
+- Upgrade steps are idempotent, so re-running them on a site is safe.
+
+## Uninstall
+- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
+- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
+- Network-level options and site transients are removed after per-site cleanup.
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */

file update:
diff --git a/docs/FAQ.md b/docs/FAQ.md
index d55e33c8ecbd82ef81e43a59fc1b8686337aab8f..3a85d1bd090ad81655ec55aa0f0ddc0f7553b898
--- a/docs/FAQ.md
+++ b/docs/FAQ.md
@@ -31,7 +31,7 @@
 Open Settings and choose between `gpt-4o` and `gpt-4o-mini`.
 
 ## 11) Can I use AgentWP on multisite?
-Yes. Network-activate the plugin and enable it on sites with WooCommerce installed.
+Yes. Network-activate the plugin and enable it on sites with WooCommerce installed. Activation and upgrades run per site, so visit each site once (or run a network upgrade) to initialize tables and defaults. See `docs/MULTISITE.md` for lifecycle details.
 
 ## 12) The AgentWP menu is missing. Why?
 Only users with the `manage_woocommerce` capability can access the menu. Check your role permissions.
diff --git a/docs/MULTISITE.md b/docs/MULTISITE.md
new file mode 100644
index 0000000000000000000000000000000000000000..54d542cde0dd2e45196a1861e26f7d3aa04e883e
--- /dev/null
+++ b/docs/MULTISITE.md
@@ -0,0 +1,19 @@
+# Multisite Expectations
+
+AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.
+
+## Activation
+- Network activation is supported, but WordPress calls the activation hook only once for the current site.
+- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
+- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
+- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.
+
+## Upgrades
+- Upgrades run per-site the next time the plugin loads on that site.
+- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
+- Upgrade steps are idempotent, so re-running them on a site is safe.
+
+## Uninstall
+- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
+- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
+- Network-level options and site transients are removed after per-site cleanup.
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */



thinking
**Adding phpcs ignore for switch_to_blog**

Planning to add phpcs ignore comments for switch_to_blog calls in the Uninstall class and restore logic to avoid WordPressVIPMinimum warnings, as these calls are allowed for multisite uninstall operations. The direct DB queries are already properly flagged, and delete_site_option usage is guarded by multisite checks, so those are safe.
thinking
**Verifying multisite safety and code style**

Confirming uninstall logic safely checks multisite functions before use and handles scheduled hooks conditionally; direct calls to delete_site_option remain safe. Also verifying uninstall.php indentation uses tabs consistently to match existing style before finalizing.
exec
/bin/zsh -lc "sed -n '1,220p' src/Plugin/Uninstall.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Uninstall cleanup helpers.
 *
 * @package AgentWP\Plugin
 */

namespace AgentWP\Plugin;

/**
 * Handles uninstall cleanup for single-site and multisite.
 */
final class Uninstall {

	/**
	 * Option keys to remove on uninstall.
	 *
	 * @var string[]
	 */
	public const OPTION_KEYS = array(
file update:
diff --git a/docs/FAQ.md b/docs/FAQ.md
index d55e33c8ecbd82ef81e43a59fc1b8686337aab8f..3a85d1bd090ad81655ec55aa0f0ddc0f7553b898
--- a/docs/FAQ.md
+++ b/docs/FAQ.md
@@ -31,7 +31,7 @@
 Open Settings and choose between `gpt-4o` and `gpt-4o-mini`.
 
 ## 11) Can I use AgentWP on multisite?
-Yes. Network-activate the plugin and enable it on sites with WooCommerce installed.
+Yes. Network-activate the plugin and enable it on sites with WooCommerce installed. Activation and upgrades run per site, so visit each site once (or run a network upgrade) to initialize tables and defaults. See `docs/MULTISITE.md` for lifecycle details.
 
 ## 12) The AgentWP menu is missing. Why?
 Only users with the `manage_woocommerce` capability can access the menu. Check your role permissions.
diff --git a/docs/MULTISITE.md b/docs/MULTISITE.md
new file mode 100644
index 0000000000000000000000000000000000000000..54d542cde0dd2e45196a1861e26f7d3aa04e883e
--- /dev/null
+++ b/docs/MULTISITE.md
@@ -0,0 +1,19 @@
+# Multisite Expectations
+
+AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.
+
+## Activation
+- Network activation is supported, but WordPress calls the activation hook only once for the current site.
+- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
+- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
+- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.
+
+## Upgrades
+- Upgrades run per-site the next time the plugin loads on that site.
+- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
+- Upgrade steps are idempotent, so re-running them on a site is safe.
+
+## Uninstall
+- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
+- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
+- Network-level options and site transients are removed after per-site cleanup.
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */

exec
/bin/zsh -lc "sed -n '220,400p' src/Plugin/Uninstall.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
	 * @return bool
	 */
	private static function can_switch_blogs(): bool {
		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
	}
}
file update:
diff --git a/docs/FAQ.md b/docs/FAQ.md
index d55e33c8ecbd82ef81e43a59fc1b8686337aab8f..3a85d1bd090ad81655ec55aa0f0ddc0f7553b898
--- a/docs/FAQ.md
+++ b/docs/FAQ.md
@@ -31,7 +31,7 @@
 Open Settings and choose between `gpt-4o` and `gpt-4o-mini`.
 
 ## 11) Can I use AgentWP on multisite?
-Yes. Network-activate the plugin and enable it on sites with WooCommerce installed.
+Yes. Network-activate the plugin and enable it on sites with WooCommerce installed. Activation and upgrades run per site, so visit each site once (or run a network upgrade) to initialize tables and defaults. See `docs/MULTISITE.md` for lifecycle details.
 
 ## 12) The AgentWP menu is missing. Why?
 Only users with the `manage_woocommerce` capability can access the menu. Check your role permissions.
diff --git a/docs/MULTISITE.md b/docs/MULTISITE.md
new file mode 100644
index 0000000000000000000000000000000000000000..54d542cde0dd2e45196a1861e26f7d3aa04e883e
--- /dev/null
+++ b/docs/MULTISITE.md
@@ -0,0 +1,19 @@
+# Multisite Expectations
+
+AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.
+
+## Activation
+- Network activation is supported, but WordPress calls the activation hook only once for the current site.
+- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
+- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
+- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.
+
+## Upgrades
+- Upgrades run per-site the next time the plugin loads on that site.
+- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
+- Upgrade steps are idempotent, so re-running them on a site is safe.
+
+## Uninstall
+- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
+- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
+- Network-level options and site transients are removed after per-site cleanup.
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..60f08bfc69f6f5169be7f9dd9939a979b0e85e8c
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,225 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */


thinking
**Adding phpcs ignore for switch_to_blog**

I'm adding a phpcs ignore comment for the switch_to_blog call to suppress warnings, as it's required for multisite uninstall. I'll also add one for restore_current_blog to prevent any warnings there.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Plugin/Uninstall.php
@@ -58,2 +58,3 @@
 			foreach ( $site_ids as $site_id ) {
+				// phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog -- Required for multisite uninstall.
 				switch_to_blog( (int) $site_id );
apply_patch(auto_approved=true) exited 0 in 64ms:
Success. Updated the following files:
M src/Plugin/Uninstall.php
file update:
diff --git a/docs/FAQ.md b/docs/FAQ.md
index d55e33c8ecbd82ef81e43a59fc1b8686337aab8f..3a85d1bd090ad81655ec55aa0f0ddc0f7553b898
--- a/docs/FAQ.md
+++ b/docs/FAQ.md
@@ -31,7 +31,7 @@
 Open Settings and choose between `gpt-4o` and `gpt-4o-mini`.
 
 ## 11) Can I use AgentWP on multisite?
-Yes. Network-activate the plugin and enable it on sites with WooCommerce installed.
+Yes. Network-activate the plugin and enable it on sites with WooCommerce installed. Activation and upgrades run per site, so visit each site once (or run a network upgrade) to initialize tables and defaults. See `docs/MULTISITE.md` for lifecycle details.
 
 ## 12) The AgentWP menu is missing. Why?
 Only users with the `manage_woocommerce` capability can access the menu. Check your role permissions.
diff --git a/docs/MULTISITE.md b/docs/MULTISITE.md
new file mode 100644
index 0000000000000000000000000000000000000000..54d542cde0dd2e45196a1861e26f7d3aa04e883e
--- /dev/null
+++ b/docs/MULTISITE.md
@@ -0,0 +1,19 @@
+# Multisite Expectations
+
+AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.
+
+## Activation
+- Network activation is supported, but WordPress calls the activation hook only once for the current site.
+- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
+- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
+- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.
+
+## Upgrades
+- Upgrades run per-site the next time the plugin loads on that site.
+- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
+- Upgrade steps are idempotent, so re-running them on a site is safe.
+
+## Uninstall
+- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
+- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
+- Network-level options and site transients are removed after per-site cleanup.
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..a1ee5d8c6215f9ffbc316a71dd8dff7199fb61b1
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,226 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				// phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog -- Required for multisite uninstall.
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */

file update:
diff --git a/docs/FAQ.md b/docs/FAQ.md
index d55e33c8ecbd82ef81e43a59fc1b8686337aab8f..3a85d1bd090ad81655ec55aa0f0ddc0f7553b898
--- a/docs/FAQ.md
+++ b/docs/FAQ.md
@@ -31,7 +31,7 @@
 Open Settings and choose between `gpt-4o` and `gpt-4o-mini`.
 
 ## 11) Can I use AgentWP on multisite?
-Yes. Network-activate the plugin and enable it on sites with WooCommerce installed.
+Yes. Network-activate the plugin and enable it on sites with WooCommerce installed. Activation and upgrades run per site, so visit each site once (or run a network upgrade) to initialize tables and defaults. See `docs/MULTISITE.md` for lifecycle details.
 
 ## 12) The AgentWP menu is missing. Why?
 Only users with the `manage_woocommerce` capability can access the menu. Check your role permissions.
diff --git a/docs/MULTISITE.md b/docs/MULTISITE.md
new file mode 100644
index 0000000000000000000000000000000000000000..54d542cde0dd2e45196a1861e26f7d3aa04e883e
--- /dev/null
+++ b/docs/MULTISITE.md
@@ -0,0 +1,19 @@
+# Multisite Expectations
+
+AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.
+
+## Activation
+- Network activation is supported, but WordPress calls the activation hook only once for the current site.
+- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
+- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
+- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.
+
+## Upgrades
+- Upgrades run per-site the next time the plugin loads on that site.
+- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
+- Upgrade steps are idempotent, so re-running them on a site is safe.
+
+## Uninstall
+- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
+- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
+- Network-level options and site transients are removed after per-site cleanup.
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..a1ee5d8c6215f9ffbc316a71dd8dff7199fb61b1
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,226 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				// phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog -- Required for multisite uninstall.
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */


thinking
**Reviewing uninstall script and docs**

I'm confirming uninstall.php should use safe checks like file_exists and class_exists, ensuring tests use PHP 7.4+ features like arrow functions, and considering doc formatting updates but find no urgent changes needed.
exec
/bin/zsh -lc 'cat uninstall.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * Plugin uninstall cleanup.
 *
 * @package AgentWP
 */

if ( ! defined( 'WP_UNINSTALL_PLUGIN' ) ) {
	exit;
}

$autoload = __DIR__ . '/vendor/autoload.php';
if ( file_exists( $autoload ) ) {
	require_once $autoload;
}

require_once __DIR__ . '/src/Plugin/Uninstall.php';

if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
	AgentWP\Plugin\Uninstall::run();
file update:
diff --git a/docs/FAQ.md b/docs/FAQ.md
index d55e33c8ecbd82ef81e43a59fc1b8686337aab8f..3a85d1bd090ad81655ec55aa0f0ddc0f7553b898
--- a/docs/FAQ.md
+++ b/docs/FAQ.md
@@ -31,7 +31,7 @@
 Open Settings and choose between `gpt-4o` and `gpt-4o-mini`.
 
 ## 11) Can I use AgentWP on multisite?
-Yes. Network-activate the plugin and enable it on sites with WooCommerce installed.
+Yes. Network-activate the plugin and enable it on sites with WooCommerce installed. Activation and upgrades run per site, so visit each site once (or run a network upgrade) to initialize tables and defaults. See `docs/MULTISITE.md` for lifecycle details.
 
 ## 12) The AgentWP menu is missing. Why?
 Only users with the `manage_woocommerce` capability can access the menu. Check your role permissions.
diff --git a/docs/MULTISITE.md b/docs/MULTISITE.md
new file mode 100644
index 0000000000000000000000000000000000000000..54d542cde0dd2e45196a1861e26f7d3aa04e883e
--- /dev/null
+++ b/docs/MULTISITE.md
@@ -0,0 +1,19 @@
+# Multisite Expectations
+
+AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.
+
+## Activation
+- Network activation is supported, but WordPress calls the activation hook only once for the current site.
+- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
+- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
+- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.
+
+## Upgrades
+- Upgrades run per-site the next time the plugin loads on that site.
+- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
+- Upgrade steps are idempotent, so re-running them on a site is safe.
+
+## Uninstall
+- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
+- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
+- Network-level options and site transients are removed after per-site cleanup.
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..a1ee5d8c6215f9ffbc316a71dd8dff7199fb61b1
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,226 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				// phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog -- Required for multisite uninstall.
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */



thinking
**Reviewing multisite uninstall handling**

Verified network uninstall cleans network options regardless of site ID retrieval, preserving previous behavior; confirmed table drops and scheduled hook clears happen per site, and that WP is loaded during uninstall ensuring multisite checks function correctly.
thinking
**Preparing final summary and verification notes**

Planning a structured final message with status DONE, a clear list of changes including multisite uninstall improvements and doc updates, stating no verification commands provided, and noting risks like large network uninstall duration; will suggest running unit tests as a natural next step.
codex
Status: DONE

Summary of changes:
- Centralized uninstall logic in `src/Plugin/Uninstall.php`, expanded option cleanup, and added multisite-aware site iteration helpers.
- Updated `uninstall.php` to delegate to the new uninstall helper.
- Documented multisite activation/upgrade/uninstall expectations in `docs/MULTISITE.md` and expanded FAQ guidance in `docs/FAQ.md`.
- Added unit tests for uninstall option key coverage and multisite helper behavior in `tests/Unit/Plugin/UninstallTest.php`.

How to verify (exact commands):
- No verification commands provided.

Risks / follow-ups:
- Uninstall still iterates all sites on multisite; large networks may take longer (documented in `docs/MULTISITE.md`).

Next steps:
1) Run `vendor/bin/phpunit` if you want to exercise the new unit tests.
file update:
diff --git a/docs/FAQ.md b/docs/FAQ.md
index d55e33c8ecbd82ef81e43a59fc1b8686337aab8f..3a85d1bd090ad81655ec55aa0f0ddc0f7553b898
--- a/docs/FAQ.md
+++ b/docs/FAQ.md
@@ -31,7 +31,7 @@
 Open Settings and choose between `gpt-4o` and `gpt-4o-mini`.
 
 ## 11) Can I use AgentWP on multisite?
-Yes. Network-activate the plugin and enable it on sites with WooCommerce installed.
+Yes. Network-activate the plugin and enable it on sites with WooCommerce installed. Activation and upgrades run per site, so visit each site once (or run a network upgrade) to initialize tables and defaults. See `docs/MULTISITE.md` for lifecycle details.
 
 ## 12) The AgentWP menu is missing. Why?
 Only users with the `manage_woocommerce` capability can access the menu. Check your role permissions.
diff --git a/docs/MULTISITE.md b/docs/MULTISITE.md
new file mode 100644
index 0000000000000000000000000000000000000000..54d542cde0dd2e45196a1861e26f7d3aa04e883e
--- /dev/null
+++ b/docs/MULTISITE.md
@@ -0,0 +1,19 @@
+# Multisite Expectations
+
+AgentWP works in WordPress multisite networks, but the lifecycle hooks behave a bit differently than single-site installs. This document outlines what to expect for activation, upgrades, and uninstall.
+
+## Activation
+- Network activation is supported, but WordPress calls the activation hook only once for the current site.
+- AgentWP creates default options for the activating site only. Other sites read defaults until settings are saved.
+- Usage/search tables and background schedules are created lazily on each site when AgentWP runs.
+- For large networks, visit each site once (or run a scripted loop) if you need tables and options pre-created everywhere.
+
+## Upgrades
+- Upgrades run per-site the next time the plugin loads on that site.
+- Network admins can force upgrades across all sites by calling `AgentWP\Plugin\Upgrader::run_network_upgrades()` from a network admin context.
+- Upgrade steps are idempotent, so re-running them on a site is safe.
+
+## Uninstall
+- Uninstall removes per-site options, tables, transients, scheduled hooks, and user meta.
+- On multisite, the uninstall routine iterates through all sites (when multisite APIs are available) and cleans each site.
+- Network-level options and site transients are removed after per-site cleanup.
diff --git a/src/Plugin/Uninstall.php b/src/Plugin/Uninstall.php
new file mode 100644
index 0000000000000000000000000000000000000000..a1ee5d8c6215f9ffbc316a71dd8dff7199fb61b1
--- /dev/null
+++ b/src/Plugin/Uninstall.php
@@ -0,0 +1,226 @@
+<?php
+/**
+ * Uninstall cleanup helpers.
+ *
+ * @package AgentWP\Plugin
+ */
+
+namespace AgentWP\Plugin;
+
+/**
+ * Handles uninstall cleanup for single-site and multisite.
+ */
+final class Uninstall {
+
+	/**
+	 * Option keys to remove on uninstall.
+	 *
+	 * @var string[]
+	 */
+	public const OPTION_KEYS = array(
+		'agentwp_settings',
+		'agentwp_api_key',
+		'agentwp_api_key_last4',
+		'agentwp_demo_api_key',
+		'agentwp_demo_api_key_last4',
+		'agentwp_budget_limit',
+		'agentwp_draft_ttl_minutes',
+		'agentwp_usage_stats',
+		'agentwp_memory_limit',
+		'agentwp_memory_ttl',
+		'agentwp_usage_version',
+		'agentwp_usage_purge_last_run',
+		'agentwp_search_index_version',
+		'agentwp_search_index_state',
+		'agentwp_search_index_backfill_heartbeat',
+		'agentwp_schema_version',
+		'agentwp_installed_version',
+		'order_cache_version',
+		'agentwp_order_cache_version',
+	);
+
+	/**
+	 * Run uninstall cleanup.
+	 *
+	 * @return void
+	 */
+	public static function run(): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		$option_keys = self::get_option_keys();
+		$site_ids    = self::get_site_ids();
+
+		if ( ! empty( $site_ids ) ) {
+			foreach ( $site_ids as $site_id ) {
+				// phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog -- Required for multisite uninstall.
+				switch_to_blog( (int) $site_id );
+				self::cleanup_site( $option_keys );
+				restore_current_blog();
+			}
+		} else {
+			self::cleanup_site( $option_keys );
+		}
+
+		self::cleanup_user_meta();
+
+		if ( self::is_multisite_enabled() ) {
+			self::cleanup_network_options( $option_keys );
+		}
+	}
+
+	/**
+	 * Get option keys to remove on uninstall.
+	 *
+	 * @return string[]
+	 */
+	public static function get_option_keys(): array {
+		return self::OPTION_KEYS;
+	}
+
+	/**
+	 * Resolve site IDs for multisite cleanup.
+	 *
+	 * @param callable|null $is_multisite Optional multisite checker.
+	 * @param callable|null $get_sites Optional site list fetcher.
+	 * @param callable|null $can_switch Optional switch guard checker.
+	 * @return int[]
+	 */
+	public static function get_site_ids(
+		?callable $is_multisite = null,
+		?callable $get_sites = null,
+		?callable $can_switch = null
+	): array {
+		$is_multisite = $is_multisite ?? ( function_exists( 'is_multisite' ) ? 'is_multisite' : null );
+		if ( ! $is_multisite || ! $is_multisite() ) {
+			return array();
+		}
+
+		$get_sites = $get_sites ?? ( function_exists( 'get_sites' ) ? 'get_sites' : null );
+		if ( ! $get_sites ) {
+			return array();
+		}
+
+		$can_switch = $can_switch ?? array( __CLASS__, 'can_switch_blogs' );
+		if ( ! $can_switch() ) {
+			return array();
+		}
+
+		$site_ids = $get_sites( array( 'fields' => 'ids' ) );
+		if ( ! is_array( $site_ids ) ) {
+			return array();
+		}
+
+		return array_map( 'intval', $site_ids );
+	}
+
+	/**
+	 * Delete per-site AgentWP data (options, tables, transients, cron hooks).
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_site( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_option( $key );
+		}
+
+		if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
+			wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
+			wp_clear_scheduled_hook( 'agentwp_usage_purge' );
+			wp_clear_scheduled_hook( 'agentwp_search_backfill' );
+		}
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( 'agentwp_bulk_process' );
+		}
+
+		$usage_table  = $wpdb->prefix . 'agentwp_usage';
+		$search_table = $wpdb->prefix . 'agentwp_search_index';
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
+		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
+		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
+
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
+				"_transient_{$transient_like}",
+				"_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange
+	}
+
+	/**
+	 * Remove AgentWP user meta values.
+	 *
+	 * @return void
+	 */
+	private static function cleanup_user_meta(): void {
+		if ( function_exists( 'delete_metadata' ) ) {
+			delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
+			delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
+			delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
+		}
+	}
+
+	/**
+	 * Remove network-level options and transients.
+	 *
+	 * @param array $option_keys Option keys to delete.
+	 * @return void
+	 */
+	private static function cleanup_network_options( array $option_keys ): void {
+		global $wpdb;
+
+		if ( ! $wpdb ) {
+			return;
+		}
+
+		foreach ( $option_keys as $key ) {
+			delete_site_option( $key );
+		}
+
+		// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+		$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
+		$wpdb->query(
+			$wpdb->prepare(
+				"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
+				"_site_transient_{$transient_like}",
+				"_site_transient_timeout_{$transient_like}"
+			)
+		);
+		// phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
+	}
+
+	/**
+	 * Check if multisite functions are available and enabled.
+	 *
+	 * @return bool
+	 */
+	private static function is_multisite_enabled(): bool {
+		return function_exists( 'is_multisite' ) && is_multisite();
+	}
+
+	/**
+	 * Check if blog switching functions are available.
+	 *
+	 * @return bool
+	 */
+	private static function can_switch_blogs(): bool {
+		return function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' );
+	}
+}
diff --git a/tests/Unit/Plugin/UninstallTest.php b/tests/Unit/Plugin/UninstallTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8ace2842bf3e238aa3ac64dab1392d9ebe9ec4a1
--- /dev/null
+++ b/tests/Unit/Plugin/UninstallTest.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Uninstall helper unit tests.
+ *
+ * @package AgentWP\Tests\Unit\Plugin
+ */
+
+namespace AgentWP\Tests\Unit\Plugin;
+
+use AgentWP\Plugin\Uninstall;
+use AgentWP\Tests\TestCase;
+
+/**
+ * Unit tests for uninstall helpers.
+ */
+class UninstallTest extends TestCase {
+
+	public function test_option_keys_include_expected_values(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$expected = array(
+			'agentwp_settings',
+			'agentwp_api_key',
+			'agentwp_api_key_last4',
+			'agentwp_demo_api_key',
+			'agentwp_demo_api_key_last4',
+			'agentwp_budget_limit',
+			'agentwp_draft_ttl_minutes',
+			'agentwp_usage_stats',
+			'agentwp_memory_limit',
+			'agentwp_memory_ttl',
+			'agentwp_usage_version',
+			'agentwp_usage_purge_last_run',
+			'agentwp_search_index_version',
+			'agentwp_search_index_state',
+			'agentwp_search_index_backfill_heartbeat',
+			'agentwp_schema_version',
+			'agentwp_installed_version',
+			'order_cache_version',
+		);
+
+		$missing = array_diff( $expected, $keys );
+
+		$this->assertSame( array(), $missing );
+	}
+
+	public function test_option_keys_are_unique_non_empty_strings(): void {
+		$keys = Uninstall::get_option_keys();
+
+		$this->assertSame( $keys, array_values( array_unique( $keys ) ) );
+
+		foreach ( $keys as $key ) {
+			$this->assertIsString( $key );
+			$this->assertNotSame( '', $key );
+		}
+	}
+
+	public function test_get_site_ids_returns_empty_when_not_multisite(): void {
+		$ids = Uninstall::get_site_ids( fn() => false );
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_empty_when_cannot_switch(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( 1, 2 ),
+			fn() => false
+		);
+
+		$this->assertSame( array(), $ids );
+	}
+
+	public function test_get_site_ids_returns_site_ids_when_multisite(): void {
+		$ids = Uninstall::get_site_ids(
+			fn() => true,
+			fn() => array( '1', 2, 3 ),
+			fn() => true
+		);
+
+		$this->assertSame( array( 1, 2, 3 ), $ids );
+	}
+}
diff --git a/uninstall.php b/uninstall.php
index d11680787ab798b563f394ec6e008e4a083951a4..185945083781d0d511c5bee36cc9903363d76c65
--- a/uninstall.php
+++ b/uninstall.php
@@ -9,97 +9,13 @@
 	exit;
 }
 
-global $wpdb;
-
-if ( ! $wpdb ) {
-	return;
+$autoload = __DIR__ . '/vendor/autoload.php';
+if ( file_exists( $autoload ) ) {
+	require_once $autoload;
 }
 
-/* phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */
+require_once __DIR__ . '/src/Plugin/Uninstall.php';
 
-$option_keys = array(
-	'agentwp_settings',
-	'agentwp_api_key',
-	'agentwp_api_key_last4',
-	'agentwp_demo_api_key',
-	'agentwp_demo_api_key_last4',
-	'agentwp_budget_limit',
-	'agentwp_draft_ttl_minutes',
-	'agentwp_usage_stats',
-	'agentwp_usage_version',
-	'agentwp_search_index_version',
-	'agentwp_search_index_state',
-	'agentwp_order_cache_version',
-	'agentwp_installed_version',
-);
-
-/**
- * Delete per-site AgentWP data (options, tables, transients, cron hooks).
- *
- * @param array $option_keys Option keys to delete.
- * @return void
- */
-$cleanup_site = static function ( array $option_keys ) use ( $wpdb ) {
-	foreach ( $option_keys as $key ) {
-		delete_option( $key );
-	}
-
-	if ( function_exists( 'wp_clear_scheduled_hook' ) ) {
-		wp_clear_scheduled_hook( 'agentwp_demo_daily_reset' );
-	}
-
-	if ( function_exists( 'as_unschedule_all_actions' ) ) {
-		as_unschedule_all_actions( 'agentwp_bulk_process' );
-	}
-
-		$usage_table  = $wpdb->prefix . 'agentwp_usage';
-		$search_table = $wpdb->prefix . 'agentwp_search_index';
-
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$usage_table}" );
-		// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- Table names are derived from $wpdb->prefix.
-		$wpdb->query( "DROP TABLE IF EXISTS {$search_table}" );
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->options} WHERE option_name LIKE %s OR option_name LIKE %s",
-			"_transient_{$transient_like}",
-			"_transient_timeout_{$transient_like}"
-		)
-	);
-};
-
-if ( is_multisite() && function_exists( 'get_sites' ) && function_exists( 'switch_to_blog' ) && function_exists( 'restore_current_blog' ) ) {
-	$site_ids = get_sites( array( 'fields' => 'ids' ) );
-	foreach ( $site_ids as $site_id ) {
-		switch_to_blog( (int) $site_id );
-		$cleanup_site( $option_keys );
-		restore_current_blog();
-	}
-} else {
-	$cleanup_site( $option_keys );
-}
-
-if ( function_exists( 'delete_metadata' ) ) {
-	delete_metadata( 'user', 0, 'agentwp_command_history', '', true );
-	delete_metadata( 'user', 0, 'agentwp_command_favorites', '', true );
-	delete_metadata( 'user', 0, 'agentwp_theme_preference', '', true );
-}
-
-if ( is_multisite() ) {
-	foreach ( $option_keys as $key ) {
-		delete_site_option( $key );
-	}
-
-	$transient_like = $wpdb->esc_like( 'agentwp_' ) . '%';
-	$wpdb->query(
-		$wpdb->prepare(
-			"DELETE FROM {$wpdb->sitemeta} WHERE meta_key LIKE %s OR meta_key LIKE %s",
-			"_site_transient_{$transient_like}",
-			"_site_transient_timeout_{$transient_like}"
-		)
-	);
+if ( class_exists( 'AgentWP\\Plugin\\Uninstall' ) ) {
+	AgentWP\Plugin\Uninstall::run();
 }
-
-/* phpcs:enable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.DirectDatabaseQuery.SchemaChange, WordPressVIPMinimum.Functions.RestrictedFunctions.switch_to_blog_switch_to_blog */

tokens used
110,003
