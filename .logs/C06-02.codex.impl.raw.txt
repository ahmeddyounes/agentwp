Implemented resilient search backfill scheduling with safer locking, bounded runtime, and stuck recovery, plus updated docs/tests to reflect WP‑Cron behavior and state transitions.

Status: DONE

Summary of changes:
- Added lock tokening, heartbeat tracking, stale schedule recovery, and per‑item deadline checks for bounded backfill runs in `src/Search/Index.php`.
- Expanded unit coverage for scheduling idempotence/stale recovery and lock release behavior in `tests/Unit/Search/BackfillTest.php`.
- Updated search index documentation for WP‑Cron scheduling, heartbeat/stuck troubleshooting, and revised timing guidance in `docs/search-index.md`.

How to verify (exact commands):
- N/A (no format/lint/test commands were provided)

Risks / follow-ups:
- Recovery still depends on WP‑Cron execution; sites with `DISABLE_WP_CRON` must run a real cron to avoid stalled backfills.
- If indexing a single item is slow, a run can exceed the window by a small amount; consider tuning backfill limits/window if needed.

OpenAI Codex v0.87.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/agentwp
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019bd246-ace7-76e2-9123-d58046a8cb9b
--------
user
You are implementing task C06-02 in this git repository.

1) Read the spec: .plans/C06-02.md
2) Read handoff/context: .t2/handoff/C06-02.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: 
- test: 

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers
exec
/bin/zsh -lc ls in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 41ms:
agentwp.php
assets
composer.json
composer.lock
docker
docker-compose.demo.yml
docker-compose.yml
docs
includes
languages
node_modules
package-lock.json
package.json
phpcs.xml
phpstan
phpstan.neon
phpunit.xml.dist
plan_tasks.csv
playwright.config.cjs
react

thinking
**Planning to read spec**
exec
/bin/zsh -lc 'cat .plans/C06-02.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
# C06-02 — Implement resilient Search backfill scheduling

Implement the chosen scheduling mechanism for search backfill: idempotent scheduling, safe locking, bounded execution time, and recovery when stuck. Update `docs/search-index.md` and add tests around scheduling/state transitions.

thinking
**Reading handoff instructions**
exec
/bin/zsh -lc 'cat .t2/handoff/C06-02.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
# Handoff: C06-02

Created: 2026-01-18T18:03:25.772528Z

Spec: .plans/C06-02.md

thinking
**Searching for backfill scheduling**
exec
/bin/zsh -lc 'rg -n "backfill|search backfill|search index" src includes tests docs -S' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
docs/OPERATIONAL-KNOBS.md:119:### Search Index Settings
docs/OPERATIONAL-KNOBS.md:121:Configure the search index backfill behavior.
docs/OPERATIONAL-KNOBS.md:126:| `agentwp_config_search_backfill_limit` | 200 | Batch size for backfill operations |
docs/OPERATIONAL-KNOBS.md:127:| `agentwp_config_search_backfill_window` | 0.35 | Time window in seconds for backfill |
docs/OPERATIONAL-KNOBS.md:131:// Increase backfill batch size for faster indexing
docs/OPERATIONAL-KNOBS.md:132:add_filter( 'agentwp_config_search_backfill_limit', fn() => 500 );
docs/openapi.json:271:        "summary": "Search indexed resources",
docs/CHANGELOG.md:44:  - ADR 0006: Search Index Architecture
docs/CHANGELOG.md:47:- **Search Index** (`docs/search-index.md`): Detailed search index troubleshooting and performance documentation.
docs/API.md:169:Admin-only diagnostics snapshot (health, recent REST logs, rate limit, config flags, search index state).
docs/search-index.md:1:# Search Index
docs/search-index.md:3:AgentWP includes a custom search index for fast fulltext search of WooCommerce products, orders, and customers. This document explains how the index works, how to troubleshoot issues, and performance considerations.
docs/search-index.md:7:The search index is a MySQL table (`agentwp_search_index`) that stores normalized, searchable text for:
docs/search-index.md:49:### Incremental Backfill
docs/search-index.md:51:When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
docs/search-index.md:53:1. **Activation**: Creates the table and initializes backfill state
docs/search-index.md:57:Backfill parameters:
docs/search-index.md:91:## Backfill State
docs/search-index.md:93:Backfill progress is tracked in the `agentwp_search_index_state` option:
docs/search-index.md:112:1. **Check backfill status**:

thinking
**Reviewing search index scheduling**

I'm examining the relevant parts of the search index class to understand how the scheduling currently operates before making modifications.
exec
/bin/zsh -lc "sed -n '800,1100p' src/Search/Index.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
			return $normalized;
		}

		$tokens = array_filter( $tokens );

		if ( empty( $tokens ) ) {
			return $normalized;
		}

		$parts = array();
		foreach ( $tokens as $token ) {
			$cleaned = preg_replace( '/[^a-z0-9@._\-]/', '', $token );
			$token   = is_string( $cleaned ) ? $cleaned : $token;
			if ( '' === $token ) {
				continue;
			}
			$parts[] = '+' . $token . '*';
		}

		return $parts ? implode( ' ', $parts ) : $normalized;

thinking
**Reviewing scheduling requirements**

I'm noting the need to enhance scheduling with resilience, idempotency, safe locking, bounded execution, and stuck recovery, and plan to examine the search-index docs and code for existing scheduling logic and state handling.
exec
/bin/zsh -lc "sed -n '1100,1300p' src/Search/Index.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
					ORDER BY ID ASC
					LIMIT %d",
					'product',
					$after_id,
					$limit
				)
			);
		}

		if ( 'orders' === $type ) {
			return $wpdb->get_col(
				$wpdb->prepare(
					"SELECT ID FROM {$wpdb->posts}
					WHERE post_type = %s
					AND post_status NOT IN ('trash', 'auto-draft')
					AND ID > %d
					ORDER BY ID ASC
					LIMIT %d",
					'shop_order',
					$after_id,

thinking
**Reviewing scheduling and locking strategy**

Current scheduling triggers backfill on init with a short-lived lock; next steps include improving idempotency, safety, execution bounds, and recovery—possibly capturing this in ADR 0009.
exec
/bin/zsh -lc 'cat docs/adr/0009-background-job-scheduling.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 45ms:
# ADR 0009: Background Job Scheduling (WP-Cron vs Action Scheduler)

**Date:** 2026-01-18
**Status:** Accepted

## Context

AgentWP currently runs two background tasks using WP-Cron:

1. **Search index backfill** (`src/Search/Index.php`)
   - Hook: `agentwp_search_backfill`
   - Schedule: every minute (custom interval)
   - Characteristics: time-sliced batches, transient lock, unschedules when complete
   - Fallback: search queries fall back to source tables while backfill is incomplete

2. **Usage retention purge** (`src/Billing/UsageTracker.php`)
   - Hook: `agentwp_usage_purge`
   - Schedule: daily
   - Characteristics: deletes old rows based on retention config


thinking
**Inspecting docs search-index**

I'm reviewing the docs search-index code to identify current scheduling logic and locate any issues before implementing the new scheduling mechanism and adding tests.
exec
/bin/zsh -lc "sed -n '1,220p' docs/search-index.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
# Search Index

AgentWP includes a custom search index for fast fulltext search of WooCommerce products, orders, and customers. This document explains how the index works, how to troubleshoot issues, and performance considerations.

## Overview

The search index is a MySQL table (`agentwp_search_index`) that stores normalized, searchable text for:

- **Products**: Name, SKU, and ID
- **Orders**: Order number, customer name, email, and status
- **Customers**: Display name, email, and ID

The index enables fast typeahead search via the `/agentwp/v1/search` REST endpoint.

## How It Works

### Index Table

The index table has the following structure:


thinking
**Clarifying scheduling and adding tests**

The cron scheduling, not admin page loads, drives backfill state transitions, so I need to update documentation and add or revise tests around this scheduling behavior by reviewing existing backfill tests.
exec
/bin/zsh -lc "sed -n '1,220p' tests/Unit/Search/BackfillTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Tests for Search Index Backfill Logic.
 *
 * @package AgentWP\Tests\Unit\Search
 */

namespace AgentWP\Tests\Unit\Search;

use AgentWP\Search\Index;
use AgentWP\Tests\TestCase;
use ReflectionClass;
use ReflectionMethod;
use WP_Mock;

/**
 * Unit tests for Index backfill and throttling behavior.
 *
 * These tests validate the backfill logic including:
 * - State transitions (not started -> in progress -> complete)
exec
/bin/zsh -lc "sed -n '220,520p' tests/Unit/Search/BackfillTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
	// Backfill Order Tests
	// ===========================================

	public function test_backfill_processes_types_in_order(): void {
		// Backfill processes: products -> orders -> customers.
		// This is the expected order as defined in maybe_backfill().
		$expected_order = array( 'products', 'orders', 'customers' );

		$this->assertSame( 'products', $expected_order[0] );
		$this->assertSame( 'orders', $expected_order[1] );
		$this->assertSame( 'customers', $expected_order[2] );
	}

	public function test_backfill_skips_complete_types(): void {
		// If products is complete (-1), backfill should skip it.
		$state = array(
			'products'  => -1, // Skip.
			'orders'    => 0,  // Process this.
			'customers' => 0,
		);

thinking
**Planning tests for scheduling and state transitions**

I'm focusing on adding thorough tests around scheduling behavior, state transitions, idempotency of backfill scheduling, unscheduling on completion, and locking. I'll also inspect the Search Index for other static properties like hooks_registered that might influence this behavior.
exec
/bin/zsh -lc 'rg -n "hooks_registered|table_verified" src/Search/Index.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 43ms:
66:	private static $hooks_registered = false;
78:		if ( self::$hooks_registered ) {
82:		self::$hooks_registered = true;
137:	private static $table_verified = false;
149:		if ( self::$table_verified ) {
159:			self::$table_verified = true;
185:		self::$table_verified = true;

thinking
**Planning index and state setup**

I'm preparing to add an index for scheduling and consider introducing additional state at the top of the file.
exec
/bin/zsh -lc "sed -n '1,200p' src/Search/Index.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Search index management.
 *
 * @package AgentWP
 */

namespace AgentWP\Search;

use AgentWP\Config\AgentWPConfig;
use AgentWP\Plugin;

// phpcs:disable WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching -- Custom search index relies on direct SQL; caching/invalidation is managed by the index lifecycle.

class Index {
	const TABLE           = 'agentwp_search_index';
	const VERSION         = '1.0';
	const VERSION_OPTION  = 'agentwp_search_index_version';
	const STATE_OPTION    = 'agentwp_search_index_state';
	const BACKFILL_HOOK   = 'agentwp_search_backfill';


thinking
**Analyzing backfill scheduling resilience**

I'm assessing the current backfill locking using transients with race conditions due to non-atomic set operations; switching to `add_option` or `wp_cache_add` might provide atomic lock acquisition with TTL managed by timestamp storage, enabling safe locking and recovery when stuck. Next, I'll ensure scheduling prevents duplicates for idempotency.
thinking
**Refining scheduling logic and recovery**

I'm confirming idempotent scheduling via `wp_next_scheduled` but will improve recovery by detecting and clearing stale locks and re-scheduling incomplete states. I'll ensure bounded execution is respected in backfill runs and plan to add unit tests covering scheduling and state transitions using WP_Mock.
exec
/bin/zsh -lc "sed -n '1,200p' tests/TestCase.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 44ms:
<?php
/**
 * Base test case for AgentWP.
 */

namespace AgentWP\Tests;

use WP_Mock\Tools\TestCase as WP_Mock_TestCase;

class TestCase extends WP_Mock_TestCase {
}

thinking
**Searching for scheduling tests**

I'm looking for existing test coverage around `wp_next_scheduled` to understand how scheduling is currently tested before crafting new tests with WP_Mock.
exec
/bin/zsh -lc 'rg -n "wp_next_scheduled|wp_schedule_event|wp_unschedule_event|cron" tests/Unit -S' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
tests/Unit/Search/BackfillTest.php:346:	// Cron Interval Tests
tests/Unit/Search/BackfillTest.php:349:	public function test_add_cron_interval_adds_one_minute_schedule(): void {
tests/Unit/Search/BackfillTest.php:350:		$schedules = Index::add_cron_interval( array() );
tests/Unit/Search/BackfillTest.php:356:	public function test_add_cron_interval_preserves_existing_schedules(): void {
tests/Unit/Search/BackfillTest.php:364:		$schedules = Index::add_cron_interval( $existing );
tests/Unit/Search/BackfillTest.php:370:	public function test_add_cron_interval_does_not_overwrite_existing(): void {
tests/Unit/Search/BackfillTest.php:378:		$schedules = Index::add_cron_interval( $existing );

thinking
**Reviewing scheduling and config state**

I'm planning to add tests for scheduling and will review Search/Index for related state management. I'll also check config for search settings and AgentWPConfig to potentially configure new behavior and add constants for lock TTL or state.
exec
/bin/zsh -lc "sed -n '130,210p' src/Config/AgentWPConfig.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:

	/**
	 * Rate limiter settings.
	 */
	public const RATE_LIMIT_REQUESTS  = 30;   // Max requests per window
	public const RATE_LIMIT_WINDOW    = 60;   // Window duration in seconds
	public const RATE_LIMIT_LOCK_TIMEOUT = 5; // Lock timeout in seconds
	public const RATE_LIMIT_LOCK_ATTEMPTS = 10; // Max lock acquisition attempts
	public const RATE_LIMIT_LOCK_DELAY_US = 10000; // Delay between lock attempts (microseconds)

	/**
	 * Cache lock settings.
	 */
	public const CACHE_LOCK_TIMEOUT    = 30;    // Lock timeout in seconds
	public const CACHE_LOCK_ATTEMPTS   = 50;    // Max lock acquisition attempts
	public const CACHE_LOCK_DELAY_US   = 20000; // Delay between lock attempts (microseconds)
	public const CACHE_TTL_MINIMUM     = 300;   // Minimum cache TTL (5 minutes)

	/**
	 * Search index settings.

thinking
**Considering lock TTL option**

I'm evaluating adding a lock TTL with timestamp storage for safer locking and will investigate existing lock strategies in the codebase for consistency before deciding.
exec
/bin/zsh -lc 'rg -n "lock" src -S | head' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
src/Services/AnalyticsService.php:11:use AgentWP\Contracts\ClockInterface;
src/Services/AnalyticsService.php:38:	 * Clock service for timezone-aware time operations.
src/Services/AnalyticsService.php:40:	 * @var ClockInterface
src/Services/AnalyticsService.php:42:	private ClockInterface $clock;
src/Services/AnalyticsService.php:49:	 * @param ClockInterface                   $clock           Clock service.
src/Services/AnalyticsService.php:54:		ClockInterface $clock
src/Services/AnalyticsService.php:58:		$this->clock           = $clock;
src/Services/AnalyticsService.php:69:		$now  = $this->clock->now();
src/Services/AnalyticsService.php:173:		$now    = $this->clock->now();
src/Services/AnalyticsService.php:293:		$now  = $this->clock->now();

thinking
**Searching for CacheLock references**
exec
/bin/zsh -lc 'rg -n "Lock" src -S | head -n 40' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 63ms:
src/Infrastructure/WordPressTransientCache.php:96:	private function getLockTimeout(): int {
src/Infrastructure/WordPressTransientCache.php:107:	private function getMaxLockAttempts(): int {
src/Infrastructure/WordPressTransientCache.php:118:	private function getLockRetryDelayUs(): int {
src/Infrastructure/WordPressTransientCache.php:154:		$maxAttempts  = $this->getMaxLockAttempts();
src/Infrastructure/WordPressTransientCache.php:155:		$lockTimeout  = $this->getLockTimeout();
src/Infrastructure/WordPressTransientCache.php:156:		$retryDelay   = $this->getLockRetryDelayUs();
src/Infrastructure/WordPressTransientCache.php:221:			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Lock keys may intentionally use short TTLs.
src/Infrastructure/RateLimiting/RateLimiter.php:32:	 * Lock timeout in seconds.
src/Infrastructure/RateLimiting/RateLimiter.php:43:	private int $maxLockAttempts;
src/Infrastructure/RateLimiting/RateLimiter.php:90:	 * Lock settings are read from AgentWPConfig with filter support.
src/Infrastructure/RateLimiting/RateLimiter.php:92:	 * - 'agentwp_config_rate_limit_lock_timeout' (int): Lock timeout in seconds (default 5)
src/Infrastructure/RateLimiting/RateLimiter.php:117:		$this->maxLockAttempts  = (int) AgentWPConfig::get( 'rate_limit.lock_attempts', AgentWPConfig::RATE_LIMIT_LOCK_ATTEMPTS );
src/Infrastructure/RateLimiting/RateLimiter.php:181:			for ( $i = 0; $i < $this->maxLockAttempts; $i++ ) {
src/Config/AgentWPConfig.php:136:	public const RATE_LIMIT_LOCK_TIMEOUT = 5; // Lock timeout in seconds
src/Config/AgentWPConfig.php:143:	public const CACHE_LOCK_TIMEOUT    = 30;    // Lock timeout in seconds

thinking
**Inspecting WordPressTransientCache lock mechanism**
exec
/bin/zsh -lc "sed -n '130,220p' src/Infrastructure/WordPressTransientCache.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 33ms:
		return (int) AgentWPConfig::get( 'cache.ttl_minimum', AgentWPConfig::CACHE_TTL_MINIMUM );
	}

	/**
	 * {@inheritDoc}
	 */
	public function remember( string $key, callable $callback, int $expiration = 0 ): mixed {
		$prefixed_key = $this->prefixKey( $key );

		// First check - fast path for existing values.
		$raw = get_transient( $prefixed_key );

		// Check for wrapped value (new format).
		if ( is_array( $raw ) && isset( $raw['__wrapped__'] ) ) {
			return $raw['value'];
		}

		// For backward compatibility - non-wrapped truthy values.
		if ( false !== $raw ) {
			return $raw;
exec
/bin/zsh -lc "sed -n '220,360p' src/Infrastructure/WordPressTransientCache.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 38ms:
			// wp_cache_add returns false if key already exists.
			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Lock keys may intentionally use short TTLs.
			return wp_cache_add( $prefixed_key, $wrapped, 'transient', $expiration );
		}

		// For database-backed transients, check existence first then set.
		// This has a small race window but is the best we can do without object cache.
		$existing = get_transient( $prefixed_key );
		if ( false !== $existing ) {
			return false;
		}

		return set_transient( $prefixed_key, $wrapped, $expiration );
	}

	/**
	 * Prefix a key.
	 *
	 * @param string $key The key.
	 * @return string


thinking
**Planning robust locking with recovery**

Considering implementing a safe lock using add_option for atomicity, storing a token and expiration to prevent stale releases. Planning to track last activity timestamps separately to enable recovery when the lock is stuck, possibly extending state with metadata for progress monitoring.
thinking
**Detailing safe locking and bounded execution**

Planning to implement atomic lock with `add_option` plus timestamps and unique tokens to handle expiration and recovery, considering object cache with `wp_cache_add` for atomicity. Also deciding to enforce bounded execution by adding deadline checks inside batch loops to stop early and update cursors, plus tracking `last_run` for detecting and recovering from stuck backfills.
exec
/bin/zsh -lc "sed -n '110,170p' docs/OPERATIONAL-KNOBS.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
Control streaming response processing limits.

| Filter | Default | Description |
|--------|---------|-------------|
| `agentwp_config_stream_max_content_length` | 1048576 | Max content length (1MB) |
| `agentwp_config_stream_max_tool_calls` | 50 | Max tool calls per stream |
| `agentwp_config_stream_max_raw_chunks` | 100 | Max raw chunks to buffer |
| `agentwp_config_stream_max_tool_arg_length` | 102400 | Max tool argument length (100KB) |

### Search Index Settings

Configure the search index backfill behavior.

| Filter | Default | Description |
|--------|---------|-------------|
| `agentwp_config_search_default_limit` | 5 | Default search result limit |
| `agentwp_config_search_backfill_limit` | 200 | Batch size for backfill operations |
| `agentwp_config_search_backfill_window` | 0.35 | Time window in seconds for backfill |

**Example:**

thinking
**Considering state format change**

I'm evaluating adding metadata like `last_run` or `last_cursor` to the search index state but want to avoid breaking existing array-based formats, so I'm planning to add a separate option for meta info and will check tests to confirm current state usage.
exec
/bin/zsh -lc 'rg -n "search_index_state" tests src -S' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 64ms:
src/Rest/DiagnosticsController.php:55:				'search_index' => $this->get_search_index_state(),
src/Rest/DiagnosticsController.php:175:	private function get_search_index_state(): array {
src/Search/Index.php:19:	const STATE_OPTION    = 'agentwp_search_index_state';
tests/Unit/Search/IndexTest.php:96:		$this->assertSame( 'agentwp_search_index_state', Index::STATE_OPTION );

thinking
**Reviewing diagnostics controller**
exec
/bin/zsh -lc "sed -n '150,220p' src/Rest/DiagnosticsController.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
	 */
	private function read_settings(): array {
		$settings_manager = $this->getSettingsManager();
		if ( $settings_manager ) {
			return $settings_manager->getAll();
		}

		return SettingsManager::getDefaults();
	}

	/**
	 * Get the SettingsManager service from the container.
	 *
	 * @return SettingsManager|null
	 */
	private function getSettingsManager(): ?SettingsManager {
		$manager = $this->resolve( SettingsManager::class );
		return $manager instanceof SettingsManager ? $manager : null;
	}



thinking
**Planning separate metadata storage**

Deciding to keep backfill metadata in a separate option for clarity and backward compatibility, avoiding mixing metadata into the main state array to prevent confusion and ensure easier testing. Next, I'll define new constants for backfill lock TTL and option and verify idempotent scheduling using existing WordPress scheduling functions.
thinking
**Designing safe locking and stuck recovery**

Planning to enhance locking with tokens to prevent accidental lock release by other processes and set a fixed 120-second TTL for locks. Also defining stuck recovery by tracking last run heartbeat and state progress, releasing stale locks, and re-scheduling backfill if inactivity exceeds a 10–15 minute threshold.
exec
/bin/zsh -lc 'rg -n "C06-02" -n tasks.csv plan_tasks.csv .plans -S' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
plan_tasks.csv:26:C06-02,"Implement resilient Search backfill scheduling","Implement the chosen scheduling mechanism for search backfill: idempotent scheduling, safe locking, bounded execution time, and recovery when stuck. Update `docs/search-index.md` and add tests around scheduling/state transitions."
.plans/C06-02.md:1:# C06-02 — Implement resilient Search backfill scheduling

thinking
**Planning test inspection**

I'm preparing to examine Search Index tests, likely named IndexTest, to identify expected constants and determine if updates are needed for new constants or behavior.
exec
/bin/zsh -lc "sed -n '80,130p' tests/Unit/Search/IndexTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
	// Constants Tests
	// ===========================================

	public function test_version_constant_is_defined(): void {
		$this->assertSame( '1.0', Index::VERSION );
	}

	public function test_table_constant_is_defined(): void {
		$this->assertSame( 'agentwp_search_index', Index::TABLE );
	}

	public function test_version_option_constant_is_defined(): void {
		$this->assertSame( 'agentwp_search_index_version', Index::VERSION_OPTION );
	}

	public function test_state_option_constant_is_defined(): void {
		$this->assertSame( 'agentwp_search_index_state', Index::STATE_OPTION );
	}

	public function test_default_limit_is_five(): void {




thinking
**Planning bounded backfill execution**

I'm designing a time-limited backfill approach by adding a deadline parameter to abort once exceeded, updating progress to the last processed ID without prematurely marking completion to avoid infinite loops or stuck states. Next, I'll integrate time checks within iteration and ensure coordinated calls prevent overlap.
thinking
**Designing idempotent scheduling and stuck recovery**

I'm outlining a robust locking mechanism with token-based transient locks and TTL to safely coordinate backfill runs, adding heartbeat tracking to detect stuck backfills and reschedule stale events. Next, I'll implement idempotent scheduling by verifying existing schedules and introduce recovery logic to clear stale locks and reschedule if progress stalls or events become outdated.
thinking
**Refining lock handling and scheduling resilience**

I'm finalizing lock acquire/release with transient-stored token and expiration checks to robustly handle stale locks, and moving cron schedule registration into init for consistent availability. Also refining schedule_backfill to reschedule only when backfill incomplete and schedule stale, with heartbeat tracking updated after runs for stuck detection.
thinking
**Designing heartbeat, deadline handling, and detailed tests**

I'm defining new heartbeat helpers, deadline-aware backfill processing, and refined stale schedule detection with stuck recovery. Also planning thorough tests for lock acquire/release logic, idempotent scheduling, stale schedule handling, and ensuring heartbeat correctness.
exec
/bin/zsh -lc 'rg -n "return_in_order" tests -S' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 40ms:


thinking
**Assessing WP_Mock return control**

I'm exploring WP_Mock's support for 'return_in_order' to simulate multiple calls with different returns, aiming to handle scheduling loops by adjusting how events are unscheduled and mimicked in tests. Checking vendor code may confirm the proper mocking API to use.
exec
/bin/zsh -lc 'rg -n "return_in_order" vendor -S' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 202ms:
vendor/10up/wp_mock/php/WP_Mock.php:420:     * - `return_in_order`: Use this if your function will be called multiple times in the test but needs to have different return values.
vendor/10up/wp_mock/php/WP_Mock.php:422:     *                      For example, if you are mocking `is_single()`, you can set `return_in_order` to `[false, true]`. The first time is_single() is called it will return false.
vendor/10up/wp_mock/php/WP_Mock.php:426:     *                 You can also set this to true, which is equivalent to `0`. This will override both return and return_in_order.
vendor/10up/wp_mock/php/WP_Mock/Functions.php:145:        if (isset($args['return_arg']) || isset($args['return_in_order'])) {
vendor/10up/wp_mock/php/WP_Mock/Functions.php:240:        } elseif (isset($args['return_in_order'])) {
vendor/10up/wp_mock/php/WP_Mock/Functions.php:243:            $returnValue->setReturnValues((array) $args['return_in_order']);


thinking
**Planning lock constant and test updates**

The existing lock constant aligns with the expected key, so I'll keep using the transient-based key for now. I'll add the new static property for the lock token and update related tests accordingly while implementing the lock as a transient storing an array with a token.
thinking
**Designing transient-based lock with token and retries**

I'm outlining a transient-backed lock storing an array with token and expiration, including helpers to check active/stale states and safely acquire/release the lock with retries on stale locks. I'll guard calls to caching functions for test compatibility and plan test updates to mock multiple transient reads using return_in_order.
exec
/bin/zsh -lc "sed -n '380,460p' vendor/10up/wp_mock/php/WP_Mock.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
        $intercept = Mockery::mock('intercept');
        $intercept->shouldNotReceive('intercepted');

        /** @var WP_Mock\HookedCallbackResponder $responder */
        $responder = self::onHookAdded($hook, $type)
            ->with($callback, $priority, $args);
        $responder->perform([$intercept, 'intercepted']);
    }

    /**
     * Asserts that all hooks are added.
     *
     * @return void
     */
    public static function assertHooksAdded() : void
    {
        $allHooksAdded = self::$event_manager->allHooksAdded();
        $failed = implode(', ', self::$event_manager->expectedHooks());
        PHPUnit\Framework\Assert::assertTrue($allHooksAdded, 'Method failed to add hooks: ' . $failed);
    }

thinking
**Updating code and tests for return_in_order**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Search/Index.php
@@ -21,2 +21,5 @@
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
@@ -83,2 +86,4 @@
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
@@ -862,2 +867,162 @@
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
@@ -876,9 +1041,3 @@
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
@@ -890,9 +1049,17 @@
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
@@ -944,5 +1111,6 @@
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
@@ -950,6 +1118,28 @@
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
@@ -962,3 +1152,16 @@
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
@@ -981,2 +1184,4 @@
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
@@ -987,9 +1192,3 @@
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
@@ -1020,9 +1219,3 @@
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
@@ -1032,5 +1225,6 @@
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
@@ -1038,8 +1232,8 @@
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
@@ -1056,3 +1250,7 @@
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
@@ -1065,3 +1263,8 @@
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
@@ -1073,5 +1276,9 @@
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
@@ -1151,3 +1358,3 @@
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Search/Index.php
file update:
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}

file update:
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}



thinking
**Reviewing backfill filter and lock updates**

I'm verifying no duplicate add_filter calls remain after moving schedule_backfill logic and confirming backfill_type signatures and array_flip usage are correct and PHP 7.4 compatible. I'll fix indent issues in fetch_ids and update tests to reset lock tokens and handle multiple transient calls with expected array values.
thinking
**Detailing transient and scheduling test mocks**

I'm clarifying get_transient call sequencing and return values for lock tests, adjusting mocks to handle multiple calls with consistent return_in_order settings. I'll add coverage for lock release token matching and no-delete scenarios, plus comprehensive mocks for schedule_backfill variations, ensuring all transient, option, and schedule-related functions are properly stubbed and expectations reflect updated lock data structures.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/tests/Unit/Search/BackfillTest.php
@@ -52,2 +52,3 @@
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
@@ -393,3 +394,3 @@
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
@@ -401,3 +402,3 @@
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
@@ -418,3 +419,7 @@
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
@@ -429,2 +434,16 @@
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
@@ -446,2 +465,148 @@
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M /Users/ahmedyounis/Documents/Projects/agentwp/tests/Unit/Search/BackfillTest.php
file update:
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..79ac3253c2bf38b88fd2271a88f3ee8e3778667c
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,152 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================

file update:
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..79ac3253c2bf38b88fd2271a88f3ee8e3778667c
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,152 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================


Reconnecting... 1/5 (stream disconnected before completion: Transport error: network error: error decoding response body)


thinking
**Reviewing test coverage for transient calls and filters**

Tests use fully qualified WP_Mock\Functions calls, so imports are fine; the updated transient expectations match the new constant and should pass. The backfill lock tests verify set_transient and get_transient calls appropriately. The added add_filter in init is not triggered in tests yet, but schedule_backfill no longer adds filters directly, relying on init instead, which aligns with the hook usage.
thinking
**Clarifying cron scheduling and updating backfill docs**

The filter for custom cron schedules is registered before the init action runs, ensuring the backfill schedule uses the intended interval. The new backfill constants and heartbeat option call for doc updates—especially revising the incremental backfill steps to emphasize WP-Cron use, explaining heartbeat-based recovery, and specifying exact timing constants for TTL and stuck thresholds.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/search-index.md
@@ -53,3 +53,3 @@
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
@@ -59,3 +59,3 @@
 - **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Execution context**: WP-Cron only (no frontend overhead)
 
@@ -107,2 +107,11 @@
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
@@ -140,3 +149,10 @@
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
@@ -146,3 +162,3 @@
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
@@ -200,3 +216,5 @@
 | Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
@@ -212,3 +230,3 @@
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: ~5-10 minutes (at 200 records per minute)
 
apply_patch(auto_approved=true) exited 0 in 38ms:
Success. Updated the following files:
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/search-index.md
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..ea049c17385c1f2f84765fec3303bbb44619e6f5
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
 - **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
    // Next admin page load will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -198,7 +214,9 @@
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
 | Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: ~5-10 minutes (at 200 records per minute)
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..79ac3253c2bf38b88fd2271a88f3ee8e3778667c
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,152 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================

file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..ea049c17385c1f2f84765fec3303bbb44619e6f5
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
 - **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
    // Next admin page load will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -198,7 +214,9 @@
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
 | Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: ~5-10 minutes (at 200 records per minute)
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..79ac3253c2bf38b88fd2271a88f3ee8e3778667c
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,152 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================


thinking
**Updating wording for cron context**

I'm correcting text references from "page load" to "cron run" and standardizing timing descriptions to clearly reflect WP-Cron execution context.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/search-index.md
@@ -58,3 +58,3 @@
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
+- **Time window**: 350ms maximum per cron run
 - **Execution context**: WP-Cron only (no frontend overhead)
@@ -159,3 +159,3 @@
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
apply_patch(auto_approved=true) exited 0 in 50ms:
Success. Updated the following files:
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/search-index.md
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..db9894d09a917e4d2e0efedd1fdc8cbd89169e94
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -198,7 +214,9 @@
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
 | Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: ~5-10 minutes (at 200 records per minute)
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..79ac3253c2bf38b88fd2271a88f3ee8e3778667c
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,152 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================

file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..db9894d09a917e4d2e0efedd1fdc8cbd89169e94
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -198,7 +214,9 @@
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
 | Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: ~5-10 minutes (at 200 records per minute)
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..79ac3253c2bf38b88fd2271a88f3ee8e3778667c
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,152 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================


thinking
**Planning admin reference update**
exec
/bin/zsh -lc 'rg -n "admin page|page load|admin" docs/search-index.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
126:   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
197:   // Next admin loads will re-index
216:| Time window | 350ms | Limits page load impact |
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..db9894d09a917e4d2e0efedd1fdc8cbd89169e94
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -198,7 +214,9 @@
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
 | Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: ~5-10 minutes (at 200 records per minute)
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..79ac3253c2bf38b88fd2271a88f3ee8e3778667c
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,152 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================


thinking
**Updating troubleshooting messages**

I'm revising troubleshooting text to clarify that cron events trigger re-indexing and to better describe impact limitations, replacing mentions of admin page loads with cron references.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/search-index.md
@@ -125,3 +125,3 @@
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
@@ -196,3 +196,3 @@
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
@@ -215,3 +215,3 @@
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
+| Time window | 350ms | Limits cron run impact |
 | Lock TTL | 120s | Prevents concurrent backfill runs |
apply_patch(auto_approved=true) exited 0 in 49ms:
Success. Updated the following files:
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/search-index.md
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..80ec2297b0b57bfd484da78d89aa214f10f94614
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: ~5-10 minutes (at 200 records per minute)
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..79ac3253c2bf38b88fd2271a88f3ee8e3778667c
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,152 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================

file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..80ec2297b0b57bfd484da78d89aa214f10f94614
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: ~5-10 minutes (at 200 records per minute)
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..79ac3253c2bf38b88fd2271a88f3ee8e3778667c
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,152 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================


thinking
**Extending backfill context check**

I'm adding a check for "admin" within the backfill context to ensure comprehensive coverage. Next, I'll verify results after updating the search criteria.
exec
/bin/zsh -lc 'rg -n "admin" docs/search-index.md' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 50ms:

file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..80ec2297b0b57bfd484da78d89aa214f10f94614
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: ~5-10 minutes (at 200 records per minute)
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..79ac3253c2bf38b88fd2271a88f3ee8e3778667c
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,152 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================



thinking
**Reviewing WP-Cron scheduling and mocking in tests**

I'm confirming that WP-Cron is scheduled per minute and considering adding a note about DISABLE_WP_CRON in the backfill docs. I verified that relevant tests mock `get_option` properly for heartbeat checks and backfill state but noted the loop in unscheduling backs out correctly when `wp_next_scheduled` returns false, matching the mocked calls. The test mocks for `get_option` appear sufficient given the paths exercised.
thinking
**Evaluating backfill scheduling logic and test coverage**

I carefully reviewed scheduling logic, confirming correct use of `get_option` for state and heartbeat and verifying unscheduling loops behave as expected. I identified a missing test for rescheduling when the heartbeat is stale despite `next_scheduled` being in the future, so I'll add a targeted test mocking these conditions with precise `get_option` expectations to cover this recovery path.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/tests/Unit/Search/BackfillTest.php
@@ -611,2 +611,57 @@
 
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
apply_patch(auto_approved=true) exited 0 in 42ms:
Success. Updated the following files:
M /Users/ahmedyounis/Documents/Projects/agentwp/tests/Unit/Search/BackfillTest.php
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..80ec2297b0b57bfd484da78d89aa214f10f94614
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: ~5-10 minutes (at 200 records per minute)
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================

file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..80ec2297b0b57bfd484da78d89aa214f10f94614
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: ~5-10 minutes (at 200 records per minute)
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================



thinking
**Finalizing heartbeat test details and doc checks**

Tests for schedule heartbeat are planned with attention to avoiding duplicate mocks and verifying option calls; the backfill lock token is already correctly initialized. Documentation will be updated to clarify the backfill timing and troubleshooting without adding unnecessary admin references.
thinking
**Reviewing backfill scheduling logic and updating timing docs**

I confirmed the heartbeat and scheduling interactions handle fresh starts and early returns correctly, with timing checks aligned to avoid overruns by more than one item. The backfill time estimates need updating to reflect realistic cron run frequencies, adjusting examples from 5–10 minutes to about 50 minutes or more for 10k products depending on cron frequency.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/search-index.md
@@ -230,3 +230,3 @@
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per minute)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
apply_patch(auto_approved=true) exited 0 in 48ms:
Success. Updated the following files:
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/search-index.md
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================

file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================



thinking
**Refining backfill docs and code placement**

Planning to add notes on WP-Cron triggered by system cron near incremental backfill and troubleshooting, confirming time window and execution context docs are correct. Verified `array_flip` use is safe, method insertion order in Index.php looks fine, and considering but not committing to adding heartbeat info in diagnostics tests.
thinking
**Reviewing docs, code comments, and formatting**

Confirmed heartbeat option mention in docs is fine without adding to diagnostics, verified no needed indentation fixes in Index.php, and ensured `wp_next_scheduled` checks remain. Checked time window constants and existing comments mostly still apply, planning to review comments about "page loads" and admin requests for accuracy after changes.
exec
/bin/zsh -lc 'rg -n "admin|page load" src/Search/Index.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 36ms:
93:		// Backfill runs via scheduled cron event to avoid blocking admin requests.
168:		require_once ABSPATH . 'wp-admin/includes/upgrade.php';
1031:	 * blocking normal admin requests.
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..adda08245d8ab6b19323a77cf1d2567350f5de02
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,6 +84,8 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
-			return;
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
+			return;
+		}
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================


thinking
**Aligning comments for clarity**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Search/Index.php
@@ -92,3 +92,3 @@
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
apply_patch(auto_approved=true) exited 0 in 46ms:
Success. Updated the following files:
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Search/Index.php
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..0cc00f5a07928179d0db768ec0bd7de0b6f40741
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,14 +1047,22 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
-
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
 	}
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
 
-		return $result;
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
+
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================

file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..0cc00f5a07928179d0db768ec0bd7de0b6f40741
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,14 +1047,22 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
-
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
 	}
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
 
-		return $result;
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
+
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================


thinking
**Reviewing comment changes**

Noting that only one comment was changed in the patch; checking another comment near maybe_backfill related to admin for clarity.
exec
/bin/zsh -lc 'rg -n "admin" src/Search/Index.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
168:		require_once ABSPATH . 'wp-admin/includes/upgrade.php';
1031:	 * blocking normal admin requests.
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..0cc00f5a07928179d0db768ec0bd7de0b6f40741
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,14 +1047,22 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
-
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
 	}
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
 
-		return $result;
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
+
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================


thinking
**Updating docblock for clarity**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Search/Index.php
apply_patch(auto_approved=true) exited 0 in 47ms:
Success. Updated the following files:
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Search/Index.php
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..0cc00f5a07928179d0db768ec0bd7de0b6f40741
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,14 +1047,22 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
-
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
 	}
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
 
-		return $result;
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
+
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================

file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..0cc00f5a07928179d0db768ec0bd7de0b6f40741
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,14 +1047,22 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
-
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
 	}
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
 
-		return $result;
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
+
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================


thinking
**Verifying snippet lines for patch**
exec
/bin/zsh -lc "sed -n '1010,1045p' src/Search/Index.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
		if ( self::is_backfill_fully_complete( $state ) ) {
			return false;
		}

		$heartbeat = self::get_backfill_heartbeat();
		if ( empty( $heartbeat['last_run'] ) ) {
			return false;
		}

		$last_run = (int) $heartbeat['last_run'];
		if ( $last_run <= 0 ) {
			return false;
		}

		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
	}

	/**
	 * Schedule the backfill cron event if not already scheduled.
	 *
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..0cc00f5a07928179d0db768ec0bd7de0b6f40741
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,6 +865,166 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,14 +1047,22 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
 
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
-
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
 	}
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
 
-		return $result;
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
+
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
-
-			$state = self::backfill_type( $type, $state );
 
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================


thinking
**Updating docblock for clarity**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Search/Index.php
@@ -1030,3 +1030,3 @@
 	 * Uses a one-minute interval to process backfill incrementally without
-	 * blocking normal admin requests.
+	 * blocking normal requests.
 	 *
apply_patch(auto_approved=true) exited 0 in 52ms:
Success. Updated the following files:
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Search/Index.php
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..aa71614405fbf8db0995f32e60cb2403a6ad0147
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,10 +865,170 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
-	 * blocking normal admin requests.
+	 * blocking normal requests.
 	 *
 	 * @return void
 	 */
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
-
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
 
-			$state = self::backfill_type( $type, $state );
-
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================

file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..aa71614405fbf8db0995f32e60cb2403a6ad0147
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,10 +865,170 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
-	 * blocking normal admin requests.
+	 * blocking normal requests.
 	 *
 	 * @return void
 	 */
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
-
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
 
-			$state = self::backfill_type( $type, $state );
-
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================


thinking
**Searching for additional "admin" mentions**
exec
/bin/zsh -lc 'rg -n "admin" src/Search/Index.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
168:		require_once ABSPATH . 'wp-admin/includes/upgrade.php';
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..aa71614405fbf8db0995f32e60cb2403a6ad0147
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,10 +865,170 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
-	 * blocking normal admin requests.
+	 * blocking normal requests.
 	 *
 	 * @return void
 	 */
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
-
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
 
-			$state = self::backfill_type( $type, $state );
-
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================


thinking
**Confirming backfill heartbeat usage**

I'm verifying that the backfill heartbeat constant is consistently used and ensuring the backfill heartbeat update is called only where appropriate, noting that `maybe_backfill` is mainly called from `run_scheduled_backfill`. Next, I'll confirm no missing calls outside cron and check for any unintended doc or formatting changes.
exec
/bin/zsh -lc 'rg -n "maybe_backfill" -S' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 73ms:
src/Search/Index.php:224:		// Do not call ensure_table() or maybe_backfill() here to avoid
src/Search/Index.php:1184:			self::maybe_backfill();
src/Search/Index.php:1209:	public static function maybe_backfill() {
tests/Unit/Search/BackfillTest.php:226:		// This is the expected order as defined in maybe_backfill().
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..aa71614405fbf8db0995f32e60cb2403a6ad0147
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,10 +865,170 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
-	 * blocking normal admin requests.
+	 * blocking normal requests.
 	 *
 	 * @return void
 	 */
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
-
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
 
-			$state = self::backfill_type( $type, $state );
-
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================



thinking
**Reviewing backfill locking and scheduling logic**

I've confirmed that the heartbeat updates only when the backfill runs, and the lock should always be released even if the backfill exits early. Also verified that the transient lock handling and TTL usage in tests align with the new array-based lock storage. Next, I'll ensure the backfill lock tests properly mock the transient and the number of calls to it.
thinking
**Confirming idempotent scheduling and backfill doc updates**

I've reviewed that the scheduling is idempotent with stale checks and safe locking with new lock token and TTL constants, all reflected in updated docs. Tests already align with new constants and expectations, and style and locking recovery are solid. Next, I'll finalize docs and tests, ensuring consistent use of constants and coverage of heartbeat and lock behaviors.
exec
/bin/zsh -lc 'rg -n "page load|admin" docs/search-index.md' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 52ms:

file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..aa71614405fbf8db0995f32e60cb2403a6ad0147
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,10 +865,170 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
-	 * blocking normal admin requests.
+	 * blocking normal requests.
 	 *
 	 * @return void
 	 */
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
-
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
 
-			$state = self::backfill_type( $type, $state );
-
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================



thinking
**Verifying backfill lock logic and docs**

Checked backfill lock uses transients and object cache correctly with no redundant calls affecting logic. Verified no warnings from array operations on backfill types list. Confirmed heartbeat updates only happen on WP Cron runs and updated related docs accordingly, including cross-references and notes on resetting backfill state.
thinking
**Finalizing backfill scheduling logic and docs**

Completed thorough review and update of backfill scheduling, locking, and heartbeat logic with matching docs reflecting lock TTL, stuck recovery, and WP-Cron assumptions. Verified test expectations align with wp_schedule_event and wp_unschedule_event call sequences and constants usage. Confirmed heartbeat updates occur correctly after backfill runs and that static state resets properly. No new config introduced; no test runs executed as per instructions.

**How to verify:**

- Format: (none provided)  
- Lint: (none provided)  
- Test: (none provided)  

**Risks / follow-ups:**

Backfill relies on WP-Cron running reliably; if disabled, system cron is required to avoid stuck backfills. Consider adding diagnostic hooks or logging for heartbeat status and cron runs to aid troubleshooting. Also, watch for timing delicacies in tests using `time()`. Tests remain unrun and should be executed with `phpunit` or the project's standard test runner before deployment.
exec
/bin/zsh -lc 'git status -sb' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
## main...origin/main
 M .t2/state.json
 M docs/search-index.md
 M src/Search/Index.php
 M tests/Unit/Search/BackfillTest.php
?? .logs/C06-01.gitcommit.txt
?? .plans/C06-02.md
?? .t2/handoff/C06-02.md
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..aa71614405fbf8db0995f32e60cb2403a6ad0147
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,10 +865,170 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
-	 * blocking normal admin requests.
+	 * blocking normal requests.
 	 *
 	 * @return void
 	 */
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
-
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
 
-			$state = self::backfill_type( $type, $state );
-
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================



thinking
**Summarizing key code changes**

Implemented resilient backfill scheduling and locking with TTL, heartbeat, and stale detection in core index code; added related unit tests for locking and recovery; updated search index documentation to reflect new scheduling and recovery features with performance notes but no explicit verification commands.
thinking
**Crafting final structured response**

I'll provide a brief explanatory sentence about adding resilient backfill scheduling and locking with related docs and tests, then follow with the required sections: Status, Summary of changes (with file paths), How to verify noting no commands provided, and Risks / follow-ups including WP-Cron dependency and runtime considerations. I'll keep formatting plain with simple bullets and no special markdown headers.
codex
Implemented resilient search backfill scheduling with safer locking, bounded runtime, and stuck recovery, plus updated docs/tests to reflect WP‑Cron behavior and state transitions.

Status: DONE

Summary of changes:
- Added lock tokening, heartbeat tracking, stale schedule recovery, and per‑item deadline checks for bounded backfill runs in `src/Search/Index.php`.
- Expanded unit coverage for scheduling idempotence/stale recovery and lock release behavior in `tests/Unit/Search/BackfillTest.php`.
- Updated search index documentation for WP‑Cron scheduling, heartbeat/stuck troubleshooting, and revised timing guidance in `docs/search-index.md`.

How to verify (exact commands):
- N/A (no format/lint/test commands were provided)

Risks / follow-ups:
- Recovery still depends on WP‑Cron execution; sites with `DISABLE_WP_CRON` must run a real cron to avoid stalled backfills.
- If indexing a single item is slow, a run can exceed the window by a small amount; consider tuning backfill limits/window if needed.
file update:
diff --git a/docs/search-index.md b/docs/search-index.md
index 53ea482580678aa83779252d09568aa2c7ac0749..567f6d67b2bc905c02c4827041ada1befb240796
--- a/docs/search-index.md
+++ b/docs/search-index.md
@@ -51,13 +51,13 @@
 When the plugin is installed on a site with existing data, a background backfill process indexes existing records:
 
 1. **Activation**: Creates the table and initializes backfill state
-2. **Background processing**: On each admin page load, indexes a batch of records
+2. **Background processing**: A WP-Cron job (`agentwp_search_backfill`) runs every minute and indexes a batch of records
 3. **Completion**: Marked when all types have been processed
 
 Backfill parameters:
 - **Batch size**: 200 records per type per cycle
-- **Time window**: 350ms maximum per page load
-- **Execution context**: Admin requests only (no frontend overhead)
+- **Time window**: 350ms maximum per cron run
+- **Execution context**: WP-Cron only (no frontend overhead)
 
 ### Search Query Flow
 
@@ -105,6 +105,15 @@
 - `N` (positive) = Cursor position (last processed ID)
 - `-1` = Complete
 
+Backfill heartbeat is tracked in `agentwp_search_index_backfill_heartbeat`:
+
+```php
+[
+    'last_run' => 1700000000, // Unix timestamp of most recent run
+    'state'    => [ 'products' => 150, 'orders' => 0, 'customers' => -1 ],
+]
+```
+
 ## Troubleshooting
 
 ### Search Returns No Results
@@ -114,7 +123,7 @@
    $state = get_option('agentwp_search_index_state');
    var_dump($state);
    ```
-   If any type shows `0`, backfill hasn't started. Visit any admin page to trigger it.
+   If any type shows `0`, backfill hasn't started. Ensure WP-Cron is running to trigger it.
 
 2. **Check table exists**:
    ```sql
@@ -138,13 +147,20 @@
 
 1. **Check for PHP errors**: Look in error logs for issues with `wc_get_product()` or `wc_get_order()` calls
 
-2. **Force reset**:
+2. **Verify heartbeat**:
+   ```php
+   $heartbeat = get_option('agentwp_search_index_backfill_heartbeat');
+   var_dump($heartbeat);
+   ```
+   If `last_run` is older than 15 minutes, WP-Cron may not be executing. Ensure a real cron is calling `wp-cron.php` when `DISABLE_WP_CRON` is set.
+
+3. **Force reset**:
    ```php
    delete_option('agentwp_search_index_state');
-   // Next admin page load will restart from ID 0
+   // Next cron run will restart from ID 0
    ```
 
-3. **Manual re-index**: For a specific product:
+4. **Manual re-index**: For a specific product:
    ```php
    \AgentWP\Search\Index::index_product($product_id);
    ```
@@ -178,7 +194,7 @@
    $state = get_option('agentwp_search_index_state', []);
    $state['products'] = 0;
    update_option('agentwp_search_index_state', $state, false);
-   // Next admin loads will re-index
+   // Next cron runs will re-index
    ```
 
 3. **Clear and rebuild**:
@@ -197,8 +213,10 @@
 | Limit | Value | Purpose |
 |-------|-------|---------|
 | Batch size | 200 records | Prevents memory issues |
-| Time window | 350ms | Limits page load impact |
-| Admin-only | Yes | No frontend overhead |
+| Time window | 350ms | Limits cron run impact |
+| Lock TTL | 120s | Prevents concurrent backfill runs |
+| Stuck recovery | 15 min | Reschedules if no progress detected |
+| WP-Cron only | Yes | No frontend overhead |
 | Single run | Per request | Prevents race conditions |
 
 ### Index Size Estimates
@@ -210,7 +228,7 @@
 
 For a store with 10,000 products, 50,000 orders, 20,000 customers:
 - Index size: ~45 MB
-- Backfill time: ~5-10 minutes (at 200 records per admin page load)
+- Backfill time: depends on cron frequency; at one run per minute, 10,000 products alone take ~50 minutes (plus orders/customers).
 
 ### Query Performance
 
diff --git a/src/Search/Index.php b/src/Search/Index.php
index 876ff0db3a1f2f4c9f8badd0fbd3b234cd541097..aa71614405fbf8db0995f32e60cb2403a6ad0147
--- a/src/Search/Index.php
+++ b/src/Search/Index.php
@@ -19,6 +19,9 @@
 	const STATE_OPTION    = 'agentwp_search_index_state';
 	const BACKFILL_HOOK   = 'agentwp_search_backfill';
 	const BACKFILL_LOCK   = Plugin::TRANSIENT_PREFIX . AgentWPConfig::CACHE_PREFIX_SEARCH_BACKFILL . 'lock';
+	const BACKFILL_HEARTBEAT_OPTION = 'agentwp_search_index_backfill_heartbeat';
+	const BACKFILL_LOCK_TTL         = 120; // Seconds.
+	const BACKFILL_STUCK_THRESHOLD  = 900; // Seconds.
 
 	// Backward-compat constants (tests + public API expectations).
 	const DEFAULT_LIMIT   = AgentWPConfig::SEARCH_DEFAULT_LIMIT;
@@ -81,11 +84,13 @@
 
 		self::$hooks_registered = true;
 
+		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
+
 		// Table creation runs via init hook.
 		// ensure_table() uses an option check to skip work when already current.
 		add_action( 'init', array( __CLASS__, 'ensure_table' ) );
 
-		// Backfill runs via scheduled cron event to avoid blocking admin requests.
+		// Backfill runs via scheduled cron event to avoid blocking live requests.
 		// Schedule the event if not already scheduled.
 		add_action( 'init', array( __CLASS__, 'schedule_backfill' ) );
 		add_action( self::BACKFILL_HOOK, array( __CLASS__, 'run_scheduled_backfill' ) );
@@ -860,10 +865,170 @@
 	private static $backfill_ran = false;
 
 	/**
+	 * Track backfill lock token.
+	 *
+	 * @var string
+	 */
+	private static $backfill_lock_token = '';
+
+	/**
+	 * Get backfill types.
+	 *
+	 * @return array<int, string>
+	 */
+	private static function get_backfill_types(): array {
+		return array( 'products', 'orders', 'customers' );
+	}
+
+	/**
+	 * Check if all backfill types are complete.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_fully_complete( array $state ): bool {
+		foreach ( self::get_backfill_types() as $type ) {
+			if ( ! self::is_backfill_complete( $type, $state ) ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Determine if a stored lock is still valid.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_active_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] > $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) > $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determine if a stored lock has expired.
+	 *
+	 * @param mixed $lock Lock value.
+	 * @param int   $now  Current timestamp.
+	 * @return bool
+	 */
+	private static function is_stale_lock( $lock, int $now ): bool {
+		if ( is_array( $lock ) && isset( $lock['expires_at'] ) ) {
+			return (int) $lock['expires_at'] <= $now;
+		}
+
+		if ( is_numeric( $lock ) ) {
+			return ( (int) $lock + self::BACKFILL_LOCK_TTL ) <= $now;
+		}
+
+		return false;
+	}
+
+	/**
+	 * Generate a lock token.
+	 *
+	 * @return string
+	 */
+	private static function generate_lock_token(): string {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'agentwp_backfill_', true );
+	}
+
+	/**
+	 * Attempt to add the backfill lock.
+	 *
+	 * @param array $payload Lock payload.
+	 * @param int   $ttl Lock TTL in seconds.
+	 * @return bool
+	 */
+	private static function add_backfill_lock( array $payload, int $ttl ): bool {
+		if (
+			function_exists( 'wp_using_ext_object_cache' )
+			&& function_exists( 'wp_cache_add' )
+			&& wp_using_ext_object_cache()
+		) {
+			// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+			return wp_cache_add( self::BACKFILL_LOCK, $payload, 'transient', $ttl );
+		}
+
+		$existing = get_transient( self::BACKFILL_LOCK );
+		if ( false !== $existing ) {
+			return false;
+		}
+
+		// phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Backfill lock intentionally uses short TTL.
+		return set_transient( self::BACKFILL_LOCK, $payload, $ttl );
+	}
+
+	/**
+	 * Get backfill heartbeat info.
+	 *
+	 * @return array<string, mixed>
+	 */
+	private static function get_backfill_heartbeat(): array {
+		$heartbeat = get_option( self::BACKFILL_HEARTBEAT_OPTION, array() );
+		return is_array( $heartbeat ) ? $heartbeat : array();
+	}
+
+	/**
+	 * Update backfill heartbeat.
+	 *
+	 * @param array $state Current backfill state.
+	 * @return void
+	 */
+	private static function update_backfill_heartbeat( array $state ): void {
+		update_option(
+			self::BACKFILL_HEARTBEAT_OPTION,
+			array(
+				'last_run' => time(),
+				'state'    => array_intersect_key( $state, array_flip( self::get_backfill_types() ) ),
+			),
+			false
+		);
+	}
+
+	/**
+	 * Determine if the scheduled backfill appears stuck.
+	 *
+	 * @param array $state Current state.
+	 * @return bool
+	 */
+	private static function is_backfill_stuck( array $state ): bool {
+		if ( self::is_backfill_fully_complete( $state ) ) {
+			return false;
+		}
+
+		$heartbeat = self::get_backfill_heartbeat();
+		if ( empty( $heartbeat['last_run'] ) ) {
+			return false;
+		}
+
+		$last_run = (int) $heartbeat['last_run'];
+		if ( $last_run <= 0 ) {
+			return false;
+		}
+
+		return ( time() - $last_run ) >= self::BACKFILL_STUCK_THRESHOLD;
+	}
+
+	/**
 	 * Schedule the backfill cron event if not already scheduled.
 	 *
 	 * Uses a one-minute interval to process backfill incrementally without
-	 * blocking normal admin requests.
+	 * blocking normal requests.
 	 *
 	 * @return void
 	 */
@@ -874,13 +1039,7 @@
 
 		// Check if backfill is already complete.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		// If backfill is complete, unschedule and return.
 		if ( $all_complete ) {
@@ -888,13 +1047,21 @@
 			return;
 		}
 
-		// Already scheduled, nothing to do.
-		if ( wp_next_scheduled( self::BACKFILL_HOOK ) ) {
+		$next_scheduled = wp_next_scheduled( self::BACKFILL_HOOK );
+		$now            = time();
+
+		if ( $next_scheduled && $next_scheduled < ( $now - self::BACKFILL_STUCK_THRESHOLD ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		} elseif ( $next_scheduled && self::is_backfill_stuck( $state ) ) {
+			self::unschedule_backfill();
+			$next_scheduled = false;
+		}
+
+		// Already scheduled and not stale, nothing to do.
+		if ( $next_scheduled ) {
 			return;
 		}
-
-		// Register a custom one-minute interval if not present.
-		add_filter( 'cron_schedules', array( __CLASS__, 'add_cron_interval' ) ); // phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 
 		// phpcs:ignore WordPress.WP.CronInterval.CronSchedulesInterval -- Short interval needed for backfill.
 		wp_schedule_event( time() + 30, 'agentwp_one_minute', self::BACKFILL_HOOK );
@@ -942,16 +1109,39 @@
 	 * @return bool True if lock acquired, false if already locked.
 	 */
 	private static function acquire_backfill_lock() {
+		$now        = time();
 		$lock_value = get_transient( self::BACKFILL_LOCK );
 
-		if ( false !== $lock_value ) {
+		if ( self::is_active_lock( $lock_value, $now ) ) {
 			return false;
 		}
 
-		// Set lock with 60 second TTL (covers the time window + buffer).
-		$result = set_transient( self::BACKFILL_LOCK, time(), 60 );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		$token   = self::generate_lock_token();
+		$payload = array(
+			'token'      => $token,
+			'issued_at'  => $now,
+			'expires_at' => $now + self::BACKFILL_LOCK_TTL,
+		);
+
+		if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+			self::$backfill_lock_token = $token;
+			return true;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if ( self::is_stale_lock( $lock_value, $now ) ) {
+			delete_transient( self::BACKFILL_LOCK );
+			if ( self::add_backfill_lock( $payload, self::BACKFILL_LOCK_TTL ) ) {
+				self::$backfill_lock_token = $token;
+				return true;
+			}
+		}
 
-		return $result;
+		return false;
 	}
 
 	/**
@@ -960,7 +1150,20 @@
 	 * @return void
 	 */
 	private static function release_backfill_lock() {
-		delete_transient( self::BACKFILL_LOCK );
+		if ( '' === self::$backfill_lock_token ) {
+			return;
+		}
+
+		$lock_value = get_transient( self::BACKFILL_LOCK );
+		if (
+			is_array( $lock_value )
+			&& isset( $lock_value['token'] )
+			&& hash_equals( (string) $lock_value['token'], (string) self::$backfill_lock_token )
+		) {
+			delete_transient( self::BACKFILL_LOCK );
+		}
+
+		self::$backfill_lock_token = '';
 	}
 
 	/**
@@ -979,19 +1182,15 @@
 
 		try {
 			self::maybe_backfill();
+			$state = self::get_state();
+			self::update_backfill_heartbeat( $state );
 		} finally {
 			self::release_backfill_lock();
 		}
 
 		// Check if backfill is now complete and unschedule if so.
 		$state        = self::get_state();
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			self::unschedule_backfill();
@@ -1018,30 +1217,25 @@
 		$state = self::get_state();
 
 		// Early exit if all types are complete.
-		$all_complete = true;
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
-			if ( ! self::is_backfill_complete( $type, $state ) ) {
-				$all_complete = false;
-				break;
-			}
-		}
+		$all_complete = self::is_backfill_fully_complete( $state );
 
 		if ( $all_complete ) {
 			return;
 		}
 
-		$start = microtime( true );
+		$start    = microtime( true );
+		$deadline = $start + self::getBackfillWindow();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( self::is_backfill_complete( $type, $state ) ) {
 				continue;
 			}
 
-			$state = self::backfill_type( $type, $state );
-
-			if ( microtime( true ) - $start >= self::getBackfillWindow() ) {
+			if ( microtime( true ) >= $deadline ) {
 				break;
 			}
+
+			$state = self::backfill_type( $type, $state, $deadline );
 		}
 
 		update_option( self::STATE_OPTION, $state, false );
@@ -1054,7 +1248,11 @@
 	 * @param array  $state Current state.
 	 * @return array
 	 */
-	private static function backfill_type( $type, array $state ) {
+	private static function backfill_type( $type, array $state, $deadline = null ) {
+		if ( null !== $deadline && microtime( true ) >= $deadline ) {
+			return $state;
+		}
+
 		$cursor = isset( $state[ $type ] ) ? (int) $state[ $type ] : 0;
 		$ids    = self::fetch_ids( $type, $cursor, self::getBackfillLimit() );
 
@@ -1063,7 +1261,12 @@
 			return $state;
 		}
 
+		$last_processed = $cursor;
 		foreach ( $ids as $id ) {
+			if ( null !== $deadline && microtime( true ) >= $deadline ) {
+				break;
+			}
+
 			if ( 'products' === $type ) {
 				self::index_product( $id );
 			} elseif ( 'orders' === $type ) {
@@ -1071,9 +1274,13 @@
 			} elseif ( 'customers' === $type ) {
 				self::index_customer( $id );
 			}
+
+			$last_processed = max( $last_processed, $id );
 		}
 
-		$state[ $type ] = max( $ids );
+		if ( $last_processed !== $cursor ) {
+			$state[ $type ] = $last_processed;
+		}
 		return $state;
 	}
 
@@ -1149,7 +1356,7 @@
 		$state = get_option( self::STATE_OPTION, array() );
 		$state = is_array( $state ) ? $state : array();
 
-		foreach ( array( 'products', 'orders', 'customers' ) as $type ) {
+		foreach ( self::get_backfill_types() as $type ) {
 			if ( ! isset( $state[ $type ] ) ) {
 				$state[ $type ] = 0;
 			}
diff --git a/tests/Unit/Search/BackfillTest.php b/tests/Unit/Search/BackfillTest.php
index fad1305a13e94cf1d6e15c8889b44fcee8979114..6fc15051d4a4b4f275d47fc55151a189b2d1a1d0
--- a/tests/Unit/Search/BackfillTest.php
+++ b/tests/Unit/Search/BackfillTest.php
@@ -50,6 +50,7 @@
 			'hooks_registered' => false,
 			'table_verified'   => false,
 			'backfill_ran'     => false,
+			'backfill_lock_token' => '',
 		);
 
 		foreach ( $properties as $name => $default ) {
@@ -391,7 +392,7 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => false,
+				'return_in_order' => array( false, false ),
 			)
 		);
 
@@ -399,7 +400,7 @@
 		WP_Mock::userFunction(
 			'set_transient',
 			array(
-				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'int' ), 60 ),
+				'args'   => array( Index::BACKFILL_LOCK, WP_Mock\Functions::type( 'array' ), Index::BACKFILL_LOCK_TTL ),
 				'return' => true,
 			)
 		);
@@ -416,7 +417,11 @@
 			'get_transient',
 			array(
 				'args'   => array( Index::BACKFILL_LOCK ),
-				'return' => time(),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
 			)
 		);
 
@@ -427,6 +432,20 @@
 	}
 
 	public function test_release_lock_calls_delete_transient(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'lock-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
 		// Mock delete_transient to verify it's called.
 		WP_Mock::userFunction(
 			'delete_transient',
@@ -444,6 +463,207 @@
 		$this->assertTrue( true );
 	}
 
+	public function test_release_lock_skips_when_token_mismatch(): void {
+		$this->set_static_property( 'backfill_lock_token', 'lock-token' );
+
+		WP_Mock::userFunction(
+			'get_transient',
+			array(
+				'args'   => array( Index::BACKFILL_LOCK ),
+				'return' => array(
+					'token'      => 'other-token',
+					'issued_at'  => time(),
+					'expires_at' => time() + Index::BACKFILL_LOCK_TTL,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'delete_transient',
+			array(
+				'args'  => array( Index::BACKFILL_LOCK ),
+				'times' => 0,
+			)
+		);
+
+		$release_method = $this->get_method( 'release_backfill_lock' );
+		$release_method->invoke( null );
+
+		$this->assertTrue( true );
+	}
+
+	// ===========================================
+	// Scheduling Tests
+	// ===========================================
+
+	public function test_schedule_backfill_skips_when_complete(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => -1,
+					'orders'    => -1,
+					'customers' => -1,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'times' => 0,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_schedules_when_needed(): void {
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'   => array( Index::BACKFILL_HOOK ),
+				'return' => false,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_stale(): void {
+		$stale = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $stale, $stale, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $stale, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
+	public function test_schedule_backfill_reschedules_when_heartbeat_stale(): void {
+		$future = time() + 30;
+		$stale  = time() - ( Index::BACKFILL_STUCK_THRESHOLD + 5 );
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::STATE_OPTION, array() ),
+				'return' => array(
+					'products'  => 0,
+					'orders'    => 0,
+					'customers' => 0,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'get_option',
+			array(
+				'args'   => array( Index::BACKFILL_HEARTBEAT_OPTION, array() ),
+				'return' => array(
+					'last_run' => $stale,
+				),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_next_scheduled',
+			array(
+				'args'            => array( Index::BACKFILL_HOOK ),
+				'return_in_order' => array( $future, $future, false ),
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_unschedule_event',
+			array(
+				'args'  => array( $future, Index::BACKFILL_HOOK ),
+				'times' => 1,
+			)
+		);
+
+		WP_Mock::userFunction(
+			'wp_schedule_event',
+			array(
+				'args'   => array( WP_Mock\Functions::type( 'int' ), 'agentwp_one_minute', Index::BACKFILL_HOOK ),
+				'return' => true,
+				'times'  => 1,
+			)
+		);
+
+		Index::schedule_backfill();
+		$this->assertTrue( true );
+	}
+
 	// ===========================================
 	// Scheduled Backfill Execution Tests
 	// ===========================================

tokens used
92,633
