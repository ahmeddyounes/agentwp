Implemented the refund draft/confirm workflow in a dedicated handler, including transient-backed draft storage, refund amount validation, gateway capability checks, audit logging, and optional notification hooks. The new `src/Handlers/RefundHandler.php` is where the draft is built, stored, and confirmed with `wc_create_refund`, ensuring refunds only execute on explicit confirmation and drafts expire after the configured TTL.

**Status**
- DONE

**Summary of changes**
- Added `src/Handlers/RefundHandler.php` to prepare refund drafts with required fields, calculate remaining refundable amounts, and store drafts in transients with a 10‑minute TTL default.
- Implemented confirmation flow that validates draft/order state, triggers gateway refunds when supported, adds an audit note, and optionally notifies the customer via a filter.
- Included full‑refund restock support (manual restock of all line items) and preserved required draft payload fields.

**How to verify**
- No verification commands provided.

**Risks / follow-ups**
- Restocking is applied only for full refunds (partial refunds skip restock without line‑item selection).
- Customer notification is off by default and relies on the `agentwp_refund_notify_customer` filter to enable sending.

OpenAI Codex v0.77.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/agentwp
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019b94de-e38c-7662-9d6a-96f21dabfc2c
--------
user
You are implementing task M02-03 in this git repository.

1) Read the spec: .plans/M02-03.md
2) Read handoff/context: .t2/handoff/M02-03.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: 
- test: 

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers

thinking
**Using command-line tools to read files**
exec
/bin/zsh -lc ls in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 43ms:
agentwp.php
assets
composer.json
docker
docker-compose.yml
docs
includes
languages
react
README.md
scripts
setup.sh
src
tasks.csv
uninstall.php

thinking
**Reading specification and handoff instructions**
exec
/bin/zsh -lc 'cat .plans/M02-03.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 32ms:
# M02-03 — Refund Processing - Draft Mode

Implement the refund workflow with Draft-Confirm protocol: 1) Create AgentWP\Handlers\RefundHandler class. 2) OpenAI function schema: prepare_refund(order_id: int, amount?: float, reason?: string, restock_items?: bool). 3) NEVER execute refund on first call - return draft object only. 4) Draft object contains: order_id, order_total, refund_amount, reason, items_to_restock, customer_email, payment_method, requires_manual_refund (bool). 5) Create separate confirm_refund(draft_id: string) function that executes wc_create_refund(). 6) Generate unique draft_id, store in transient with 10-minute expiry. 7) Handle partial refunds, full refunds, and refund+restock scenarios. 8) After confirmation, optionally trigger customer notification email. Acceptance Criteria: No refund ever processed without explicit confirm_refund call, draft expires after 10 minutes, partial refund calculates correctly, payment gateway refund triggered for supported gateways, audit log entry created.

thinking
**Preparing for handoff**
exec
/bin/zsh -lc 'cat .t2/handoff/M02-03.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 44ms:
# Handoff: M02-03

Created: 2026-01-06T19:53:13.839248Z

Spec: .plans/M02-03.md

thinking
**Preparing to implement refund feature**
exec
/bin/zsh -lc 'rg -n "Refund" includes src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 34ms:
src/AI/Functions/ConfirmRefund.php:10:class ConfirmRefund extends AbstractFunction {
src/AI/Functions/PrepareRefund.php:10:class PrepareRefund extends AbstractFunction {
src/AI/Functions/PrepareRefund.php:31:					'description' => 'Refund amount. Leave empty for full refund.',
src/AI/Functions/PrepareRefund.php:35:					'description' => 'Refund reason to include in the audit log.',
src/Intent/Handlers/OrderRefundHandler.php:13:class OrderRefundHandler extends BaseHandler {
src/Intent/Intent.php:63:				'example' => 'Refund order 1452 for $25.',
src/Intent/Engine.php:15:use AgentWP\Intent\Handlers\OrderRefundHandler;
src/Intent/Engine.php:131:			new OrderRefundHandler(),

thinking
**Checking existing functions**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/PrepareRefund.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * Function schema for refund preparation.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class PrepareRefund extends AbstractFunction {
	public function get_name() {
		return 'prepare_refund';
	}

	public function get_description() {
		return 'Prepare a draft refund for an order without executing it.';
	}

	public function get_parameters() {
		return array(

thinking
**Checking for existing ConfirmRefund**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/ConfirmRefund.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 34ms:
<?php
/**
 * Function schema for refund confirmation.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class ConfirmRefund extends AbstractFunction {
	public function get_name() {
		return 'confirm_refund';
	}

	public function get_description() {
		return 'Confirm and execute a previously prepared refund draft.';
	}

	public function get_parameters() {
		return array(

thinking
**Checking for similar refund handler**
exec
/bin/zsh -lc "sed -n '1,240p' src/Intent/Handlers/OrderRefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 46ms:
<?php
/**
 * Handle order refund intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Intent;

class OrderRefundHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_REFUND );
	}

	/**
	 * @param array $context Context data.
	 * @return Response

thinking
**Checking existing handlers**
exec
/bin/zsh -lc 'rg -n "Handlers" src/includes' in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 54ms:
rg: src/includes: IO error for operation on src/includes: No such file or directory (os error 2)

thinking
**Noting directory focus**
exec
/bin/zsh -lc 'rg -n "class .*Handler" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 63ms:
src/Handlers/OrderSearchHandler.php:16:class OrderSearchHandler {
src/Intent/Handlers/FallbackHandler.php:13:class FallbackHandler extends BaseHandler {
src/Intent/Handlers/CustomerLookupHandler.php:13:class CustomerLookupHandler extends BaseHandler {
src/Intent/Handlers/OrderRefundHandler.php:13:class OrderRefundHandler extends BaseHandler {
src/Intent/Handlers/ProductStockHandler.php:13:class ProductStockHandler extends BaseHandler {
src/Intent/Handlers/BaseHandler.php:14:abstract class BaseHandler implements Handler {
src/Intent/Handlers/OrderSearchHandler.php:14:class OrderSearchHandler extends BaseHandler {
src/Intent/Handlers/EmailDraftHandler.php:13:class EmailDraftHandler extends BaseHandler {
src/Intent/Handlers/OrderStatusHandler.php:13:class OrderStatusHandler extends BaseHandler {
src/Intent/Handlers/AnalyticsQueryHandler.php:13:class AnalyticsQueryHandler extends BaseHandler {

thinking
**Checking for OrderSearchHandler**
exec
/bin/zsh -lc "sed -n '1,200p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Handle order search requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;
use DateTimeImmutable;
use DateTimeZone;
use Exception;

class OrderSearchHandler {
	const DEFAULT_LIMIT = 10;
	const CACHE_TTL     = 3600;

	/**

thinking
**Searching for refund handler**
exec
/bin/zsh -lc 'rg -n "prepare_refund|confirm_refund" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
src/AI/Functions/ConfirmRefund.php:12:		return 'confirm_refund';
src/AI/Functions/PrepareRefund.php:12:		return 'prepare_refund';
src/Intent/Engine.php:177:			Intent::ORDER_REFUND    => array( 'prepare_refund', 'confirm_refund' ),

thinking
**Inspecting intent engine handlers**
exec
/bin/zsh -lc 'rg -n "Handlers" src/AI src/Handlers src/Intent' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
src/Handlers/OrderSearchHandler.php:8:namespace AgentWP\Handlers;
src/Intent/Handlers/FallbackHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/CustomerLookupHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderRefundHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/ProductStockHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/EmailDraftHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/BaseHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderStatusHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderSearchHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderSearchHandler.php:11:use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
src/Intent/Engine.php:11:use AgentWP\Intent\Handlers\AnalyticsQueryHandler;
src/Intent/Engine.php:12:use AgentWP\Intent\Handlers\CustomerLookupHandler;
src/Intent/Engine.php:13:use AgentWP\Intent\Handlers\EmailDraftHandler;
src/Intent/Engine.php:14:use AgentWP\Intent\Handlers\FallbackHandler;
src/Intent/Engine.php:15:use AgentWP\Intent\Handlers\OrderRefundHandler;
src/Intent/Engine.php:16:use AgentWP\Intent\Handlers\OrderSearchHandler;
src/Intent/Engine.php:17:use AgentWP\Intent\Handlers\OrderStatusHandler;
src/Intent/Engine.php:18:use AgentWP\Intent\Handlers\ProductStockHandler;
src/Intent/Handlers/AnalyticsQueryHandler.php:8:namespace AgentWP\Intent\Handlers;

thinking
**Checking for AI handlers**
exec
/bin/zsh -lc 'rg -n "prepare_" src/Handlers src/AI src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 59ms:
src/Intent/Engine.php:177:			Intent::ORDER_REFUND    => array( 'prepare_refund', 'confirm_refund' ),
src/Intent/Engine.php:178:			Intent::ORDER_STATUS    => array( 'prepare_status_update', 'prepare_bulk_status_update', 'bulk_update' ),
src/Intent/Engine.php:179:			Intent::PRODUCT_STOCK   => array( 'prepare_stock_update', 'search_product' ),
src/AI/Functions/PrepareStockUpdate.php:12:		return 'prepare_stock_update';
src/AI/Functions/PrepareStatusUpdate.php:12:		return 'prepare_status_update';
src/AI/Functions/PrepareStockUpdate.php:12:		return 'prepare_stock_update';
src/AI/Functions/PrepareBulkStatusUpdate.php:12:		return 'prepare_bulk_status_update';
src/AI/Functions/PrepareRefund.php:12:		return 'prepare_refund';
src/AI/Functions/PrepareBulkStatusUpdate.php:12:		return 'prepare_bulk_status_update';
src/AI/Functions/PrepareRefund.php:12:		return 'prepare_refund';
src/AI/Functions/PrepareStatusUpdate.php:12:		return 'prepare_status_update';

thinking
**Searching for function handlers**
exec
/bin/zsh -lc 'rg -n "class .*Handler" src/AI src/Handlers' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
src/Handlers/OrderSearchHandler.php:16:class OrderSearchHandler {

thinking
**Inspecting AI pipeline for function handling**
exec
/bin/zsh -lc 'rg -n "Function" src/AI src/Intent src/Handlers' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
src/AI/Functions/GetSalesReport.php:3: * Function schema for sales reports.
src/AI/Functions/GetSalesReport.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/GetSalesReport.php:10:class GetSalesReport extends AbstractFunction {
src/Intent/Engine.php:37:	 * @var FunctionRegistry
src/Intent/Engine.php:53:	 * @param FunctionRegistry|null $function_registry Optional registry.
src/Intent/Engine.php:60:		FunctionRegistry $function_registry = null,
src/Intent/Engine.php:68:		$this->function_registry = $function_registry ? $function_registry : new FunctionRegistry();
src/Intent/Engine.php:112:	 * @return FunctionRegistry
src/AI/Functions/SearchOrders.php:3: * Function schema for order search.
src/AI/Functions/SearchOrders.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/SearchOrders.php:10:class SearchOrders extends AbstractFunction {
src/AI/Functions/PrepareBulkStatusUpdate.php:3: * Function schema for bulk order status updates.
src/AI/Functions/PrepareBulkStatusUpdate.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/PrepareBulkStatusUpdate.php:10:class PrepareBulkStatusUpdate extends AbstractFunction {
src/Intent/FunctionRegistry.php:10:class FunctionRegistry {
src/AI/Functions/SelectOrders.php:3: * Function schema for selecting orders for bulk actions.
src/AI/Functions/SelectOrders.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/SelectOrders.php:10:class SelectOrders extends AbstractFunction {
src/AI/Functions/BulkUpdate.php:3: * Function schema for executing bulk order actions.
src/AI/Functions/BulkUpdate.php:8:namespace AgentWP\AI\Functions;

thinking
**Inspecting FunctionRegistry usage**
exec
/bin/zsh -lc "sed -n '1,240p' src/Intent/FunctionRegistry.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * OpenAI function registry for intent handlers.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

class FunctionRegistry {
	/**
	 * @var array<string, Handler>
	 */
	private $map = array();

	/**
	 * @param string  $function_name OpenAI function name.
	 * @param Handler $handler Handler instance.
	 * @return void
	 */

thinking
**Searching for handler functions**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
<?php
/**
 * Intent handler contract.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

use AgentWP\AI\Response;

interface Handler {
	/**
	 * @param string $intent Intent identifier.
	 * @return bool
	 */
	public function canHandle( string $intent ): bool;

	/**
	 * @param array $context Enriched request context.

thinking
**Investigating intent handler registration**
exec
/bin/zsh -lc "sed -n '1,260p' src/Intent/Engine.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
<?php
/**
 * Intent engine for routing requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

use AgentWP\AI\Response;
use AgentWP\Intent\Handlers\AnalyticsQueryHandler;
use AgentWP\Intent\Handlers\CustomerLookupHandler;
use AgentWP\Intent\Handlers\EmailDraftHandler;
use AgentWP\Intent\Handlers\FallbackHandler;
use AgentWP\Intent\Handlers\OrderRefundHandler;
use AgentWP\Intent\Handlers\OrderSearchHandler;
use AgentWP\Intent\Handlers\OrderStatusHandler;
use AgentWP\Intent\Handlers\ProductStockHandler;

class Engine {

thinking
**Investigating intent handler registration**
exec
/bin/zsh -lc 'rg -n "function call|tool call|call" src/AI src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 59ms:
src/Rest/HealthController.php:25:				'callback'            => array( $this, 'get_health' ),
src/Rest/HealthController.php:26:				'permission_callback' => array( $this, 'permissions_check' ),
src/Rest/SettingsController.php:30:					'callback'            => array( $this, 'get_settings' ),
src/Rest/SettingsController.php:31:					'permission_callback' => array( $this, 'permissions_check' ),
src/Rest/SettingsController.php:35:					'callback'            => array( $this, 'update_settings' ),
src/Rest/SettingsController.php:36:					'permission_callback' => array( $this, 'permissions_check' ),
src/Rest/SettingsController.php:46:				'callback'            => array( $this, 'update_api_key' ),
src/Rest/SettingsController.php:47:				'permission_callback' => array( $this, 'permissions_check' ),
src/Rest/SettingsController.php:56:				'callback'            => array( $this, 'get_usage' ),
src/Rest/SettingsController.php:57:				'permission_callback' => array( $this, 'permissions_check' ),
src/Rest/IntentController.php:26:				'callback'            => array( $this, 'create_intent' ),
src/Rest/IntentController.php:27:				'permission_callback' => array( $this, 'permissions_check' ),
src/AI/OpenAIClient.php:36:	 * @var callable|null
src/AI/OpenAIClient.php:75:		$this->on_stream     = isset( $options['on_stream'] ) && is_callable( $options['on_stream'] ) ? $options['on_stream'] : null;
src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:389:				'tool_calls' => array(),
src/AI/OpenAIClient.php:400:		$tool_calls = isset( $message['tool_calls'] ) && is_array( $message['tool_calls'] ) ? $message['tool_calls'] : array();
src/AI/OpenAIClient.php:402:		if ( empty( $tool_calls ) && isset( $message['function_call'] ) && is_array( $message['function_call'] ) ) {
src/AI/OpenAIClient.php:403:			$tool_calls = array(
src/AI/OpenAIClient.php:407:					'function' => $message['function_call'],

thinking
**Inspecting IntentController**
exec
/bin/zsh -lc "sed -n '1,260p' src/Rest/IntentController.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
<?php
/**
 * Intent REST controller.
 *
 * @package AgentWP
 */

namespace AgentWP\Rest;

use AgentWP\API\RestController;
use AgentWP\Intent\Engine;
use WP_REST_Server;

class IntentController extends RestController {
	/**
	 * Register REST routes.
	 *
	 * @return void
	 */
	public function register_routes() {

thinking
**Searching for function usage in REST**
exec
/bin/zsh -lc 'rg -n "function" src/Rest src/API src/Handlers' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 35ms:
src/API/RestController.php:21:	public function __construct() {
src/API/RestController.php:31:	public function permissions_check( $request ) {
src/API/RestController.php:56:	protected function validate_request( $request, array $schema, $source = 'json' ) {
src/API/RestController.php:77:	protected function response_success( $data, $status = 200 ) {
src/API/RestController.php:100:	protected function response_error( $code, $message, $status = 400 ) {
src/API/RestController.php:125:	public static function check_rate_limit( $request ) {
src/API/RestController.php:180:	public static function log_request( $request, $status, $error_code = '' ) {
src/Handlers/OrderSearchHandler.php:26:	public function handle( array $args ): Response {
src/Handlers/OrderSearchHandler.php:27:		if ( ! function_exists( 'wc_get_orders' ) ) {
src/Handlers/OrderSearchHandler.php:63:	private function normalize_args( array $args ) {
src/Handlers/OrderSearchHandler.php:103:	private function apply_query_hints( array $normalized, $query ) {
src/Handlers/OrderSearchHandler.php:140:	private function normalize_date_range_input( $date_range ) {
src/Handlers/OrderSearchHandler.php:155:	private function normalize_status( $status ) {
src/Handlers/OrderSearchHandler.php:168:	private function build_cache_key( array $normalized ) {
src/Handlers/OrderSearchHandler.php:179:	private function read_cache( $cache_key ) {
src/Handlers/OrderSearchHandler.php:180:		if ( ! function_exists( 'get_transient' ) ) {
src/Handlers/OrderSearchHandler.php:197:	private function write_cache( $cache_key, array $orders ) {
src/Handlers/OrderSearchHandler.php:198:		if ( ! function_exists( 'set_transient' ) ) {
src/Handlers/OrderSearchHandler.php:209:	private function run_query( array $normalized ) {
src/Handlers/OrderSearchHandler.php:210:		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {

thinking
**Searching for AI response handlers**
exec
/bin/zsh -lc 'rg -n "function" src/AI src/Handlers src/Intent -g"*.php"' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
src/Intent/IntentClassifier.php:16:	public function classify( $input, array $context = array() ) {
src/Intent/IntentClassifier.php:56:	private function score_refund( $text ) {
src/Intent/IntentClassifier.php:73:	private function score_status( $text ) {
src/Intent/IntentClassifier.php:93:	private function score_stock( $text ) {
src/Intent/IntentClassifier.php:111:	private function score_email( $text ) {
src/Intent/IntentClassifier.php:134:	private function score_analytics( $text ) {
src/Intent/IntentClassifier.php:154:	private function score_customer( $text ) {
src/Intent/IntentClassifier.php:171:	private function score_search( $text ) {
src/Intent/IntentClassifier.php:191:	private function match_score( $text, array $phrases ) {
src/Intent/IntentClassifier.php:207:	private function contains_phrase( $text, $phrase ) {
src/Handlers/OrderSearchHandler.php:26:	public function handle( array $args ): Response {
src/Handlers/OrderSearchHandler.php:27:		if ( ! function_exists( 'wc_get_orders' ) ) {
src/Handlers/OrderSearchHandler.php:63:	private function normalize_args( array $args ) {
src/Handlers/OrderSearchHandler.php:103:	private function apply_query_hints( array $normalized, $query ) {
src/Handlers/OrderSearchHandler.php:140:	private function normalize_date_range_input( $date_range ) {
src/Handlers/OrderSearchHandler.php:155:	private function normalize_status( $status ) {
src/Handlers/OrderSearchHandler.php:168:	private function build_cache_key( array $normalized ) {
src/Handlers/OrderSearchHandler.php:179:	private function read_cache( $cache_key ) {
src/Handlers/OrderSearchHandler.php:180:		if ( ! function_exists( 'get_transient' ) ) {
src/Handlers/OrderSearchHandler.php:197:	private function write_cache( $cache_key, array $orders ) {

thinking
**Searching for function handlers**
exec
/bin/zsh -lc 'rg -n "tool_calls" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 59ms:
src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:389:				'tool_calls' => array(),
src/AI/OpenAIClient.php:400:		$tool_calls = isset( $message['tool_calls'] ) && is_array( $message['tool_calls'] ) ? $message['tool_calls'] : array();
src/AI/OpenAIClient.php:402:		if ( empty( $tool_calls ) && isset( $message['function_call'] ) && is_array( $message['function_call'] ) ) {
src/AI/OpenAIClient.php:403:			$tool_calls = array(
src/AI/OpenAIClient.php:416:			'tool_calls' => $tool_calls,
src/AI/OpenAIClient.php:430:		$tool_calls = array();
src/AI/OpenAIClient.php:476:			if ( isset( $delta['tool_calls'] ) && is_array( $delta['tool_calls'] ) ) {
src/AI/OpenAIClient.php:477:				$tool_calls = $this->merge_tool_call_deltas( $tool_calls, $delta['tool_calls'] );
src/AI/OpenAIClient.php:481:				$tool_calls = $this->merge_tool_call_deltas(
src/AI/OpenAIClient.php:482:					$tool_calls,
src/AI/OpenAIClient.php:498:			'tool_calls' => array_values( $tool_calls ),
src/AI/OpenAIClient.php:506:	 * @param array $tool_calls Existing tool calls.
src/AI/OpenAIClient.php:510:	private function merge_tool_call_deltas( array $tool_calls, array $deltas ) {
src/AI/OpenAIClient.php:514:			if ( ! isset( $tool_calls[ $index ] ) ) {
src/AI/OpenAIClient.php:515:				$tool_calls[ $index ] = array(
src/AI/OpenAIClient.php:526:				$tool_calls[ $index ]['id'] = $delta['id'];
src/AI/OpenAIClient.php:530:				$tool_calls[ $index ]['type'] = $delta['type'];
src/AI/OpenAIClient.php:535:					$tool_calls[ $index ]['function']['name'] = $delta['function']['name'];
src/AI/OpenAIClient.php:539:					$tool_calls[ $index ]['function']['arguments'] .= $delta['function']['arguments'];

thinking
**Searching documentation for integration hints**
exec
/bin/zsh -lc 'rg -n "execute|tool|function" docs src -g"*.md"' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 60ms:
docs/agentwp-prd.md:3:**An AI-powered WooCommerce plugin entering a $64 billion market has a clear path to success—but only by filling the specific gaps left by fragmented tools and absent native AI features.** With **4.5–6 million active WooCommerce stores** representing 93.7% of WordPress e-commerce and no native AI assistant (unlike Shopify's Sidekick), the opportunity for AgentWP to become the definitive "Shopify Sidekick for WooCommerce" is substantial. This report synthesizes competitive intelligence, technical requirements, marketplace dynamics, and regulatory considerations to refine AgentWP's product specification.
docs/agentwp-prd.md:9:WooCommerce store owners currently patch together **5–10 separate tools** at cumulative costs of **$100–1,000+ monthly** for capabilities Shopify bundles into a single platform. This fragmentation creates the core opportunity.
docs/agentwp-prd.md:11:**Current tool landscape and pricing:**
docs/agentwp-prd.md:31:CodeCanyon's WooCommerce category presents a mature but opportunity-rich environment. The **top-selling plugins** cluster around essential e-commerce functions: Filter Everything ($49, 121 weekly sales), CURCY multi-currency ($34), and Extra Product Options ($69, 1,300+ reviews). These establish the proven price ceiling.
docs/agentwp-prd.md:39:The data shows **98.2% of plugins price under $40**, but top performers consistently price at **$42–69**. AI plugins like MagicAI and Davinci AI successfully command $49–69, validating premium pricing for AI-powered functionality. The "race to bottom" strategy fails—the average plugin price of $18.91 correlates with minimal success, while category leaders demonstrate that merchants pay for genuine value.
docs/agentwp-prd.md:46:- Live demo site showcasing real functionality (essential, not optional)
docs/agentwp-prd.md:62:- Design functions that pass the "intern test"—if the function name and description alone don't make usage obvious, refine them
docs/agentwp-prd.md:63:- Combine functions that are always called sequentially into single operations
docs/agentwp-prd.md:65:- Assume multiple tool calls per response; the model may return zero, one, or many
docs/agentwp-prd.md:67:For error handling, when tool execution fails, **return the error to the model** rather than throwing exceptions. The model adapts and can suggest alternatives or request different inputs.
docs/agentwp-prd.md:85:Use `@wordpress/scripts` for build tooling, `@wordpress/element` for React abstraction, and `@wordpress/api-fetch` for authenticated requests. This approach ensures compatibility with WordPress core patterns while enabling modern component-based development. Externalize React and ReactDOM to use WordPress's bundled versions.
docs/agentwp-prd.md:98:- **78–88%** of companies use AI in at least one business function
docs/agentwp-prd.md:112:Pricing sensitivity data suggests **$29–69/month** as the acceptable range for premium AI tools, with annual billing discounts (20–30%) preferred. Users consistently compare to Shopify's $29–299/month baseline, positioning WooCommerce as the cost-conscious alternative. The key insight: merchants pay willingly when **clear ROI is demonstrated**—they reject subscriptions for ambiguous value.
docs/agentwp-prd.md:169:**1. "AI that acts, not just answers"** — Unlike chatbots that handle FAQs, AgentWP executes operations: processes refunds, updates orders, manages inventory. This mirrors Shopify Sidekick's capability gap versus WooCommerce's current state.
docs/agentwp-prd.md:171:**2. "Replace 5 SaaS subscriptions with one plugin"** — The fragmentation pain is real and expensive. Quantify the savings: merchants paying $200–500/month across Metorik, Tidio, Zendesk integrations, and automation tools could consolidate to a single $49–69 one-time purchase plus API costs.
docs/agentwp-prd.md:196:**Compliance:** Execute OpenAI DPA immediately, build GDPR consent mechanisms into initial release, and implement CCPA opt-out functionality. These cannot be afterthoughts.
docs/ARCHITECTURE.md:463:6) Confirmations are executed via `/drafts/{draft_id}/confirm`.

thinking
**Searching for draft system details**
exec
/bin/zsh -lc 'rg -n "draft" docs/ARCHITECTURE.md src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
docs/ARCHITECTURE.md:126:- Drafts are stored in transients (e.g., `agentwp_draft_{id}`) with short TTLs.
docs/ARCHITECTURE.md:146:Primary AI entry point. Converts user input into actions and/or drafts.
docs/ARCHITECTURE.md:155:    "draft_id": "string"
docs/ARCHITECTURE.md:166:    "draft": {
docs/ARCHITECTURE.md:208:    "draft_ttl_minutes": 10
docs/ARCHITECTURE.md:221:  "draft_ttl_minutes": 10
docs/ARCHITECTURE.md:291:### GET /drafts/{draft_id}
docs/ARCHITECTURE.md:292:Fetches a pending draft for confirmation UI.
docs/ARCHITECTURE.md:307:### POST /drafts/{draft_id}/confirm
docs/ARCHITECTURE.md:308:Confirms a draft action (refund, status update, stock update, bulk action).
docs/ARCHITECTURE.md:328:### POST /drafts/{draft_id}/cancel
docs/ARCHITECTURE.md:329:Cancels a pending draft action.
docs/ARCHITECTURE.md:382:Draft-Confirm prevents destructive actions without explicit approval. The AI prepares a draft, then the user confirms the action in the UI.
docs/ARCHITECTURE.md:395:  REST->>DraftStore: Save draft (10 min TTL)
docs/ARCHITECTURE.md:396:  REST->>CommandDeck: Draft preview + draft_id
docs/ARCHITECTURE.md:398:  CommandDeck->>REST: POST /drafts/{draft_id}/confirm
docs/ARCHITECTURE.md:400:  REST->>DraftStore: Delete draft
docs/ARCHITECTURE.md:406:  Intent[Intent received] --> Draft[Create draft]
docs/ARCHITECTURE.md:408:  Store --> Preview[Return draft_id + preview]
docs/ARCHITECTURE.md:411:  Decision -->|Cancel| Cancel[Discard draft]

thinking
**Reading draft section in ARCHITECTURE.md**
exec
/bin/zsh -lc "sed -n '120,230p' docs/ARCHITECTURE.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
### Settings and Storage Rules
- Settings and encrypted BYOK are stored in `wp_options`.
- Example keys:
  - `agentwp_api_key` (encrypted)
  - `agentwp_settings` (JSON)
  - `agentwp_budget_limit` (numeric)
- Drafts are stored in transients (e.g., `agentwp_draft_{id}`) with short TTLs.
- No custom tables are introduced for core features.

## 3) REST API Endpoint Specification

Base path: `/wp-json/agentwp/v1`

**Common response envelope**
```json
{
  "success": true,
  "data": {},
  "error": {
    "code": "string",

thinking
**Reviewing endpoints near line 291**
exec
/bin/zsh -lc "sed -n '280,360p' docs/ARCHITECTURE.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 34ms:
```json
{
  "success": true,
  "data": {
    "products": [],
    "orders": [],
    "customers": []
  }
}
```

### GET /drafts/{draft_id}
Fetches a pending draft for confirmation UI.

Response schema:
```json
{
  "success": true,
  "data": {
    "id": "string",

thinking
**Searching for draft endpoints in Rest folder**
exec
/bin/zsh -lc 'rg -n "Draft" src/Rest src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 60ms:
src/AI/Functions/ConfirmRefund.php:27:					'description' => 'Draft refund identifier to confirm.',
src/Intent/Handlers/EmailDraftHandler.php:13:class EmailDraftHandler extends BaseHandler {
src/AI/Functions/DraftEmail.php:10:class DraftEmail extends AbstractFunction {
src/AI/Functions/DraftEmail.php:16:		return 'Draft a customer email for a given order and intent.';
src/Intent/Intent.php:77:				'label'   => 'Draft a customer email',
src/Intent/Intent.php:78:				'example' => 'Draft an apology email for order 1452.',
src/Intent/Engine.php:13:use AgentWP\Intent\Handlers\EmailDraftHandler;
src/Intent/Engine.php:134:			new EmailDraftHandler(),

thinking
**Searching for specific handler functions**
exec
/bin/zsh -lc 'rg -n "prepare_status_update|bulk_update|prepare_stock_update|draft_email" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
src/AI/Functions/PrepareStockUpdate.php:12:		return 'prepare_stock_update';
src/AI/Functions/BulkUpdate.php:12:		return 'bulk_update';
src/AI/Functions/DraftEmail.php:12:		return 'draft_email';
src/AI/Functions/PrepareStatusUpdate.php:12:		return 'prepare_status_update';
src/Intent/Engine.php:178:			Intent::ORDER_STATUS    => array( 'prepare_status_update', 'prepare_bulk_status_update', 'bulk_update' ),
src/Intent/Engine.php:179:			Intent::PRODUCT_STOCK   => array( 'prepare_stock_update', 'search_product' ),
src/Intent/Engine.php:180:			Intent::EMAIL_DRAFT     => array( 'draft_email' ),

thinking
**Searching for related handler classes**
exec
/bin/zsh -lc 'rg -n "Status|Stock|Bulk|Email" src/Handlers' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 59ms:


thinking
**Searching for Action system**
exec
/bin/zsh -lc 'rg -n "Action" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
src/AI/Functions/BulkUpdate.php:39:					'description' => 'Action-specific parameters.',

thinking
**Examining function execution patterns**
exec
/bin/zsh -lc 'rg -n "search_orders" -g"*.php" -g"*.js"' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/AI/Functions/SearchOrders.php:12:		return 'search_orders';
src/Intent/Engine.php:176:			Intent::ORDER_SEARCH    => array( 'search_orders', 'select_orders' ),

thinking
**Investigating Handlers in docs**
exec
/bin/zsh -lc 'rg -n "Handler" docs -g"*.md"' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 57ms:


thinking
**Searching for documentation clues**
exec
/bin/zsh -lc 'rg -n "M02-03" -g"*"' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 76ms:
tasks.csv:13:M02-03,"Refund Processing - Draft Mode","Implement the refund workflow with Draft-Confirm protocol: 1) Create AgentWP\Handlers\RefundHandler class. 2) OpenAI function schema: prepare_refund(order_id: int, amount?: float, reason?: string, restock_items?: bool). 3) NEVER execute refund on first call - return draft object only. 4) Draft object contains: order_id, order_total, refund_amount, reason, items_to_restock, customer_email, payment_method, requires_manual_refund (bool). 5) Create separate confirm_refund(draft_id: string) function that executes wc_create_refund(). 6) Generate unique draft_id, store in transient with 10-minute expiry. 7) Handle partial refunds, full refunds, and refund+restock scenarios. 8) After confirmation, optionally trigger customer notification email. Acceptance Criteria: No refund ever processed without explicit confirm_refund call, draft expires after 10 minutes, partial refund calculates correctly, payment gateway refund triggered for supported gateways, audit log entry created."
.logs/M01-05.codex.impl.raw.txt:334:tasks.csv:13:M02-03,"Refund Processing - Draft Mode","Implement the refund workflow with Draft-Confirm protocol: 1) Create AgentWP\Handlers\RefundHandler class. 2) OpenAI function schema: prepare_refund(order_id: int, amount?: float, reason?: string, restock_items?: bool). 3) NEVER execute refund on first call - return draft object only. 4) Draft object contains: order_id, order_total, refund_amount, reason, items_to_restock, customer_email, payment_method, requires_manual_refund (bool). 5) Create separate confirm_refund(draft_id: string) function that executes wc_create_refund(). 6) Generate unique draft_id, store in transient with 10-minute expiry. 7) Handle partial refunds, full refunds, and refund+restock scenarios. 8) After confirmation, optionally trigger customer notification email. Acceptance Criteria: No refund ever processed without explicit confirm_refund call, draft expires after 10 minutes, partial refund calculates correctly, payment gateway refund triggered for supported gateways, audit log entry created."
.plans/M02-03.md:1:# M02-03 — Refund Processing - Draft Mode
.t2/handoff/M02-03.md:1:# Handoff: M02-03
.t2/handoff/M02-03.md:5:Spec: .plans/M02-03.md

thinking
**Examining draft system in code**
exec
/bin/zsh -lc 'rg -n "draft" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
src/Rest/SettingsController.php:236:		if ( isset( $payload['draft_ttl_minutes'] ) ) {
src/Rest/SettingsController.php:237:			$draft_ttl = intval( $payload['draft_ttl_minutes'] );
src/Rest/SettingsController.php:238:			if ( $draft_ttl >= 0 ) {
src/Rest/SettingsController.php:239:				$settings['draft_ttl_minutes'] = $draft_ttl;
src/Rest/SettingsController.php:351:				'draft_ttl_minutes' => array(
src/AI/Functions/PrepareBulkStatusUpdate.php:16:		return 'Prepare a draft bulk status update for multiple orders.';
src/AI/Functions/ConfirmRefund.php:16:		return 'Confirm and execute a previously prepared refund draft.';
src/AI/Functions/ConfirmRefund.php:23:			'required'             => array( 'draft_id' ),
src/AI/Functions/ConfirmRefund.php:25:				'draft_id' => array(
src/AI/Functions/PrepareStockUpdate.php:16:		return 'Prepare a draft stock update for a product.';
src/AI/Functions/PrepareRefund.php:16:		return 'Prepare a draft refund for an order without executing it.';
src/AI/Functions/DraftEmail.php:3: * Function schema for drafting emails.
src/AI/Functions/DraftEmail.php:12:		return 'draft_email';
src/AI/Functions/DraftEmail.php:41:					'description' => 'Optional instructions for the draft.',
src/AI/Functions/PrepareStatusUpdate.php:16:		return 'Prepare a draft order status update without applying it.';
src/Intent/IntentClassifier.php:114:			|| $this->contains_phrase( $text, 'draft' )
src/Intent/Handlers/OrderRefundHandler.php:23:		$message = 'I can prepare a refund draft. Provide the order ID and refund amount if needed.';
src/Intent/Handlers/EmailDraftHandler.php:3: * Handle email draft intents.
src/Intent/Handlers/EmailDraftHandler.php:23:		$message = 'I can draft a customer email. Share the order ID and desired tone.';
src/Intent/Intent.php:44:			self::EMAIL_DRAFT     => 'Email draft',

thinking
**Investigating refund handler placement**
exec
/bin/zsh -lc "sed -n '1,220p' src/Plugin.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 38ms:
<?php
/**
 * Core plugin bootstrap.
 *
 * @package AgentWP
 */

namespace AgentWP;

class Plugin {
	const OPTION_SETTINGS     = 'agentwp_settings';
	const OPTION_API_KEY      = 'agentwp_api_key';
	const OPTION_API_KEY_LAST4 = 'agentwp_api_key_last4';
	const OPTION_BUDGET_LIMIT = 'agentwp_budget_limit';
	const OPTION_DRAFT_TTL    = 'agentwp_draft_ttl_minutes';
	const OPTION_USAGE_STATS  = 'agentwp_usage_stats';
	const TRANSIENT_PREFIX    = 'agentwp_';

	/**
	 * @var Plugin|null

thinking
**Identifying refund handler needs**
exec
/bin/zsh -lc "rg -n \"AgentWP\\\\Handlers\" -g\"*.php\"" in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 51ms:
rg: regex parse error:
    (?:AgentWP\Handlers)
              ^^
error: unrecognized escape sequence

thinking
**Using plain string for Handlers**
exec
/bin/zsh -lc "rg -n \"Handlers\\\\\" src" in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 53ms:
rg: regex parse error:
    (?:Handlers\)
    ^
error: unclosed group

thinking
**Using fixed string option (-F)**
exec
/bin/zsh -lc "rg -n -F \"AgentWP\\\\Handlers\" src" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 46ms:
src/Handlers/OrderSearchHandler.php:8:namespace AgentWP\Handlers;
src/Intent/Handlers/OrderSearchHandler.php:11:use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;

thinking
**Investigating function call execution location**
exec
/bin/zsh -lc 'rg -n "tool" src -g"*.php"' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
src/AI/Functions/FunctionSchema.php:29:	public function to_tool_definition();
src/AI/Functions/AbstractFunction.php:3: * Base class for tool definitions.
src/AI/Functions/AbstractFunction.php:14:	public function to_tool_definition() {
src/AI/TokenCounter.php:20:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:24:	public function count_request_tokens( array $messages, array $tools, $model ) {
src/AI/TokenCounter.php:28:			+ $this->count_tool_tokens( $tools, $model );
src/AI/TokenCounter.php:67:	 * Count tokens for tool definitions.
src/AI/TokenCounter.php:69:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:73:	public function count_tool_tokens( array $tools, $model ) {
src/AI/TokenCounter.php:74:		if ( empty( $tools ) ) {
src/AI/TokenCounter.php:78:		$payload = wp_json_encode( $tools );
src/AI/OpenAIClient.php:99:		$tools = $this->normalize_tools( $functions );
src/AI/OpenAIClient.php:106:		if ( ! empty( $tools ) ) {
src/AI/OpenAIClient.php:107:			$payload['tools']       = $tools;
src/AI/OpenAIClient.php:108:			$payload['tool_choice'] = 'auto';
src/AI/OpenAIClient.php:116:		$input_tokens = $this->token_counter->count_request_tokens( $messages, $tools, $this->model );
src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:296:	private function normalize_tools( array $functions ) {
src/AI/OpenAIClient.php:297:		$tools = array();
src/AI/OpenAIClient.php:301:				$tools[] = $function->to_tool_definition();

thinking
**Searching for tool usage in React**
exec
/bin/zsh -lc 'rg -n "function|tool|draft" react src/assets' in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 33ms:
rg: src/assets: No such file or directory (os error 2)
react/src/App.jsx:64:  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
react/src/App.jsx:79:export default function App() {
react/src/App.jsx:151:    if (lastActive && typeof lastActive.focus === 'function') {
react/src/App.jsx:343:              &ldquo;Summarize today&apos;s pending orders and draft a response for the two longest

thinking
**Investigating backend handlers and function calls**
exec
/bin/zsh -lc 'rg -n "action" src -g"*.php"' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
src/AI/Functions/SelectOrders.php:3: * Function schema for selecting orders for bulk actions.
src/AI/Functions/SelectOrders.php:16:		return 'Select orders matching a set of criteria for bulk actions.';
src/AI/Functions/BulkUpdate.php:3: * Function schema for executing bulk order actions.
src/AI/Functions/BulkUpdate.php:16:		return 'Apply a bulk action to a list of order IDs.';
src/AI/Functions/BulkUpdate.php:23:			'required'             => array( 'order_ids', 'action', 'params' ),
src/AI/Functions/BulkUpdate.php:32:				'action'    => array(
src/AI/Functions/BulkUpdate.php:35:					'description' => 'Bulk action to perform.',
src/AI/Model.php:3: * OpenAI model abstraction.
src/Intent/IntentClassifier.php:113:		$has_action = $this->contains_phrase( $text, 'compose' )
src/Intent/IntentClassifier.php:119:		if ( $has_email && $has_action ) {
src/Intent/IntentClassifier.php:123:		if ( $has_action ) {
src/Plugin.php:72:		add_action( 'init', array( $this, 'load_textdomain' ) );
src/Plugin.php:73:		add_action( 'admin_menu', array( $this, 'register_menu' ) );
src/Plugin.php:74:		add_action( 'admin_enqueue_scripts', array( $this, 'enqueue_admin_assets' ) );
src/Plugin.php:75:		add_action( 'rest_api_init', array( $this, 'register_rest_routes' ) );

thinking
**Investigating function handler implementation**
exec
/bin/zsh -lc 'rg -n "execute|executor|dispatch" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
src/AI/Functions/ConfirmRefund.php:16:		return 'Confirm and execute a previously prepared refund draft.';
src/Plugin.php:76:		add_filter( 'rest_post_dispatch', array( $this, 'format_rest_response' ), 10, 3 );

thinking
**Investigating missing handler for tool calls**
exec
/bin/zsh -lc 'rg -n "OpenAI" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/Rest/SettingsController.php:266:	 * Validate API key against OpenAI.
src/Rest/SettingsController.php:284:			return new WP_Error( 'agentwp_openai_unreachable', __( 'OpenAI API is unreachable.', 'agentwp' ) );
src/Rest/SettingsController.php:289:			return new WP_Error( 'agentwp_openai_invalid', __( 'OpenAI rejected the API key.', 'agentwp' ) );
src/AI/TokenCounter.php:32:	 * Count tokens for messages using OpenAI chat heuristics.
src/AI/OpenAIClient.php:3: * OpenAI API client wrapper.
src/AI/OpenAIClient.php:12:class OpenAIClient {
src/AI/OpenAIClient.php:66:	 * @param string $api_key OpenAI API key.
src/AI/OpenAIClient.php:96:			return Response::error( 'Missing OpenAI API key.', 401 );
src/AI/OpenAIClient.php:175:	 * Validate an OpenAI API key.
src/AI/OpenAIClient.php:274:			$error = 'OpenAI API request failed.';
src/AI/OpenAIClient.php:387:				'error'      => 'Invalid response from OpenAI.',
src/AI/Model.php:3: * OpenAI model abstraction.
src/AI/Response.php:3: * OpenAI response wrapper.
src/Intent/FunctionRegistry.php:3: * OpenAI function registry for intent handlers.
src/Intent/FunctionRegistry.php:17:	 * @param string  $function_name OpenAI function name.
src/Intent/FunctionRegistry.php:31:	 * @param string $function_name OpenAI function name.

thinking
**Considering RefundHandler implementation**
exec
/bin/zsh -lc "sed -n '1,120p' tasks.csv" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
id,title,spec
M00-01,"Technical Architecture Document","Create a comprehensive technical architecture document in Markdown format covering: 1) System overview diagram showing WordPress plugin structure, React frontend, PHP backend, and OpenAI API integration. 2) Database schema using only standard WooCommerce tables plus wp_options for settings (no custom tables). 3) REST API endpoint specification for /wp-json/agentwp/v1/* routes. 4) Security architecture for BYOK (Bring Your Own Key) with AES-256 encryption. 5) Data flow diagrams for the Draft-Confirm protocol. 6) Component hierarchy for React Command Deck. Save to /docs/ARCHITECTURE.md. Acceptance Criteria: Document covers all major subsystems, includes Mermaid diagrams, specifies all API endpoints with request/response schemas, and passes technical review."
M00-02,"Docker Development Environment","Create Docker-based development environment with docker-compose.yml including: 1) WordPress container with PHP 8.1+ and WooCommerce 8.x pre-installed. 2) MySQL 8.0 container with persistent volume. 3) Node.js container for React build tooling. 4) Mailhog for email testing. 5) Volume mounts for live code reloading. Include .env.example with all configuration variables. Create setup script (setup.sh) that initializes WooCommerce with sample data. Acceptance Criteria: Running 'docker-compose up' creates fully functional dev environment within 5 minutes, hot reloading works for both PHP and React, sample store has 50+ products and 100+ orders."
M00-03,"CI/CD Pipeline Configuration","Create GitHub Actions workflows in .github/workflows/ for: 1) ci.yml - runs on PR: PHP linting (PHPCS with WordPress standards), PHPUnit tests, Jest tests, ESLint, build verification. 2) release.yml - runs on tag: builds production assets, creates CodeCanyon-ready ZIP, generates changelog from commits. 3) security.yml - runs weekly: dependency vulnerability scanning with Composer audit and npm audit. Include branch protection rules documentation. Acceptance Criteria: CI blocks merges on test failures, release workflow produces valid plugin ZIP under 10MB, security scans report to GitHub Security tab."
M01-01,"WordPress Plugin Scaffold","Create the core plugin file structure following WordPress coding standards: 1) Main plugin file (agentwp.php) with proper headers, activation/deactivation hooks, and autoloader. 2) PSR-4 autoloading via Composer for /src directory. 3) Namespace: AgentWP\*. 4) Directory structure: /src (PHP classes), /assets (compiled JS/CSS), /react (source), /includes (legacy compatibility), /languages (i18n). 5) Activation hook creates default options, deactivation cleans transients, uninstall.php removes all data. 6) Admin menu registration under WooCommerce menu. 7) Enqueue scripts only on plugin pages and WooCommerce screens. Acceptance Criteria: Plugin activates without errors on WordPress 6.4+ with WooCommerce 8.0+, passes WordPress Plugin Check, no PHP notices/warnings."
M01-02,"Settings Page - React Interface","Build React-based settings page using @wordpress/scripts and @wordpress/components: 1) Settings sections: API Configuration, Model Selection, Interface Preferences, Usage Statistics. 2) API Key input field with masked display (show last 4 chars only), validation button that tests key against OpenAI API. 3) Model dropdown: gpt-4o (recommended), gpt-4o-mini (budget). 4) Hotkey configuration (default Cmd+K / Ctrl+K). 5) Toggle for dark/light mode default. 6) Usage stats display: total commands this month, estimated cost, last sync time. 7) Export/Import settings as JSON. 8) Save button with optimistic updates via @wordpress/api-fetch. Acceptance Criteria: Settings persist across page reloads, API key validation provides clear success/error feedback within 3 seconds, all settings accessible via REST API."
M01-03,"API Key Encryption System","Implement secure API key storage in PHP: 1) Create AgentWP\Security\Encryption class using AES-256-CTR with WordPress salts (LOGGED_IN_KEY and LOGGED_IN_SALT) as encryption materials. 2) Methods: encrypt(string $plaintext): string, decrypt(string $ciphertext): string, isEncrypted(string $data): bool. 3) Store encrypted key in wp_options table under 'agentwp_api_key'. 4) Create REST endpoint POST /agentwp/v1/settings/api-key that validates key format (sk-*), tests against OpenAI /v1/models endpoint, encrypts and stores on success. 5) Never log or expose plaintext keys. 6) Add key rotation support (re-encrypt with new salts). Acceptance Criteria: Stored key is unreadable without WordPress salts, key validation catches invalid/expired keys, encryption/decryption round-trips correctly, no plaintext keys in logs or database queries."
M01-04,"REST API Framework","Build the REST API infrastructure in PHP: 1) Create AgentWP\API\RestController base class extending WP_REST_Controller with common auth, validation, and response formatting. 2) Register namespace 'agentwp/v1'. 3) Implement permission callbacks using current_user_can('manage_woocommerce'). 4) Create rate limiter using transients: 60 requests/minute per user, return 429 with Retry-After header when exceeded. 5) Endpoints to create: POST /intent (main AI endpoint), GET/POST /settings, GET /usage, GET /health. 6) Request validation with JSON schemas. 7) Standardized response format: {success: bool, data: any, error?: {code: string, message: string}}. 8) Add request logging for debugging (stored in transients, auto-expire 24h). Acceptance Criteria: All endpoints require authentication, rate limiter triggers at 61st request within 60 seconds, invalid requests return descriptive errors with correct HTTP codes, OpenAPI/Swagger spec generated."
M01-05,"OpenAI Integration Layer","Create the OpenAI API client wrapper in PHP: 1) AgentWP\AI\OpenAIClient class with methods: chat(array $messages, array $functions): Response, validateKey(string $key): bool. 2) Implement Function Calling (Tools API) with strict mode enabled. 3) Define function schemas in AgentWP\AI\Functions\* classes (one per function). 4) Retry logic with exponential backoff: initial 1s, max 60s, 10 retries, add random jitter 0-1s. 5) Handle rate limits (429), server errors (5xx), and network timeouts gracefully. 6) Stream response support for long-running queries (SSE). 7) Token counting using tiktoken-php for cost estimation. 8) Model abstraction allowing easy switching between gpt-4o and gpt-4o-mini. Acceptance Criteria: Function calls return properly structured responses, retry logic handles transient failures without user intervention, streaming works for responses >10 seconds, token counts accurate within 5%."
M01-06,"Command Deck Modal - Basic","Build the React modal interface (Command Deck) using React 18 and TailwindCSS: 1) Floating modal overlay with semi-transparent backdrop. 2) Trigger: global hotkey listener (Cmd+K Mac, Ctrl+K Windows), admin bar button click. 3) Visual style: Linear.app aesthetic, dark mode default, 600px max width, centered vertically. 4) Components: Omnibox (text input with placeholder 'Ask AgentWP anything...'), Stage (results area), Status Bar (latency + token cost). 5) Input handling: submit on Enter, close on Escape, focus trap within modal. 6) Loading state with skeleton animation. 7) Basic request/response flow to /agentwp/v1/intent endpoint. 8) Render markdown in responses using react-markdown. 9) Persist modal open state in session. Acceptance Criteria: Modal opens within 100ms of hotkey press, doesn't conflict with browser/OS shortcuts, closes cleanly without memory leaks, works across Chrome/Firefox/Safari/Edge, meets WCAG 2.1 AA accessibility."
M02-01,"Intent Engine Core","Build the intent classification and routing system in PHP: 1) AgentWP\Intent\Engine class that receives natural language input and routes to appropriate handler. 2) Define intent categories: ORDER_SEARCH, ORDER_REFUND, ORDER_STATUS, PRODUCT_STOCK, EMAIL_DRAFT, ANALYTICS_QUERY, CUSTOMER_LOOKUP. 3) Create AgentWP\Intent\Handler interface with methods: canHandle(string $intent): bool, handle(array $context): Response. 4) Context builder that enriches requests with: current user, recent orders (last 5), store timezone, currency. 5) Function registry mapping OpenAI function names to PHP handlers. 6) Implement conversation memory within session (last 5 exchanges). 7) Fallback handler for unrecognized intents with helpful suggestions. Acceptance Criteria: Correct intent identified >95% of test cases, context includes relevant store data, handlers receive properly structured input, unhandled intents suggest alternatives."
M02-02,"Order Search and Retrieval","Implement natural language order search: 1) Create AgentWP\Handlers\OrderSearchHandler class. 2) OpenAI function schema: search_orders(query?: string, order_id?: int, email?: string, status?: string, date_range?: {start: string, end: string}, limit?: int). 3) Translate natural language to WC_Order_Query parameters: 'last order' → limit 1 + orderby date DESC, 'orders from john@...' → customer email filter, 'pending orders' → status filter. 4) Return simplified order objects: id, status, total, customer_name, customer_email, date_created, items_summary, shipping_address. 5) Cache recent queries in transients (1 hour TTL). 6) Support relative dates: 'yesterday', 'last week', 'this month'. Acceptance Criteria: 'Show me the last order' returns most recent order within 500ms, email search finds orders by billing/shipping email, date parsing handles common formats, cache reduces DB queries by 50%+ for repeated searches."
M02-03,"Refund Processing - Draft Mode","Implement the refund workflow with Draft-Confirm protocol: 1) Create AgentWP\Handlers\RefundHandler class. 2) OpenAI function schema: prepare_refund(order_id: int, amount?: float, reason?: string, restock_items?: bool). 3) NEVER execute refund on first call - return draft object only. 4) Draft object contains: order_id, order_total, refund_amount, reason, items_to_restock, customer_email, payment_method, requires_manual_refund (bool). 5) Create separate confirm_refund(draft_id: string) function that executes wc_create_refund(). 6) Generate unique draft_id, store in transient with 10-minute expiry. 7) Handle partial refunds, full refunds, and refund+restock scenarios. 8) After confirmation, optionally trigger customer notification email. Acceptance Criteria: No refund ever processed without explicit confirm_refund call, draft expires after 10 minutes, partial refund calculates correctly, payment gateway refund triggered for supported gateways, audit log entry created."
M02-04,"Order Status Updates","Implement order status change functionality: 1) Create AgentWP\Handlers\OrderStatusHandler class. 2) OpenAI function schema: prepare_status_update(order_id: int, new_status: string, note?: string, notify_customer?: bool). 3) Valid statuses from wc_get_order_statuses(): pending, processing, on-hold, completed, cancelled, refunded, failed. 4) Draft-Confirm protocol: return preview showing current_status → new_status with warning for irreversible changes (cancelled, refunded). 5) Support bulk updates: prepare_bulk_status_update(order_ids: int[], new_status: string). 6) Add order note with '[AgentWP]' prefix for audit trail. 7) Trigger WooCommerce status change hooks for email notifications. Acceptance Criteria: Status only changes after confirmation, customer notification respects notify_customer flag, bulk updates handle up to 50 orders, invalid status transitions rejected with explanation."
M02-05,"Product Stock Management","Implement inventory management functionality: 1) Create AgentWP\Handlers\StockHandler class. 2) OpenAI function schemas: search_product(query: string, sku?: string), prepare_stock_update(product_id: int, quantity: int, operation: 'set'|'increase'|'decrease'). 3) Product search by name (fuzzy match), SKU (exact), or ID. 4) Return product info: id, name, sku, current_stock, stock_status, manage_stock, backorders_allowed. 5) Draft-Confirm for stock changes showing: product name, SKU, current_stock → new_stock. 6) Handle variable products: show variations, allow updating specific variation. 7) Validate: can't decrease below 0 unless backorders allowed, warn if setting stock when manage_stock is disabled. Acceptance Criteria: SKU search returns exact match, name search handles partial matches, stock updates trigger woocommerce_product_set_stock hook, variations displayed and updatable independently."
M02-06,"Action Cards Component Library","Build React component library for displaying AI responses: 1) Create components in /react/components/cards/: BaseCard, DangerousActionCard, SuccessCard, ErrorCard, InfoCard, ChartCard, DataTableCard. 2) DangerousActionCard: red accent border, warning icon, clear headline (e.g., 'Confirm Refund?'), details section, [Execute] (red) and [Cancel] (gray) buttons. 3) SuccessCard: green accent, checkmark icon, action summary, optional 'Undo' link. 4) ErrorCard: red background, error message, retry button, 'Report Issue' link. 5) InfoCard: neutral styling for read-only data display. 6) DataTableCard: sortable columns, pagination for >10 rows. 7) All cards support dark/light mode via CSS variables. 8) Animate card entry with subtle fade+slide. Acceptance Criteria: Cards render correctly in both themes, buttons have proper hover/focus states, animations complete in <200ms, keyboard navigation works (Tab through actions, Enter to confirm)."
M03-01,"Email Context Builder","Build context aggregation for email drafting: 1) Create AgentWP\Context\EmailContextBuilder class. 2) For given order_id, gather: order details (items, totals, dates), customer info (name, email, order history count, total spent), shipping info (method, tracking number if available, estimated delivery), payment info (method, last 4 digits if card), recent order notes (last 5). 3) Integrate with popular tracking plugins: WooCommerce Shipment Tracking, AfterShip, ShipStation (check if active, fetch tracking URL). 4) Detect order issues: payment failed, backordered items, delayed shipping (created >3 days ago, not shipped). 5) Return structured context object for AI prompt construction. Acceptance Criteria: Context loads within 300ms for single order, tracking info retrieved when plugins active, issue detection flags common problems, handles orders with 50+ line items."
M03-02,"AI Email Drafting Engine","Implement AI-powered email draft generation: 1) Create AgentWP\Handlers\EmailDraftHandler class. 2) OpenAI function schema: draft_email(order_id: int, intent: string, tone: 'professional'|'friendly'|'apologetic', custom_instructions?: string). 3) Intent types: shipping_update, refund_confirmation, order_issue, general_inquiry, review_request. 4) Build dynamic prompts incorporating EmailContextBuilder output. 5) Response includes: subject_line, email_body (HTML with simple formatting), plain_text_version. 6) Store drafts in transient with 30-minute expiry, allow retrieval/editing. 7) Support template variables: {{customer_name}}, {{order_id}}, {{tracking_url}}, etc. Acceptance Criteria: Generated emails are contextually relevant (mention specific products, tracking info), tone clearly different between options, drafts valid HTML, no placeholder text like '[TRACKING URL]' when data available."
M03-03,"Copy to Clipboard and Export","Implement clipboard and export functionality in React: 1) ClipboardButton component using navigator.clipboard API with fallback for older browsers. 2) Copy formats: plain text, HTML (for email clients), Markdown. 3) Visual feedback: button text changes to 'Copied!' for 2 seconds, subtle animation. 4) Email client integration: 'Open in Mail' button generates mailto: link with subject and body (URL-encoded). 5) Draft history: store last 10 drafts in localStorage, display in collapsible panel, click to restore. 6) Export analytics charts as PNG using html2canvas. Acceptance Criteria: Copy works across all modern browsers, mailto link opens default email client with content populated, draft history persists across sessions, chart export produces crisp image at 2x resolution."
M03-04,"Sales Analytics Queries","Implement sales analytics functionality: 1) Create AgentWP\Handlers\AnalyticsHandler class. 2) OpenAI function schema: get_sales_report(period: 'today'|'yesterday'|'this_week'|'last_week'|'this_month'|'last_month'|'custom', start_date?: string, end_date?: string, compare_previous?: bool). 3) Metrics to return: total_revenue, order_count, average_order_value, items_sold, refund_total, net_revenue, top_products (top 5), top_categories. 4) Use WooCommerce Analytics tables (wp_wc_order_stats) for performance. 5) Comparison mode: return current_period and previous_period with percentage_change. 6) Cache results in transients: 1 hour for historical data, 5 minutes for 'today'. 7) Format currency according to WooCommerce settings. Acceptance Criteria: 'Sales this month' returns accurate totals matching WooCommerce Analytics, comparison calculations correct, queries execute in <1 second for stores with 100k orders, proper currency formatting."

thinking
**Analyzing handler pattern and planning RefundHandler**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Response.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
<?php
/**
 * OpenAI response wrapper.
 *
 * @package AgentWP
 */

namespace AgentWP\AI;

class Response {
	/**
	 * @var bool
	 */
	private $success;

	/**
	 * @var int
	 */
	private $status;


thinking
**Analyzing refund handler structure**
exec
/bin/zsh -lc "sed -n '1,160p' src/Intent/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Handle order search intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
use AgentWP\Intent\Intent;

class OrderSearchHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_SEARCH );
	}

	/**
	 * @param array $context Context data.

thinking
**Analyzing intent handler and service roles**
exec
/bin/zsh -lc "sed -n '1,220p' src/Intent/IntentClassifier.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
<?php
/**
 * Rule-based intent classifier.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

class IntentClassifier {
	/**
	 * @param string $input User input.
	 * @param array  $context Enriched context.
	 * @return string
	 */
	public function classify( $input, array $context = array() ) {
		if ( isset( $context['intent'] ) ) {
			$override = Intent::normalize( $context['intent'] );
			if ( Intent::UNKNOWN !== $override ) {
				return $override;

thinking
**Analyzing RefundHandler implementation approach**
exec
/bin/zsh -lc 'rg -n "drafts" README.md docs -g"*.md"' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 59ms:
docs/ARCHITECTURE.md:146:Primary AI entry point. Converts user input into actions and/or drafts.
docs/ARCHITECTURE.md:291:### GET /drafts/{draft_id}
docs/ARCHITECTURE.md:307:### POST /drafts/{draft_id}/confirm
docs/ARCHITECTURE.md:328:### POST /drafts/{draft_id}/cancel
docs/ARCHITECTURE.md:398:  CommandDeck->>REST: POST /drafts/{draft_id}/confirm
docs/ARCHITECTURE.md:463:6) Confirmations are executed via `/drafts/{draft_id}/confirm`.

thinking
**Analyzing draft management and refund flow**

I’m figuring out how drafts should be stored and confirmed, focusing on using transients for 10-minute expiry without needing to build REST endpoints yet. I’ll implement RefundHandler logic to prevent auto refunds before confirmation, detect manual refund needs by checking the payment gateway’s refund support, and consider adding audit log entries as order notes prefixed with [AgentWP]. Let’s explore the existing code to confirm these patterns.
exec
/bin/zsh -lc 'rg -n "AgentWP" src -g"*.php"' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 42ms:
src/Rest/HealthController.php:5: * @package AgentWP
src/Rest/HealthController.php:8:namespace AgentWP\Rest;
src/Rest/HealthController.php:10:use AgentWP\API\RestController;
src/Rest/SettingsController.php:5: * @package AgentWP
src/Rest/SettingsController.php:8:namespace AgentWP\Rest;
src/Rest/SettingsController.php:10:use AgentWP\API\RestController;
src/Rest/SettingsController.php:11:use AgentWP\Plugin;
src/Rest/SettingsController.php:12:use AgentWP\Security\Encryption;
src/Rest/IntentController.php:5: * @package AgentWP
src/Rest/IntentController.php:8:namespace AgentWP\Rest;
src/Rest/IntentController.php:10:use AgentWP\API\RestController;
src/Rest/IntentController.php:11:use AgentWP\Intent\Engine;
src/Handlers/OrderSearchHandler.php:5: * @package AgentWP
src/Handlers/OrderSearchHandler.php:8:namespace AgentWP\Handlers;
src/Handlers/OrderSearchHandler.php:10:use AgentWP\AI\Response;
src/Handlers/OrderSearchHandler.php:11:use AgentWP\Plugin;
src/API/RestController.php:5: * @package AgentWP
src/API/RestController.php:8:namespace AgentWP\API;
src/API/RestController.php:10:use AgentWP\Plugin;
src/API/RestController.php:35:				__( 'Sorry, you are not allowed to access AgentWP.', 'agentwp' ),



thinking
**Devising RefundHandler design and logic**
thinking
**Detailing refund confirmation and restock logic**

I’m mapping out confirm_refund behavior—checking draft validity, loading order data, handling refund creation via WooCommerce with careful restock item logic, and considering how to best support partial vs full refunds while respecting restock flags. I’m also exploring how to optionally trigger customer notification emails within the limits of existing schemas and WooCommerce capabilities.
thinking
**Planning notification and audit log integration**

I’m working through how to let integrators optionally enable customer refund emails using a filter, avoiding duplicate emails since WooCommerce may send automatically. I’m also planning to add audit log entries on refund confirmation and structuring RefundHandler with explicit prepare and confirm methods, considering how this fits into existing intent handling workflows.
exec
/bin/zsh -lc "sed -n '1,220p' react/src/App.jsx" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
import { useCallback, useEffect, useRef, useState } from 'react';
import ReactMarkdown from 'react-markdown';

const OPEN_STATE_KEY = 'agentwp-command-deck-open';
const ADMIN_TRIGGER_SELECTORS = [
  '#wp-admin-bar-agentwp',
  '[data-agentwp-command-deck]',
  '#agentwp-command-deck',
];
const REST_PATH = '/agentwp/v1/intent';
const FOCUSABLE_SELECTORS = [
  'a[href]',
  'button:not([disabled])',
  'textarea:not([disabled])',
  'input:not([disabled])',
  'select:not([disabled])',
  '[tabindex]:not([tabindex="-1"])',
];

const getInitialOpenState = () => {

thinking
**Mapping refund workflow requirements**
exec
/bin/zsh -lc 'rg -n "get_default_settings" -n src/Plugin.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
48:		$defaults      = self::get_default_settings();
310:	public static function get_default_settings() {
exec
/bin/zsh -lc "sed -n '300,380p' src/Plugin.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 33ms:
		$route = is_string( $route ) ? $route : '';

		return ( 0 === strpos( $route, '/' . API\RestController::REST_NAMESPACE ) );
	}

	/**
	 * Default settings values.
	 *
	 * @return array
	 */
	public static function get_default_settings() {
		return array(
			'model'             => 'gpt-4o-mini',
			'budget_limit'      => 0,
			'draft_ttl_minutes' => 10,
			'hotkey'            => 'Cmd+K / Ctrl+K',
			'theme'             => 'light',
		);
	}


thinking
**Checking draft TTL settings**
exec
/bin/zsh -lc "sed -n '200,280p' src/Rest/SettingsController.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 61ms:
	}

	/**
	 * Read stored settings with defaults.
	 *
	 * @return array
	 */
	private function read_settings() {
		$settings = get_option( Plugin::OPTION_SETTINGS, array() );
		$settings = is_array( $settings ) ? $settings : array();

		return wp_parse_args( $settings, Plugin::get_default_settings() );
	}

	/**
	 * Apply settings updates with sanitization.
	 *
	 * @param array $settings Existing settings.
	 * @param array $payload Raw payload.
	 * @return array


thinking
**Analyzing refund TTL and draft data handling**
thinking
**Designing customer notification and integration steps**

I’m planning a filtered, optional customer notification after refunds, carefully checking which WooCommerce functions exist before calling. I’ll prepare the new RefundHandler file with minimal integration, relying on PSR-4 autoloading, and skip deep intent handler changes unless clearly needed.
exec
/bin/zsh -lc 'cat composer.json' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 45ms:
{
  "name": "agentwp/agentwp",
  "description": "AgentWP WordPress plugin.",
  "type": "wordpress-plugin",
  "license": "GPL-2.0-or-later",
  "autoload": {
    "psr-4": {
      "AgentWP\\": "src/"
    }
  },
  "require": {
    "php": ">=7.4",
    "yethee/tiktoken": "^0.1.2"
  }
}


thinking
**Designing RefundHandler class and refund workflow**
thinking
**Implementing refund draft preparation and confirmation**

I’m working through the detailed logic for preparing a refund draft and confirming it, including validating inputs, calculating refundable amounts, handling restock flags, storing drafts in transients, and performing refunds with WooCommerce functions. I’ll carefully coordinate WooCommerce availability checks, manual restock steps after refund creation to avoid duplication, and returning appropriate success or error responses. This will keep the refund workflow robust and clear.
file update
A /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/RefundHandler.php
<?php
/**
 * Handle refund draft preparation and confirmation.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;

class RefundHandler {
	const DRAFT_TYPE = 'refund';

	/**
	 * Handle refund-related requests.
	 *
	 * @param array $args Request args.
	 * @return Response
	 */
	public function handle( array $args ): Response {
		if ( isset( $args['draft_id'] ) ) {
			return $this->confirm_refund( $args['draft_id'] );
		}

		return $this->prepare_refund( $args );
	}

	/**
	 * Prepare a refund draft without executing it.
	 *
	 * @param array $args Request args.
	 * @return Response
	 */
	public function prepare_refund( array $args ): Response {
		if ( ! function_exists( 'wc_get_order' ) ) {
			return Response::error( 'WooCommerce is required to prepare refunds.', 400 );
		}

		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
		if ( 0 === $order_id ) {
			return Response::error( 'Missing order ID for refund.', 400 );
		}

		$order = wc_get_order( $order_id );
		if ( ! $order ) {
			return Response::error( 'Order not found for refund.', 404 );
		}

		$amount_provided = array_key_exists( 'amount', $args ) && '' !== $args['amount'] && null !== $args['amount'];
		$amount_input    = $amount_provided ? $this->normalize_amount( $args['amount'] ) : null;
		$reason          = isset( $args['reason'] ) ? sanitize_text_field( wp_unslash( $args['reason'] ) ) : '';
		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );

		$order_total    = $this->normalize_amount( $order->get_total() );
		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );

		if ( $remaining <= 0 ) {
			return Response::error( 'Order has no refundable balance.', 400 );
		}

		if ( $amount_provided ) {
			if ( null === $amount_input || $amount_input <= 0 ) {
				return Response::error( 'Refund amount must be greater than zero.', 400 );
			}

			if ( $amount_input > $remaining + $this->amount_epsilon() ) {
				return Response::error( 'Refund amount exceeds remaining order total.', 400 );
			}

			$refund_amount = $this->is_full_refund( $amount_input, $remaining ) ? $remaining : $amount_input;
		} else {
			$refund_amount = $remaining;
		}

		$is_full_refund   = $this->is_full_refund( $refund_amount, $remaining );
		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();

		$payment_method = $this->get_payment_method_label( $order );
		$gateway        = $this->get_payment_gateway( $order );
		$requires_manual_refund = $this->requires_manual_refund( $gateway );

		$draft_payload = array(
			'order_id'               => $order_id,
			'order_total'            => $order_total,
			'refund_amount'          => $refund_amount,
			'reason'                 => $reason,
			'items_to_restock'       => $items_to_restock,
			'customer_email'         => $this->get_customer_email( $order ),
			'payment_method'         => $payment_method,
			'requires_manual_refund' => $requires_manual_refund,
		);

		$draft_id   = $this->generate_draft_id();
		$ttl        = $this->get_draft_ttl_seconds();
		$expires_at = gmdate( 'c', time() + $ttl );
		$stored     = $this->store_draft(
			$draft_id,
			array(
				'id'         => $draft_id,
				'type'       => self::DRAFT_TYPE,
				'payload'    => $draft_payload,
				'expires_at' => $expires_at,
			),
			$ttl
		);

		if ( ! $stored ) {
			return Response::error( 'Unable to store refund draft.', 500 );
		}

		return Response::success(
			array(
				'draft_id'   => $draft_id,
				'draft'      => $draft_payload,
				'expires_at' => $expires_at,
			)
		);
	}

	/**
	 * Confirm and execute a refund from a draft.
	 *
	 * @param string $draft_id Draft identifier.
	 * @return Response
	 */
	public function confirm_refund( $draft_id ): Response {
		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_create_refund' ) ) {
			return Response::error( 'WooCommerce is required to process refunds.', 400 );
		}

		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
		if ( '' === $draft_id ) {
			return Response::error( 'Missing refund draft ID.', 400 );
		}

		$draft = $this->load_draft( $draft_id );
		if ( null === $draft ) {
			return Response::error( 'Refund draft not found or expired.', 404 );
		}

		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
			return Response::error( 'Draft type mismatch for refund confirmation.', 400 );
		}

		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
		if ( 0 === $order_id ) {
			return Response::error( 'Refund draft is missing the order ID.', 400 );
		}

		$order = wc_get_order( $order_id );
		if ( ! $order ) {
			return Response::error( 'Order not found for refund confirmation.', 404 );
		}

		$refund_amount = isset( $payload['refund_amount'] ) ? $this->normalize_amount( $payload['refund_amount'] ) : 0;
		if ( $refund_amount <= 0 ) {
			return Response::error( 'Refund amount is invalid for confirmation.', 400 );
		}

		$order_total    = $this->normalize_amount( $order->get_total() );
		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );

		if ( $remaining <= 0 ) {
			return Response::error( 'Order has no refundable balance.', 400 );
		}

		if ( $refund_amount > $remaining + $this->amount_epsilon() ) {
			return Response::error( 'Refund amount exceeds remaining order total.', 400 );
		}

		$refund_amount = $this->is_full_refund( $refund_amount, $remaining ) ? $remaining : $refund_amount;
		$reason        = isset( $payload['reason'] ) ? (string) $payload['reason'] : '';
		$requires_manual_refund = ! empty( $payload['requires_manual_refund'] );
		$items_to_restock = isset( $payload['items_to_restock'] ) && is_array( $payload['items_to_restock'] )
			? $payload['items_to_restock']
			: array();
		$should_restock = $this->is_full_refund( $refund_amount, $remaining ) && ! empty( $items_to_restock );

		$refund = wc_create_refund(
			array(
				'amount'         => $refund_amount,
				'reason'         => $reason,
				'order_id'       => $order_id,
				'refund_payment' => ! $requires_manual_refund,
				'restock_items'  => false,
			)
		);

		if ( is_wp_error( $refund ) ) {
			return Response::error( $refund->get_error_message(), 400 );
		}

		$refund_id = is_object( $refund ) && method_exists( $refund, 'get_id' ) ? $refund->get_id() : 0;
		$restocked = $should_restock ? $this->restock_items( $order, $items_to_restock ) : array();

		$this->delete_draft( $draft_id );
		$this->add_audit_note( $order, $draft_id, $refund_amount, $reason, ! empty( $restocked ) );
		$this->maybe_notify_customer( $order, $refund, $payload );

		return Response::success(
			array(
				'confirmed'              => true,
				'draft_id'               => $draft_id,
				'order_id'               => $order_id,
				'refund_id'              => $refund_id,
				'refund_amount'          => $refund_amount,
				'restocked_items'        => $restocked,
				'requires_manual_refund' => $requires_manual_refund,
			)
		);
	}

	/**
	 * @param mixed $value Input.
	 * @return bool
	 */
	private function normalize_bool( $value ) {
		if ( function_exists( 'rest_sanitize_boolean' ) ) {
			return rest_sanitize_boolean( $value );
		}

		return (bool) $value;
	}

	/**
	 * @param mixed $amount Amount input.
	 * @return float
	 */
	private function normalize_amount( $amount ) {
		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
		$decimals = $this->get_price_decimals();

		if ( function_exists( 'wc_format_decimal' ) ) {
			return (float) wc_format_decimal( $amount, $decimals );
		}

		return round( $amount, $decimals );
	}

	/**
	 * @return int
	 */
	private function get_price_decimals() {
		if ( function_exists( 'wc_get_price_decimals' ) ) {
			return wc_get_price_decimals();
		}

		return 2;
	}

	/**
	 * @return float
	 */
	private function amount_epsilon() {
		$decimals = $this->get_price_decimals();
		return 1 / pow( 10, $decimals );
	}

	/**
	 * @param float $refund_amount Refund amount.
	 * @param float $remaining Remaining total.
	 * @return bool
	 */
	private function is_full_refund( $refund_amount, $remaining ) {
		return abs( $remaining - $refund_amount ) <= $this->amount_epsilon();
	}

	/**
	 * @param mixed $order Order instance.
	 * @return array
	 */
	private function build_items_to_restock( $order ) {
		$items = array();

		if ( ! $order || ! method_exists( $order, 'get_items' ) ) {
			return $items;
		}

		foreach ( $order->get_items() as $item_id => $item ) {
			if ( ! $item || ! method_exists( $item, 'get_quantity' ) ) {
				continue;
			}

			$quantity = (int) $item->get_quantity();
			if ( $quantity <= 0 ) {
				continue;
			}

			$items[] = array(
				'item_id'     => (int) $item_id,
				'product_id'  => (int) $item->get_product_id(),
				'variation_id'=> (int) $item->get_variation_id(),
				'name'        => sanitize_text_field( $item->get_name() ),
				'quantity'    => $quantity,
			);
		}

		return $items;
	}

	/**
	 * @param mixed $order Order instance.
	 * @return string
	 */
	private function get_customer_email( $order ) {
		if ( ! $order || ! method_exists( $order, 'get_billing_email' ) ) {
			return '';
		}

		return sanitize_email( $order->get_billing_email() );
	}

	/**
	 * @param mixed $order Order instance.
	 * @return string
	 */
	private function get_payment_method_label( $order ) {
		if ( ! $order ) {
			return '';
		}

		if ( method_exists( $order, 'get_payment_method_title' ) ) {
			$title = (string) $order->get_payment_method_title();
			if ( '' !== $title ) {
				return $title;
			}
		}

		return method_exists( $order, 'get_payment_method' ) ? (string) $order->get_payment_method() : '';
	}

	/**
	 * @param mixed $order Order instance.
	 * @return mixed|null
	 */
	private function get_payment_gateway( $order ) {
		if ( function_exists( 'wc_get_payment_gateway_by_order' ) ) {
			return wc_get_payment_gateway_by_order( $order );
		}

		if ( ! function_exists( 'WC' ) || ! $order || ! method_exists( $order, 'get_payment_method' ) ) {
			return null;
		}

		$gateways = WC()->payment_gateways();
		if ( ! $gateways || ! method_exists( $gateways, 'payment_gateways' ) ) {
			return null;
		}

		$method_id = $order->get_payment_method();
		$all       = $gateways->payment_gateways();

		return ( $method_id && isset( $all[ $method_id ] ) ) ? $all[ $method_id ] : null;
	}

	/**
	 * @param mixed $gateway Payment gateway.
	 * @return bool
	 */
	private function requires_manual_refund( $gateway ) {
		if ( ! $gateway || ! method_exists( $gateway, 'supports' ) ) {
			return true;
		}

		return ! $gateway->supports( 'refunds' );
	}

	/**
	 * @return string
	 */
	private function generate_draft_id() {
		if ( function_exists( 'wp_generate_uuid4' ) ) {
			return wp_generate_uuid4();
		}

		return uniqid( 'draft_', true );
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return string
	 */
	private function build_draft_key( $draft_id ) {
		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
	}

	/**
	 * @return int
	 */
	private function get_draft_ttl_seconds() {
		$ttl_minutes = null;

		if ( function_exists( 'get_option' ) ) {
			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
			if ( null !== $option_ttl && '' !== $option_ttl ) {
				$ttl_minutes = intval( $option_ttl );
			}
		}

		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
			}
		}

		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
			$ttl_minutes = 10;
		}

		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;

		return $ttl_minutes * $minute_seconds;
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @param array  $draft Draft payload.
	 * @param int    $ttl_seconds Expiration seconds.
	 * @return bool
	 */
	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
		if ( ! function_exists( 'set_transient' ) ) {
			return false;
		}

		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return array|null
	 */
	private function load_draft( $draft_id ) {
		if ( ! function_exists( 'get_transient' ) ) {
			return null;
		}

		$draft = get_transient( $this->build_draft_key( $draft_id ) );
		if ( false === $draft || ! is_array( $draft ) ) {
			return null;
		}

		return $draft;
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return void
	 */
	private function delete_draft( $draft_id ) {
		if ( function_exists( 'delete_transient' ) ) {
			delete_transient( $this->build_draft_key( $draft_id ) );
		}
	}

	/**
	 * @param mixed $order Order instance.
	 * @param array $items_to_restock Items to restock.
	 * @return array
	 */
	private function restock_items( $order, array $items_to_restock ) {
		$restocked = array();

		if ( ! $order || ! function_exists( 'wc_update_product_stock' ) ) {
			return $restocked;
		}

		foreach ( $items_to_restock as $item_data ) {
			$item_id  = isset( $item_data['item_id'] ) ? absint( $item_data['item_id'] ) : 0;
			$quantity = isset( $item_data['quantity'] ) ? absint( $item_data['quantity'] ) : 0;
			if ( 0 === $item_id || 0 === $quantity ) {
				continue;
			}

			$item = $order->get_item( $item_id );
			if ( ! $item || ! method_exists( $item, 'get_product' ) ) {
				continue;
			}

			$product = $item->get_product();
			if ( ! $product || ! $product->managing_stock() ) {
				continue;
			}

			wc_update_product_stock( $product, $quantity, 'increase' );
			$restocked[] = array(
				'product_id' => $product->get_id(),
				'quantity'   => $quantity,
			);
		}

		return $restocked;
	}

	/**
	 * @param mixed  $order Order instance.
	 * @param string $draft_id Draft ID.
	 * @param float  $amount Refund amount.
	 * @param string $reason Refund reason.
	 * @param bool   $restocked Restock indicator.
	 * @return void
	 */
	private function add_audit_note( $order, $draft_id, $amount, $reason, $restocked ) {
		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
			return;
		}

		$reason_text = '' !== $reason ? $reason : 'no reason provided';
		$note        = sprintf(
			'[AgentWP] Refund confirmed (draft %s). Amount: %s. Reason: %s. Restocked: %s.',
			$draft_id,
			$amount,
			$reason_text,
			$restocked ? 'yes' : 'no'
		);

		$order->add_order_note( $note );
	}

	/**
	 * @param mixed $order Order instance.
	 * @param mixed $refund Refund instance.
	 * @param array $payload Draft payload.
	 * @return void
	 */
	private function maybe_notify_customer( $order, $refund, array $payload ) {
		if ( ! $order || ! $refund ) {
			return;
		}

		$notify = apply_filters( 'agentwp_refund_notify_customer', false, $refund, $order, $payload );
		if ( ! $notify ) {
			return;
		}

		if ( function_exists( 'wc_send_order_refund_notification' ) ) {
			wc_send_order_refund_notification( $order->get_id(), $refund->get_id() );
			return;
		}

		if ( method_exists( $order, 'send_customer_refund_notification' ) ) {
			$order->send_customer_refund_notification( $refund->get_id() );
			return;
		}

		if ( function_exists( 'WC' ) ) {
			$mailer = WC()->mailer();
			if ( $mailer && isset( $mailer->emails['WC_Email_Customer_Refunded_Order'] ) ) {
				$mailer->emails['WC_Email_Customer_Refunded_Order']->trigger( $order->get_id(), $refund->get_id() );
			}
		}
	}
}
apply_patch(auto_approved=true) exited 0 in 34ms:
Success. Updated the following files:
A src/Handlers/RefundHandler.php
file update:
diff --git a/src/Handlers/RefundHandler.php b/src/Handlers/RefundHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..59a3aecbc0175cd5ab900c3a9d0852b0d203ae6f
--- /dev/null
+++ b/src/Handlers/RefundHandler.php
@@ -0,0 +1,559 @@
+<?php
+/**
+ * Handle refund draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class RefundHandler {
+	const DRAFT_TYPE = 'refund';
+
+	/**
+	 * Handle refund-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_refund( $args['draft_id'] );
+		}
+
+		return $this->prepare_refund( $args );
+	}
+
+	/**
+	 * Prepare a refund draft without executing it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_refund( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare refunds.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for refund.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund.', 404 );
+		}
+
+		$amount_provided = array_key_exists( 'amount', $args ) && '' !== $args['amount'] && null !== $args['amount'];
+		$amount_input    = $amount_provided ? $this->normalize_amount( $args['amount'] ) : null;
+		$reason          = isset( $args['reason'] ) ? sanitize_text_field( wp_unslash( $args['reason'] ) ) : '';
+		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $amount_provided ) {
+			if ( null === $amount_input || $amount_input <= 0 ) {
+				return Response::error( 'Refund amount must be greater than zero.', 400 );
+			}
+
+			if ( $amount_input > $remaining + $this->amount_epsilon() ) {
+				return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+			}
+
+			$refund_amount = $this->is_full_refund( $amount_input, $remaining ) ? $remaining : $amount_input;
+		} else {
+			$refund_amount = $remaining;
+		}
+
+		$is_full_refund   = $this->is_full_refund( $refund_amount, $remaining );
+		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();
+
+		$payment_method = $this->get_payment_method_label( $order );
+		$gateway        = $this->get_payment_gateway( $order );
+		$requires_manual_refund = $this->requires_manual_refund( $gateway );
+
+		$draft_payload = array(
+			'order_id'               => $order_id,
+			'order_total'            => $order_total,
+			'refund_amount'          => $refund_amount,
+			'reason'                 => $reason,
+			'items_to_restock'       => $items_to_restock,
+			'customer_email'         => $this->get_customer_email( $order ),
+			'payment_method'         => $payment_method,
+			'requires_manual_refund' => $requires_manual_refund,
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store refund draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a refund from a draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_refund( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_create_refund' ) ) {
+			return Response::error( 'WooCommerce is required to process refunds.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing refund draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Refund draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for refund confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Refund draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund confirmation.', 404 );
+		}
+
+		$refund_amount = isset( $payload['refund_amount'] ) ? $this->normalize_amount( $payload['refund_amount'] ) : 0;
+		if ( $refund_amount <= 0 ) {
+			return Response::error( 'Refund amount is invalid for confirmation.', 400 );
+		}
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $refund_amount > $remaining + $this->amount_epsilon() ) {
+			return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+		}
+
+		$refund_amount = $this->is_full_refund( $refund_amount, $remaining ) ? $remaining : $refund_amount;
+		$reason        = isset( $payload['reason'] ) ? (string) $payload['reason'] : '';
+		$requires_manual_refund = ! empty( $payload['requires_manual_refund'] );
+		$items_to_restock = isset( $payload['items_to_restock'] ) && is_array( $payload['items_to_restock'] )
+			? $payload['items_to_restock']
+			: array();
+		$should_restock = $this->is_full_refund( $refund_amount, $remaining ) && ! empty( $items_to_restock );
+
+		$refund = wc_create_refund(
+			array(
+				'amount'         => $refund_amount,
+				'reason'         => $reason,
+				'order_id'       => $order_id,
+				'refund_payment' => ! $requires_manual_refund,
+				'restock_items'  => false,
+			)
+		);
+
+		if ( is_wp_error( $refund ) ) {
+			return Response::error( $refund->get_error_message(), 400 );
+		}
+
+		$refund_id = is_object( $refund ) && method_exists( $refund, 'get_id' ) ? $refund->get_id() : 0;
+		$restocked = $should_restock ? $this->restock_items( $order, $items_to_restock ) : array();
+
+		$this->delete_draft( $draft_id );
+		$this->add_audit_note( $order, $draft_id, $refund_amount, $reason, ! empty( $restocked ) );
+		$this->maybe_notify_customer( $order, $refund, $payload );
+
+		return Response::success(
+			array(
+				'confirmed'              => true,
+				'draft_id'               => $draft_id,
+				'order_id'               => $order_id,
+				'refund_id'              => $refund_id,
+				'refund_amount'          => $refund_amount,
+				'restocked_items'        => $restocked,
+				'requires_manual_refund' => $requires_manual_refund,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @return float
+	 */
+	private function amount_epsilon() {
+		$decimals = $this->get_price_decimals();
+		return 1 / pow( 10, $decimals );
+	}
+
+	/**
+	 * @param float $refund_amount Refund amount.
+	 * @param float $remaining Remaining total.
+	 * @return bool
+	 */
+	private function is_full_refund( $refund_amount, $remaining ) {
+		return abs( $remaining - $refund_amount ) <= $this->amount_epsilon();
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return array
+	 */
+	private function build_items_to_restock( $order ) {
+		$items = array();
+
+		if ( ! $order || ! method_exists( $order, 'get_items' ) ) {
+			return $items;
+		}
+
+		foreach ( $order->get_items() as $item_id => $item ) {
+			if ( ! $item || ! method_exists( $item, 'get_quantity' ) ) {
+				continue;
+			}
+
+			$quantity = (int) $item->get_quantity();
+			if ( $quantity <= 0 ) {
+				continue;
+			}
+
+			$items[] = array(
+				'item_id'     => (int) $item_id,
+				'product_id'  => (int) $item->get_product_id(),
+				'variation_id'=> (int) $item->get_variation_id(),
+				'name'        => sanitize_text_field( $item->get_name() ),
+				'quantity'    => $quantity,
+			);
+		}
+
+		return $items;
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		if ( ! $order || ! method_exists( $order, 'get_billing_email' ) ) {
+			return '';
+		}
+
+		return sanitize_email( $order->get_billing_email() );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_payment_method_label( $order ) {
+		if ( ! $order ) {
+			return '';
+		}
+
+		if ( method_exists( $order, 'get_payment_method_title' ) ) {
+			$title = (string) $order->get_payment_method_title();
+			if ( '' !== $title ) {
+				return $title;
+			}
+		}
+
+		return method_exists( $order, 'get_payment_method' ) ? (string) $order->get_payment_method() : '';
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return mixed|null
+	 */
+	private function get_payment_gateway( $order ) {
+		if ( function_exists( 'wc_get_payment_gateway_by_order' ) ) {
+			return wc_get_payment_gateway_by_order( $order );
+		}
+
+		if ( ! function_exists( 'WC' ) || ! $order || ! method_exists( $order, 'get_payment_method' ) ) {
+			return null;
+		}
+
+		$gateways = WC()->payment_gateways();
+		if ( ! $gateways || ! method_exists( $gateways, 'payment_gateways' ) ) {
+			return null;
+		}
+
+		$method_id = $order->get_payment_method();
+		$all       = $gateways->payment_gateways();
+
+		return ( $method_id && isset( $all[ $method_id ] ) ) ? $all[ $method_id ] : null;
+	}
+
+	/**
+	 * @param mixed $gateway Payment gateway.
+	 * @return bool
+	 */
+	private function requires_manual_refund( $gateway ) {
+		if ( ! $gateway || ! method_exists( $gateway, 'supports' ) ) {
+			return true;
+		}
+
+		return ! $gateway->supports( 'refunds' );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param array $items_to_restock Items to restock.
+	 * @return array
+	 */
+	private function restock_items( $order, array $items_to_restock ) {
+		$restocked = array();
+
+		if ( ! $order || ! function_exists( 'wc_update_product_stock' ) ) {
+			return $restocked;
+		}
+
+		foreach ( $items_to_restock as $item_data ) {
+			$item_id  = isset( $item_data['item_id'] ) ? absint( $item_data['item_id'] ) : 0;
+			$quantity = isset( $item_data['quantity'] ) ? absint( $item_data['quantity'] ) : 0;
+			if ( 0 === $item_id || 0 === $quantity ) {
+				continue;
+			}
+
+			$item = $order->get_item( $item_id );
+			if ( ! $item || ! method_exists( $item, 'get_product' ) ) {
+				continue;
+			}
+
+			$product = $item->get_product();
+			if ( ! $product || ! $product->managing_stock() ) {
+				continue;
+			}
+
+			wc_update_product_stock( $product, $quantity, 'increase' );
+			$restocked[] = array(
+				'product_id' => $product->get_id(),
+				'quantity'   => $quantity,
+			);
+		}
+
+		return $restocked;
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $draft_id Draft ID.
+	 * @param float  $amount Refund amount.
+	 * @param string $reason Refund reason.
+	 * @param bool   $restocked Restock indicator.
+	 * @return void
+	 */
+	private function add_audit_note( $order, $draft_id, $amount, $reason, $restocked ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return;
+		}
+
+		$reason_text = '' !== $reason ? $reason : 'no reason provided';
+		$note        = sprintf(
+			'[AgentWP] Refund confirmed (draft %s). Amount: %s. Reason: %s. Restocked: %s.',
+			$draft_id,
+			$amount,
+			$reason_text,
+			$restocked ? 'yes' : 'no'
+		);
+
+		$order->add_order_note( $note );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param mixed $refund Refund instance.
+	 * @param array $payload Draft payload.
+	 * @return void
+	 */
+	private function maybe_notify_customer( $order, $refund, array $payload ) {
+		if ( ! $order || ! $refund ) {
+			return;
+		}
+
+		$notify = apply_filters( 'agentwp_refund_notify_customer', false, $refund, $order, $payload );
+		if ( ! $notify ) {
+			return;
+		}
+
+		if ( function_exists( 'wc_send_order_refund_notification' ) ) {
+			wc_send_order_refund_notification( $order->get_id(), $refund->get_id() );
+			return;
+		}
+
+		if ( method_exists( $order, 'send_customer_refund_notification' ) ) {
+			$order->send_customer_refund_notification( $refund->get_id() );
+			return;
+		}
+
+		if ( function_exists( 'WC' ) ) {
+			$mailer = WC()->mailer();
+			if ( $mailer && isset( $mailer->emails['WC_Email_Customer_Refunded_Order'] ) ) {
+				$mailer->emails['WC_Email_Customer_Refunded_Order']->trigger( $order->get_id(), $refund->get_id() );
+			}
+		}
+	}
+}

file update:
diff --git a/src/Handlers/RefundHandler.php b/src/Handlers/RefundHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..59a3aecbc0175cd5ab900c3a9d0852b0d203ae6f
--- /dev/null
+++ b/src/Handlers/RefundHandler.php
@@ -0,0 +1,559 @@
+<?php
+/**
+ * Handle refund draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class RefundHandler {
+	const DRAFT_TYPE = 'refund';
+
+	/**
+	 * Handle refund-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_refund( $args['draft_id'] );
+		}
+
+		return $this->prepare_refund( $args );
+	}
+
+	/**
+	 * Prepare a refund draft without executing it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_refund( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare refunds.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for refund.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund.', 404 );
+		}
+
+		$amount_provided = array_key_exists( 'amount', $args ) && '' !== $args['amount'] && null !== $args['amount'];
+		$amount_input    = $amount_provided ? $this->normalize_amount( $args['amount'] ) : null;
+		$reason          = isset( $args['reason'] ) ? sanitize_text_field( wp_unslash( $args['reason'] ) ) : '';
+		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $amount_provided ) {
+			if ( null === $amount_input || $amount_input <= 0 ) {
+				return Response::error( 'Refund amount must be greater than zero.', 400 );
+			}
+
+			if ( $amount_input > $remaining + $this->amount_epsilon() ) {
+				return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+			}
+
+			$refund_amount = $this->is_full_refund( $amount_input, $remaining ) ? $remaining : $amount_input;
+		} else {
+			$refund_amount = $remaining;
+		}
+
+		$is_full_refund   = $this->is_full_refund( $refund_amount, $remaining );
+		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();
+
+		$payment_method = $this->get_payment_method_label( $order );
+		$gateway        = $this->get_payment_gateway( $order );
+		$requires_manual_refund = $this->requires_manual_refund( $gateway );
+
+		$draft_payload = array(
+			'order_id'               => $order_id,
+			'order_total'            => $order_total,
+			'refund_amount'          => $refund_amount,
+			'reason'                 => $reason,
+			'items_to_restock'       => $items_to_restock,
+			'customer_email'         => $this->get_customer_email( $order ),
+			'payment_method'         => $payment_method,
+			'requires_manual_refund' => $requires_manual_refund,
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store refund draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a refund from a draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_refund( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_create_refund' ) ) {
+			return Response::error( 'WooCommerce is required to process refunds.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing refund draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Refund draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for refund confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Refund draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund confirmation.', 404 );
+		}
+
+		$refund_amount = isset( $payload['refund_amount'] ) ? $this->normalize_amount( $payload['refund_amount'] ) : 0;
+		if ( $refund_amount <= 0 ) {
+			return Response::error( 'Refund amount is invalid for confirmation.', 400 );
+		}
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $refund_amount > $remaining + $this->amount_epsilon() ) {
+			return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+		}
+
+		$refund_amount = $this->is_full_refund( $refund_amount, $remaining ) ? $remaining : $refund_amount;
+		$reason        = isset( $payload['reason'] ) ? (string) $payload['reason'] : '';
+		$requires_manual_refund = ! empty( $payload['requires_manual_refund'] );
+		$items_to_restock = isset( $payload['items_to_restock'] ) && is_array( $payload['items_to_restock'] )
+			? $payload['items_to_restock']
+			: array();
+		$should_restock = $this->is_full_refund( $refund_amount, $remaining ) && ! empty( $items_to_restock );
+
+		$refund = wc_create_refund(
+			array(
+				'amount'         => $refund_amount,
+				'reason'         => $reason,
+				'order_id'       => $order_id,
+				'refund_payment' => ! $requires_manual_refund,
+				'restock_items'  => false,
+			)
+		);
+
+		if ( is_wp_error( $refund ) ) {
+			return Response::error( $refund->get_error_message(), 400 );
+		}
+
+		$refund_id = is_object( $refund ) && method_exists( $refund, 'get_id' ) ? $refund->get_id() : 0;
+		$restocked = $should_restock ? $this->restock_items( $order, $items_to_restock ) : array();
+
+		$this->delete_draft( $draft_id );
+		$this->add_audit_note( $order, $draft_id, $refund_amount, $reason, ! empty( $restocked ) );
+		$this->maybe_notify_customer( $order, $refund, $payload );
+
+		return Response::success(
+			array(
+				'confirmed'              => true,
+				'draft_id'               => $draft_id,
+				'order_id'               => $order_id,
+				'refund_id'              => $refund_id,
+				'refund_amount'          => $refund_amount,
+				'restocked_items'        => $restocked,
+				'requires_manual_refund' => $requires_manual_refund,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @return float
+	 */
+	private function amount_epsilon() {
+		$decimals = $this->get_price_decimals();
+		return 1 / pow( 10, $decimals );
+	}
+
+	/**
+	 * @param float $refund_amount Refund amount.
+	 * @param float $remaining Remaining total.
+	 * @return bool
+	 */
+	private function is_full_refund( $refund_amount, $remaining ) {
+		return abs( $remaining - $refund_amount ) <= $this->amount_epsilon();
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return array
+	 */
+	private function build_items_to_restock( $order ) {
+		$items = array();
+
+		if ( ! $order || ! method_exists( $order, 'get_items' ) ) {
+			return $items;
+		}
+
+		foreach ( $order->get_items() as $item_id => $item ) {
+			if ( ! $item || ! method_exists( $item, 'get_quantity' ) ) {
+				continue;
+			}
+
+			$quantity = (int) $item->get_quantity();
+			if ( $quantity <= 0 ) {
+				continue;
+			}
+
+			$items[] = array(
+				'item_id'     => (int) $item_id,
+				'product_id'  => (int) $item->get_product_id(),
+				'variation_id'=> (int) $item->get_variation_id(),
+				'name'        => sanitize_text_field( $item->get_name() ),
+				'quantity'    => $quantity,
+			);
+		}
+
+		return $items;
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		if ( ! $order || ! method_exists( $order, 'get_billing_email' ) ) {
+			return '';
+		}
+
+		return sanitize_email( $order->get_billing_email() );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_payment_method_label( $order ) {
+		if ( ! $order ) {
+			return '';
+		}
+
+		if ( method_exists( $order, 'get_payment_method_title' ) ) {
+			$title = (string) $order->get_payment_method_title();
+			if ( '' !== $title ) {
+				return $title;
+			}
+		}
+
+		return method_exists( $order, 'get_payment_method' ) ? (string) $order->get_payment_method() : '';
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return mixed|null
+	 */
+	private function get_payment_gateway( $order ) {
+		if ( function_exists( 'wc_get_payment_gateway_by_order' ) ) {
+			return wc_get_payment_gateway_by_order( $order );
+		}
+
+		if ( ! function_exists( 'WC' ) || ! $order || ! method_exists( $order, 'get_payment_method' ) ) {
+			return null;
+		}
+
+		$gateways = WC()->payment_gateways();
+		if ( ! $gateways || ! method_exists( $gateways, 'payment_gateways' ) ) {
+			return null;
+		}
+
+		$method_id = $order->get_payment_method();
+		$all       = $gateways->payment_gateways();
+
+		return ( $method_id && isset( $all[ $method_id ] ) ) ? $all[ $method_id ] : null;
+	}
+
+	/**
+	 * @param mixed $gateway Payment gateway.
+	 * @return bool
+	 */
+	private function requires_manual_refund( $gateway ) {
+		if ( ! $gateway || ! method_exists( $gateway, 'supports' ) ) {
+			return true;
+		}
+
+		return ! $gateway->supports( 'refunds' );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param array $items_to_restock Items to restock.
+	 * @return array
+	 */
+	private function restock_items( $order, array $items_to_restock ) {
+		$restocked = array();
+
+		if ( ! $order || ! function_exists( 'wc_update_product_stock' ) ) {
+			return $restocked;
+		}
+
+		foreach ( $items_to_restock as $item_data ) {
+			$item_id  = isset( $item_data['item_id'] ) ? absint( $item_data['item_id'] ) : 0;
+			$quantity = isset( $item_data['quantity'] ) ? absint( $item_data['quantity'] ) : 0;
+			if ( 0 === $item_id || 0 === $quantity ) {
+				continue;
+			}
+
+			$item = $order->get_item( $item_id );
+			if ( ! $item || ! method_exists( $item, 'get_product' ) ) {
+				continue;
+			}
+
+			$product = $item->get_product();
+			if ( ! $product || ! $product->managing_stock() ) {
+				continue;
+			}
+
+			wc_update_product_stock( $product, $quantity, 'increase' );
+			$restocked[] = array(
+				'product_id' => $product->get_id(),
+				'quantity'   => $quantity,
+			);
+		}
+
+		return $restocked;
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $draft_id Draft ID.
+	 * @param float  $amount Refund amount.
+	 * @param string $reason Refund reason.
+	 * @param bool   $restocked Restock indicator.
+	 * @return void
+	 */
+	private function add_audit_note( $order, $draft_id, $amount, $reason, $restocked ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return;
+		}
+
+		$reason_text = '' !== $reason ? $reason : 'no reason provided';
+		$note        = sprintf(
+			'[AgentWP] Refund confirmed (draft %s). Amount: %s. Reason: %s. Restocked: %s.',
+			$draft_id,
+			$amount,
+			$reason_text,
+			$restocked ? 'yes' : 'no'
+		);
+
+		$order->add_order_note( $note );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param mixed $refund Refund instance.
+	 * @param array $payload Draft payload.
+	 * @return void
+	 */
+	private function maybe_notify_customer( $order, $refund, array $payload ) {
+		if ( ! $order || ! $refund ) {
+			return;
+		}
+
+		$notify = apply_filters( 'agentwp_refund_notify_customer', false, $refund, $order, $payload );
+		if ( ! $notify ) {
+			return;
+		}
+
+		if ( function_exists( 'wc_send_order_refund_notification' ) ) {
+			wc_send_order_refund_notification( $order->get_id(), $refund->get_id() );
+			return;
+		}
+
+		if ( method_exists( $order, 'send_customer_refund_notification' ) ) {
+			$order->send_customer_refund_notification( $refund->get_id() );
+			return;
+		}
+
+		if ( function_exists( 'WC' ) ) {
+			$mailer = WC()->mailer();
+			if ( $mailer && isset( $mailer->emails['WC_Email_Customer_Refunded_Order'] ) ) {
+				$mailer->emails['WC_Email_Customer_Refunded_Order']->trigger( $order->get_id(), $refund->get_id() );
+			}
+		}
+	}
+}


thinking
**Correcting coding style and validating amount handling**

I’m reviewing spacing around array arrows to align with WordPress coding style and checking various amount validations, ensuring zero or "0" inputs are handled correctly. I’m also verifying usage of formatting functions like `normalize_amount`, `wc_format_decimal`, and confirming safety around method calls like `get_variation_id` and filters in WordPress context. Next, I'll fix spacing and improve formatting by applying patches.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/RefundHandler.php
@@ -296,3 +296,3 @@
 				'product_id'  => (int) $item->get_product_id(),
-				'variation_id'=> (int) $item->get_variation_id(),
+				'variation_id' => (int) $item->get_variation_id(),
 				'name'        => sanitize_text_field( $item->get_name() ),
apply_patch(auto_approved=true) exited 0 in 36ms:
Success. Updated the following files:
M src/Handlers/RefundHandler.php
file update:
diff --git a/src/Handlers/RefundHandler.php b/src/Handlers/RefundHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..4d36902b2bf0fc8a00b9daea9b99654acbc58146
--- /dev/null
+++ b/src/Handlers/RefundHandler.php
@@ -0,0 +1,559 @@
+<?php
+/**
+ * Handle refund draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class RefundHandler {
+	const DRAFT_TYPE = 'refund';
+
+	/**
+	 * Handle refund-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_refund( $args['draft_id'] );
+		}
+
+		return $this->prepare_refund( $args );
+	}
+
+	/**
+	 * Prepare a refund draft without executing it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_refund( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare refunds.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for refund.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund.', 404 );
+		}
+
+		$amount_provided = array_key_exists( 'amount', $args ) && '' !== $args['amount'] && null !== $args['amount'];
+		$amount_input    = $amount_provided ? $this->normalize_amount( $args['amount'] ) : null;
+		$reason          = isset( $args['reason'] ) ? sanitize_text_field( wp_unslash( $args['reason'] ) ) : '';
+		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $amount_provided ) {
+			if ( null === $amount_input || $amount_input <= 0 ) {
+				return Response::error( 'Refund amount must be greater than zero.', 400 );
+			}
+
+			if ( $amount_input > $remaining + $this->amount_epsilon() ) {
+				return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+			}
+
+			$refund_amount = $this->is_full_refund( $amount_input, $remaining ) ? $remaining : $amount_input;
+		} else {
+			$refund_amount = $remaining;
+		}
+
+		$is_full_refund   = $this->is_full_refund( $refund_amount, $remaining );
+		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();
+
+		$payment_method = $this->get_payment_method_label( $order );
+		$gateway        = $this->get_payment_gateway( $order );
+		$requires_manual_refund = $this->requires_manual_refund( $gateway );
+
+		$draft_payload = array(
+			'order_id'               => $order_id,
+			'order_total'            => $order_total,
+			'refund_amount'          => $refund_amount,
+			'reason'                 => $reason,
+			'items_to_restock'       => $items_to_restock,
+			'customer_email'         => $this->get_customer_email( $order ),
+			'payment_method'         => $payment_method,
+			'requires_manual_refund' => $requires_manual_refund,
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store refund draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a refund from a draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_refund( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_create_refund' ) ) {
+			return Response::error( 'WooCommerce is required to process refunds.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing refund draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Refund draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for refund confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Refund draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund confirmation.', 404 );
+		}
+
+		$refund_amount = isset( $payload['refund_amount'] ) ? $this->normalize_amount( $payload['refund_amount'] ) : 0;
+		if ( $refund_amount <= 0 ) {
+			return Response::error( 'Refund amount is invalid for confirmation.', 400 );
+		}
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $refund_amount > $remaining + $this->amount_epsilon() ) {
+			return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+		}
+
+		$refund_amount = $this->is_full_refund( $refund_amount, $remaining ) ? $remaining : $refund_amount;
+		$reason        = isset( $payload['reason'] ) ? (string) $payload['reason'] : '';
+		$requires_manual_refund = ! empty( $payload['requires_manual_refund'] );
+		$items_to_restock = isset( $payload['items_to_restock'] ) && is_array( $payload['items_to_restock'] )
+			? $payload['items_to_restock']
+			: array();
+		$should_restock = $this->is_full_refund( $refund_amount, $remaining ) && ! empty( $items_to_restock );
+
+		$refund = wc_create_refund(
+			array(
+				'amount'         => $refund_amount,
+				'reason'         => $reason,
+				'order_id'       => $order_id,
+				'refund_payment' => ! $requires_manual_refund,
+				'restock_items'  => false,
+			)
+		);
+
+		if ( is_wp_error( $refund ) ) {
+			return Response::error( $refund->get_error_message(), 400 );
+		}
+
+		$refund_id = is_object( $refund ) && method_exists( $refund, 'get_id' ) ? $refund->get_id() : 0;
+		$restocked = $should_restock ? $this->restock_items( $order, $items_to_restock ) : array();
+
+		$this->delete_draft( $draft_id );
+		$this->add_audit_note( $order, $draft_id, $refund_amount, $reason, ! empty( $restocked ) );
+		$this->maybe_notify_customer( $order, $refund, $payload );
+
+		return Response::success(
+			array(
+				'confirmed'              => true,
+				'draft_id'               => $draft_id,
+				'order_id'               => $order_id,
+				'refund_id'              => $refund_id,
+				'refund_amount'          => $refund_amount,
+				'restocked_items'        => $restocked,
+				'requires_manual_refund' => $requires_manual_refund,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @return float
+	 */
+	private function amount_epsilon() {
+		$decimals = $this->get_price_decimals();
+		return 1 / pow( 10, $decimals );
+	}
+
+	/**
+	 * @param float $refund_amount Refund amount.
+	 * @param float $remaining Remaining total.
+	 * @return bool
+	 */
+	private function is_full_refund( $refund_amount, $remaining ) {
+		return abs( $remaining - $refund_amount ) <= $this->amount_epsilon();
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return array
+	 */
+	private function build_items_to_restock( $order ) {
+		$items = array();
+
+		if ( ! $order || ! method_exists( $order, 'get_items' ) ) {
+			return $items;
+		}
+
+		foreach ( $order->get_items() as $item_id => $item ) {
+			if ( ! $item || ! method_exists( $item, 'get_quantity' ) ) {
+				continue;
+			}
+
+			$quantity = (int) $item->get_quantity();
+			if ( $quantity <= 0 ) {
+				continue;
+			}
+
+			$items[] = array(
+				'item_id'     => (int) $item_id,
+				'product_id'  => (int) $item->get_product_id(),
+				'variation_id' => (int) $item->get_variation_id(),
+				'name'        => sanitize_text_field( $item->get_name() ),
+				'quantity'    => $quantity,
+			);
+		}
+
+		return $items;
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		if ( ! $order || ! method_exists( $order, 'get_billing_email' ) ) {
+			return '';
+		}
+
+		return sanitize_email( $order->get_billing_email() );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_payment_method_label( $order ) {
+		if ( ! $order ) {
+			return '';
+		}
+
+		if ( method_exists( $order, 'get_payment_method_title' ) ) {
+			$title = (string) $order->get_payment_method_title();
+			if ( '' !== $title ) {
+				return $title;
+			}
+		}
+
+		return method_exists( $order, 'get_payment_method' ) ? (string) $order->get_payment_method() : '';
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return mixed|null
+	 */
+	private function get_payment_gateway( $order ) {
+		if ( function_exists( 'wc_get_payment_gateway_by_order' ) ) {
+			return wc_get_payment_gateway_by_order( $order );
+		}
+
+		if ( ! function_exists( 'WC' ) || ! $order || ! method_exists( $order, 'get_payment_method' ) ) {
+			return null;
+		}
+
+		$gateways = WC()->payment_gateways();
+		if ( ! $gateways || ! method_exists( $gateways, 'payment_gateways' ) ) {
+			return null;
+		}
+
+		$method_id = $order->get_payment_method();
+		$all       = $gateways->payment_gateways();
+
+		return ( $method_id && isset( $all[ $method_id ] ) ) ? $all[ $method_id ] : null;
+	}
+
+	/**
+	 * @param mixed $gateway Payment gateway.
+	 * @return bool
+	 */
+	private function requires_manual_refund( $gateway ) {
+		if ( ! $gateway || ! method_exists( $gateway, 'supports' ) ) {
+			return true;
+		}
+
+		return ! $gateway->supports( 'refunds' );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param array $items_to_restock Items to restock.
+	 * @return array
+	 */
+	private function restock_items( $order, array $items_to_restock ) {
+		$restocked = array();
+
+		if ( ! $order || ! function_exists( 'wc_update_product_stock' ) ) {
+			return $restocked;
+		}
+
+		foreach ( $items_to_restock as $item_data ) {
+			$item_id  = isset( $item_data['item_id'] ) ? absint( $item_data['item_id'] ) : 0;
+			$quantity = isset( $item_data['quantity'] ) ? absint( $item_data['quantity'] ) : 0;
+			if ( 0 === $item_id || 0 === $quantity ) {
+				continue;
+			}
+
+			$item = $order->get_item( $item_id );
+			if ( ! $item || ! method_exists( $item, 'get_product' ) ) {
+				continue;
+			}
+
+			$product = $item->get_product();
+			if ( ! $product || ! $product->managing_stock() ) {
+				continue;
+			}
+
+			wc_update_product_stock( $product, $quantity, 'increase' );
+			$restocked[] = array(
+				'product_id' => $product->get_id(),
+				'quantity'   => $quantity,
+			);
+		}
+
+		return $restocked;
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $draft_id Draft ID.
+	 * @param float  $amount Refund amount.
+	 * @param string $reason Refund reason.
+	 * @param bool   $restocked Restock indicator.
+	 * @return void
+	 */
+	private function add_audit_note( $order, $draft_id, $amount, $reason, $restocked ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return;
+		}
+
+		$reason_text = '' !== $reason ? $reason : 'no reason provided';
+		$note        = sprintf(
+			'[AgentWP] Refund confirmed (draft %s). Amount: %s. Reason: %s. Restocked: %s.',
+			$draft_id,
+			$amount,
+			$reason_text,
+			$restocked ? 'yes' : 'no'
+		);
+
+		$order->add_order_note( $note );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param mixed $refund Refund instance.
+	 * @param array $payload Draft payload.
+	 * @return void
+	 */
+	private function maybe_notify_customer( $order, $refund, array $payload ) {
+		if ( ! $order || ! $refund ) {
+			return;
+		}
+
+		$notify = apply_filters( 'agentwp_refund_notify_customer', false, $refund, $order, $payload );
+		if ( ! $notify ) {
+			return;
+		}
+
+		if ( function_exists( 'wc_send_order_refund_notification' ) ) {
+			wc_send_order_refund_notification( $order->get_id(), $refund->get_id() );
+			return;
+		}
+
+		if ( method_exists( $order, 'send_customer_refund_notification' ) ) {
+			$order->send_customer_refund_notification( $refund->get_id() );
+			return;
+		}
+
+		if ( function_exists( 'WC' ) ) {
+			$mailer = WC()->mailer();
+			if ( $mailer && isset( $mailer->emails['WC_Email_Customer_Refunded_Order'] ) ) {
+				$mailer->emails['WC_Email_Customer_Refunded_Order']->trigger( $order->get_id(), $refund->get_id() );
+			}
+		}
+	}
+}

file update:
diff --git a/src/Handlers/RefundHandler.php b/src/Handlers/RefundHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..4d36902b2bf0fc8a00b9daea9b99654acbc58146
--- /dev/null
+++ b/src/Handlers/RefundHandler.php
@@ -0,0 +1,559 @@
+<?php
+/**
+ * Handle refund draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class RefundHandler {
+	const DRAFT_TYPE = 'refund';
+
+	/**
+	 * Handle refund-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_refund( $args['draft_id'] );
+		}
+
+		return $this->prepare_refund( $args );
+	}
+
+	/**
+	 * Prepare a refund draft without executing it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_refund( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare refunds.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for refund.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund.', 404 );
+		}
+
+		$amount_provided = array_key_exists( 'amount', $args ) && '' !== $args['amount'] && null !== $args['amount'];
+		$amount_input    = $amount_provided ? $this->normalize_amount( $args['amount'] ) : null;
+		$reason          = isset( $args['reason'] ) ? sanitize_text_field( wp_unslash( $args['reason'] ) ) : '';
+		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $amount_provided ) {
+			if ( null === $amount_input || $amount_input <= 0 ) {
+				return Response::error( 'Refund amount must be greater than zero.', 400 );
+			}
+
+			if ( $amount_input > $remaining + $this->amount_epsilon() ) {
+				return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+			}
+
+			$refund_amount = $this->is_full_refund( $amount_input, $remaining ) ? $remaining : $amount_input;
+		} else {
+			$refund_amount = $remaining;
+		}
+
+		$is_full_refund   = $this->is_full_refund( $refund_amount, $remaining );
+		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();
+
+		$payment_method = $this->get_payment_method_label( $order );
+		$gateway        = $this->get_payment_gateway( $order );
+		$requires_manual_refund = $this->requires_manual_refund( $gateway );
+
+		$draft_payload = array(
+			'order_id'               => $order_id,
+			'order_total'            => $order_total,
+			'refund_amount'          => $refund_amount,
+			'reason'                 => $reason,
+			'items_to_restock'       => $items_to_restock,
+			'customer_email'         => $this->get_customer_email( $order ),
+			'payment_method'         => $payment_method,
+			'requires_manual_refund' => $requires_manual_refund,
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store refund draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a refund from a draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_refund( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_create_refund' ) ) {
+			return Response::error( 'WooCommerce is required to process refunds.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing refund draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Refund draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for refund confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Refund draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund confirmation.', 404 );
+		}
+
+		$refund_amount = isset( $payload['refund_amount'] ) ? $this->normalize_amount( $payload['refund_amount'] ) : 0;
+		if ( $refund_amount <= 0 ) {
+			return Response::error( 'Refund amount is invalid for confirmation.', 400 );
+		}
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $refund_amount > $remaining + $this->amount_epsilon() ) {
+			return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+		}
+
+		$refund_amount = $this->is_full_refund( $refund_amount, $remaining ) ? $remaining : $refund_amount;
+		$reason        = isset( $payload['reason'] ) ? (string) $payload['reason'] : '';
+		$requires_manual_refund = ! empty( $payload['requires_manual_refund'] );
+		$items_to_restock = isset( $payload['items_to_restock'] ) && is_array( $payload['items_to_restock'] )
+			? $payload['items_to_restock']
+			: array();
+		$should_restock = $this->is_full_refund( $refund_amount, $remaining ) && ! empty( $items_to_restock );
+
+		$refund = wc_create_refund(
+			array(
+				'amount'         => $refund_amount,
+				'reason'         => $reason,
+				'order_id'       => $order_id,
+				'refund_payment' => ! $requires_manual_refund,
+				'restock_items'  => false,
+			)
+		);
+
+		if ( is_wp_error( $refund ) ) {
+			return Response::error( $refund->get_error_message(), 400 );
+		}
+
+		$refund_id = is_object( $refund ) && method_exists( $refund, 'get_id' ) ? $refund->get_id() : 0;
+		$restocked = $should_restock ? $this->restock_items( $order, $items_to_restock ) : array();
+
+		$this->delete_draft( $draft_id );
+		$this->add_audit_note( $order, $draft_id, $refund_amount, $reason, ! empty( $restocked ) );
+		$this->maybe_notify_customer( $order, $refund, $payload );
+
+		return Response::success(
+			array(
+				'confirmed'              => true,
+				'draft_id'               => $draft_id,
+				'order_id'               => $order_id,
+				'refund_id'              => $refund_id,
+				'refund_amount'          => $refund_amount,
+				'restocked_items'        => $restocked,
+				'requires_manual_refund' => $requires_manual_refund,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @return float
+	 */
+	private function amount_epsilon() {
+		$decimals = $this->get_price_decimals();
+		return 1 / pow( 10, $decimals );
+	}
+
+	/**
+	 * @param float $refund_amount Refund amount.
+	 * @param float $remaining Remaining total.
+	 * @return bool
+	 */
+	private function is_full_refund( $refund_amount, $remaining ) {
+		return abs( $remaining - $refund_amount ) <= $this->amount_epsilon();
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return array
+	 */
+	private function build_items_to_restock( $order ) {
+		$items = array();
+
+		if ( ! $order || ! method_exists( $order, 'get_items' ) ) {
+			return $items;
+		}
+
+		foreach ( $order->get_items() as $item_id => $item ) {
+			if ( ! $item || ! method_exists( $item, 'get_quantity' ) ) {
+				continue;
+			}
+
+			$quantity = (int) $item->get_quantity();
+			if ( $quantity <= 0 ) {
+				continue;
+			}
+
+			$items[] = array(
+				'item_id'     => (int) $item_id,
+				'product_id'  => (int) $item->get_product_id(),
+				'variation_id' => (int) $item->get_variation_id(),
+				'name'        => sanitize_text_field( $item->get_name() ),
+				'quantity'    => $quantity,
+			);
+		}
+
+		return $items;
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		if ( ! $order || ! method_exists( $order, 'get_billing_email' ) ) {
+			return '';
+		}
+
+		return sanitize_email( $order->get_billing_email() );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_payment_method_label( $order ) {
+		if ( ! $order ) {
+			return '';
+		}
+
+		if ( method_exists( $order, 'get_payment_method_title' ) ) {
+			$title = (string) $order->get_payment_method_title();
+			if ( '' !== $title ) {
+				return $title;
+			}
+		}
+
+		return method_exists( $order, 'get_payment_method' ) ? (string) $order->get_payment_method() : '';
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return mixed|null
+	 */
+	private function get_payment_gateway( $order ) {
+		if ( function_exists( 'wc_get_payment_gateway_by_order' ) ) {
+			return wc_get_payment_gateway_by_order( $order );
+		}
+
+		if ( ! function_exists( 'WC' ) || ! $order || ! method_exists( $order, 'get_payment_method' ) ) {
+			return null;
+		}
+
+		$gateways = WC()->payment_gateways();
+		if ( ! $gateways || ! method_exists( $gateways, 'payment_gateways' ) ) {
+			return null;
+		}
+
+		$method_id = $order->get_payment_method();
+		$all       = $gateways->payment_gateways();
+
+		return ( $method_id && isset( $all[ $method_id ] ) ) ? $all[ $method_id ] : null;
+	}
+
+	/**
+	 * @param mixed $gateway Payment gateway.
+	 * @return bool
+	 */
+	private function requires_manual_refund( $gateway ) {
+		if ( ! $gateway || ! method_exists( $gateway, 'supports' ) ) {
+			return true;
+		}
+
+		return ! $gateway->supports( 'refunds' );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param array $items_to_restock Items to restock.
+	 * @return array
+	 */
+	private function restock_items( $order, array $items_to_restock ) {
+		$restocked = array();
+
+		if ( ! $order || ! function_exists( 'wc_update_product_stock' ) ) {
+			return $restocked;
+		}
+
+		foreach ( $items_to_restock as $item_data ) {
+			$item_id  = isset( $item_data['item_id'] ) ? absint( $item_data['item_id'] ) : 0;
+			$quantity = isset( $item_data['quantity'] ) ? absint( $item_data['quantity'] ) : 0;
+			if ( 0 === $item_id || 0 === $quantity ) {
+				continue;
+			}
+
+			$item = $order->get_item( $item_id );
+			if ( ! $item || ! method_exists( $item, 'get_product' ) ) {
+				continue;
+			}
+
+			$product = $item->get_product();
+			if ( ! $product || ! $product->managing_stock() ) {
+				continue;
+			}
+
+			wc_update_product_stock( $product, $quantity, 'increase' );
+			$restocked[] = array(
+				'product_id' => $product->get_id(),
+				'quantity'   => $quantity,
+			);
+		}
+
+		return $restocked;
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $draft_id Draft ID.
+	 * @param float  $amount Refund amount.
+	 * @param string $reason Refund reason.
+	 * @param bool   $restocked Restock indicator.
+	 * @return void
+	 */
+	private function add_audit_note( $order, $draft_id, $amount, $reason, $restocked ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return;
+		}
+
+		$reason_text = '' !== $reason ? $reason : 'no reason provided';
+		$note        = sprintf(
+			'[AgentWP] Refund confirmed (draft %s). Amount: %s. Reason: %s. Restocked: %s.',
+			$draft_id,
+			$amount,
+			$reason_text,
+			$restocked ? 'yes' : 'no'
+		);
+
+		$order->add_order_note( $note );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param mixed $refund Refund instance.
+	 * @param array $payload Draft payload.
+	 * @return void
+	 */
+	private function maybe_notify_customer( $order, $refund, array $payload ) {
+		if ( ! $order || ! $refund ) {
+			return;
+		}
+
+		$notify = apply_filters( 'agentwp_refund_notify_customer', false, $refund, $order, $payload );
+		if ( ! $notify ) {
+			return;
+		}
+
+		if ( function_exists( 'wc_send_order_refund_notification' ) ) {
+			wc_send_order_refund_notification( $order->get_id(), $refund->get_id() );
+			return;
+		}
+
+		if ( method_exists( $order, 'send_customer_refund_notification' ) ) {
+			$order->send_customer_refund_notification( $refund->get_id() );
+			return;
+		}
+
+		if ( function_exists( 'WC' ) ) {
+			$mailer = WC()->mailer();
+			if ( $mailer && isset( $mailer->emails['WC_Email_Customer_Refunded_Order'] ) ) {
+				$mailer->emails['WC_Email_Customer_Refunded_Order']->trigger( $order->get_id(), $refund->get_id() );
+			}
+		}
+	}
+}


thinking
**Reviewing audit note formatting**
exec
/bin/zsh -lc "sed -n '1,320p' src/Handlers/RefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Handle refund draft preparation and confirmation.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;

class RefundHandler {
	const DRAFT_TYPE = 'refund';

	/**
	 * Handle refund-related requests.
	 *
	 * @param array $args Request args.
	 * @return Response
file update:
diff --git a/src/Handlers/RefundHandler.php b/src/Handlers/RefundHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..4d36902b2bf0fc8a00b9daea9b99654acbc58146
--- /dev/null
+++ b/src/Handlers/RefundHandler.php
@@ -0,0 +1,559 @@
+<?php
+/**
+ * Handle refund draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class RefundHandler {
+	const DRAFT_TYPE = 'refund';
+
+	/**
+	 * Handle refund-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_refund( $args['draft_id'] );
+		}
+
+		return $this->prepare_refund( $args );
+	}
+
+	/**
+	 * Prepare a refund draft without executing it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_refund( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare refunds.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for refund.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund.', 404 );
+		}
+
+		$amount_provided = array_key_exists( 'amount', $args ) && '' !== $args['amount'] && null !== $args['amount'];
+		$amount_input    = $amount_provided ? $this->normalize_amount( $args['amount'] ) : null;
+		$reason          = isset( $args['reason'] ) ? sanitize_text_field( wp_unslash( $args['reason'] ) ) : '';
+		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $amount_provided ) {
+			if ( null === $amount_input || $amount_input <= 0 ) {
+				return Response::error( 'Refund amount must be greater than zero.', 400 );
+			}
+
+			if ( $amount_input > $remaining + $this->amount_epsilon() ) {
+				return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+			}
+
+			$refund_amount = $this->is_full_refund( $amount_input, $remaining ) ? $remaining : $amount_input;
+		} else {
+			$refund_amount = $remaining;
+		}
+
+		$is_full_refund   = $this->is_full_refund( $refund_amount, $remaining );
+		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();
+
+		$payment_method = $this->get_payment_method_label( $order );
+		$gateway        = $this->get_payment_gateway( $order );
+		$requires_manual_refund = $this->requires_manual_refund( $gateway );
+
+		$draft_payload = array(
+			'order_id'               => $order_id,
+			'order_total'            => $order_total,
+			'refund_amount'          => $refund_amount,
+			'reason'                 => $reason,
+			'items_to_restock'       => $items_to_restock,
+			'customer_email'         => $this->get_customer_email( $order ),
+			'payment_method'         => $payment_method,
+			'requires_manual_refund' => $requires_manual_refund,
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store refund draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a refund from a draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_refund( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_create_refund' ) ) {
+			return Response::error( 'WooCommerce is required to process refunds.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing refund draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Refund draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for refund confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Refund draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund confirmation.', 404 );
+		}
+
+		$refund_amount = isset( $payload['refund_amount'] ) ? $this->normalize_amount( $payload['refund_amount'] ) : 0;
+		if ( $refund_amount <= 0 ) {
+			return Response::error( 'Refund amount is invalid for confirmation.', 400 );
+		}
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $refund_amount > $remaining + $this->amount_epsilon() ) {
+			return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+		}
+
+		$refund_amount = $this->is_full_refund( $refund_amount, $remaining ) ? $remaining : $refund_amount;
+		$reason        = isset( $payload['reason'] ) ? (string) $payload['reason'] : '';
+		$requires_manual_refund = ! empty( $payload['requires_manual_refund'] );
+		$items_to_restock = isset( $payload['items_to_restock'] ) && is_array( $payload['items_to_restock'] )
+			? $payload['items_to_restock']
+			: array();
+		$should_restock = $this->is_full_refund( $refund_amount, $remaining ) && ! empty( $items_to_restock );
+
+		$refund = wc_create_refund(
+			array(
+				'amount'         => $refund_amount,
+				'reason'         => $reason,
+				'order_id'       => $order_id,
+				'refund_payment' => ! $requires_manual_refund,
+				'restock_items'  => false,
+			)
+		);
+
+		if ( is_wp_error( $refund ) ) {
+			return Response::error( $refund->get_error_message(), 400 );
+		}
+
+		$refund_id = is_object( $refund ) && method_exists( $refund, 'get_id' ) ? $refund->get_id() : 0;
+		$restocked = $should_restock ? $this->restock_items( $order, $items_to_restock ) : array();
+
+		$this->delete_draft( $draft_id );
+		$this->add_audit_note( $order, $draft_id, $refund_amount, $reason, ! empty( $restocked ) );
+		$this->maybe_notify_customer( $order, $refund, $payload );
+
+		return Response::success(
+			array(
+				'confirmed'              => true,
+				'draft_id'               => $draft_id,
+				'order_id'               => $order_id,
+				'refund_id'              => $refund_id,
+				'refund_amount'          => $refund_amount,
+				'restocked_items'        => $restocked,
+				'requires_manual_refund' => $requires_manual_refund,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @return float
+	 */
+	private function amount_epsilon() {
+		$decimals = $this->get_price_decimals();
+		return 1 / pow( 10, $decimals );
+	}
+
+	/**
+	 * @param float $refund_amount Refund amount.
+	 * @param float $remaining Remaining total.
+	 * @return bool
+	 */
+	private function is_full_refund( $refund_amount, $remaining ) {
+		return abs( $remaining - $refund_amount ) <= $this->amount_epsilon();
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return array
+	 */
+	private function build_items_to_restock( $order ) {
+		$items = array();
+
+		if ( ! $order || ! method_exists( $order, 'get_items' ) ) {
+			return $items;
+		}
+
+		foreach ( $order->get_items() as $item_id => $item ) {
+			if ( ! $item || ! method_exists( $item, 'get_quantity' ) ) {
+				continue;
+			}
+
+			$quantity = (int) $item->get_quantity();
+			if ( $quantity <= 0 ) {
+				continue;
+			}
+
+			$items[] = array(
+				'item_id'     => (int) $item_id,
+				'product_id'  => (int) $item->get_product_id(),
+				'variation_id' => (int) $item->get_variation_id(),
+				'name'        => sanitize_text_field( $item->get_name() ),
+				'quantity'    => $quantity,
+			);
+		}
+
+		return $items;
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		if ( ! $order || ! method_exists( $order, 'get_billing_email' ) ) {
+			return '';
+		}
+
+		return sanitize_email( $order->get_billing_email() );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_payment_method_label( $order ) {
+		if ( ! $order ) {
+			return '';
+		}
+
+		if ( method_exists( $order, 'get_payment_method_title' ) ) {
+			$title = (string) $order->get_payment_method_title();
+			if ( '' !== $title ) {
+				return $title;
+			}
+		}
+
+		return method_exists( $order, 'get_payment_method' ) ? (string) $order->get_payment_method() : '';
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return mixed|null
+	 */
+	private function get_payment_gateway( $order ) {
+		if ( function_exists( 'wc_get_payment_gateway_by_order' ) ) {
+			return wc_get_payment_gateway_by_order( $order );
+		}
+
+		if ( ! function_exists( 'WC' ) || ! $order || ! method_exists( $order, 'get_payment_method' ) ) {
+			return null;
+		}
+
+		$gateways = WC()->payment_gateways();
+		if ( ! $gateways || ! method_exists( $gateways, 'payment_gateways' ) ) {
+			return null;
+		}
+
+		$method_id = $order->get_payment_method();
+		$all       = $gateways->payment_gateways();
+
+		return ( $method_id && isset( $all[ $method_id ] ) ) ? $all[ $method_id ] : null;
+	}
+
+	/**
+	 * @param mixed $gateway Payment gateway.
+	 * @return bool
+	 */
+	private function requires_manual_refund( $gateway ) {
+		if ( ! $gateway || ! method_exists( $gateway, 'supports' ) ) {
+			return true;
+		}
+
+		return ! $gateway->supports( 'refunds' );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param array $items_to_restock Items to restock.
+	 * @return array
+	 */
+	private function restock_items( $order, array $items_to_restock ) {
+		$restocked = array();
+
+		if ( ! $order || ! function_exists( 'wc_update_product_stock' ) ) {
+			return $restocked;
+		}
+
+		foreach ( $items_to_restock as $item_data ) {
+			$item_id  = isset( $item_data['item_id'] ) ? absint( $item_data['item_id'] ) : 0;
+			$quantity = isset( $item_data['quantity'] ) ? absint( $item_data['quantity'] ) : 0;
+			if ( 0 === $item_id || 0 === $quantity ) {
+				continue;
+			}
+
+			$item = $order->get_item( $item_id );
+			if ( ! $item || ! method_exists( $item, 'get_product' ) ) {
+				continue;
+			}
+
+			$product = $item->get_product();
+			if ( ! $product || ! $product->managing_stock() ) {
+				continue;
+			}
+
+			wc_update_product_stock( $product, $quantity, 'increase' );
+			$restocked[] = array(
+				'product_id' => $product->get_id(),
+				'quantity'   => $quantity,
+			);
+		}
+
+		return $restocked;
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $draft_id Draft ID.
+	 * @param float  $amount Refund amount.
+	 * @param string $reason Refund reason.
+	 * @param bool   $restocked Restock indicator.
+	 * @return void
+	 */
+	private function add_audit_note( $order, $draft_id, $amount, $reason, $restocked ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return;
+		}
+
+		$reason_text = '' !== $reason ? $reason : 'no reason provided';
+		$note        = sprintf(
+			'[AgentWP] Refund confirmed (draft %s). Amount: %s. Reason: %s. Restocked: %s.',
+			$draft_id,
+			$amount,
+			$reason_text,
+			$restocked ? 'yes' : 'no'
+		);
+
+		$order->add_order_note( $note );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param mixed $refund Refund instance.
+	 * @param array $payload Draft payload.
+	 * @return void
+	 */
+	private function maybe_notify_customer( $order, $refund, array $payload ) {
+		if ( ! $order || ! $refund ) {
+			return;
+		}
+
+		$notify = apply_filters( 'agentwp_refund_notify_customer', false, $refund, $order, $payload );
+		if ( ! $notify ) {
+			return;
+		}
+
+		if ( function_exists( 'wc_send_order_refund_notification' ) ) {
+			wc_send_order_refund_notification( $order->get_id(), $refund->get_id() );
+			return;
+		}
+
+		if ( method_exists( $order, 'send_customer_refund_notification' ) ) {
+			$order->send_customer_refund_notification( $refund->get_id() );
+			return;
+		}
+
+		if ( function_exists( 'WC' ) ) {
+			$mailer = WC()->mailer();
+			if ( $mailer && isset( $mailer->emails['WC_Email_Customer_Refunded_Order'] ) ) {
+				$mailer->emails['WC_Email_Customer_Refunded_Order']->trigger( $order->get_id(), $refund->get_id() );
+			}
+		}
+	}
+}


thinking
**Reviewing code formatting and logic nuances**
exec
/bin/zsh -lc "sed -n '320,640p' src/Handlers/RefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
	 * @return string
	 */
	private function get_payment_method_label( $order ) {
		if ( ! $order ) {
			return '';
		}

		if ( method_exists( $order, 'get_payment_method_title' ) ) {
			$title = (string) $order->get_payment_method_title();
			if ( '' !== $title ) {
				return $title;
			}
		}

		return method_exists( $order, 'get_payment_method' ) ? (string) $order->get_payment_method() : '';
	}

	/**
	 * @param mixed $order Order instance.
	 * @return mixed|null
file update:
diff --git a/src/Handlers/RefundHandler.php b/src/Handlers/RefundHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..4d36902b2bf0fc8a00b9daea9b99654acbc58146
--- /dev/null
+++ b/src/Handlers/RefundHandler.php
@@ -0,0 +1,559 @@
+<?php
+/**
+ * Handle refund draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class RefundHandler {
+	const DRAFT_TYPE = 'refund';
+
+	/**
+	 * Handle refund-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_refund( $args['draft_id'] );
+		}
+
+		return $this->prepare_refund( $args );
+	}
+
+	/**
+	 * Prepare a refund draft without executing it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_refund( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare refunds.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for refund.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund.', 404 );
+		}
+
+		$amount_provided = array_key_exists( 'amount', $args ) && '' !== $args['amount'] && null !== $args['amount'];
+		$amount_input    = $amount_provided ? $this->normalize_amount( $args['amount'] ) : null;
+		$reason          = isset( $args['reason'] ) ? sanitize_text_field( wp_unslash( $args['reason'] ) ) : '';
+		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $amount_provided ) {
+			if ( null === $amount_input || $amount_input <= 0 ) {
+				return Response::error( 'Refund amount must be greater than zero.', 400 );
+			}
+
+			if ( $amount_input > $remaining + $this->amount_epsilon() ) {
+				return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+			}
+
+			$refund_amount = $this->is_full_refund( $amount_input, $remaining ) ? $remaining : $amount_input;
+		} else {
+			$refund_amount = $remaining;
+		}
+
+		$is_full_refund   = $this->is_full_refund( $refund_amount, $remaining );
+		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();
+
+		$payment_method = $this->get_payment_method_label( $order );
+		$gateway        = $this->get_payment_gateway( $order );
+		$requires_manual_refund = $this->requires_manual_refund( $gateway );
+
+		$draft_payload = array(
+			'order_id'               => $order_id,
+			'order_total'            => $order_total,
+			'refund_amount'          => $refund_amount,
+			'reason'                 => $reason,
+			'items_to_restock'       => $items_to_restock,
+			'customer_email'         => $this->get_customer_email( $order ),
+			'payment_method'         => $payment_method,
+			'requires_manual_refund' => $requires_manual_refund,
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store refund draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a refund from a draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_refund( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_create_refund' ) ) {
+			return Response::error( 'WooCommerce is required to process refunds.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing refund draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Refund draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for refund confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Refund draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund confirmation.', 404 );
+		}
+
+		$refund_amount = isset( $payload['refund_amount'] ) ? $this->normalize_amount( $payload['refund_amount'] ) : 0;
+		if ( $refund_amount <= 0 ) {
+			return Response::error( 'Refund amount is invalid for confirmation.', 400 );
+		}
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $refund_amount > $remaining + $this->amount_epsilon() ) {
+			return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+		}
+
+		$refund_amount = $this->is_full_refund( $refund_amount, $remaining ) ? $remaining : $refund_amount;
+		$reason        = isset( $payload['reason'] ) ? (string) $payload['reason'] : '';
+		$requires_manual_refund = ! empty( $payload['requires_manual_refund'] );
+		$items_to_restock = isset( $payload['items_to_restock'] ) && is_array( $payload['items_to_restock'] )
+			? $payload['items_to_restock']
+			: array();
+		$should_restock = $this->is_full_refund( $refund_amount, $remaining ) && ! empty( $items_to_restock );
+
+		$refund = wc_create_refund(
+			array(
+				'amount'         => $refund_amount,
+				'reason'         => $reason,
+				'order_id'       => $order_id,
+				'refund_payment' => ! $requires_manual_refund,
+				'restock_items'  => false,
+			)
+		);
+
+		if ( is_wp_error( $refund ) ) {
+			return Response::error( $refund->get_error_message(), 400 );
+		}
+
+		$refund_id = is_object( $refund ) && method_exists( $refund, 'get_id' ) ? $refund->get_id() : 0;
+		$restocked = $should_restock ? $this->restock_items( $order, $items_to_restock ) : array();
+
+		$this->delete_draft( $draft_id );
+		$this->add_audit_note( $order, $draft_id, $refund_amount, $reason, ! empty( $restocked ) );
+		$this->maybe_notify_customer( $order, $refund, $payload );
+
+		return Response::success(
+			array(
+				'confirmed'              => true,
+				'draft_id'               => $draft_id,
+				'order_id'               => $order_id,
+				'refund_id'              => $refund_id,
+				'refund_amount'          => $refund_amount,
+				'restocked_items'        => $restocked,
+				'requires_manual_refund' => $requires_manual_refund,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @return float
+	 */
+	private function amount_epsilon() {
+		$decimals = $this->get_price_decimals();
+		return 1 / pow( 10, $decimals );
+	}
+
+	/**
+	 * @param float $refund_amount Refund amount.
+	 * @param float $remaining Remaining total.
+	 * @return bool
+	 */
+	private function is_full_refund( $refund_amount, $remaining ) {
+		return abs( $remaining - $refund_amount ) <= $this->amount_epsilon();
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return array
+	 */
+	private function build_items_to_restock( $order ) {
+		$items = array();
+
+		if ( ! $order || ! method_exists( $order, 'get_items' ) ) {
+			return $items;
+		}
+
+		foreach ( $order->get_items() as $item_id => $item ) {
+			if ( ! $item || ! method_exists( $item, 'get_quantity' ) ) {
+				continue;
+			}
+
+			$quantity = (int) $item->get_quantity();
+			if ( $quantity <= 0 ) {
+				continue;
+			}
+
+			$items[] = array(
+				'item_id'     => (int) $item_id,
+				'product_id'  => (int) $item->get_product_id(),
+				'variation_id' => (int) $item->get_variation_id(),
+				'name'        => sanitize_text_field( $item->get_name() ),
+				'quantity'    => $quantity,
+			);
+		}
+
+		return $items;
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		if ( ! $order || ! method_exists( $order, 'get_billing_email' ) ) {
+			return '';
+		}
+
+		return sanitize_email( $order->get_billing_email() );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_payment_method_label( $order ) {
+		if ( ! $order ) {
+			return '';
+		}
+
+		if ( method_exists( $order, 'get_payment_method_title' ) ) {
+			$title = (string) $order->get_payment_method_title();
+			if ( '' !== $title ) {
+				return $title;
+			}
+		}
+
+		return method_exists( $order, 'get_payment_method' ) ? (string) $order->get_payment_method() : '';
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return mixed|null
+	 */
+	private function get_payment_gateway( $order ) {
+		if ( function_exists( 'wc_get_payment_gateway_by_order' ) ) {
+			return wc_get_payment_gateway_by_order( $order );
+		}
+
+		if ( ! function_exists( 'WC' ) || ! $order || ! method_exists( $order, 'get_payment_method' ) ) {
+			return null;
+		}
+
+		$gateways = WC()->payment_gateways();
+		if ( ! $gateways || ! method_exists( $gateways, 'payment_gateways' ) ) {
+			return null;
+		}
+
+		$method_id = $order->get_payment_method();
+		$all       = $gateways->payment_gateways();
+
+		return ( $method_id && isset( $all[ $method_id ] ) ) ? $all[ $method_id ] : null;
+	}
+
+	/**
+	 * @param mixed $gateway Payment gateway.
+	 * @return bool
+	 */
+	private function requires_manual_refund( $gateway ) {
+		if ( ! $gateway || ! method_exists( $gateway, 'supports' ) ) {
+			return true;
+		}
+
+		return ! $gateway->supports( 'refunds' );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param array $items_to_restock Items to restock.
+	 * @return array
+	 */
+	private function restock_items( $order, array $items_to_restock ) {
+		$restocked = array();
+
+		if ( ! $order || ! function_exists( 'wc_update_product_stock' ) ) {
+			return $restocked;
+		}
+
+		foreach ( $items_to_restock as $item_data ) {
+			$item_id  = isset( $item_data['item_id'] ) ? absint( $item_data['item_id'] ) : 0;
+			$quantity = isset( $item_data['quantity'] ) ? absint( $item_data['quantity'] ) : 0;
+			if ( 0 === $item_id || 0 === $quantity ) {
+				continue;
+			}
+
+			$item = $order->get_item( $item_id );
+			if ( ! $item || ! method_exists( $item, 'get_product' ) ) {
+				continue;
+			}
+
+			$product = $item->get_product();
+			if ( ! $product || ! $product->managing_stock() ) {
+				continue;
+			}
+
+			wc_update_product_stock( $product, $quantity, 'increase' );
+			$restocked[] = array(
+				'product_id' => $product->get_id(),
+				'quantity'   => $quantity,
+			);
+		}
+
+		return $restocked;
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $draft_id Draft ID.
+	 * @param float  $amount Refund amount.
+	 * @param string $reason Refund reason.
+	 * @param bool   $restocked Restock indicator.
+	 * @return void
+	 */
+	private function add_audit_note( $order, $draft_id, $amount, $reason, $restocked ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return;
+		}
+
+		$reason_text = '' !== $reason ? $reason : 'no reason provided';
+		$note        = sprintf(
+			'[AgentWP] Refund confirmed (draft %s). Amount: %s. Reason: %s. Restocked: %s.',
+			$draft_id,
+			$amount,
+			$reason_text,
+			$restocked ? 'yes' : 'no'
+		);
+
+		$order->add_order_note( $note );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param mixed $refund Refund instance.
+	 * @param array $payload Draft payload.
+	 * @return void
+	 */
+	private function maybe_notify_customer( $order, $refund, array $payload ) {
+		if ( ! $order || ! $refund ) {
+			return;
+		}
+
+		$notify = apply_filters( 'agentwp_refund_notify_customer', false, $refund, $order, $payload );
+		if ( ! $notify ) {
+			return;
+		}
+
+		if ( function_exists( 'wc_send_order_refund_notification' ) ) {
+			wc_send_order_refund_notification( $order->get_id(), $refund->get_id() );
+			return;
+		}
+
+		if ( method_exists( $order, 'send_customer_refund_notification' ) ) {
+			$order->send_customer_refund_notification( $refund->get_id() );
+			return;
+		}
+
+		if ( function_exists( 'WC' ) ) {
+			$mailer = WC()->mailer();
+			if ( $mailer && isset( $mailer->emails['WC_Email_Customer_Refunded_Order'] ) ) {
+				$mailer->emails['WC_Email_Customer_Refunded_Order']->trigger( $order->get_id(), $refund->get_id() );
+			}
+		}
+	}
+}


thinking
**Reviewing refund amount handling and potential improvements**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/RefundHandler.php
@@ -514,2 +514,3 @@
 		$reason_text = '' !== $reason ? $reason : 'no reason provided';
+		$amount      = $this->normalize_amount( $amount );
 		$note        = sprintf(
apply_patch(auto_approved=true) exited 0 in 36ms:
Success. Updated the following files:
M src/Handlers/RefundHandler.php
file update:
diff --git a/src/Handlers/RefundHandler.php b/src/Handlers/RefundHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..2da8614d4549508f8579d1510446ab1bbc4a8412
--- /dev/null
+++ b/src/Handlers/RefundHandler.php
@@ -0,0 +1,560 @@
+<?php
+/**
+ * Handle refund draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class RefundHandler {
+	const DRAFT_TYPE = 'refund';
+
+	/**
+	 * Handle refund-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_refund( $args['draft_id'] );
+		}
+
+		return $this->prepare_refund( $args );
+	}
+
+	/**
+	 * Prepare a refund draft without executing it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_refund( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare refunds.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for refund.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund.', 404 );
+		}
+
+		$amount_provided = array_key_exists( 'amount', $args ) && '' !== $args['amount'] && null !== $args['amount'];
+		$amount_input    = $amount_provided ? $this->normalize_amount( $args['amount'] ) : null;
+		$reason          = isset( $args['reason'] ) ? sanitize_text_field( wp_unslash( $args['reason'] ) ) : '';
+		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $amount_provided ) {
+			if ( null === $amount_input || $amount_input <= 0 ) {
+				return Response::error( 'Refund amount must be greater than zero.', 400 );
+			}
+
+			if ( $amount_input > $remaining + $this->amount_epsilon() ) {
+				return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+			}
+
+			$refund_amount = $this->is_full_refund( $amount_input, $remaining ) ? $remaining : $amount_input;
+		} else {
+			$refund_amount = $remaining;
+		}
+
+		$is_full_refund   = $this->is_full_refund( $refund_amount, $remaining );
+		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();
+
+		$payment_method = $this->get_payment_method_label( $order );
+		$gateway        = $this->get_payment_gateway( $order );
+		$requires_manual_refund = $this->requires_manual_refund( $gateway );
+
+		$draft_payload = array(
+			'order_id'               => $order_id,
+			'order_total'            => $order_total,
+			'refund_amount'          => $refund_amount,
+			'reason'                 => $reason,
+			'items_to_restock'       => $items_to_restock,
+			'customer_email'         => $this->get_customer_email( $order ),
+			'payment_method'         => $payment_method,
+			'requires_manual_refund' => $requires_manual_refund,
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store refund draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a refund from a draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_refund( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_create_refund' ) ) {
+			return Response::error( 'WooCommerce is required to process refunds.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing refund draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Refund draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for refund confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Refund draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund confirmation.', 404 );
+		}
+
+		$refund_amount = isset( $payload['refund_amount'] ) ? $this->normalize_amount( $payload['refund_amount'] ) : 0;
+		if ( $refund_amount <= 0 ) {
+			return Response::error( 'Refund amount is invalid for confirmation.', 400 );
+		}
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $refund_amount > $remaining + $this->amount_epsilon() ) {
+			return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+		}
+
+		$refund_amount = $this->is_full_refund( $refund_amount, $remaining ) ? $remaining : $refund_amount;
+		$reason        = isset( $payload['reason'] ) ? (string) $payload['reason'] : '';
+		$requires_manual_refund = ! empty( $payload['requires_manual_refund'] );
+		$items_to_restock = isset( $payload['items_to_restock'] ) && is_array( $payload['items_to_restock'] )
+			? $payload['items_to_restock']
+			: array();
+		$should_restock = $this->is_full_refund( $refund_amount, $remaining ) && ! empty( $items_to_restock );
+
+		$refund = wc_create_refund(
+			array(
+				'amount'         => $refund_amount,
+				'reason'         => $reason,
+				'order_id'       => $order_id,
+				'refund_payment' => ! $requires_manual_refund,
+				'restock_items'  => false,
+			)
+		);
+
+		if ( is_wp_error( $refund ) ) {
+			return Response::error( $refund->get_error_message(), 400 );
+		}
+
+		$refund_id = is_object( $refund ) && method_exists( $refund, 'get_id' ) ? $refund->get_id() : 0;
+		$restocked = $should_restock ? $this->restock_items( $order, $items_to_restock ) : array();
+
+		$this->delete_draft( $draft_id );
+		$this->add_audit_note( $order, $draft_id, $refund_amount, $reason, ! empty( $restocked ) );
+		$this->maybe_notify_customer( $order, $refund, $payload );
+
+		return Response::success(
+			array(
+				'confirmed'              => true,
+				'draft_id'               => $draft_id,
+				'order_id'               => $order_id,
+				'refund_id'              => $refund_id,
+				'refund_amount'          => $refund_amount,
+				'restocked_items'        => $restocked,
+				'requires_manual_refund' => $requires_manual_refund,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @return float
+	 */
+	private function amount_epsilon() {
+		$decimals = $this->get_price_decimals();
+		return 1 / pow( 10, $decimals );
+	}
+
+	/**
+	 * @param float $refund_amount Refund amount.
+	 * @param float $remaining Remaining total.
+	 * @return bool
+	 */
+	private function is_full_refund( $refund_amount, $remaining ) {
+		return abs( $remaining - $refund_amount ) <= $this->amount_epsilon();
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return array
+	 */
+	private function build_items_to_restock( $order ) {
+		$items = array();
+
+		if ( ! $order || ! method_exists( $order, 'get_items' ) ) {
+			return $items;
+		}
+
+		foreach ( $order->get_items() as $item_id => $item ) {
+			if ( ! $item || ! method_exists( $item, 'get_quantity' ) ) {
+				continue;
+			}
+
+			$quantity = (int) $item->get_quantity();
+			if ( $quantity <= 0 ) {
+				continue;
+			}
+
+			$items[] = array(
+				'item_id'     => (int) $item_id,
+				'product_id'  => (int) $item->get_product_id(),
+				'variation_id' => (int) $item->get_variation_id(),
+				'name'        => sanitize_text_field( $item->get_name() ),
+				'quantity'    => $quantity,
+			);
+		}
+
+		return $items;
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		if ( ! $order || ! method_exists( $order, 'get_billing_email' ) ) {
+			return '';
+		}
+
+		return sanitize_email( $order->get_billing_email() );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_payment_method_label( $order ) {
+		if ( ! $order ) {
+			return '';
+		}
+
+		if ( method_exists( $order, 'get_payment_method_title' ) ) {
+			$title = (string) $order->get_payment_method_title();
+			if ( '' !== $title ) {
+				return $title;
+			}
+		}
+
+		return method_exists( $order, 'get_payment_method' ) ? (string) $order->get_payment_method() : '';
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return mixed|null
+	 */
+	private function get_payment_gateway( $order ) {
+		if ( function_exists( 'wc_get_payment_gateway_by_order' ) ) {
+			return wc_get_payment_gateway_by_order( $order );
+		}
+
+		if ( ! function_exists( 'WC' ) || ! $order || ! method_exists( $order, 'get_payment_method' ) ) {
+			return null;
+		}
+
+		$gateways = WC()->payment_gateways();
+		if ( ! $gateways || ! method_exists( $gateways, 'payment_gateways' ) ) {
+			return null;
+		}
+
+		$method_id = $order->get_payment_method();
+		$all       = $gateways->payment_gateways();
+
+		return ( $method_id && isset( $all[ $method_id ] ) ) ? $all[ $method_id ] : null;
+	}
+
+	/**
+	 * @param mixed $gateway Payment gateway.
+	 * @return bool
+	 */
+	private function requires_manual_refund( $gateway ) {
+		if ( ! $gateway || ! method_exists( $gateway, 'supports' ) ) {
+			return true;
+		}
+
+		return ! $gateway->supports( 'refunds' );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param array $items_to_restock Items to restock.
+	 * @return array
+	 */
+	private function restock_items( $order, array $items_to_restock ) {
+		$restocked = array();
+
+		if ( ! $order || ! function_exists( 'wc_update_product_stock' ) ) {
+			return $restocked;
+		}
+
+		foreach ( $items_to_restock as $item_data ) {
+			$item_id  = isset( $item_data['item_id'] ) ? absint( $item_data['item_id'] ) : 0;
+			$quantity = isset( $item_data['quantity'] ) ? absint( $item_data['quantity'] ) : 0;
+			if ( 0 === $item_id || 0 === $quantity ) {
+				continue;
+			}
+
+			$item = $order->get_item( $item_id );
+			if ( ! $item || ! method_exists( $item, 'get_product' ) ) {
+				continue;
+			}
+
+			$product = $item->get_product();
+			if ( ! $product || ! $product->managing_stock() ) {
+				continue;
+			}
+
+			wc_update_product_stock( $product, $quantity, 'increase' );
+			$restocked[] = array(
+				'product_id' => $product->get_id(),
+				'quantity'   => $quantity,
+			);
+		}
+
+		return $restocked;
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $draft_id Draft ID.
+	 * @param float  $amount Refund amount.
+	 * @param string $reason Refund reason.
+	 * @param bool   $restocked Restock indicator.
+	 * @return void
+	 */
+	private function add_audit_note( $order, $draft_id, $amount, $reason, $restocked ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return;
+		}
+
+		$reason_text = '' !== $reason ? $reason : 'no reason provided';
+		$amount      = $this->normalize_amount( $amount );
+		$note        = sprintf(
+			'[AgentWP] Refund confirmed (draft %s). Amount: %s. Reason: %s. Restocked: %s.',
+			$draft_id,
+			$amount,
+			$reason_text,
+			$restocked ? 'yes' : 'no'
+		);
+
+		$order->add_order_note( $note );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param mixed $refund Refund instance.
+	 * @param array $payload Draft payload.
+	 * @return void
+	 */
+	private function maybe_notify_customer( $order, $refund, array $payload ) {
+		if ( ! $order || ! $refund ) {
+			return;
+		}
+
+		$notify = apply_filters( 'agentwp_refund_notify_customer', false, $refund, $order, $payload );
+		if ( ! $notify ) {
+			return;
+		}
+
+		if ( function_exists( 'wc_send_order_refund_notification' ) ) {
+			wc_send_order_refund_notification( $order->get_id(), $refund->get_id() );
+			return;
+		}
+
+		if ( method_exists( $order, 'send_customer_refund_notification' ) ) {
+			$order->send_customer_refund_notification( $refund->get_id() );
+			return;
+		}
+
+		if ( function_exists( 'WC' ) ) {
+			$mailer = WC()->mailer();
+			if ( $mailer && isset( $mailer->emails['WC_Email_Customer_Refunded_Order'] ) ) {
+				$mailer->emails['WC_Email_Customer_Refunded_Order']->trigger( $order->get_id(), $refund->get_id() );
+			}
+		}
+	}
+}

file update:
diff --git a/src/Handlers/RefundHandler.php b/src/Handlers/RefundHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..2da8614d4549508f8579d1510446ab1bbc4a8412
--- /dev/null
+++ b/src/Handlers/RefundHandler.php
@@ -0,0 +1,560 @@
+<?php
+/**
+ * Handle refund draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class RefundHandler {
+	const DRAFT_TYPE = 'refund';
+
+	/**
+	 * Handle refund-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_refund( $args['draft_id'] );
+		}
+
+		return $this->prepare_refund( $args );
+	}
+
+	/**
+	 * Prepare a refund draft without executing it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_refund( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare refunds.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for refund.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund.', 404 );
+		}
+
+		$amount_provided = array_key_exists( 'amount', $args ) && '' !== $args['amount'] && null !== $args['amount'];
+		$amount_input    = $amount_provided ? $this->normalize_amount( $args['amount'] ) : null;
+		$reason          = isset( $args['reason'] ) ? sanitize_text_field( wp_unslash( $args['reason'] ) ) : '';
+		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $amount_provided ) {
+			if ( null === $amount_input || $amount_input <= 0 ) {
+				return Response::error( 'Refund amount must be greater than zero.', 400 );
+			}
+
+			if ( $amount_input > $remaining + $this->amount_epsilon() ) {
+				return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+			}
+
+			$refund_amount = $this->is_full_refund( $amount_input, $remaining ) ? $remaining : $amount_input;
+		} else {
+			$refund_amount = $remaining;
+		}
+
+		$is_full_refund   = $this->is_full_refund( $refund_amount, $remaining );
+		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();
+
+		$payment_method = $this->get_payment_method_label( $order );
+		$gateway        = $this->get_payment_gateway( $order );
+		$requires_manual_refund = $this->requires_manual_refund( $gateway );
+
+		$draft_payload = array(
+			'order_id'               => $order_id,
+			'order_total'            => $order_total,
+			'refund_amount'          => $refund_amount,
+			'reason'                 => $reason,
+			'items_to_restock'       => $items_to_restock,
+			'customer_email'         => $this->get_customer_email( $order ),
+			'payment_method'         => $payment_method,
+			'requires_manual_refund' => $requires_manual_refund,
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store refund draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a refund from a draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_refund( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_create_refund' ) ) {
+			return Response::error( 'WooCommerce is required to process refunds.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing refund draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Refund draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for refund confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Refund draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund confirmation.', 404 );
+		}
+
+		$refund_amount = isset( $payload['refund_amount'] ) ? $this->normalize_amount( $payload['refund_amount'] ) : 0;
+		if ( $refund_amount <= 0 ) {
+			return Response::error( 'Refund amount is invalid for confirmation.', 400 );
+		}
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $refund_amount > $remaining + $this->amount_epsilon() ) {
+			return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+		}
+
+		$refund_amount = $this->is_full_refund( $refund_amount, $remaining ) ? $remaining : $refund_amount;
+		$reason        = isset( $payload['reason'] ) ? (string) $payload['reason'] : '';
+		$requires_manual_refund = ! empty( $payload['requires_manual_refund'] );
+		$items_to_restock = isset( $payload['items_to_restock'] ) && is_array( $payload['items_to_restock'] )
+			? $payload['items_to_restock']
+			: array();
+		$should_restock = $this->is_full_refund( $refund_amount, $remaining ) && ! empty( $items_to_restock );
+
+		$refund = wc_create_refund(
+			array(
+				'amount'         => $refund_amount,
+				'reason'         => $reason,
+				'order_id'       => $order_id,
+				'refund_payment' => ! $requires_manual_refund,
+				'restock_items'  => false,
+			)
+		);
+
+		if ( is_wp_error( $refund ) ) {
+			return Response::error( $refund->get_error_message(), 400 );
+		}
+
+		$refund_id = is_object( $refund ) && method_exists( $refund, 'get_id' ) ? $refund->get_id() : 0;
+		$restocked = $should_restock ? $this->restock_items( $order, $items_to_restock ) : array();
+
+		$this->delete_draft( $draft_id );
+		$this->add_audit_note( $order, $draft_id, $refund_amount, $reason, ! empty( $restocked ) );
+		$this->maybe_notify_customer( $order, $refund, $payload );
+
+		return Response::success(
+			array(
+				'confirmed'              => true,
+				'draft_id'               => $draft_id,
+				'order_id'               => $order_id,
+				'refund_id'              => $refund_id,
+				'refund_amount'          => $refund_amount,
+				'restocked_items'        => $restocked,
+				'requires_manual_refund' => $requires_manual_refund,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @return float
+	 */
+	private function amount_epsilon() {
+		$decimals = $this->get_price_decimals();
+		return 1 / pow( 10, $decimals );
+	}
+
+	/**
+	 * @param float $refund_amount Refund amount.
+	 * @param float $remaining Remaining total.
+	 * @return bool
+	 */
+	private function is_full_refund( $refund_amount, $remaining ) {
+		return abs( $remaining - $refund_amount ) <= $this->amount_epsilon();
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return array
+	 */
+	private function build_items_to_restock( $order ) {
+		$items = array();
+
+		if ( ! $order || ! method_exists( $order, 'get_items' ) ) {
+			return $items;
+		}
+
+		foreach ( $order->get_items() as $item_id => $item ) {
+			if ( ! $item || ! method_exists( $item, 'get_quantity' ) ) {
+				continue;
+			}
+
+			$quantity = (int) $item->get_quantity();
+			if ( $quantity <= 0 ) {
+				continue;
+			}
+
+			$items[] = array(
+				'item_id'     => (int) $item_id,
+				'product_id'  => (int) $item->get_product_id(),
+				'variation_id' => (int) $item->get_variation_id(),
+				'name'        => sanitize_text_field( $item->get_name() ),
+				'quantity'    => $quantity,
+			);
+		}
+
+		return $items;
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		if ( ! $order || ! method_exists( $order, 'get_billing_email' ) ) {
+			return '';
+		}
+
+		return sanitize_email( $order->get_billing_email() );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_payment_method_label( $order ) {
+		if ( ! $order ) {
+			return '';
+		}
+
+		if ( method_exists( $order, 'get_payment_method_title' ) ) {
+			$title = (string) $order->get_payment_method_title();
+			if ( '' !== $title ) {
+				return $title;
+			}
+		}
+
+		return method_exists( $order, 'get_payment_method' ) ? (string) $order->get_payment_method() : '';
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return mixed|null
+	 */
+	private function get_payment_gateway( $order ) {
+		if ( function_exists( 'wc_get_payment_gateway_by_order' ) ) {
+			return wc_get_payment_gateway_by_order( $order );
+		}
+
+		if ( ! function_exists( 'WC' ) || ! $order || ! method_exists( $order, 'get_payment_method' ) ) {
+			return null;
+		}
+
+		$gateways = WC()->payment_gateways();
+		if ( ! $gateways || ! method_exists( $gateways, 'payment_gateways' ) ) {
+			return null;
+		}
+
+		$method_id = $order->get_payment_method();
+		$all       = $gateways->payment_gateways();
+
+		return ( $method_id && isset( $all[ $method_id ] ) ) ? $all[ $method_id ] : null;
+	}
+
+	/**
+	 * @param mixed $gateway Payment gateway.
+	 * @return bool
+	 */
+	private function requires_manual_refund( $gateway ) {
+		if ( ! $gateway || ! method_exists( $gateway, 'supports' ) ) {
+			return true;
+		}
+
+		return ! $gateway->supports( 'refunds' );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param array $items_to_restock Items to restock.
+	 * @return array
+	 */
+	private function restock_items( $order, array $items_to_restock ) {
+		$restocked = array();
+
+		if ( ! $order || ! function_exists( 'wc_update_product_stock' ) ) {
+			return $restocked;
+		}
+
+		foreach ( $items_to_restock as $item_data ) {
+			$item_id  = isset( $item_data['item_id'] ) ? absint( $item_data['item_id'] ) : 0;
+			$quantity = isset( $item_data['quantity'] ) ? absint( $item_data['quantity'] ) : 0;
+			if ( 0 === $item_id || 0 === $quantity ) {
+				continue;
+			}
+
+			$item = $order->get_item( $item_id );
+			if ( ! $item || ! method_exists( $item, 'get_product' ) ) {
+				continue;
+			}
+
+			$product = $item->get_product();
+			if ( ! $product || ! $product->managing_stock() ) {
+				continue;
+			}
+
+			wc_update_product_stock( $product, $quantity, 'increase' );
+			$restocked[] = array(
+				'product_id' => $product->get_id(),
+				'quantity'   => $quantity,
+			);
+		}
+
+		return $restocked;
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $draft_id Draft ID.
+	 * @param float  $amount Refund amount.
+	 * @param string $reason Refund reason.
+	 * @param bool   $restocked Restock indicator.
+	 * @return void
+	 */
+	private function add_audit_note( $order, $draft_id, $amount, $reason, $restocked ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return;
+		}
+
+		$reason_text = '' !== $reason ? $reason : 'no reason provided';
+		$amount      = $this->normalize_amount( $amount );
+		$note        = sprintf(
+			'[AgentWP] Refund confirmed (draft %s). Amount: %s. Reason: %s. Restocked: %s.',
+			$draft_id,
+			$amount,
+			$reason_text,
+			$restocked ? 'yes' : 'no'
+		);
+
+		$order->add_order_note( $note );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param mixed $refund Refund instance.
+	 * @param array $payload Draft payload.
+	 * @return void
+	 */
+	private function maybe_notify_customer( $order, $refund, array $payload ) {
+		if ( ! $order || ! $refund ) {
+			return;
+		}
+
+		$notify = apply_filters( 'agentwp_refund_notify_customer', false, $refund, $order, $payload );
+		if ( ! $notify ) {
+			return;
+		}
+
+		if ( function_exists( 'wc_send_order_refund_notification' ) ) {
+			wc_send_order_refund_notification( $order->get_id(), $refund->get_id() );
+			return;
+		}
+
+		if ( method_exists( $order, 'send_customer_refund_notification' ) ) {
+			$order->send_customer_refund_notification( $refund->get_id() );
+			return;
+		}
+
+		if ( function_exists( 'WC' ) ) {
+			$mailer = WC()->mailer();
+			if ( $mailer && isset( $mailer->emails['WC_Email_Customer_Refunded_Order'] ) ) {
+				$mailer->emails['WC_Email_Customer_Refunded_Order']->trigger( $order->get_id(), $refund->get_id() );
+			}
+		}
+	}
+}


thinking
**Reviewing refund handler details and response drafting**
codex
Implemented the refund draft/confirm workflow in a dedicated handler, including transient-backed draft storage, refund amount validation, gateway capability checks, audit logging, and optional notification hooks. The new `src/Handlers/RefundHandler.php` is where the draft is built, stored, and confirmed with `wc_create_refund`, ensuring refunds only execute on explicit confirmation and drafts expire after the configured TTL.

**Status**
- DONE

**Summary of changes**
- Added `src/Handlers/RefundHandler.php` to prepare refund drafts with required fields, calculate remaining refundable amounts, and store drafts in transients with a 10‑minute TTL default.
- Implemented confirmation flow that validates draft/order state, triggers gateway refunds when supported, adds an audit note, and optionally notifies the customer via a filter.
- Included full‑refund restock support (manual restock of all line items) and preserved required draft payload fields.

**How to verify**
- No verification commands provided.

**Risks / follow-ups**
- Restocking is applied only for full refunds (partial refunds skip restock without line‑item selection).
- Customer notification is off by default and relies on the `agentwp_refund_notify_customer` filter to enable sending.
file update:
diff --git a/src/Handlers/RefundHandler.php b/src/Handlers/RefundHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..2da8614d4549508f8579d1510446ab1bbc4a8412
--- /dev/null
+++ b/src/Handlers/RefundHandler.php
@@ -0,0 +1,560 @@
+<?php
+/**
+ * Handle refund draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class RefundHandler {
+	const DRAFT_TYPE = 'refund';
+
+	/**
+	 * Handle refund-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_refund( $args['draft_id'] );
+		}
+
+		return $this->prepare_refund( $args );
+	}
+
+	/**
+	 * Prepare a refund draft without executing it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_refund( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare refunds.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for refund.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund.', 404 );
+		}
+
+		$amount_provided = array_key_exists( 'amount', $args ) && '' !== $args['amount'] && null !== $args['amount'];
+		$amount_input    = $amount_provided ? $this->normalize_amount( $args['amount'] ) : null;
+		$reason          = isset( $args['reason'] ) ? sanitize_text_field( wp_unslash( $args['reason'] ) ) : '';
+		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $amount_provided ) {
+			if ( null === $amount_input || $amount_input <= 0 ) {
+				return Response::error( 'Refund amount must be greater than zero.', 400 );
+			}
+
+			if ( $amount_input > $remaining + $this->amount_epsilon() ) {
+				return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+			}
+
+			$refund_amount = $this->is_full_refund( $amount_input, $remaining ) ? $remaining : $amount_input;
+		} else {
+			$refund_amount = $remaining;
+		}
+
+		$is_full_refund   = $this->is_full_refund( $refund_amount, $remaining );
+		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();
+
+		$payment_method = $this->get_payment_method_label( $order );
+		$gateway        = $this->get_payment_gateway( $order );
+		$requires_manual_refund = $this->requires_manual_refund( $gateway );
+
+		$draft_payload = array(
+			'order_id'               => $order_id,
+			'order_total'            => $order_total,
+			'refund_amount'          => $refund_amount,
+			'reason'                 => $reason,
+			'items_to_restock'       => $items_to_restock,
+			'customer_email'         => $this->get_customer_email( $order ),
+			'payment_method'         => $payment_method,
+			'requires_manual_refund' => $requires_manual_refund,
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store refund draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a refund from a draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_refund( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_create_refund' ) ) {
+			return Response::error( 'WooCommerce is required to process refunds.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing refund draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Refund draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for refund confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Refund draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for refund confirmation.', 404 );
+		}
+
+		$refund_amount = isset( $payload['refund_amount'] ) ? $this->normalize_amount( $payload['refund_amount'] ) : 0;
+		if ( $refund_amount <= 0 ) {
+			return Response::error( 'Refund amount is invalid for confirmation.', 400 );
+		}
+
+		$order_total    = $this->normalize_amount( $order->get_total() );
+		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
+		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
+
+		if ( $remaining <= 0 ) {
+			return Response::error( 'Order has no refundable balance.', 400 );
+		}
+
+		if ( $refund_amount > $remaining + $this->amount_epsilon() ) {
+			return Response::error( 'Refund amount exceeds remaining order total.', 400 );
+		}
+
+		$refund_amount = $this->is_full_refund( $refund_amount, $remaining ) ? $remaining : $refund_amount;
+		$reason        = isset( $payload['reason'] ) ? (string) $payload['reason'] : '';
+		$requires_manual_refund = ! empty( $payload['requires_manual_refund'] );
+		$items_to_restock = isset( $payload['items_to_restock'] ) && is_array( $payload['items_to_restock'] )
+			? $payload['items_to_restock']
+			: array();
+		$should_restock = $this->is_full_refund( $refund_amount, $remaining ) && ! empty( $items_to_restock );
+
+		$refund = wc_create_refund(
+			array(
+				'amount'         => $refund_amount,
+				'reason'         => $reason,
+				'order_id'       => $order_id,
+				'refund_payment' => ! $requires_manual_refund,
+				'restock_items'  => false,
+			)
+		);
+
+		if ( is_wp_error( $refund ) ) {
+			return Response::error( $refund->get_error_message(), 400 );
+		}
+
+		$refund_id = is_object( $refund ) && method_exists( $refund, 'get_id' ) ? $refund->get_id() : 0;
+		$restocked = $should_restock ? $this->restock_items( $order, $items_to_restock ) : array();
+
+		$this->delete_draft( $draft_id );
+		$this->add_audit_note( $order, $draft_id, $refund_amount, $reason, ! empty( $restocked ) );
+		$this->maybe_notify_customer( $order, $refund, $payload );
+
+		return Response::success(
+			array(
+				'confirmed'              => true,
+				'draft_id'               => $draft_id,
+				'order_id'               => $order_id,
+				'refund_id'              => $refund_id,
+				'refund_amount'          => $refund_amount,
+				'restocked_items'        => $restocked,
+				'requires_manual_refund' => $requires_manual_refund,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @return float
+	 */
+	private function amount_epsilon() {
+		$decimals = $this->get_price_decimals();
+		return 1 / pow( 10, $decimals );
+	}
+
+	/**
+	 * @param float $refund_amount Refund amount.
+	 * @param float $remaining Remaining total.
+	 * @return bool
+	 */
+	private function is_full_refund( $refund_amount, $remaining ) {
+		return abs( $remaining - $refund_amount ) <= $this->amount_epsilon();
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return array
+	 */
+	private function build_items_to_restock( $order ) {
+		$items = array();
+
+		if ( ! $order || ! method_exists( $order, 'get_items' ) ) {
+			return $items;
+		}
+
+		foreach ( $order->get_items() as $item_id => $item ) {
+			if ( ! $item || ! method_exists( $item, 'get_quantity' ) ) {
+				continue;
+			}
+
+			$quantity = (int) $item->get_quantity();
+			if ( $quantity <= 0 ) {
+				continue;
+			}
+
+			$items[] = array(
+				'item_id'     => (int) $item_id,
+				'product_id'  => (int) $item->get_product_id(),
+				'variation_id' => (int) $item->get_variation_id(),
+				'name'        => sanitize_text_field( $item->get_name() ),
+				'quantity'    => $quantity,
+			);
+		}
+
+		return $items;
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		if ( ! $order || ! method_exists( $order, 'get_billing_email' ) ) {
+			return '';
+		}
+
+		return sanitize_email( $order->get_billing_email() );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return string
+	 */
+	private function get_payment_method_label( $order ) {
+		if ( ! $order ) {
+			return '';
+		}
+
+		if ( method_exists( $order, 'get_payment_method_title' ) ) {
+			$title = (string) $order->get_payment_method_title();
+			if ( '' !== $title ) {
+				return $title;
+			}
+		}
+
+		return method_exists( $order, 'get_payment_method' ) ? (string) $order->get_payment_method() : '';
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @return mixed|null
+	 */
+	private function get_payment_gateway( $order ) {
+		if ( function_exists( 'wc_get_payment_gateway_by_order' ) ) {
+			return wc_get_payment_gateway_by_order( $order );
+		}
+
+		if ( ! function_exists( 'WC' ) || ! $order || ! method_exists( $order, 'get_payment_method' ) ) {
+			return null;
+		}
+
+		$gateways = WC()->payment_gateways();
+		if ( ! $gateways || ! method_exists( $gateways, 'payment_gateways' ) ) {
+			return null;
+		}
+
+		$method_id = $order->get_payment_method();
+		$all       = $gateways->payment_gateways();
+
+		return ( $method_id && isset( $all[ $method_id ] ) ) ? $all[ $method_id ] : null;
+	}
+
+	/**
+	 * @param mixed $gateway Payment gateway.
+	 * @return bool
+	 */
+	private function requires_manual_refund( $gateway ) {
+		if ( ! $gateway || ! method_exists( $gateway, 'supports' ) ) {
+			return true;
+		}
+
+		return ! $gateway->supports( 'refunds' );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param array $items_to_restock Items to restock.
+	 * @return array
+	 */
+	private function restock_items( $order, array $items_to_restock ) {
+		$restocked = array();
+
+		if ( ! $order || ! function_exists( 'wc_update_product_stock' ) ) {
+			return $restocked;
+		}
+
+		foreach ( $items_to_restock as $item_data ) {
+			$item_id  = isset( $item_data['item_id'] ) ? absint( $item_data['item_id'] ) : 0;
+			$quantity = isset( $item_data['quantity'] ) ? absint( $item_data['quantity'] ) : 0;
+			if ( 0 === $item_id || 0 === $quantity ) {
+				continue;
+			}
+
+			$item = $order->get_item( $item_id );
+			if ( ! $item || ! method_exists( $item, 'get_product' ) ) {
+				continue;
+			}
+
+			$product = $item->get_product();
+			if ( ! $product || ! $product->managing_stock() ) {
+				continue;
+			}
+
+			wc_update_product_stock( $product, $quantity, 'increase' );
+			$restocked[] = array(
+				'product_id' => $product->get_id(),
+				'quantity'   => $quantity,
+			);
+		}
+
+		return $restocked;
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $draft_id Draft ID.
+	 * @param float  $amount Refund amount.
+	 * @param string $reason Refund reason.
+	 * @param bool   $restocked Restock indicator.
+	 * @return void
+	 */
+	private function add_audit_note( $order, $draft_id, $amount, $reason, $restocked ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return;
+		}
+
+		$reason_text = '' !== $reason ? $reason : 'no reason provided';
+		$amount      = $this->normalize_amount( $amount );
+		$note        = sprintf(
+			'[AgentWP] Refund confirmed (draft %s). Amount: %s. Reason: %s. Restocked: %s.',
+			$draft_id,
+			$amount,
+			$reason_text,
+			$restocked ? 'yes' : 'no'
+		);
+
+		$order->add_order_note( $note );
+	}
+
+	/**
+	 * @param mixed $order Order instance.
+	 * @param mixed $refund Refund instance.
+	 * @param array $payload Draft payload.
+	 * @return void
+	 */
+	private function maybe_notify_customer( $order, $refund, array $payload ) {
+		if ( ! $order || ! $refund ) {
+			return;
+		}
+
+		$notify = apply_filters( 'agentwp_refund_notify_customer', false, $refund, $order, $payload );
+		if ( ! $notify ) {
+			return;
+		}
+
+		if ( function_exists( 'wc_send_order_refund_notification' ) ) {
+			wc_send_order_refund_notification( $order->get_id(), $refund->get_id() );
+			return;
+		}
+
+		if ( method_exists( $order, 'send_customer_refund_notification' ) ) {
+			$order->send_customer_refund_notification( $refund->get_id() );
+			return;
+		}
+
+		if ( function_exists( 'WC' ) ) {
+			$mailer = WC()->mailer();
+			if ( $mailer && isset( $mailer->emails['WC_Email_Customer_Refunded_Order'] ) ) {
+				$mailer->emails['WC_Email_Customer_Refunded_Order']->trigger( $order->get_id(), $refund->get_id() );
+			}
+		}
+	}
+}

tokens used
194,859
