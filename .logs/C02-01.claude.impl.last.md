The implementation is complete. Let me provide a summary.

---

**Status: DONE**

## Summary of changes

1. **Created `src/Contracts/AtomicRateLimiterInterface.php`**
   - New interface extending `RateLimiterInterface`
   - Adds `checkAndIncrement(int $userId): bool` method for atomic rate limiting

2. **Modified `src/Infrastructure/RateLimiting/RateLimiter.php`**
   - Changed `implements RateLimiterInterface` to `implements AtomicRateLimiterInterface`
   - Added import for `AtomicRateLimiterInterface`
   - Updated `checkAndIncrement()` docblock to use `{@inheritDoc}`
   - Backwards compatible: still implements `RateLimiterInterface` via inheritance

3. **Modified `src/Providers/RestServiceProvider.php`**
   - Added import for `AtomicRateLimiterInterface`
   - Registered `AtomicRateLimiterInterface` as singleton pointing to same instance as `RateLimiterInterface`
   - Allows consumers to type-hint on either interface based on their needs

## How to verify

```bash
# Syntax check
php -l src/Contracts/AtomicRateLimiterInterface.php
php -l src/Infrastructure/RateLimiting/RateLimiter.php
php -l src/Providers/RestServiceProvider.php

# Run rate limiter tests
vendor/bin/phpunit tests/Unit/Infrastructure/RateLimiting/RateLimiterTest.php

# Run container wiring tests
vendor/bin/phpunit tests/Integration/Container/ContainerWiringTest.php
```

## Risks / follow-ups

- **Low risk:** Existing consumers of `RateLimiterInterface` (like `RestController`) continue to work unchanged since `RateLimiter` still implements `RateLimiterInterface` via the interface inheritance chain
- **Follow-up:** Consider updating `RestController::check_rate_limit_via_service()` to use `AtomicRateLimiterInterface` and `checkAndIncrement()` for proper race-condition-free rate limiting (currently uses separate `check()` + `increment()` calls)
- **Follow-up:** Consider updating `FakeRateLimiter` to implement `AtomicRateLimiterInterface` for tests that need to test the atomic behavior
