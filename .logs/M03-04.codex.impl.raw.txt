Status: DONE
Summary of changes:
- Implemented sales analytics reporting with WooCommerce analytics table queries, period handling, comparison mode, caching, and currency formatting in `src/Handlers/AnalyticsHandler.php`.
- Added top products/categories aggregation and percentage-change calculations, with formatted currency companion fields in `src/Handlers/AnalyticsHandler.php`.

How to verify (exact commands):
- No verification commands provided.

Risks / follow-ups:
- WooCommerce analytics table schemas can vary; if `total_sales`/`product_net_revenue` columns are unavailable, totals fall back to `net_total` and top lists default to revenue=0.
- If you want percentage change to always show two decimals (independent of currency precision), adjust `calculate_percentage_change` in `src/Handlers/AnalyticsHandler.php`.

OpenAI Codex v0.77.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/agentwp
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019b96f4-9f2e-7302-8254-a5576eb6b1df
--------
user
You are implementing task M03-04 in this git repository.

1) Read the spec: .plans/M03-04.md
2) Read handoff/context: .t2/handoff/M03-04.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: 
- test: 

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers

thinking
**Preparing to read specification files**
exec
/bin/zsh -lc ls in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 60ms:
agentwp.php
assets
composer.json
docker
docker-compose.yml
docs
includes
languages
react
README.md
scripts
setup.sh
src
tasks.csv
uninstall.php

thinking
**Reading files using cat**
exec
/bin/zsh -lc 'cat .plans/M03-04.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 66ms:
# M03-04 — Sales Analytics Queries

Implement sales analytics functionality: 1) Create AgentWP\Handlers\AnalyticsHandler class. 2) OpenAI function schema: get_sales_report(period: 'today'|'yesterday'|'this_week'|'last_week'|'this_month'|'last_month'|'custom', start_date?: string, end_date?: string, compare_previous?: bool). 3) Metrics to return: total_revenue, order_count, average_order_value, items_sold, refund_total, net_revenue, top_products (top 5), top_categories. 4) Use WooCommerce Analytics tables (wp_wc_order_stats) for performance. 5) Comparison mode: return current_period and previous_period with percentage_change. 6) Cache results in transients: 1 hour for historical data, 5 minutes for 'today'. 7) Format currency according to WooCommerce settings. Acceptance Criteria: 'Sales this month' returns accurate totals matching WooCommerce Analytics, comparison calculations correct, queries execute in <1 second for stores with 100k orders, proper currency formatting.
exec
/bin/zsh -lc 'cat .t2/handoff/M03-04.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 67ms:
# Handoff: M03-04

Created: 2026-01-07T05:36:12.538191Z

Spec: .plans/M03-04.md

thinking
**Searching repository for implementation**
exec
/bin/zsh -lc 'rg -n "AnalyticsHandler|analytics|sales report|get_sales_report" -S includes src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 79ms:
src/Intent/IntentClassifier.php:34:			Intent::ANALYTICS_QUERY => $this->score_analytics( $text ),
src/Intent/IntentClassifier.php:134:	private function score_analytics( $text ) {
src/Intent/IntentClassifier.php:138:				'analytics',
src/Intent/Engine.php:181:			Intent::ANALYTICS_QUERY => array( 'get_sales_report' ),
src/Intent/Intent.php:82:				'label'   => 'Run an analytics report',
src/AI/Functions/GetSalesReport.php:3: * Function schema for sales reports.
src/AI/Functions/GetSalesReport.php:12:		return 'get_sales_report';
src/AI/Functions/GetSalesReport.php:16:		return 'Fetch a sales report for a specified period.';
src/Intent/Handlers/AnalyticsQueryHandler.php:3: * Handle analytics query intents.
src/Intent/Handlers/AnalyticsQueryHandler.php:23:		$message = 'I can pull analytics. Specify a timeframe or metric you need.';

thinking
**Inspecting existing sales report code**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/GetSalesReport.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 64ms:
<?php
/**
 * Function schema for sales reports.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class GetSalesReport extends AbstractFunction {
	public function get_name() {
		return 'get_sales_report';
	}

	public function get_description() {
		return 'Fetch a sales report for a specified period.';
	}

	public function get_parameters() {
		return array(

thinking
**Reviewing existing handlers**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/AnalyticsQueryHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * Handle analytics query intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Intent;

class AnalyticsQueryHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ANALYTICS_QUERY );
	}

	/**
	 * @param array $context Context data.
	 * @return Response

thinking
**Searching for existing Handler classes**
exec
/bin/zsh -lc 'ls src/Handlers' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
EmailDraftHandler.php
OrderSearchHandler.php
OrderStatusHandler.php
RefundHandler.php
StockHandler.php

thinking
**Verifying handler patterns**
exec
/bin/zsh -lc "sed -n '1,240p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Handle order search requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;
use DateTimeImmutable;
use DateTimeZone;
use Exception;

class OrderSearchHandler {
	const DEFAULT_LIMIT = 10;
	const CACHE_TTL     = 3600;

	/**
exec
/bin/zsh -lc "sed -n '240,480p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 39ms:
				array(
					'key'     => '_billing_email',
					'value'   => $normalized['email'],
					'compare' => '=',
				),
				array(
					'key'     => '_shipping_email',
					'value'   => $normalized['email'],
					'compare' => '=',
				),
			);
		}

		$orders = wc_get_orders( $query_args );
		if ( ! is_array( $orders ) ) {
			return array();
		}

		$results = array();
		foreach ( $orders as $order ) {
exec
/bin/zsh -lc "sed -n '480,960p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
	}

	/**
	 * @param string $query Query string.
	 * @return array|null
	 */
	private function parse_date_range_from_query( $query ) {
		if ( false !== strpos( $query, 'yesterday' ) ) {
			return $this->relative_date_range( 'yesterday' );
		}

		if ( false !== strpos( $query, 'last week' ) ) {
			return $this->relative_date_range( 'last week' );
		}

		if ( false !== strpos( $query, 'this month' ) ) {
			return $this->relative_date_range( 'this month' );
		}

		$range = $this->extract_explicit_date_range( $query );

thinking
**Searching for Handler usages**
exec
/bin/zsh -lc 'rg -n "AnalyticsHandler|OrderSearchHandler|RefundHandler|StockHandler" -S src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
src/Handlers/RefundHandler.php:13:class RefundHandler {
src/Handlers/StockHandler.php:13:class StockHandler {
src/Handlers/OrderSearchHandler.php:16:class OrderSearchHandler {
src/Intent/Handlers/OrderRefundHandler.php:13:class OrderRefundHandler extends BaseHandler {
src/Intent/Handlers/ProductStockHandler.php:11:use AgentWP\Handlers\StockHandler;
src/Intent/Handlers/ProductStockHandler.php:14:class ProductStockHandler extends BaseHandler {
src/Intent/Handlers/ProductStockHandler.php:32:		$search = new StockHandler();
src/Intent/Handlers/OrderSearchHandler.php:11:use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
src/Intent/Handlers/OrderSearchHandler.php:14:class OrderSearchHandler extends BaseHandler {
src/Intent/Engine.php:15:use AgentWP\Intent\Handlers\OrderRefundHandler;
src/Intent/Engine.php:16:use AgentWP\Intent\Handlers\OrderSearchHandler;
src/Intent/Engine.php:18:use AgentWP\Intent\Handlers\ProductStockHandler;
src/Intent/Engine.php:130:			new OrderSearchHandler(),
src/Intent/Engine.php:131:			new OrderRefundHandler(),
src/Intent/Engine.php:133:			new ProductStockHandler(),

thinking
**Reviewing intent handlers usage**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Handle order search intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
use AgentWP\Intent\Intent;

class OrderSearchHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_SEARCH );
	}

	/**
	 * @param array $context Context data.

thinking
**Locating AnalyticsHandler and usage**
exec
/bin/zsh -lc "sed -n '1,220p' src/Intent/Engine.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Intent engine for routing requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

use AgentWP\AI\Response;
use AgentWP\Intent\Handlers\AnalyticsQueryHandler;
use AgentWP\Intent\Handlers\CustomerLookupHandler;
use AgentWP\Intent\Handlers\EmailDraftHandler;
use AgentWP\Intent\Handlers\FallbackHandler;
use AgentWP\Intent\Handlers\OrderRefundHandler;
use AgentWP\Intent\Handlers\OrderSearchHandler;
use AgentWP\Intent\Handlers\OrderStatusHandler;
use AgentWP\Intent\Handlers\ProductStockHandler;

class Engine {

thinking
**Investigating function handling for sales report**
exec
/bin/zsh -lc "sed -n '1,240p' src/Intent/FunctionRegistry.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
<?php
/**
 * OpenAI function registry for intent handlers.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

class FunctionRegistry {
	/**
	 * @var array<string, Handler>
	 */
	private $map = array();

	/**
	 * @param string  $function_name OpenAI function name.
	 * @param Handler $handler Handler instance.
	 * @return void
	 */

thinking
**Identifying AI function usage**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/OrderRefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Handle order refund intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Intent;

class OrderRefundHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_REFUND );
	}

	/**
	 * @param array $context Context data.
	 * @return Response

thinking
**Noticing missing service call in Handler**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/ProductStockHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
<?php
/**
 * Handle product stock intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Handlers\StockHandler;
use AgentWP\Intent\Intent;

class ProductStockHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::PRODUCT_STOCK );
	}

	/**
	 * @param array $context Context data.

thinking
**Reviewing AnalyticsHandler integration**
exec
/bin/zsh -lc "sed -n '1,220p' src/Intent/Handlers/BaseHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
<?php
/**
 * Base handler for intent responses.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Handler;
use AgentWP\Intent\Intent;

abstract class BaseHandler implements Handler {
	/**
	 * @var string
	 */
	protected $intent;

	/**

thinking
**Checking other Handler classes**
exec
/bin/zsh -lc "sed -n '1,240p' src/Handlers/RefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Handle refund draft preparation and confirmation.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;

class RefundHandler {
	const DRAFT_TYPE = 'refund';

	/**
	 * Handle refund-related requests.
	 *
	 * @param array $args Request args.
	 * @return Response

thinking
**Identifying handler roles and integration points**
exec
/bin/zsh -lc "rg -n \"get_handler\\(|FunctionRegistry|function_call|openai\" -S src includes" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
src/Rest/SettingsController.php:144:		$validation = $this->validate_openai_api_key( $api_key );
src/Rest/SettingsController.php:271:	private function validate_openai_api_key( $api_key ) {
src/Rest/SettingsController.php:273:			'https://api.openai.com/v1/models',
src/Rest/SettingsController.php:284:			return new WP_Error( 'agentwp_openai_unreachable', __( 'OpenAI API is unreachable.', 'agentwp' ) );
src/Rest/SettingsController.php:289:			return new WP_Error( 'agentwp_openai_invalid', __( 'OpenAI rejected the API key.', 'agentwp' ) );
src/Intent/FunctionRegistry.php:10:class FunctionRegistry {
src/Intent/FunctionRegistry.php:34:	public function get_handler( $function_name ) {
src/AI/OpenAIClient.php:13:	const API_BASE = 'https://api.openai.com/v1';
src/AI/OpenAIClient.php:159:			'usage_source'  => $usage_fallback ? 'tiktoken' : 'openai',
src/AI/OpenAIClient.php:402:		if ( empty( $tool_calls ) && isset( $message['function_call'] ) && is_array( $message['function_call'] ) ) {
src/AI/OpenAIClient.php:407:					'function' => $message['function_call'],
src/AI/OpenAIClient.php:480:			if ( isset( $delta['function_call'] ) && is_array( $delta['function_call'] ) ) {
src/AI/OpenAIClient.php:487:							'function' => $delta['function_call'],
src/Intent/Engine.php:37:	 * @var FunctionRegistry
src/Intent/Engine.php:53:	 * @param FunctionRegistry|null $function_registry Optional registry.
src/Intent/Engine.php:60:		FunctionRegistry $function_registry = null,
src/Intent/Engine.php:68:		$this->function_registry = $function_registry ? $function_registry : new FunctionRegistry();
src/Intent/Engine.php:112:	 * @return FunctionRegistry

thinking
**Searching for function call integration**
exec
/bin/zsh -lc 'rg -n "tool_calls|function_call|get_handler|function_registry" -S src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:389:				'tool_calls' => array(),
src/AI/OpenAIClient.php:400:		$tool_calls = isset( $message['tool_calls'] ) && is_array( $message['tool_calls'] ) ? $message['tool_calls'] : array();
src/AI/OpenAIClient.php:402:		if ( empty( $tool_calls ) && isset( $message['function_call'] ) && is_array( $message['function_call'] ) ) {
src/AI/OpenAIClient.php:403:			$tool_calls = array(
src/AI/OpenAIClient.php:407:					'function' => $message['function_call'],
src/AI/OpenAIClient.php:416:			'tool_calls' => $tool_calls,
src/AI/OpenAIClient.php:430:		$tool_calls = array();
src/AI/OpenAIClient.php:476:			if ( isset( $delta['tool_calls'] ) && is_array( $delta['tool_calls'] ) ) {
src/AI/OpenAIClient.php:477:				$tool_calls = $this->merge_tool_call_deltas( $tool_calls, $delta['tool_calls'] );
src/AI/OpenAIClient.php:480:			if ( isset( $delta['function_call'] ) && is_array( $delta['function_call'] ) ) {
src/AI/OpenAIClient.php:481:				$tool_calls = $this->merge_tool_call_deltas(
src/AI/OpenAIClient.php:482:					$tool_calls,
src/AI/OpenAIClient.php:487:							'function' => $delta['function_call'],
src/AI/OpenAIClient.php:498:			'tool_calls' => array_values( $tool_calls ),
src/AI/OpenAIClient.php:506:	 * @param array $tool_calls Existing tool calls.
src/AI/OpenAIClient.php:510:	private function merge_tool_call_deltas( array $tool_calls, array $deltas ) {
src/AI/OpenAIClient.php:514:			if ( ! isset( $tool_calls[ $index ] ) ) {
src/AI/OpenAIClient.php:515:				$tool_calls[ $index ] = array(
src/AI/OpenAIClient.php:526:				$tool_calls[ $index ]['id'] = $delta['id'];

thinking
**Searching for tool_calls usage in REST**
exec
/bin/zsh -lc 'rg -n "tool_calls|function_call|get_sales_report|function" -S src/Rest src/AI src/Intent' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
src/Intent/IntentClassifier.php:16:	public function classify( $input, array $context = array() ) {
src/Intent/IntentClassifier.php:56:	private function score_refund( $text ) {
src/Intent/IntentClassifier.php:73:	private function score_status( $text ) {
src/Intent/IntentClassifier.php:93:	private function score_stock( $text ) {
src/Intent/IntentClassifier.php:111:	private function score_email( $text ) {
src/Intent/IntentClassifier.php:134:	private function score_analytics( $text ) {
src/Intent/IntentClassifier.php:154:	private function score_customer( $text ) {
src/Intent/IntentClassifier.php:171:	private function score_search( $text ) {
src/Intent/IntentClassifier.php:191:	private function match_score( $text, array $phrases ) {
src/Intent/IntentClassifier.php:207:	private function contains_phrase( $text, $phrase ) {
src/Rest/HealthController.php:19:	public function register_routes() {
src/Rest/HealthController.php:37:	public function get_health( $request ) {
src/Rest/SettingsController.php:23:	public function register_routes() {
src/Rest/SettingsController.php:68:	public function get_settings( $request ) {
src/Rest/SettingsController.php:91:	public function update_settings( $request ) {
src/Rest/SettingsController.php:118:	public function update_api_key( $request ) {
src/Rest/SettingsController.php:173:	public function get_usage( $request ) {
src/Rest/SettingsController.php:207:	private function read_settings() {
src/Rest/SettingsController.php:221:	private function apply_settings_updates( array $settings, array $payload ) {
src/Rest/SettingsController.php:271:	private function validate_openai_api_key( $api_key ) {

thinking
**Checking OpenAI tool invocation**
exec
/bin/zsh -lc "sed -n '1,200p' src/Rest/IntentController.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 46ms:
<?php
/**
 * Intent REST controller.
 *
 * @package AgentWP
 */

namespace AgentWP\Rest;

use AgentWP\API\RestController;
use AgentWP\Intent\Engine;
use WP_REST_Server;

class IntentController extends RestController {
	/**
	 * Register REST routes.
	 *
	 * @return void
	 */
	public function register_routes() {
Reconnecting... 1/5

thinking
**Searching for function execution in REST controllers**
exec
/bin/zsh -lc 'rg -n "function|tool" -S src/Rest' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 59ms:
src/Rest/HealthController.php:19:	public function register_routes() {
src/Rest/HealthController.php:37:	public function get_health( $request ) {
src/Rest/SettingsController.php:23:	public function register_routes() {
src/Rest/SettingsController.php:68:	public function get_settings( $request ) {
src/Rest/SettingsController.php:91:	public function update_settings( $request ) {
src/Rest/SettingsController.php:118:	public function update_api_key( $request ) {
src/Rest/SettingsController.php:173:	public function get_usage( $request ) {
src/Rest/SettingsController.php:207:	private function read_settings() {
src/Rest/SettingsController.php:221:	private function apply_settings_updates( array $settings, array $payload ) {
src/Rest/SettingsController.php:271:	private function validate_openai_api_key( $api_key ) {
src/Rest/SettingsController.php:301:	private function encrypt_api_key( $api_key ) {
src/Rest/SettingsController.php:317:	private function maybe_rotate_api_key() {
src/Rest/SettingsController.php:338:	private function get_settings_update_schema() {
src/Rest/SettingsController.php:374:	private function get_api_key_schema() {
src/Rest/SettingsController.php:391:	private function get_usage_schema() {
src/Rest/IntentController.php:20:	public function register_routes() {
src/Rest/IntentController.php:38:	public function create_intent( $request ) {
src/Rest/IntentController.php:84:	private function get_intent_schema() {

thinking
**Searching for function handlers in AI modules**
exec
/bin/zsh -lc 'rg -n "tool call|tool_calls|function" -S src | head -n 200' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
src/Rest/HealthController.php:19:	public function register_routes() {
src/Rest/HealthController.php:37:	public function get_health( $request ) {
src/Rest/SettingsController.php:23:	public function register_routes() {
src/Rest/SettingsController.php:68:	public function get_settings( $request ) {
src/Rest/SettingsController.php:91:	public function update_settings( $request ) {
src/Rest/SettingsController.php:118:	public function update_api_key( $request ) {
src/Rest/SettingsController.php:173:	public function get_usage( $request ) {
src/Rest/SettingsController.php:207:	private function read_settings() {
src/Rest/SettingsController.php:221:	private function apply_settings_updates( array $settings, array $payload ) {
src/Rest/SettingsController.php:271:	private function validate_openai_api_key( $api_key ) {
src/Rest/SettingsController.php:301:	private function encrypt_api_key( $api_key ) {
src/Rest/SettingsController.php:317:	private function maybe_rotate_api_key() {
src/Rest/SettingsController.php:338:	private function get_settings_update_schema() {
src/Rest/SettingsController.php:374:	private function get_api_key_schema() {
src/Rest/SettingsController.php:391:	private function get_usage_schema() {
src/Rest/IntentController.php:20:	public function register_routes() {
src/Rest/IntentController.php:38:	public function create_intent( $request ) {
src/Rest/IntentController.php:84:	private function get_intent_schema() {
src/Handlers/RefundHandler.php:22:	public function handle( array $args ): Response {
src/Handlers/RefundHandler.php:36:	public function prepare_refund( array $args ): Response {

thinking
**Searching for function handlers**
exec
/bin/zsh -lc 'rg -n "function_name|tool_calls|function" -S src | head -n 200' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
src/Rest/HealthController.php:19:	public function register_routes() {
src/Rest/HealthController.php:37:	public function get_health( $request ) {
src/Rest/SettingsController.php:23:	public function register_routes() {
src/Rest/SettingsController.php:68:	public function get_settings( $request ) {
src/Rest/SettingsController.php:91:	public function update_settings( $request ) {
src/Rest/SettingsController.php:118:	public function update_api_key( $request ) {
src/Rest/SettingsController.php:173:	public function get_usage( $request ) {
src/Rest/SettingsController.php:207:	private function read_settings() {
src/Rest/SettingsController.php:221:	private function apply_settings_updates( array $settings, array $payload ) {
src/Rest/SettingsController.php:271:	private function validate_openai_api_key( $api_key ) {
src/Rest/SettingsController.php:301:	private function encrypt_api_key( $api_key ) {
src/Rest/SettingsController.php:317:	private function maybe_rotate_api_key() {
src/Rest/SettingsController.php:338:	private function get_settings_update_schema() {
src/Rest/SettingsController.php:374:	private function get_api_key_schema() {
src/Rest/SettingsController.php:391:	private function get_usage_schema() {
src/Rest/IntentController.php:20:	public function register_routes() {
src/Rest/IntentController.php:38:	public function create_intent( $request ) {
src/Rest/IntentController.php:84:	private function get_intent_schema() {
src/Handlers/RefundHandler.php:22:	public function handle( array $args ): Response {
src/Handlers/RefundHandler.php:36:	public function prepare_refund( array $args ): Response {

thinking
**Investigating Analytics Handler context**
exec
/bin/zsh -lc 'rg -n "get_sales_report|AnalyticsHandler" -S includes src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 71ms:
src/AI/Functions/GetSalesReport.php:12:		return 'get_sales_report';
src/Intent/Engine.php:181:			Intent::ANALYTICS_QUERY => array( 'get_sales_report' ),

thinking
**Investigating analytics handler integration**
exec
/bin/zsh -lc 'rg -n "get_sales_report|tool_calls|function" -S react src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 74ms:
src/Plugin.php:34:	public static function init() {
src/Plugin.php:47:	public static function activate() {
src/Plugin.php:64:	public static function deactivate() {
src/Plugin.php:71:	private function __construct() {
src/Plugin.php:84:	public function load_textdomain() {
src/Plugin.php:97:	public function register_menu() {
src/Plugin.php:113:	public function render_admin_page() {
src/Plugin.php:131:	public function enqueue_admin_assets( $hook_suffix ) {
src/Plugin.php:132:		$screen = function_exists( 'get_current_screen' ) ? get_current_screen() : null;
src/Plugin.php:182:	public function register_rest_routes() {
src/Plugin.php:207:	public function format_rest_response( $result, $server, $request ) {
src/Plugin.php:298:	private function is_agentwp_route( $request ) {
src/Plugin.php:310:	public static function get_default_settings() {
src/Plugin.php:325:	public static function get_default_usage_stats() {
src/Plugin.php:339:	private function is_woocommerce_screen( $screen ) {
src/Plugin.php:340:		if ( function_exists( 'wc_get_screen_ids' ) ) {
src/Plugin.php:353:	private static function delete_transients() {
react/src/App.jsx:69:  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
react/src/App.jsx:142:    if (activeElement && typeof activeElement.focus === 'function') {
react/src/App.jsx:147:  if (html && selection && typeof document.createRange === 'function') {

thinking
**Investigating plugin entry points**
exec
/bin/zsh -lc "sed -n '1,220p' src/Plugin.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 68ms:
<?php
/**
 * Core plugin bootstrap.
 *
 * @package AgentWP
 */

namespace AgentWP;

class Plugin {
	const OPTION_SETTINGS     = 'agentwp_settings';
	const OPTION_API_KEY      = 'agentwp_api_key';
	const OPTION_API_KEY_LAST4 = 'agentwp_api_key_last4';
	const OPTION_BUDGET_LIMIT = 'agentwp_budget_limit';
	const OPTION_DRAFT_TTL    = 'agentwp_draft_ttl_minutes';
	const OPTION_USAGE_STATS  = 'agentwp_usage_stats';
	const TRANSIENT_PREFIX    = 'agentwp_';

	/**
	 * @var Plugin|null

thinking
**Investigating function call integration**
exec
/bin/zsh -lc 'rg -n "prepare_stock_update|confirm_stock_update|prepare_status_update|prepare_refund|confirm_refund|search_orders" -S src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 72ms:
src/Handlers/RefundHandler.php:24:			return $this->confirm_refund( $args['draft_id'] );
src/Handlers/RefundHandler.php:27:		return $this->prepare_refund( $args );
src/Handlers/RefundHandler.php:36:	public function prepare_refund( array $args ): Response {
src/Handlers/RefundHandler.php:129:	public function confirm_refund( $draft_id ): Response {
src/Handlers/OrderStatusHandler.php:32:		return $this->prepare_status_update( $args );
src/Handlers/OrderStatusHandler.php:41:	public function prepare_status_update( array $args ): Response {
src/Handlers/StockHandler.php:29:			return $this->confirm_stock_update( $args['draft_id'] );
src/Handlers/StockHandler.php:32:		return $this->prepare_stock_update( $args );
src/Handlers/StockHandler.php:73:	public function prepare_stock_update( array $args ): Response {
src/Handlers/StockHandler.php:167:	public function confirm_stock_update( $draft_id ): Response {
src/AI/Functions/SearchOrders.php:12:		return 'search_orders';
src/AI/Functions/ConfirmRefund.php:12:		return 'confirm_refund';
src/AI/Functions/PrepareStockUpdate.php:12:		return 'prepare_stock_update';
src/AI/Functions/PrepareRefund.php:12:		return 'prepare_refund';
src/AI/Functions/PrepareStatusUpdate.php:12:		return 'prepare_status_update';
src/Intent/Engine.php:176:			Intent::ORDER_SEARCH    => array( 'search_orders', 'select_orders' ),
src/Intent/Engine.php:177:			Intent::ORDER_REFUND    => array( 'prepare_refund', 'confirm_refund' ),
src/Intent/Engine.php:178:			Intent::ORDER_STATUS    => array( 'prepare_status_update', 'prepare_bulk_status_update', 'bulk_update' ),
src/Intent/Engine.php:179:			Intent::PRODUCT_STOCK   => array( 'prepare_stock_update', 'search_product' ),

thinking
**Investigating handler integration points**
exec
/bin/zsh -lc "rg -n \"Handlers\\\\|AgentWP\\\\Handlers\" -S src includes" in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 68ms:
rg: regex parse error:
    (?:Handlers\|AgentWP\Handlers)
                        ^^
error: unrecognized escape sequence

thinking
**Preparing to escape search query**
exec
/bin/zsh -lc "rg -n -F \"AgentWP\\\\Handlers\" src includes" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 71ms:
src/Handlers/RefundHandler.php:8:namespace AgentWP\Handlers;
src/Handlers/StockHandler.php:8:namespace AgentWP\Handlers;
src/Handlers/OrderSearchHandler.php:8:namespace AgentWP\Handlers;
src/Handlers/EmailDraftHandler.php:8:namespace AgentWP\Handlers;
src/Handlers/OrderStatusHandler.php:8:namespace AgentWP\Handlers;
src/Intent/Handlers/ProductStockHandler.php:11:use AgentWP\Handlers\StockHandler;
src/Intent/Handlers/OrderSearchHandler.php:11:use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;

thinking
**Investigating function call usage in frontend**
exec
/bin/zsh -lc 'rg -n "search_orders|get_sales_report|prepare_refund|prepare_stock_update|get_customer_profile" -S react' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 72ms:


thinking
**Evaluating handler implementation approach**
exec
/bin/zsh -lc "sed -n '1,220p' src/Handlers/StockHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 68ms:
<?php
/**
 * Handle product stock searches and updates.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;

class StockHandler {
	const DRAFT_TYPE    = 'stock_update';
	const DEFAULT_LIMIT = 10;

	/**
	 * Handle stock-related requests.
	 *
	 * @param array $args Request args.

thinking
**Reviewing handler styles and currency formatting**
exec
/bin/zsh -lc 'rg -n "wc_order_stats|order_stats|wc_order_product_lookup|wc_order_coupon_lookup|wc_order_stats" -S src' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 79ms:


thinking
**Planning WooCommerce Analytics Queries**
exec
/bin/zsh -lc 'rg -n "net_total|total_sales|num_items_sold" -S .' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
./docs/ARCHITECTURE.md:87:    decimal net_total

thinking
**Opening documentation architecture table**
exec
/bin/zsh -lc "sed -n '70,120p' docs/ARCHITECTURE.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:

  wp_usermeta {
    bigint umeta_id PK
    bigint user_id FK
    string meta_key
    longtext meta_value
  }

  wp_options {
    bigint option_id PK
    string option_name
    longtext option_value
  }

  wp_wc_order_stats {
    bigint order_id PK
    string status
    decimal net_total
    datetime date_created
  }

thinking
**Reviewing architecture and docs**
exec
/bin/zsh -lc 'rg -n "analytics|sales report|order stats" -S docs src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
docs/agentwp-prd.md:15:| Analytics | Metorik | $20–300/mo | Cloud-only, no AI insights |
docs/agentwp-prd.md:21:Tidio users specifically complain about **dramatic price increases** (from $150/year to $500/year) and conversation caps causing problems during peak sales periods. Zendesk's per-agent pricing with hidden AI add-ons ($50/mo for AI Copilot) punishes growth. Metorik, while beloved for its speed and analytics depth, provides **reporting without action**—it tells merchants what's happening but doesn't help them respond.
docs/agentwp-prd.md:110:5. **Analytics limitations** (default WooCommerce reporting described as "very slow and very limited")
docs/agentwp-prd.md:143:All three proposed core features—automated refunds, AI email drafting, and store analytics—have strong market validation.
docs/agentwp-prd.md:149:**AI-powered analytics:** MonsterInsights ($99.50/year), Google Analytics 4 Intelligence, and CleverTap validate market demand. Key capabilities: sales trend prediction, churn risk identification, marketing spend optimization, and product performance forecasting. Amazon attributes **35% of revenue to AI recommendations**; similar patterns apply at smaller scale.
docs/agentwp-prd.md:192:**Launch features:** Prioritize automated refund processing, AI email drafting, and conversational analytics dashboard. These three address the highest-severity pain points with validated market demand.
src/AI/Functions/GetSalesReport.php:3: * Function schema for sales reports.
src/AI/Functions/GetSalesReport.php:16:		return 'Fetch a sales report for a specified period.';
src/Intent/IntentClassifier.php:34:			Intent::ANALYTICS_QUERY => $this->score_analytics( $text ),
src/Intent/IntentClassifier.php:134:	private function score_analytics( $text ) {
src/Intent/IntentClassifier.php:138:				'analytics',
src/Intent/Engine.php:11:use AgentWP\Intent\Handlers\AnalyticsQueryHandler;
src/Intent/Engine.php:135:			new AnalyticsQueryHandler(),
src/Intent/Engine.php:181:			Intent::ANALYTICS_QUERY => array( 'get_sales_report' ),
src/Intent/Handlers/AnalyticsQueryHandler.php:3: * Handle analytics query intents.
src/Intent/Handlers/AnalyticsQueryHandler.php:13:class AnalyticsQueryHandler extends BaseHandler {
src/Intent/Handlers/AnalyticsQueryHandler.php:15:		parent::__construct( Intent::ANALYTICS_QUERY );
src/Intent/Handlers/AnalyticsQueryHandler.php:23:		$message = 'I can pull analytics. Specify a timeframe or metric you need.';
src/Intent/Intent.php:16:	const ANALYTICS_QUERY = 'ANALYTICS_QUERY';
src/Intent/Intent.php:30:			self::ANALYTICS_QUERY,

thinking
**Planning analytics handler implementation**
exec
/bin/zsh -lc 'cat composer.json' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
{
  "name": "agentwp/agentwp",
  "description": "AgentWP WordPress plugin.",
  "type": "wordpress-plugin",
  "license": "GPL-2.0-or-later",
  "autoload": {
    "psr-4": {
      "AgentWP\\": "src/"
    }
  },
  "require": {
    "php": ">=7.4",
    "yethee/tiktoken": "^0.1.2"
  }
}


thinking
**Designing analytics handler and queries**
thinking
**Detailing cache keys and date handling**

I'm planning cache keys with argument hashes and transient prefixes for efficient caching. I'll carefully compute period date ranges using WordPress timezone settings and validate custom ranges, plus handle previous periods for comparisons by subtracting the same duration. Also, I'll prepare optimized queries for top products and categories, joining taxonomy tables while considering product variations and status filters. Items sold and refunds require careful aggregation from analytics tables, balancing accuracy and performance, while ensuring fallback strategies if some columns are missing.
exec
/bin/zsh -lc 'rg -n "wc_order_stats|order_stats" -S docs' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 46ms:
docs/ARCHITECTURE.md:84:  wp_wc_order_stats {
docs/ARCHITECTURE.md:114:  wp_posts ||--o{ wp_wc_order_stats : order_stats

thinking
**Planning AnalyticsHandler implementation**

I'm sorting out how to calculate revenues, refunds, and averages using WooCommerce stats, while thinking about caching and currency formatting. I'm also trying to clarify how the new AnalyticsHandler fits with existing intent handlers and function call flows, aiming to implement it with minimal changes yet good integration. Let's see how to connect everything cleanly without assumptions beyond the spec.
exec
/bin/zsh -lc 'rg -n "format_currency" -n src/Handlers/EmailDraftHandler.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
552:			'{{order_total}}'      => $this->format_currency( isset( $order['totals']['total'] ) ? $order['totals']['total'] : '' ),
1066:	private function format_currency( $value ) {
exec
/bin/zsh -lc "sed -n '1058,1088p' src/Handlers/EmailDraftHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 38ms:

		return '';
	}

	/**
	 * @param mixed $value Input.
	 * @return string
	 */
	private function format_currency( $value ) {
		if ( '' === $value || null === $value ) {
			return '';
		}

		if ( function_exists( 'wc_price' ) ) {
			return wp_strip_all_tags( wc_price( $value ) );
		}

		return (string) $value;
	}


thinking
**Planning currency formatting and analytics handler**
exec
/bin/zsh -lc "sed -n '1,120p' src/Intent/Handlers/CustomerLookupHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * Handle customer lookup intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Intent;

class CustomerLookupHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::CUSTOMER_LOOKUP );
	}

	/**
	 * @param array $context Context data.
	 * @return Response



thinking
**Designing AnalyticsHandler class**
thinking
**Detailing output structure and queries**

I’m figuring out how to organize the response structure for current and previous periods with percentage changes, including formatting numeric metrics and top lists. I’m also outlining the needed SQL queries, cache keys, and validation to ensure all data—like totals, top products, and categories—are fetched accurately and efficiently with proper caching and error handling.
thinking
**Designing database helpers and class structure**

I’m planning helper methods for checking table existence and columns with caching, plus outlining the full AnalyticsHandler class including argument validation, data queries with proper filters, and response formatting. This prepares for a robust implementation to handle missing tables gracefully and meet spec requirements.
file update
A /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/AnalyticsHandler.php
<?php
/**
 * Handle sales analytics reports.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;
use DateTimeImmutable;
use DateTimeZone;
use Exception;

class AnalyticsHandler {
	const CACHE_TTL_TODAY   = 300;
	const CACHE_TTL_DEFAULT = 3600;
	const TOP_LIMIT         = 5;

	/**
	 * Handle analytics requests.
	 *
	 * @param array $args Request args.
	 * @return Response
	 */
	public function handle( array $args ): Response {
		if ( ! function_exists( 'wc_get_orders' ) ) {
			return Response::error( 'WooCommerce is required to fetch analytics.', 400 );
		}

		global $wpdb;
		if ( ! $wpdb ) {
			return Response::error( 'Database is unavailable for analytics.', 500 );
		}

		$period = isset( $args['period'] ) ? sanitize_text_field( $args['period'] ) : '';
		$period = strtolower( trim( $period ) );

		$valid_periods = array( 'today', 'yesterday', 'this_week', 'last_week', 'this_month', 'last_month', 'custom' );
		if ( ! in_array( $period, $valid_periods, true ) ) {
			return Response::error( 'Invalid period for sales report.', 400 );
		}

		$start_input = isset( $args['start_date'] ) ? sanitize_text_field( $args['start_date'] ) : '';
		$end_input   = isset( $args['end_date'] ) ? sanitize_text_field( $args['end_date'] ) : '';
		$compare     = $this->normalize_bool( isset( $args['compare_previous'] ) ? $args['compare_previous'] : false );

		$range = $this->resolve_period_range( $period, $start_input, $end_input );
		if ( null === $range ) {
			return Response::error( 'Invalid date range for sales report.', 400 );
		}

		$order_stats_table = $wpdb->prefix . 'wc_order_stats';
		if ( ! $this->table_exists( $order_stats_table ) ) {
			return Response::error( 'WooCommerce analytics tables are unavailable.', 500 );
		}

		$cache_key = $this->build_cache_key(
			array(
				'period'           => $period,
				'start'            => $range['start_mysql'],
				'end'              => $range['end_mysql'],
				'compare_previous' => $compare,
			)
		);
		$cached    = $this->read_cache( $cache_key );
		if ( null !== $cached ) {
			$cached['cached'] = true;
			return Response::success( $cached );
		}

		$statuses = $this->get_paid_statuses();
		$current  = $this->build_report( $period, $range, $statuses );

		if ( $compare ) {
			$previous_range = $this->build_previous_range( $range );
			$previous       = $this->build_report( $period, $previous_range, $statuses );
			$payload        = array(
				'period'            => $period,
				'compare_previous'  => true,
				'current_period'    => $current,
				'previous_period'   => $previous,
				'percentage_change' => $this->build_percentage_change( $current, $previous ),
			);
		} else {
			$payload = $current;
		}

		$payload['cached'] = false;

		$this->write_cache( $cache_key, $payload, $this->get_cache_ttl( $range, $period ) );

		return Response::success( $payload );
	}

	/**
	 * @param string $period Period key.
	 * @param array  $range Date range data.
	 * @param array  $statuses Status list.
	 * @return array
	 */
	private function build_report( $period, array $range, array $statuses ) {
		$totals = $this->query_totals( $range, $statuses );

		$total_revenue = $this->normalize_amount( $totals['total_revenue'] );
		$net_revenue   = $this->normalize_amount( $totals['net_revenue'] );
		$order_count   = absint( $totals['order_count'] );
		$items_sold    = absint( $totals['items_sold'] );

		$refund_total = $total_revenue - $net_revenue;
		if ( $refund_total < 0 ) {
			$refund_total = 0;
		}

		$average_order_value = 0.0;
		if ( $order_count > 0 ) {
			$average_order_value = $this->normalize_amount( $total_revenue / $order_count );
		}

		return array(
			'period'             => $period,
			'start_date'         => $range['start_date'],
			'end_date'           => $range['end_date'],
			'total_revenue'      => array(
				'amount'    => $total_revenue,
				'formatted' => $this->format_currency( $total_revenue ),
			),
			'order_count'        => $order_count,
			'average_order_value' => array(
				'amount'    => $average_order_value,
				'formatted' => $this->format_currency( $average_order_value ),
			),
			'items_sold'         => $items_sold,
			'refund_total'       => array(
				'amount'    => $this->normalize_amount( $refund_total ),
				'formatted' => $this->format_currency( $refund_total ),
			),
			'net_revenue'        => array(
				'amount'    => $net_revenue,
				'formatted' => $this->format_currency( $net_revenue ),
			),
			'top_products'       => $this->query_top_products( $range, $statuses ),
			'top_categories'     => $this->query_top_categories( $range, $statuses ),
		);
	}

	/**
	 * @param array $range Date range data.
	 * @param array $statuses Status list.
	 * @return array
	 */
	private function query_totals( array $range, array $statuses ) {
		global $wpdb;

		$table             = $wpdb->prefix . 'wc_order_stats';
		$has_total_sales   = $this->table_has_column( $table, 'total_sales' );
		$has_items_sold    = $this->table_has_column( $table, 'num_items_sold' );
		$total_column      = $has_total_sales ? 'total_sales' : 'net_total';
		$items_select      = $has_items_sold ? 'COALESCE(SUM(num_items_sold), 0) AS items_sold' : '0 AS items_sold';
		$parent_filter_sql = $this->table_has_column( $table, 'parent_id' ) ? ' AND parent_id = 0' : '';

		$params = array( $range['start_mysql'], $range['end_mysql'] );
		$status_clause = $this->build_status_clause( $statuses, $params );

		$sql = "
			SELECT
				COALESCE(SUM({$total_column}), 0) AS total_revenue,
				COALESCE(SUM(net_total), 0) AS net_revenue,
				{$items_select},
				COUNT(order_id) AS order_count
			FROM {$table}
			WHERE date_created >= %s
				AND date_created <= %s
				{$parent_filter_sql}
				{$status_clause}
		";

		$row = $wpdb->get_row( $wpdb->prepare( $sql, $params ), ARRAY_A );
		if ( ! is_array( $row ) ) {
			$row = array(
				'total_revenue' => 0,
				'net_revenue'   => 0,
				'items_sold'    => 0,
				'order_count'   => 0,
			);
		}

		if ( ! $has_items_sold ) {
			$row['items_sold'] = $this->query_items_sold( $range, $statuses );
		}

		return $row;
	}

	/**
	 * @param array $range Date range data.
	 * @param array $statuses Status list.
	 * @return int
	 */
	private function query_items_sold( array $range, array $statuses ) {
		global $wpdb;

		$stats_table  = $wpdb->prefix . 'wc_order_stats';
		$items_table  = $wpdb->prefix . 'wc_order_product_lookup';
		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';

		if ( ! $this->table_exists( $items_table ) ) {
			return 0;
		}

		$params = array( $range['start_mysql'], $range['end_mysql'] );
		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );

		$sql = "
			SELECT COALESCE(SUM(lookup.product_qty), 0)
			FROM {$items_table} AS lookup
			INNER JOIN {$stats_table} AS stats
				ON lookup.order_id = stats.order_id
			WHERE stats.date_created >= %s
				AND stats.date_created <= %s
				{$parent_filter_sql}
				{$status_clause}
		";

		$total = $wpdb->get_var( $wpdb->prepare( $sql, $params ) );
		return absint( $total );
	}

	/**
	 * @param array $range Date range data.
	 * @param array $statuses Status list.
	 * @return array
	 */
	private function query_top_products( array $range, array $statuses ) {
		global $wpdb;

		$stats_table = $wpdb->prefix . 'wc_order_stats';
		$table       = $wpdb->prefix . 'wc_order_product_lookup';

		if ( ! $this->table_exists( $table ) ) {
			return array();
		}

		$revenue_column = $this->get_product_revenue_column( $table );
		$revenue_select = $revenue_column
			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
			: '0 AS net_revenue';
		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';

		$params = array( $range['start_mysql'], $range['end_mysql'] );
		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );

		$sql = "
			SELECT
				lookup.product_id AS product_id,
				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
				{$revenue_select},
				COALESCE(posts.post_title, '') AS product_name
			FROM {$table} AS lookup
			INNER JOIN {$stats_table} AS stats
				ON lookup.order_id = stats.order_id
			LEFT JOIN {$wpdb->posts} AS posts
				ON posts.ID = lookup.product_id
			WHERE stats.date_created >= %s
				AND stats.date_created <= %s
				{$parent_filter_sql}
				{$status_clause}
				AND lookup.product_id > 0
			GROUP BY lookup.product_id
			ORDER BY {$order_by} DESC
			LIMIT %d
		";

		$params[] = self::TOP_LIMIT;

		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
		if ( empty( $rows ) ) {
			return array();
		}

		$results = array();
		foreach ( $rows as $row ) {
			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
			$results[] = array(
				'product_id' => absint( $row['product_id'] ),
				'name'       => sanitize_text_field( $row['product_name'] ),
				'items_sold' => absint( $row['items_sold'] ),
				'net_revenue' => array(
					'amount'    => $revenue,
					'formatted' => $this->format_currency( $revenue ),
				),
			);
		}

		return $results;
	}

	/**
	 * @param array $range Date range data.
	 * @param array $statuses Status list.
	 * @return array
	 */
	private function query_top_categories( array $range, array $statuses ) {
		global $wpdb;

		$stats_table = $wpdb->prefix . 'wc_order_stats';
		$table       = $wpdb->prefix . 'wc_order_product_lookup';

		if ( ! $this->table_exists( $table ) ) {
			return array();
		}

		$revenue_column = $this->get_product_revenue_column( $table );
		$revenue_select = $revenue_column
			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
			: '0 AS net_revenue';
		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';

		$params = array( $range['start_mysql'], $range['end_mysql'] );
		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );

		$sql = "
			SELECT
				terms.term_id AS term_id,
				terms.name AS category_name,
				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
				{$revenue_select}
			FROM {$table} AS lookup
			INNER JOIN {$stats_table} AS stats
				ON lookup.order_id = stats.order_id
			INNER JOIN {$wpdb->term_relationships} AS rel
				ON rel.object_id = lookup.product_id
			INNER JOIN {$wpdb->term_taxonomy} AS tax
				ON tax.term_taxonomy_id = rel.term_taxonomy_id
			INNER JOIN {$wpdb->terms} AS terms
				ON terms.term_id = tax.term_id
			WHERE stats.date_created >= %s
				AND stats.date_created <= %s
				{$parent_filter_sql}
				{$status_clause}
				AND lookup.product_id > 0
				AND tax.taxonomy = 'product_cat'
			GROUP BY terms.term_id
			ORDER BY {$order_by} DESC
			LIMIT %d
		";

		$params[] = self::TOP_LIMIT;

		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
		if ( empty( $rows ) ) {
			return array();
		}

		$results = array();
		foreach ( $rows as $row ) {
			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
			$results[] = array(
				'term_id'    => absint( $row['term_id'] ),
				'name'       => sanitize_text_field( $row['category_name'] ),
				'items_sold' => absint( $row['items_sold'] ),
				'net_revenue' => array(
					'amount'    => $revenue,
					'formatted' => $this->format_currency( $revenue ),
				),
			);
		}

		return $results;
	}

	/**
	 * @param array $current Current report.
	 * @param array $previous Previous report.
	 * @return array
	 */
	private function build_percentage_change( array $current, array $previous ) {
		$metrics = array(
			'total_revenue',
			'order_count',
			'average_order_value',
			'items_sold',
			'refund_total',
			'net_revenue',
		);

		$changes = array();
		foreach ( $metrics as $metric ) {
			$current_value  = $this->extract_metric_value( $current, $metric );
			$previous_value = $this->extract_metric_value( $previous, $metric );
			$changes[ $metric ] = $this->calculate_percentage_change( $current_value, $previous_value );
		}

		return $changes;
	}

	/**
	 * @param array  $report Report data.
	 * @param string $metric Metric key.
	 * @return float
	 */
	private function extract_metric_value( array $report, $metric ) {
		if ( ! isset( $report[ $metric ] ) ) {
			return 0.0;
		}

		$value = $report[ $metric ];
		if ( is_array( $value ) && isset( $value['amount'] ) ) {
			return (float) $value['amount'];
		}

		return (float) $value;
	}

	/**
	 * @param float $current Current value.
	 * @param float $previous Previous value.
	 * @return float|null
	 */
	private function calculate_percentage_change( $current, $previous ) {
		$current  = (float) $current;
		$previous = (float) $previous;

		if ( 0.0 === $previous ) {
			return 0.0 === $current ? 0.0 : null;
		}

		$change = ( ( $current - $previous ) / $previous ) * 100;

		return (float) $this->normalize_amount( $change );
	}

	/**
	 * @param string $period Period key.
	 * @param string $start_input Start date input.
	 * @param string $end_input End date input.
	 * @return array|null
	 */
	private function resolve_period_range( $period, $start_input, $end_input ) {
		$timezone = $this->get_timezone();
		$now      = new DateTimeImmutable( 'now', $timezone );

		switch ( $period ) {
			case 'today':
				$start = $now->setTime( 0, 0, 0 );
				$end   = $now;
				break;
			case 'yesterday':
				$start = $now->modify( '-1 day' )->setTime( 0, 0, 0 );
				$end   = $start->setTime( 23, 59, 59 );
				break;
			case 'this_week':
				$start = $this->start_of_week( $now, $timezone );
				$end   = $now;
				break;
			case 'last_week':
				$current_week_start = $this->start_of_week( $now, $timezone );
				$end   = $current_week_start->modify( '-1 second' );
				$start = $current_week_start->modify( '-7 days' )->setTime( 0, 0, 0 );
				break;
			case 'this_month':
				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
				$end   = $now;
				break;
			case 'last_month':
				$start = $now->modify( 'first day of last month' )->setTime( 0, 0, 0 );
				$end   = $now->modify( 'last day of last month' )->setTime( 23, 59, 59 );
				break;
			case 'custom':
				$start_date = $this->parse_date_input( $start_input, $timezone );
				$end_date   = $this->parse_date_input( $end_input, $timezone );
				if ( null === $start_date || null === $end_date ) {
					return null;
				}

				$start = $start_date->setTime( 0, 0, 0 );
				$end   = $end_date->setTime( 23, 59, 59 );
				break;
			default:
				return null;
		}

		if ( $end < $start ) {
			$temp  = $start;
			$start = $end;
			$end   = $temp;
		}

		return $this->format_range( $start, $end );
	}

	/**
	 * @param array $range Current range data.
	 * @return array
	 */
	private function build_previous_range( array $range ) {
		$start = $range['start'];
		$end   = $range['end'];

		$duration = max( 0, $end->getTimestamp() - $start->getTimestamp() );
		$prev_end = $start->modify( '-1 second' );
		$prev_start = $prev_end->modify( '-' . $duration . ' seconds' );

		return $this->format_range( $prev_start, $prev_end );
	}

	/**
	 * @param DateTimeImmutable $start Start date.
	 * @param DateTimeImmutable $end End date.
	 * @return array
	 */
	private function format_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
		return array(
			'start'       => $start,
			'end'         => $end,
			'start_mysql' => $start->format( 'Y-m-d H:i:s' ),
			'end_mysql'   => $end->format( 'Y-m-d H:i:s' ),
			'start_date'  => $start->format( 'Y-m-d' ),
			'end_date'    => $end->format( 'Y-m-d' ),
		);
	}

	/**
	 * @param DateTimeImmutable $now Current time.
	 * @param DateTimeZone      $timezone Timezone.
	 * @return DateTimeImmutable
	 */
	private function start_of_week( DateTimeImmutable $now, DateTimeZone $timezone ) {
		$week_start = 1;
		if ( function_exists( 'get_option' ) ) {
			$week_start = intval( get_option( 'start_of_week', 1 ) );
		}

		$weekday = intval( $now->format( 'w' ) );
		$diff    = ( $weekday - $week_start + 7 ) % 7;

		return $now->modify( '-' . $diff . ' days' )->setTime( 0, 0, 0 )->setTimezone( $timezone );
	}

	/**
	 * @param string       $value Date string.
	 * @param DateTimeZone $timezone Timezone.
	 * @return DateTimeImmutable|null
	 */
	private function parse_date_input( $value, DateTimeZone $timezone ) {
		$value = trim( (string) $value );
		if ( '' === $value ) {
			return null;
		}

		$date = DateTimeImmutable::createFromFormat( 'Y-m-d', $value, $timezone );
		if ( false === $date ) {
			return null;
		}

		return $date;
	}

	/**
	 * @param array $statuses Status list.
	 * @param array $params Parameters to append to.
	 * @param string $column Column name.
	 * @return string
	 */
	private function build_status_clause( array $statuses, array &$params, $column = 'status' ) {
		if ( empty( $statuses ) ) {
			return '';
		}

		$placeholders = implode( ', ', array_fill( 0, count( $statuses ), '%s' ) );
		foreach ( $statuses as $status ) {
			$params[] = $status;
		}

		return " AND {$column} IN ({$placeholders})";
	}

	/**
	 * @return array
	 */
	private function get_paid_statuses() {
		$statuses = function_exists( 'wc_get_is_paid_statuses' )
			? wc_get_is_paid_statuses()
			: array( 'processing', 'completed', 'on-hold' );

		$normalized = array();
		foreach ( $statuses as $status ) {
			$status = sanitize_text_field( $status );
			$status = trim( $status );
			if ( '' === $status ) {
				continue;
			}

			$normalized[] = $status;
			if ( 0 === strpos( $status, 'wc-' ) ) {
				$normalized[] = substr( $status, 3 );
			} else {
				$normalized[] = 'wc-' . $status;
			}
		}

		$normalized = array_unique( $normalized );
		sort( $normalized );

		return $normalized;
	}

	/**
	 * @param mixed $value Input.
	 * @return bool
	 */
	private function normalize_bool( $value ) {
		if ( function_exists( 'rest_sanitize_boolean' ) ) {
			return rest_sanitize_boolean( $value );
		}

		return (bool) $value;
	}

	/**
	 * @param mixed $amount Input amount.
	 * @return float
	 */
	private function normalize_amount( $amount ) {
		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
		$decimals = $this->get_price_decimals();

		if ( function_exists( 'wc_format_decimal' ) ) {
			return (float) wc_format_decimal( $amount, $decimals );
		}

		return (float) round( $amount, $decimals );
	}

	/**
	 * @return int
	 */
	private function get_price_decimals() {
		if ( function_exists( 'wc_get_price_decimals' ) ) {
			return (int) wc_get_price_decimals();
		}

		return 2;
	}

	/**
	 * @param mixed $value Input.
	 * @return string
	 */
	private function format_currency( $value ) {
		if ( '' === $value || null === $value ) {
			return '';
		}

		if ( function_exists( 'wc_price' ) ) {
			return wp_strip_all_tags( wc_price( $value ) );
		}

		return (string) $value;
	}

	/**
	 * @param array $payload Cache payload.
	 * @return string
	 */
	private function build_cache_key( array $payload ) {
		$encoded = function_exists( 'wp_json_encode' ) ? wp_json_encode( $payload ) : json_encode( $payload );
		$hash    = $encoded ? md5( $encoded ) : md5( 'sales_report' );

		return Plugin::TRANSIENT_PREFIX . 'sales_report_' . $hash;
	}

	/**
	 * @param string $cache_key Cache key.
	 * @return array|null
	 */
	private function read_cache( $cache_key ) {
		if ( ! function_exists( 'get_transient' ) ) {
			return null;
		}

		$cached = get_transient( $cache_key );
		if ( false === $cached || ! is_array( $cached ) ) {
			return null;
		}

		return $cached;
	}

	/**
	 * @param string $cache_key Cache key.
	 * @param array  $payload Cache payload.
	 * @param int    $ttl Cache TTL.
	 * @return void
	 */
	private function write_cache( $cache_key, array $payload, $ttl ) {
		if ( ! function_exists( 'set_transient' ) ) {
			return;
		}

		set_transient( $cache_key, $payload, $ttl );
	}

	/**
	 * @param array  $range Date range.
	 * @param string $period Period.
	 * @return int
	 */
	private function get_cache_ttl( array $range, $period ) {
		if ( 'today' === $period || $this->range_is_today( $range ) ) {
			return self::CACHE_TTL_TODAY;
		}

		return self::CACHE_TTL_DEFAULT;
	}

	/**
	 * @param array $range Date range.
	 * @return bool
	 */
	private function range_is_today( array $range ) {
		$timezone = $this->get_timezone();
		$today    = ( new DateTimeImmutable( 'now', $timezone ) )->format( 'Y-m-d' );

		return $range['start']->format( 'Y-m-d' ) === $today && $range['end']->format( 'Y-m-d' ) === $today;
	}

	/**
	 * @return DateTimeZone
	 */
	private function get_timezone() {
		if ( function_exists( 'wp_timezone' ) ) {
			return wp_timezone();
		}

		$timezone = '';
		if ( function_exists( 'wp_timezone_string' ) ) {
			$timezone = wp_timezone_string();
		}

		if ( '' === $timezone && function_exists( 'get_option' ) ) {
			$timezone = (string) get_option( 'timezone_string' );
		}

		if ( '' === $timezone ) {
			$timezone = 'UTC';
		}

		try {
			return new DateTimeZone( $timezone );
		} catch ( Exception $exception ) {
			return new DateTimeZone( 'UTC' );
		}
	}

	/**
	 * @param string $table Table name.
	 * @return bool
	 */
	private function table_exists( $table ) {
		global $wpdb;

		$found = $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table ) );
		return $found === $table;
	}

	/**
	 * @param string $table Table name.
	 * @param string $column Column name.
	 * @return bool
	 */
	private function table_has_column( $table, $column ) {
		static $cache = array();
		$key = $table . ':' . $column;

		if ( isset( $cache[ $key ] ) ) {
			return $cache[ $key ];
		}

		global $wpdb;
		$result = $wpdb->get_var( $wpdb->prepare( 'SHOW COLUMNS FROM ' . $table . ' LIKE %s', $column ) );
		$cache[ $key ] = ! empty( $result );

		return $cache[ $key ];
	}

	/**
	 * @param string $table Table name.
	 * @return string|null
	 */
	private function get_product_revenue_column( $table ) {
		if ( $this->table_has_column( $table, 'product_net_revenue' ) ) {
			return 'product_net_revenue';
		}

		if ( $this->table_has_column( $table, 'product_gross_revenue' ) ) {
			return 'product_gross_revenue';
		}

		return null;
	}
}
apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
A src/Handlers/AnalyticsHandler.php
file update:
diff --git a/src/Handlers/AnalyticsHandler.php b/src/Handlers/AnalyticsHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..aeb740a9b75d6ed62e72c81955fd341be113a91f
--- /dev/null
+++ b/src/Handlers/AnalyticsHandler.php
@@ -0,0 +1,805 @@
+<?php
+/**
+ * Handle sales analytics reports.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class AnalyticsHandler {
+	const CACHE_TTL_TODAY   = 300;
+	const CACHE_TTL_DEFAULT = 3600;
+	const TOP_LIMIT         = 5;
+
+	/**
+	 * Handle analytics requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to fetch analytics.', 400 );
+		}
+
+		global $wpdb;
+		if ( ! $wpdb ) {
+			return Response::error( 'Database is unavailable for analytics.', 500 );
+		}
+
+		$period = isset( $args['period'] ) ? sanitize_text_field( $args['period'] ) : '';
+		$period = strtolower( trim( $period ) );
+
+		$valid_periods = array( 'today', 'yesterday', 'this_week', 'last_week', 'this_month', 'last_month', 'custom' );
+		if ( ! in_array( $period, $valid_periods, true ) ) {
+			return Response::error( 'Invalid period for sales report.', 400 );
+		}
+
+		$start_input = isset( $args['start_date'] ) ? sanitize_text_field( $args['start_date'] ) : '';
+		$end_input   = isset( $args['end_date'] ) ? sanitize_text_field( $args['end_date'] ) : '';
+		$compare     = $this->normalize_bool( isset( $args['compare_previous'] ) ? $args['compare_previous'] : false );
+
+		$range = $this->resolve_period_range( $period, $start_input, $end_input );
+		if ( null === $range ) {
+			return Response::error( 'Invalid date range for sales report.', 400 );
+		}
+
+		$order_stats_table = $wpdb->prefix . 'wc_order_stats';
+		if ( ! $this->table_exists( $order_stats_table ) ) {
+			return Response::error( 'WooCommerce analytics tables are unavailable.', 500 );
+		}
+
+		$cache_key = $this->build_cache_key(
+			array(
+				'period'           => $period,
+				'start'            => $range['start_mysql'],
+				'end'              => $range['end_mysql'],
+				'compare_previous' => $compare,
+			)
+		);
+		$cached    = $this->read_cache( $cache_key );
+		if ( null !== $cached ) {
+			$cached['cached'] = true;
+			return Response::success( $cached );
+		}
+
+		$statuses = $this->get_paid_statuses();
+		$current  = $this->build_report( $period, $range, $statuses );
+
+		if ( $compare ) {
+			$previous_range = $this->build_previous_range( $range );
+			$previous       = $this->build_report( $period, $previous_range, $statuses );
+			$payload        = array(
+				'period'            => $period,
+				'compare_previous'  => true,
+				'current_period'    => $current,
+				'previous_period'   => $previous,
+				'percentage_change' => $this->build_percentage_change( $current, $previous ),
+			);
+		} else {
+			$payload = $current;
+		}
+
+		$payload['cached'] = false;
+
+		$this->write_cache( $cache_key, $payload, $this->get_cache_ttl( $range, $period ) );
+
+		return Response::success( $payload );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param array  $range Date range data.
+	 * @param array  $statuses Status list.
+	 * @return array
+	 */
+	private function build_report( $period, array $range, array $statuses ) {
+		$totals = $this->query_totals( $range, $statuses );
+
+		$total_revenue = $this->normalize_amount( $totals['total_revenue'] );
+		$net_revenue   = $this->normalize_amount( $totals['net_revenue'] );
+		$order_count   = absint( $totals['order_count'] );
+		$items_sold    = absint( $totals['items_sold'] );
+
+		$refund_total = $total_revenue - $net_revenue;
+		if ( $refund_total < 0 ) {
+			$refund_total = 0;
+		}
+
+		$average_order_value = 0.0;
+		if ( $order_count > 0 ) {
+			$average_order_value = $this->normalize_amount( $total_revenue / $order_count );
+		}
+
+		return array(
+			'period'             => $period,
+			'start_date'         => $range['start_date'],
+			'end_date'           => $range['end_date'],
+			'total_revenue'      => array(
+				'amount'    => $total_revenue,
+				'formatted' => $this->format_currency( $total_revenue ),
+			),
+			'order_count'        => $order_count,
+			'average_order_value' => array(
+				'amount'    => $average_order_value,
+				'formatted' => $this->format_currency( $average_order_value ),
+			),
+			'items_sold'         => $items_sold,
+			'refund_total'       => array(
+				'amount'    => $this->normalize_amount( $refund_total ),
+				'formatted' => $this->format_currency( $refund_total ),
+			),
+			'net_revenue'        => array(
+				'amount'    => $net_revenue,
+				'formatted' => $this->format_currency( $net_revenue ),
+			),
+			'top_products'       => $this->query_top_products( $range, $statuses ),
+			'top_categories'     => $this->query_top_categories( $range, $statuses ),
+		);
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_totals( array $range, array $statuses ) {
+		global $wpdb;
+
+		$table             = $wpdb->prefix . 'wc_order_stats';
+		$has_total_sales   = $this->table_has_column( $table, 'total_sales' );
+		$has_items_sold    = $this->table_has_column( $table, 'num_items_sold' );
+		$total_column      = $has_total_sales ? 'total_sales' : 'net_total';
+		$items_select      = $has_items_sold ? 'COALESCE(SUM(num_items_sold), 0) AS items_sold' : '0 AS items_sold';
+		$parent_filter_sql = $this->table_has_column( $table, 'parent_id' ) ? ' AND parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params );
+
+		$sql = "
+			SELECT
+				COALESCE(SUM({$total_column}), 0) AS total_revenue,
+				COALESCE(SUM(net_total), 0) AS net_revenue,
+				{$items_select},
+				COUNT(order_id) AS order_count
+			FROM {$table}
+			WHERE date_created >= %s
+				AND date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$row = $wpdb->get_row( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( ! is_array( $row ) ) {
+			$row = array(
+				'total_revenue' => 0,
+				'net_revenue'   => 0,
+				'items_sold'    => 0,
+				'order_count'   => 0,
+			);
+		}
+
+		if ( ! $has_items_sold ) {
+			$row['items_sold'] = $this->query_items_sold( $range, $statuses );
+		}
+
+		return $row;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return int
+	 */
+	private function query_items_sold( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table  = $wpdb->prefix . 'wc_order_stats';
+		$items_table  = $wpdb->prefix . 'wc_order_product_lookup';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		if ( ! $this->table_exists( $items_table ) ) {
+			return 0;
+		}
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT COALESCE(SUM(lookup.product_qty), 0)
+			FROM {$items_table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$total = $wpdb->get_var( $wpdb->prepare( $sql, $params ) );
+		return absint( $total );
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_products( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				lookup.product_id AS product_id,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select},
+				COALESCE(posts.post_title, '') AS product_name
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			LEFT JOIN {$wpdb->posts} AS posts
+				ON posts.ID = lookup.product_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+			GROUP BY lookup.product_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'product_id' => absint( $row['product_id'] ),
+				'name'       => sanitize_text_field( $row['product_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => array(
+					'amount'    => $revenue,
+					'formatted' => $this->format_currency( $revenue ),
+				),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_categories( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				terms.term_id AS term_id,
+				terms.name AS category_name,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select}
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			INNER JOIN {$wpdb->term_relationships} AS rel
+				ON rel.object_id = lookup.product_id
+			INNER JOIN {$wpdb->term_taxonomy} AS tax
+				ON tax.term_taxonomy_id = rel.term_taxonomy_id
+			INNER JOIN {$wpdb->terms} AS terms
+				ON terms.term_id = tax.term_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+				AND tax.taxonomy = 'product_cat'
+			GROUP BY terms.term_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'term_id'    => absint( $row['term_id'] ),
+				'name'       => sanitize_text_field( $row['category_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => array(
+					'amount'    => $revenue,
+					'formatted' => $this->format_currency( $revenue ),
+				),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $current Current report.
+	 * @param array $previous Previous report.
+	 * @return array
+	 */
+	private function build_percentage_change( array $current, array $previous ) {
+		$metrics = array(
+			'total_revenue',
+			'order_count',
+			'average_order_value',
+			'items_sold',
+			'refund_total',
+			'net_revenue',
+		);
+
+		$changes = array();
+		foreach ( $metrics as $metric ) {
+			$current_value  = $this->extract_metric_value( $current, $metric );
+			$previous_value = $this->extract_metric_value( $previous, $metric );
+			$changes[ $metric ] = $this->calculate_percentage_change( $current_value, $previous_value );
+		}
+
+		return $changes;
+	}
+
+	/**
+	 * @param array  $report Report data.
+	 * @param string $metric Metric key.
+	 * @return float
+	 */
+	private function extract_metric_value( array $report, $metric ) {
+		if ( ! isset( $report[ $metric ] ) ) {
+			return 0.0;
+		}
+
+		$value = $report[ $metric ];
+		if ( is_array( $value ) && isset( $value['amount'] ) ) {
+			return (float) $value['amount'];
+		}
+
+		return (float) $value;
+	}
+
+	/**
+	 * @param float $current Current value.
+	 * @param float $previous Previous value.
+	 * @return float|null
+	 */
+	private function calculate_percentage_change( $current, $previous ) {
+		$current  = (float) $current;
+		$previous = (float) $previous;
+
+		if ( 0.0 === $previous ) {
+			return 0.0 === $current ? 0.0 : null;
+		}
+
+		$change = ( ( $current - $previous ) / $previous ) * 100;
+
+		return (float) $this->normalize_amount( $change );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param string $start_input Start date input.
+	 * @param string $end_input End date input.
+	 * @return array|null
+	 */
+	private function resolve_period_range( $period, $start_input, $end_input ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+
+		switch ( $period ) {
+			case 'today':
+				$start = $now->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'yesterday':
+				$start = $now->modify( '-1 day' )->setTime( 0, 0, 0 );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'this_week':
+				$start = $this->start_of_week( $now, $timezone );
+				$end   = $now;
+				break;
+			case 'last_week':
+				$current_week_start = $this->start_of_week( $now, $timezone );
+				$end   = $current_week_start->modify( '-1 second' );
+				$start = $current_week_start->modify( '-7 days' )->setTime( 0, 0, 0 );
+				break;
+			case 'this_month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'last_month':
+				$start = $now->modify( 'first day of last month' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( 'last day of last month' )->setTime( 23, 59, 59 );
+				break;
+			case 'custom':
+				$start_date = $this->parse_date_input( $start_input, $timezone );
+				$end_date   = $this->parse_date_input( $end_input, $timezone );
+				if ( null === $start_date || null === $end_date ) {
+					return null;
+				}
+
+				$start = $start_date->setTime( 0, 0, 0 );
+				$end   = $end_date->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		if ( $end < $start ) {
+			$temp  = $start;
+			$start = $end;
+			$end   = $temp;
+		}
+
+		return $this->format_range( $start, $end );
+	}
+
+	/**
+	 * @param array $range Current range data.
+	 * @return array
+	 */
+	private function build_previous_range( array $range ) {
+		$start = $range['start'];
+		$end   = $range['end'];
+
+		$duration = max( 0, $end->getTimestamp() - $start->getTimestamp() );
+		$prev_end = $start->modify( '-1 second' );
+		$prev_start = $prev_end->modify( '-' . $duration . ' seconds' );
+
+		return $this->format_range( $prev_start, $prev_end );
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start'       => $start,
+			'end'         => $end,
+			'start_mysql' => $start->format( 'Y-m-d H:i:s' ),
+			'end_mysql'   => $end->format( 'Y-m-d H:i:s' ),
+			'start_date'  => $start->format( 'Y-m-d' ),
+			'end_date'    => $end->format( 'Y-m-d' ),
+		);
+	}
+
+	/**
+	 * @param DateTimeImmutable $now Current time.
+	 * @param DateTimeZone      $timezone Timezone.
+	 * @return DateTimeImmutable
+	 */
+	private function start_of_week( DateTimeImmutable $now, DateTimeZone $timezone ) {
+		$week_start = 1;
+		if ( function_exists( 'get_option' ) ) {
+			$week_start = intval( get_option( 'start_of_week', 1 ) );
+		}
+
+		$weekday = intval( $now->format( 'w' ) );
+		$diff    = ( $weekday - $week_start + 7 ) % 7;
+
+		return $now->modify( '-' . $diff . ' days' )->setTime( 0, 0, 0 )->setTimezone( $timezone );
+	}
+
+	/**
+	 * @param string       $value Date string.
+	 * @param DateTimeZone $timezone Timezone.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_input( $value, DateTimeZone $timezone ) {
+		$value = trim( (string) $value );
+		if ( '' === $value ) {
+			return null;
+		}
+
+		$date = DateTimeImmutable::createFromFormat( 'Y-m-d', $value, $timezone );
+		if ( false === $date ) {
+			return null;
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param array $statuses Status list.
+	 * @param array $params Parameters to append to.
+	 * @param string $column Column name.
+	 * @return string
+	 */
+	private function build_status_clause( array $statuses, array &$params, $column = 'status' ) {
+		if ( empty( $statuses ) ) {
+			return '';
+		}
+
+		$placeholders = implode( ', ', array_fill( 0, count( $statuses ), '%s' ) );
+		foreach ( $statuses as $status ) {
+			$params[] = $status;
+		}
+
+		return " AND {$column} IN ({$placeholders})";
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_paid_statuses() {
+		$statuses = function_exists( 'wc_get_is_paid_statuses' )
+			? wc_get_is_paid_statuses()
+			: array( 'processing', 'completed', 'on-hold' );
+
+		$normalized = array();
+		foreach ( $statuses as $status ) {
+			$status = sanitize_text_field( $status );
+			$status = trim( $status );
+			if ( '' === $status ) {
+				continue;
+			}
+
+			$normalized[] = $status;
+			if ( 0 === strpos( $status, 'wc-' ) ) {
+				$normalized[] = substr( $status, 3 );
+			} else {
+				$normalized[] = 'wc-' . $status;
+			}
+		}
+
+		$normalized = array_unique( $normalized );
+		sort( $normalized );
+
+		return $normalized;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Input amount.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return (float) round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return (int) wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return string
+	 */
+	private function format_currency( $value ) {
+		if ( '' === $value || null === $value ) {
+			return '';
+		}
+
+		if ( function_exists( 'wc_price' ) ) {
+			return wp_strip_all_tags( wc_price( $value ) );
+		}
+
+		return (string) $value;
+	}
+
+	/**
+	 * @param array $payload Cache payload.
+	 * @return string
+	 */
+	private function build_cache_key( array $payload ) {
+		$encoded = function_exists( 'wp_json_encode' ) ? wp_json_encode( $payload ) : json_encode( $payload );
+		$hash    = $encoded ? md5( $encoded ) : md5( 'sales_report' );
+
+		return Plugin::TRANSIENT_PREFIX . 'sales_report_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @param array  $payload Cache payload.
+	 * @param int    $ttl Cache TTL.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $payload, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $payload, $ttl );
+	}
+
+	/**
+	 * @param array  $range Date range.
+	 * @param string $period Period.
+	 * @return int
+	 */
+	private function get_cache_ttl( array $range, $period ) {
+		if ( 'today' === $period || $this->range_is_today( $range ) ) {
+			return self::CACHE_TTL_TODAY;
+		}
+
+		return self::CACHE_TTL_DEFAULT;
+	}
+
+	/**
+	 * @param array $range Date range.
+	 * @return bool
+	 */
+	private function range_is_today( array $range ) {
+		$timezone = $this->get_timezone();
+		$today    = ( new DateTimeImmutable( 'now', $timezone ) )->format( 'Y-m-d' );
+
+		return $range['start']->format( 'Y-m-d' ) === $today && $range['end']->format( 'Y-m-d' ) === $today;
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return bool
+	 */
+	private function table_exists( $table ) {
+		global $wpdb;
+
+		$found = $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table ) );
+		return $found === $table;
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @param string $column Column name.
+	 * @return bool
+	 */
+	private function table_has_column( $table, $column ) {
+		static $cache = array();
+		$key = $table . ':' . $column;
+
+		if ( isset( $cache[ $key ] ) ) {
+			return $cache[ $key ];
+		}
+
+		global $wpdb;
+		$result = $wpdb->get_var( $wpdb->prepare( 'SHOW COLUMNS FROM ' . $table . ' LIKE %s', $column ) );
+		$cache[ $key ] = ! empty( $result );
+
+		return $cache[ $key ];
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return string|null
+	 */
+	private function get_product_revenue_column( $table ) {
+		if ( $this->table_has_column( $table, 'product_net_revenue' ) ) {
+			return 'product_net_revenue';
+		}
+
+		if ( $this->table_has_column( $table, 'product_gross_revenue' ) ) {
+			return 'product_gross_revenue';
+		}
+
+		return null;
+	}
+}

file update:
diff --git a/src/Handlers/AnalyticsHandler.php b/src/Handlers/AnalyticsHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..aeb740a9b75d6ed62e72c81955fd341be113a91f
--- /dev/null
+++ b/src/Handlers/AnalyticsHandler.php
@@ -0,0 +1,805 @@
+<?php
+/**
+ * Handle sales analytics reports.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class AnalyticsHandler {
+	const CACHE_TTL_TODAY   = 300;
+	const CACHE_TTL_DEFAULT = 3600;
+	const TOP_LIMIT         = 5;
+
+	/**
+	 * Handle analytics requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to fetch analytics.', 400 );
+		}
+
+		global $wpdb;
+		if ( ! $wpdb ) {
+			return Response::error( 'Database is unavailable for analytics.', 500 );
+		}
+
+		$period = isset( $args['period'] ) ? sanitize_text_field( $args['period'] ) : '';
+		$period = strtolower( trim( $period ) );
+
+		$valid_periods = array( 'today', 'yesterday', 'this_week', 'last_week', 'this_month', 'last_month', 'custom' );
+		if ( ! in_array( $period, $valid_periods, true ) ) {
+			return Response::error( 'Invalid period for sales report.', 400 );
+		}
+
+		$start_input = isset( $args['start_date'] ) ? sanitize_text_field( $args['start_date'] ) : '';
+		$end_input   = isset( $args['end_date'] ) ? sanitize_text_field( $args['end_date'] ) : '';
+		$compare     = $this->normalize_bool( isset( $args['compare_previous'] ) ? $args['compare_previous'] : false );
+
+		$range = $this->resolve_period_range( $period, $start_input, $end_input );
+		if ( null === $range ) {
+			return Response::error( 'Invalid date range for sales report.', 400 );
+		}
+
+		$order_stats_table = $wpdb->prefix . 'wc_order_stats';
+		if ( ! $this->table_exists( $order_stats_table ) ) {
+			return Response::error( 'WooCommerce analytics tables are unavailable.', 500 );
+		}
+
+		$cache_key = $this->build_cache_key(
+			array(
+				'period'           => $period,
+				'start'            => $range['start_mysql'],
+				'end'              => $range['end_mysql'],
+				'compare_previous' => $compare,
+			)
+		);
+		$cached    = $this->read_cache( $cache_key );
+		if ( null !== $cached ) {
+			$cached['cached'] = true;
+			return Response::success( $cached );
+		}
+
+		$statuses = $this->get_paid_statuses();
+		$current  = $this->build_report( $period, $range, $statuses );
+
+		if ( $compare ) {
+			$previous_range = $this->build_previous_range( $range );
+			$previous       = $this->build_report( $period, $previous_range, $statuses );
+			$payload        = array(
+				'period'            => $period,
+				'compare_previous'  => true,
+				'current_period'    => $current,
+				'previous_period'   => $previous,
+				'percentage_change' => $this->build_percentage_change( $current, $previous ),
+			);
+		} else {
+			$payload = $current;
+		}
+
+		$payload['cached'] = false;
+
+		$this->write_cache( $cache_key, $payload, $this->get_cache_ttl( $range, $period ) );
+
+		return Response::success( $payload );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param array  $range Date range data.
+	 * @param array  $statuses Status list.
+	 * @return array
+	 */
+	private function build_report( $period, array $range, array $statuses ) {
+		$totals = $this->query_totals( $range, $statuses );
+
+		$total_revenue = $this->normalize_amount( $totals['total_revenue'] );
+		$net_revenue   = $this->normalize_amount( $totals['net_revenue'] );
+		$order_count   = absint( $totals['order_count'] );
+		$items_sold    = absint( $totals['items_sold'] );
+
+		$refund_total = $total_revenue - $net_revenue;
+		if ( $refund_total < 0 ) {
+			$refund_total = 0;
+		}
+
+		$average_order_value = 0.0;
+		if ( $order_count > 0 ) {
+			$average_order_value = $this->normalize_amount( $total_revenue / $order_count );
+		}
+
+		return array(
+			'period'             => $period,
+			'start_date'         => $range['start_date'],
+			'end_date'           => $range['end_date'],
+			'total_revenue'      => array(
+				'amount'    => $total_revenue,
+				'formatted' => $this->format_currency( $total_revenue ),
+			),
+			'order_count'        => $order_count,
+			'average_order_value' => array(
+				'amount'    => $average_order_value,
+				'formatted' => $this->format_currency( $average_order_value ),
+			),
+			'items_sold'         => $items_sold,
+			'refund_total'       => array(
+				'amount'    => $this->normalize_amount( $refund_total ),
+				'formatted' => $this->format_currency( $refund_total ),
+			),
+			'net_revenue'        => array(
+				'amount'    => $net_revenue,
+				'formatted' => $this->format_currency( $net_revenue ),
+			),
+			'top_products'       => $this->query_top_products( $range, $statuses ),
+			'top_categories'     => $this->query_top_categories( $range, $statuses ),
+		);
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_totals( array $range, array $statuses ) {
+		global $wpdb;
+
+		$table             = $wpdb->prefix . 'wc_order_stats';
+		$has_total_sales   = $this->table_has_column( $table, 'total_sales' );
+		$has_items_sold    = $this->table_has_column( $table, 'num_items_sold' );
+		$total_column      = $has_total_sales ? 'total_sales' : 'net_total';
+		$items_select      = $has_items_sold ? 'COALESCE(SUM(num_items_sold), 0) AS items_sold' : '0 AS items_sold';
+		$parent_filter_sql = $this->table_has_column( $table, 'parent_id' ) ? ' AND parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params );
+
+		$sql = "
+			SELECT
+				COALESCE(SUM({$total_column}), 0) AS total_revenue,
+				COALESCE(SUM(net_total), 0) AS net_revenue,
+				{$items_select},
+				COUNT(order_id) AS order_count
+			FROM {$table}
+			WHERE date_created >= %s
+				AND date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$row = $wpdb->get_row( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( ! is_array( $row ) ) {
+			$row = array(
+				'total_revenue' => 0,
+				'net_revenue'   => 0,
+				'items_sold'    => 0,
+				'order_count'   => 0,
+			);
+		}
+
+		if ( ! $has_items_sold ) {
+			$row['items_sold'] = $this->query_items_sold( $range, $statuses );
+		}
+
+		return $row;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return int
+	 */
+	private function query_items_sold( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table  = $wpdb->prefix . 'wc_order_stats';
+		$items_table  = $wpdb->prefix . 'wc_order_product_lookup';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		if ( ! $this->table_exists( $items_table ) ) {
+			return 0;
+		}
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT COALESCE(SUM(lookup.product_qty), 0)
+			FROM {$items_table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$total = $wpdb->get_var( $wpdb->prepare( $sql, $params ) );
+		return absint( $total );
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_products( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				lookup.product_id AS product_id,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select},
+				COALESCE(posts.post_title, '') AS product_name
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			LEFT JOIN {$wpdb->posts} AS posts
+				ON posts.ID = lookup.product_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+			GROUP BY lookup.product_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'product_id' => absint( $row['product_id'] ),
+				'name'       => sanitize_text_field( $row['product_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => array(
+					'amount'    => $revenue,
+					'formatted' => $this->format_currency( $revenue ),
+				),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_categories( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				terms.term_id AS term_id,
+				terms.name AS category_name,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select}
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			INNER JOIN {$wpdb->term_relationships} AS rel
+				ON rel.object_id = lookup.product_id
+			INNER JOIN {$wpdb->term_taxonomy} AS tax
+				ON tax.term_taxonomy_id = rel.term_taxonomy_id
+			INNER JOIN {$wpdb->terms} AS terms
+				ON terms.term_id = tax.term_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+				AND tax.taxonomy = 'product_cat'
+			GROUP BY terms.term_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'term_id'    => absint( $row['term_id'] ),
+				'name'       => sanitize_text_field( $row['category_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => array(
+					'amount'    => $revenue,
+					'formatted' => $this->format_currency( $revenue ),
+				),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $current Current report.
+	 * @param array $previous Previous report.
+	 * @return array
+	 */
+	private function build_percentage_change( array $current, array $previous ) {
+		$metrics = array(
+			'total_revenue',
+			'order_count',
+			'average_order_value',
+			'items_sold',
+			'refund_total',
+			'net_revenue',
+		);
+
+		$changes = array();
+		foreach ( $metrics as $metric ) {
+			$current_value  = $this->extract_metric_value( $current, $metric );
+			$previous_value = $this->extract_metric_value( $previous, $metric );
+			$changes[ $metric ] = $this->calculate_percentage_change( $current_value, $previous_value );
+		}
+
+		return $changes;
+	}
+
+	/**
+	 * @param array  $report Report data.
+	 * @param string $metric Metric key.
+	 * @return float
+	 */
+	private function extract_metric_value( array $report, $metric ) {
+		if ( ! isset( $report[ $metric ] ) ) {
+			return 0.0;
+		}
+
+		$value = $report[ $metric ];
+		if ( is_array( $value ) && isset( $value['amount'] ) ) {
+			return (float) $value['amount'];
+		}
+
+		return (float) $value;
+	}
+
+	/**
+	 * @param float $current Current value.
+	 * @param float $previous Previous value.
+	 * @return float|null
+	 */
+	private function calculate_percentage_change( $current, $previous ) {
+		$current  = (float) $current;
+		$previous = (float) $previous;
+
+		if ( 0.0 === $previous ) {
+			return 0.0 === $current ? 0.0 : null;
+		}
+
+		$change = ( ( $current - $previous ) / $previous ) * 100;
+
+		return (float) $this->normalize_amount( $change );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param string $start_input Start date input.
+	 * @param string $end_input End date input.
+	 * @return array|null
+	 */
+	private function resolve_period_range( $period, $start_input, $end_input ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+
+		switch ( $period ) {
+			case 'today':
+				$start = $now->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'yesterday':
+				$start = $now->modify( '-1 day' )->setTime( 0, 0, 0 );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'this_week':
+				$start = $this->start_of_week( $now, $timezone );
+				$end   = $now;
+				break;
+			case 'last_week':
+				$current_week_start = $this->start_of_week( $now, $timezone );
+				$end   = $current_week_start->modify( '-1 second' );
+				$start = $current_week_start->modify( '-7 days' )->setTime( 0, 0, 0 );
+				break;
+			case 'this_month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'last_month':
+				$start = $now->modify( 'first day of last month' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( 'last day of last month' )->setTime( 23, 59, 59 );
+				break;
+			case 'custom':
+				$start_date = $this->parse_date_input( $start_input, $timezone );
+				$end_date   = $this->parse_date_input( $end_input, $timezone );
+				if ( null === $start_date || null === $end_date ) {
+					return null;
+				}
+
+				$start = $start_date->setTime( 0, 0, 0 );
+				$end   = $end_date->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		if ( $end < $start ) {
+			$temp  = $start;
+			$start = $end;
+			$end   = $temp;
+		}
+
+		return $this->format_range( $start, $end );
+	}
+
+	/**
+	 * @param array $range Current range data.
+	 * @return array
+	 */
+	private function build_previous_range( array $range ) {
+		$start = $range['start'];
+		$end   = $range['end'];
+
+		$duration = max( 0, $end->getTimestamp() - $start->getTimestamp() );
+		$prev_end = $start->modify( '-1 second' );
+		$prev_start = $prev_end->modify( '-' . $duration . ' seconds' );
+
+		return $this->format_range( $prev_start, $prev_end );
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start'       => $start,
+			'end'         => $end,
+			'start_mysql' => $start->format( 'Y-m-d H:i:s' ),
+			'end_mysql'   => $end->format( 'Y-m-d H:i:s' ),
+			'start_date'  => $start->format( 'Y-m-d' ),
+			'end_date'    => $end->format( 'Y-m-d' ),
+		);
+	}
+
+	/**
+	 * @param DateTimeImmutable $now Current time.
+	 * @param DateTimeZone      $timezone Timezone.
+	 * @return DateTimeImmutable
+	 */
+	private function start_of_week( DateTimeImmutable $now, DateTimeZone $timezone ) {
+		$week_start = 1;
+		if ( function_exists( 'get_option' ) ) {
+			$week_start = intval( get_option( 'start_of_week', 1 ) );
+		}
+
+		$weekday = intval( $now->format( 'w' ) );
+		$diff    = ( $weekday - $week_start + 7 ) % 7;
+
+		return $now->modify( '-' . $diff . ' days' )->setTime( 0, 0, 0 )->setTimezone( $timezone );
+	}
+
+	/**
+	 * @param string       $value Date string.
+	 * @param DateTimeZone $timezone Timezone.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_input( $value, DateTimeZone $timezone ) {
+		$value = trim( (string) $value );
+		if ( '' === $value ) {
+			return null;
+		}
+
+		$date = DateTimeImmutable::createFromFormat( 'Y-m-d', $value, $timezone );
+		if ( false === $date ) {
+			return null;
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param array $statuses Status list.
+	 * @param array $params Parameters to append to.
+	 * @param string $column Column name.
+	 * @return string
+	 */
+	private function build_status_clause( array $statuses, array &$params, $column = 'status' ) {
+		if ( empty( $statuses ) ) {
+			return '';
+		}
+
+		$placeholders = implode( ', ', array_fill( 0, count( $statuses ), '%s' ) );
+		foreach ( $statuses as $status ) {
+			$params[] = $status;
+		}
+
+		return " AND {$column} IN ({$placeholders})";
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_paid_statuses() {
+		$statuses = function_exists( 'wc_get_is_paid_statuses' )
+			? wc_get_is_paid_statuses()
+			: array( 'processing', 'completed', 'on-hold' );
+
+		$normalized = array();
+		foreach ( $statuses as $status ) {
+			$status = sanitize_text_field( $status );
+			$status = trim( $status );
+			if ( '' === $status ) {
+				continue;
+			}
+
+			$normalized[] = $status;
+			if ( 0 === strpos( $status, 'wc-' ) ) {
+				$normalized[] = substr( $status, 3 );
+			} else {
+				$normalized[] = 'wc-' . $status;
+			}
+		}
+
+		$normalized = array_unique( $normalized );
+		sort( $normalized );
+
+		return $normalized;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Input amount.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return (float) round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return (int) wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return string
+	 */
+	private function format_currency( $value ) {
+		if ( '' === $value || null === $value ) {
+			return '';
+		}
+
+		if ( function_exists( 'wc_price' ) ) {
+			return wp_strip_all_tags( wc_price( $value ) );
+		}
+
+		return (string) $value;
+	}
+
+	/**
+	 * @param array $payload Cache payload.
+	 * @return string
+	 */
+	private function build_cache_key( array $payload ) {
+		$encoded = function_exists( 'wp_json_encode' ) ? wp_json_encode( $payload ) : json_encode( $payload );
+		$hash    = $encoded ? md5( $encoded ) : md5( 'sales_report' );
+
+		return Plugin::TRANSIENT_PREFIX . 'sales_report_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @param array  $payload Cache payload.
+	 * @param int    $ttl Cache TTL.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $payload, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $payload, $ttl );
+	}
+
+	/**
+	 * @param array  $range Date range.
+	 * @param string $period Period.
+	 * @return int
+	 */
+	private function get_cache_ttl( array $range, $period ) {
+		if ( 'today' === $period || $this->range_is_today( $range ) ) {
+			return self::CACHE_TTL_TODAY;
+		}
+
+		return self::CACHE_TTL_DEFAULT;
+	}
+
+	/**
+	 * @param array $range Date range.
+	 * @return bool
+	 */
+	private function range_is_today( array $range ) {
+		$timezone = $this->get_timezone();
+		$today    = ( new DateTimeImmutable( 'now', $timezone ) )->format( 'Y-m-d' );
+
+		return $range['start']->format( 'Y-m-d' ) === $today && $range['end']->format( 'Y-m-d' ) === $today;
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return bool
+	 */
+	private function table_exists( $table ) {
+		global $wpdb;
+
+		$found = $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table ) );
+		return $found === $table;
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @param string $column Column name.
+	 * @return bool
+	 */
+	private function table_has_column( $table, $column ) {
+		static $cache = array();
+		$key = $table . ':' . $column;
+
+		if ( isset( $cache[ $key ] ) ) {
+			return $cache[ $key ];
+		}
+
+		global $wpdb;
+		$result = $wpdb->get_var( $wpdb->prepare( 'SHOW COLUMNS FROM ' . $table . ' LIKE %s', $column ) );
+		$cache[ $key ] = ! empty( $result );
+
+		return $cache[ $key ];
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return string|null
+	 */
+	private function get_product_revenue_column( $table ) {
+		if ( $this->table_has_column( $table, 'product_net_revenue' ) ) {
+			return 'product_net_revenue';
+		}
+
+		if ( $this->table_has_column( $table, 'product_gross_revenue' ) ) {
+			return 'product_gross_revenue';
+		}
+
+		return null;
+	}
+}



thinking
**Reviewing code nuances and potential improvements**
thinking
**Weighing numeric versus formatted currency outputs**
exec
/bin/zsh -lc 'rg -n "total_revenue|refund_total|net_revenue|average_order_value|top_products|top_categories" -S react src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
src/Handlers/AnalyticsHandler.php:106:		$total_revenue = $this->normalize_amount( $totals['total_revenue'] );
src/Handlers/AnalyticsHandler.php:107:		$net_revenue   = $this->normalize_amount( $totals['net_revenue'] );
src/Handlers/AnalyticsHandler.php:111:		$refund_total = $total_revenue - $net_revenue;
src/Handlers/AnalyticsHandler.php:112:		if ( $refund_total < 0 ) {
src/Handlers/AnalyticsHandler.php:113:			$refund_total = 0;
src/Handlers/AnalyticsHandler.php:116:		$average_order_value = 0.0;
src/Handlers/AnalyticsHandler.php:118:			$average_order_value = $this->normalize_amount( $total_revenue / $order_count );
src/Handlers/AnalyticsHandler.php:125:			'total_revenue'      => array(
src/Handlers/AnalyticsHandler.php:126:				'amount'    => $total_revenue,
src/Handlers/AnalyticsHandler.php:127:				'formatted' => $this->format_currency( $total_revenue ),
src/Handlers/AnalyticsHandler.php:130:			'average_order_value' => array(
src/Handlers/AnalyticsHandler.php:131:				'amount'    => $average_order_value,
src/Handlers/AnalyticsHandler.php:132:				'formatted' => $this->format_currency( $average_order_value ),
src/Handlers/AnalyticsHandler.php:135:			'refund_total'       => array(
src/Handlers/AnalyticsHandler.php:136:				'amount'    => $this->normalize_amount( $refund_total ),
src/Handlers/AnalyticsHandler.php:137:				'formatted' => $this->format_currency( $refund_total ),
src/Handlers/AnalyticsHandler.php:139:			'net_revenue'        => array(
src/Handlers/AnalyticsHandler.php:140:				'amount'    => $net_revenue,
src/Handlers/AnalyticsHandler.php:141:				'formatted' => $this->format_currency( $net_revenue ),
src/Handlers/AnalyticsHandler.php:143:			'top_products'       => $this->query_top_products( $range, $statuses ),
file update:
diff --git a/src/Handlers/AnalyticsHandler.php b/src/Handlers/AnalyticsHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..aeb740a9b75d6ed62e72c81955fd341be113a91f
--- /dev/null
+++ b/src/Handlers/AnalyticsHandler.php
@@ -0,0 +1,805 @@
+<?php
+/**
+ * Handle sales analytics reports.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class AnalyticsHandler {
+	const CACHE_TTL_TODAY   = 300;
+	const CACHE_TTL_DEFAULT = 3600;
+	const TOP_LIMIT         = 5;
+
+	/**
+	 * Handle analytics requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to fetch analytics.', 400 );
+		}
+
+		global $wpdb;
+		if ( ! $wpdb ) {
+			return Response::error( 'Database is unavailable for analytics.', 500 );
+		}
+
+		$period = isset( $args['period'] ) ? sanitize_text_field( $args['period'] ) : '';
+		$period = strtolower( trim( $period ) );
+
+		$valid_periods = array( 'today', 'yesterday', 'this_week', 'last_week', 'this_month', 'last_month', 'custom' );
+		if ( ! in_array( $period, $valid_periods, true ) ) {
+			return Response::error( 'Invalid period for sales report.', 400 );
+		}
+
+		$start_input = isset( $args['start_date'] ) ? sanitize_text_field( $args['start_date'] ) : '';
+		$end_input   = isset( $args['end_date'] ) ? sanitize_text_field( $args['end_date'] ) : '';
+		$compare     = $this->normalize_bool( isset( $args['compare_previous'] ) ? $args['compare_previous'] : false );
+
+		$range = $this->resolve_period_range( $period, $start_input, $end_input );
+		if ( null === $range ) {
+			return Response::error( 'Invalid date range for sales report.', 400 );
+		}
+
+		$order_stats_table = $wpdb->prefix . 'wc_order_stats';
+		if ( ! $this->table_exists( $order_stats_table ) ) {
+			return Response::error( 'WooCommerce analytics tables are unavailable.', 500 );
+		}
+
+		$cache_key = $this->build_cache_key(
+			array(
+				'period'           => $period,
+				'start'            => $range['start_mysql'],
+				'end'              => $range['end_mysql'],
+				'compare_previous' => $compare,
+			)
+		);
+		$cached    = $this->read_cache( $cache_key );
+		if ( null !== $cached ) {
+			$cached['cached'] = true;
+			return Response::success( $cached );
+		}
+
+		$statuses = $this->get_paid_statuses();
+		$current  = $this->build_report( $period, $range, $statuses );
+
+		if ( $compare ) {
+			$previous_range = $this->build_previous_range( $range );
+			$previous       = $this->build_report( $period, $previous_range, $statuses );
+			$payload        = array(
+				'period'            => $period,
+				'compare_previous'  => true,
+				'current_period'    => $current,
+				'previous_period'   => $previous,
+				'percentage_change' => $this->build_percentage_change( $current, $previous ),
+			);
+		} else {
+			$payload = $current;
+		}
+
+		$payload['cached'] = false;
+
+		$this->write_cache( $cache_key, $payload, $this->get_cache_ttl( $range, $period ) );
+
+		return Response::success( $payload );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param array  $range Date range data.
+	 * @param array  $statuses Status list.
+	 * @return array
+	 */
+	private function build_report( $period, array $range, array $statuses ) {
+		$totals = $this->query_totals( $range, $statuses );
+
+		$total_revenue = $this->normalize_amount( $totals['total_revenue'] );
+		$net_revenue   = $this->normalize_amount( $totals['net_revenue'] );
+		$order_count   = absint( $totals['order_count'] );
+		$items_sold    = absint( $totals['items_sold'] );
+
+		$refund_total = $total_revenue - $net_revenue;
+		if ( $refund_total < 0 ) {
+			$refund_total = 0;
+		}
+
+		$average_order_value = 0.0;
+		if ( $order_count > 0 ) {
+			$average_order_value = $this->normalize_amount( $total_revenue / $order_count );
+		}
+
+		return array(
+			'period'             => $period,
+			'start_date'         => $range['start_date'],
+			'end_date'           => $range['end_date'],
+			'total_revenue'      => array(
+				'amount'    => $total_revenue,
+				'formatted' => $this->format_currency( $total_revenue ),
+			),
+			'order_count'        => $order_count,
+			'average_order_value' => array(
+				'amount'    => $average_order_value,
+				'formatted' => $this->format_currency( $average_order_value ),
+			),
+			'items_sold'         => $items_sold,
+			'refund_total'       => array(
+				'amount'    => $this->normalize_amount( $refund_total ),
+				'formatted' => $this->format_currency( $refund_total ),
+			),
+			'net_revenue'        => array(
+				'amount'    => $net_revenue,
+				'formatted' => $this->format_currency( $net_revenue ),
+			),
+			'top_products'       => $this->query_top_products( $range, $statuses ),
+			'top_categories'     => $this->query_top_categories( $range, $statuses ),
+		);
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_totals( array $range, array $statuses ) {
+		global $wpdb;
+
+		$table             = $wpdb->prefix . 'wc_order_stats';
+		$has_total_sales   = $this->table_has_column( $table, 'total_sales' );
+		$has_items_sold    = $this->table_has_column( $table, 'num_items_sold' );
+		$total_column      = $has_total_sales ? 'total_sales' : 'net_total';
+		$items_select      = $has_items_sold ? 'COALESCE(SUM(num_items_sold), 0) AS items_sold' : '0 AS items_sold';
+		$parent_filter_sql = $this->table_has_column( $table, 'parent_id' ) ? ' AND parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params );
+
+		$sql = "
+			SELECT
+				COALESCE(SUM({$total_column}), 0) AS total_revenue,
+				COALESCE(SUM(net_total), 0) AS net_revenue,
+				{$items_select},
+				COUNT(order_id) AS order_count
+			FROM {$table}
+			WHERE date_created >= %s
+				AND date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$row = $wpdb->get_row( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( ! is_array( $row ) ) {
+			$row = array(
+				'total_revenue' => 0,
+				'net_revenue'   => 0,
+				'items_sold'    => 0,
+				'order_count'   => 0,
+			);
+		}
+
+		if ( ! $has_items_sold ) {
+			$row['items_sold'] = $this->query_items_sold( $range, $statuses );
+		}
+
+		return $row;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return int
+	 */
+	private function query_items_sold( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table  = $wpdb->prefix . 'wc_order_stats';
+		$items_table  = $wpdb->prefix . 'wc_order_product_lookup';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		if ( ! $this->table_exists( $items_table ) ) {
+			return 0;
+		}
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT COALESCE(SUM(lookup.product_qty), 0)
+			FROM {$items_table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$total = $wpdb->get_var( $wpdb->prepare( $sql, $params ) );
+		return absint( $total );
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_products( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				lookup.product_id AS product_id,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select},
+				COALESCE(posts.post_title, '') AS product_name
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			LEFT JOIN {$wpdb->posts} AS posts
+				ON posts.ID = lookup.product_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+			GROUP BY lookup.product_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'product_id' => absint( $row['product_id'] ),
+				'name'       => sanitize_text_field( $row['product_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => array(
+					'amount'    => $revenue,
+					'formatted' => $this->format_currency( $revenue ),
+				),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_categories( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				terms.term_id AS term_id,
+				terms.name AS category_name,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select}
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			INNER JOIN {$wpdb->term_relationships} AS rel
+				ON rel.object_id = lookup.product_id
+			INNER JOIN {$wpdb->term_taxonomy} AS tax
+				ON tax.term_taxonomy_id = rel.term_taxonomy_id
+			INNER JOIN {$wpdb->terms} AS terms
+				ON terms.term_id = tax.term_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+				AND tax.taxonomy = 'product_cat'
+			GROUP BY terms.term_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'term_id'    => absint( $row['term_id'] ),
+				'name'       => sanitize_text_field( $row['category_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => array(
+					'amount'    => $revenue,
+					'formatted' => $this->format_currency( $revenue ),
+				),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $current Current report.
+	 * @param array $previous Previous report.
+	 * @return array
+	 */
+	private function build_percentage_change( array $current, array $previous ) {
+		$metrics = array(
+			'total_revenue',
+			'order_count',
+			'average_order_value',
+			'items_sold',
+			'refund_total',
+			'net_revenue',
+		);
+
+		$changes = array();
+		foreach ( $metrics as $metric ) {
+			$current_value  = $this->extract_metric_value( $current, $metric );
+			$previous_value = $this->extract_metric_value( $previous, $metric );
+			$changes[ $metric ] = $this->calculate_percentage_change( $current_value, $previous_value );
+		}
+
+		return $changes;
+	}
+
+	/**
+	 * @param array  $report Report data.
+	 * @param string $metric Metric key.
+	 * @return float
+	 */
+	private function extract_metric_value( array $report, $metric ) {
+		if ( ! isset( $report[ $metric ] ) ) {
+			return 0.0;
+		}
+
+		$value = $report[ $metric ];
+		if ( is_array( $value ) && isset( $value['amount'] ) ) {
+			return (float) $value['amount'];
+		}
+
+		return (float) $value;
+	}
+
+	/**
+	 * @param float $current Current value.
+	 * @param float $previous Previous value.
+	 * @return float|null
+	 */
+	private function calculate_percentage_change( $current, $previous ) {
+		$current  = (float) $current;
+		$previous = (float) $previous;
+
+		if ( 0.0 === $previous ) {
+			return 0.0 === $current ? 0.0 : null;
+		}
+
+		$change = ( ( $current - $previous ) / $previous ) * 100;
+
+		return (float) $this->normalize_amount( $change );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param string $start_input Start date input.
+	 * @param string $end_input End date input.
+	 * @return array|null
+	 */
+	private function resolve_period_range( $period, $start_input, $end_input ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+
+		switch ( $period ) {
+			case 'today':
+				$start = $now->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'yesterday':
+				$start = $now->modify( '-1 day' )->setTime( 0, 0, 0 );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'this_week':
+				$start = $this->start_of_week( $now, $timezone );
+				$end   = $now;
+				break;
+			case 'last_week':
+				$current_week_start = $this->start_of_week( $now, $timezone );
+				$end   = $current_week_start->modify( '-1 second' );
+				$start = $current_week_start->modify( '-7 days' )->setTime( 0, 0, 0 );
+				break;
+			case 'this_month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'last_month':
+				$start = $now->modify( 'first day of last month' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( 'last day of last month' )->setTime( 23, 59, 59 );
+				break;
+			case 'custom':
+				$start_date = $this->parse_date_input( $start_input, $timezone );
+				$end_date   = $this->parse_date_input( $end_input, $timezone );
+				if ( null === $start_date || null === $end_date ) {
+					return null;
+				}
+
+				$start = $start_date->setTime( 0, 0, 0 );
+				$end   = $end_date->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		if ( $end < $start ) {
+			$temp  = $start;
+			$start = $end;
+			$end   = $temp;
+		}
+
+		return $this->format_range( $start, $end );
+	}
+
+	/**
+	 * @param array $range Current range data.
+	 * @return array
+	 */
+	private function build_previous_range( array $range ) {
+		$start = $range['start'];
+		$end   = $range['end'];
+
+		$duration = max( 0, $end->getTimestamp() - $start->getTimestamp() );
+		$prev_end = $start->modify( '-1 second' );
+		$prev_start = $prev_end->modify( '-' . $duration . ' seconds' );
+
+		return $this->format_range( $prev_start, $prev_end );
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start'       => $start,
+			'end'         => $end,
+			'start_mysql' => $start->format( 'Y-m-d H:i:s' ),
+			'end_mysql'   => $end->format( 'Y-m-d H:i:s' ),
+			'start_date'  => $start->format( 'Y-m-d' ),
+			'end_date'    => $end->format( 'Y-m-d' ),
+		);
+	}
+
+	/**
+	 * @param DateTimeImmutable $now Current time.
+	 * @param DateTimeZone      $timezone Timezone.
+	 * @return DateTimeImmutable
+	 */
+	private function start_of_week( DateTimeImmutable $now, DateTimeZone $timezone ) {
+		$week_start = 1;
+		if ( function_exists( 'get_option' ) ) {
+			$week_start = intval( get_option( 'start_of_week', 1 ) );
+		}
+
+		$weekday = intval( $now->format( 'w' ) );
+		$diff    = ( $weekday - $week_start + 7 ) % 7;
+
+		return $now->modify( '-' . $diff . ' days' )->setTime( 0, 0, 0 )->setTimezone( $timezone );
+	}
+
+	/**
+	 * @param string       $value Date string.
+	 * @param DateTimeZone $timezone Timezone.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_input( $value, DateTimeZone $timezone ) {
+		$value = trim( (string) $value );
+		if ( '' === $value ) {
+			return null;
+		}
+
+		$date = DateTimeImmutable::createFromFormat( 'Y-m-d', $value, $timezone );
+		if ( false === $date ) {
+			return null;
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param array $statuses Status list.
+	 * @param array $params Parameters to append to.
+	 * @param string $column Column name.
+	 * @return string
+	 */
+	private function build_status_clause( array $statuses, array &$params, $column = 'status' ) {
+		if ( empty( $statuses ) ) {
+			return '';
+		}
+
+		$placeholders = implode( ', ', array_fill( 0, count( $statuses ), '%s' ) );
+		foreach ( $statuses as $status ) {
+			$params[] = $status;
+		}
+
+		return " AND {$column} IN ({$placeholders})";
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_paid_statuses() {
+		$statuses = function_exists( 'wc_get_is_paid_statuses' )
+			? wc_get_is_paid_statuses()
+			: array( 'processing', 'completed', 'on-hold' );
+
+		$normalized = array();
+		foreach ( $statuses as $status ) {
+			$status = sanitize_text_field( $status );
+			$status = trim( $status );
+			if ( '' === $status ) {
+				continue;
+			}
+
+			$normalized[] = $status;
+			if ( 0 === strpos( $status, 'wc-' ) ) {
+				$normalized[] = substr( $status, 3 );
+			} else {
+				$normalized[] = 'wc-' . $status;
+			}
+		}
+
+		$normalized = array_unique( $normalized );
+		sort( $normalized );
+
+		return $normalized;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Input amount.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return (float) round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return (int) wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return string
+	 */
+	private function format_currency( $value ) {
+		if ( '' === $value || null === $value ) {
+			return '';
+		}
+
+		if ( function_exists( 'wc_price' ) ) {
+			return wp_strip_all_tags( wc_price( $value ) );
+		}
+
+		return (string) $value;
+	}
+
+	/**
+	 * @param array $payload Cache payload.
+	 * @return string
+	 */
+	private function build_cache_key( array $payload ) {
+		$encoded = function_exists( 'wp_json_encode' ) ? wp_json_encode( $payload ) : json_encode( $payload );
+		$hash    = $encoded ? md5( $encoded ) : md5( 'sales_report' );
+
+		return Plugin::TRANSIENT_PREFIX . 'sales_report_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @param array  $payload Cache payload.
+	 * @param int    $ttl Cache TTL.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $payload, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $payload, $ttl );
+	}
+
+	/**
+	 * @param array  $range Date range.
+	 * @param string $period Period.
+	 * @return int
+	 */
+	private function get_cache_ttl( array $range, $period ) {
+		if ( 'today' === $period || $this->range_is_today( $range ) ) {
+			return self::CACHE_TTL_TODAY;
+		}
+
+		return self::CACHE_TTL_DEFAULT;
+	}
+
+	/**
+	 * @param array $range Date range.
+	 * @return bool
+	 */
+	private function range_is_today( array $range ) {
+		$timezone = $this->get_timezone();
+		$today    = ( new DateTimeImmutable( 'now', $timezone ) )->format( 'Y-m-d' );
+
+		return $range['start']->format( 'Y-m-d' ) === $today && $range['end']->format( 'Y-m-d' ) === $today;
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return bool
+	 */
+	private function table_exists( $table ) {
+		global $wpdb;
+
+		$found = $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table ) );
+		return $found === $table;
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @param string $column Column name.
+	 * @return bool
+	 */
+	private function table_has_column( $table, $column ) {
+		static $cache = array();
+		$key = $table . ':' . $column;
+
+		if ( isset( $cache[ $key ] ) ) {
+			return $cache[ $key ];
+		}
+
+		global $wpdb;
+		$result = $wpdb->get_var( $wpdb->prepare( 'SHOW COLUMNS FROM ' . $table . ' LIKE %s', $column ) );
+		$cache[ $key ] = ! empty( $result );
+
+		return $cache[ $key ];
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return string|null
+	 */
+	private function get_product_revenue_column( $table ) {
+		if ( $this->table_has_column( $table, 'product_net_revenue' ) ) {
+			return 'product_net_revenue';
+		}
+
+		if ( $this->table_has_column( $table, 'product_gross_revenue' ) ) {
+			return 'product_gross_revenue';
+		}
+
+		return null;
+	}
+}


thinking
**Evaluating currency formatting approach**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/AnalyticsHandler.php
@@ -124,20 +124,12 @@
 			'end_date'           => $range['end_date'],
-			'total_revenue'      => array(
-				'amount'    => $total_revenue,
-				'formatted' => $this->format_currency( $total_revenue ),
-			),
+			'total_revenue'      => $total_revenue,
+			'total_revenue_formatted' => $this->format_currency( $total_revenue ),
 			'order_count'        => $order_count,
-			'average_order_value' => array(
-				'amount'    => $average_order_value,
-				'formatted' => $this->format_currency( $average_order_value ),
-			),
+			'average_order_value' => $average_order_value,
+			'average_order_value_formatted' => $this->format_currency( $average_order_value ),
 			'items_sold'         => $items_sold,
-			'refund_total'       => array(
-				'amount'    => $this->normalize_amount( $refund_total ),
-				'formatted' => $this->format_currency( $refund_total ),
-			),
-			'net_revenue'        => array(
-				'amount'    => $net_revenue,
-				'formatted' => $this->format_currency( $net_revenue ),
-			),
+			'refund_total'       => $this->normalize_amount( $refund_total ),
+			'refund_total_formatted' => $this->format_currency( $refund_total ),
+			'net_revenue'        => $net_revenue,
+			'net_revenue_formatted' => $this->format_currency( $net_revenue ),
 			'top_products'       => $this->query_top_products( $range, $statuses ),
@@ -289,6 +281,4 @@
 				'items_sold' => absint( $row['items_sold'] ),
-				'net_revenue' => array(
-					'amount'    => $revenue,
-					'formatted' => $this->format_currency( $revenue ),
-				),
+				'net_revenue' => $revenue,
+				'net_revenue_formatted' => $this->format_currency( $revenue ),
 			);
@@ -364,6 +354,4 @@
 				'items_sold' => absint( $row['items_sold'] ),
-				'net_revenue' => array(
-					'amount'    => $revenue,
-					'formatted' => $this->format_currency( $revenue ),
-				),
+				'net_revenue' => $revenue,
+				'net_revenue_formatted' => $this->format_currency( $revenue ),
 			);
apply_patch(auto_approved=true) exited 0 in 28ms:
Success. Updated the following files:
M src/Handlers/AnalyticsHandler.php
file update:
diff --git a/src/Handlers/AnalyticsHandler.php b/src/Handlers/AnalyticsHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..38e71e091a57c9064f796a9af87696859948a87c
--- /dev/null
+++ b/src/Handlers/AnalyticsHandler.php
@@ -0,0 +1,793 @@
+<?php
+/**
+ * Handle sales analytics reports.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class AnalyticsHandler {
+	const CACHE_TTL_TODAY   = 300;
+	const CACHE_TTL_DEFAULT = 3600;
+	const TOP_LIMIT         = 5;
+
+	/**
+	 * Handle analytics requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to fetch analytics.', 400 );
+		}
+
+		global $wpdb;
+		if ( ! $wpdb ) {
+			return Response::error( 'Database is unavailable for analytics.', 500 );
+		}
+
+		$period = isset( $args['period'] ) ? sanitize_text_field( $args['period'] ) : '';
+		$period = strtolower( trim( $period ) );
+
+		$valid_periods = array( 'today', 'yesterday', 'this_week', 'last_week', 'this_month', 'last_month', 'custom' );
+		if ( ! in_array( $period, $valid_periods, true ) ) {
+			return Response::error( 'Invalid period for sales report.', 400 );
+		}
+
+		$start_input = isset( $args['start_date'] ) ? sanitize_text_field( $args['start_date'] ) : '';
+		$end_input   = isset( $args['end_date'] ) ? sanitize_text_field( $args['end_date'] ) : '';
+		$compare     = $this->normalize_bool( isset( $args['compare_previous'] ) ? $args['compare_previous'] : false );
+
+		$range = $this->resolve_period_range( $period, $start_input, $end_input );
+		if ( null === $range ) {
+			return Response::error( 'Invalid date range for sales report.', 400 );
+		}
+
+		$order_stats_table = $wpdb->prefix . 'wc_order_stats';
+		if ( ! $this->table_exists( $order_stats_table ) ) {
+			return Response::error( 'WooCommerce analytics tables are unavailable.', 500 );
+		}
+
+		$cache_key = $this->build_cache_key(
+			array(
+				'period'           => $period,
+				'start'            => $range['start_mysql'],
+				'end'              => $range['end_mysql'],
+				'compare_previous' => $compare,
+			)
+		);
+		$cached    = $this->read_cache( $cache_key );
+		if ( null !== $cached ) {
+			$cached['cached'] = true;
+			return Response::success( $cached );
+		}
+
+		$statuses = $this->get_paid_statuses();
+		$current  = $this->build_report( $period, $range, $statuses );
+
+		if ( $compare ) {
+			$previous_range = $this->build_previous_range( $range );
+			$previous       = $this->build_report( $period, $previous_range, $statuses );
+			$payload        = array(
+				'period'            => $period,
+				'compare_previous'  => true,
+				'current_period'    => $current,
+				'previous_period'   => $previous,
+				'percentage_change' => $this->build_percentage_change( $current, $previous ),
+			);
+		} else {
+			$payload = $current;
+		}
+
+		$payload['cached'] = false;
+
+		$this->write_cache( $cache_key, $payload, $this->get_cache_ttl( $range, $period ) );
+
+		return Response::success( $payload );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param array  $range Date range data.
+	 * @param array  $statuses Status list.
+	 * @return array
+	 */
+	private function build_report( $period, array $range, array $statuses ) {
+		$totals = $this->query_totals( $range, $statuses );
+
+		$total_revenue = $this->normalize_amount( $totals['total_revenue'] );
+		$net_revenue   = $this->normalize_amount( $totals['net_revenue'] );
+		$order_count   = absint( $totals['order_count'] );
+		$items_sold    = absint( $totals['items_sold'] );
+
+		$refund_total = $total_revenue - $net_revenue;
+		if ( $refund_total < 0 ) {
+			$refund_total = 0;
+		}
+
+		$average_order_value = 0.0;
+		if ( $order_count > 0 ) {
+			$average_order_value = $this->normalize_amount( $total_revenue / $order_count );
+		}
+
+		return array(
+			'period'             => $period,
+			'start_date'         => $range['start_date'],
+			'end_date'           => $range['end_date'],
+			'total_revenue'      => $total_revenue,
+			'total_revenue_formatted' => $this->format_currency( $total_revenue ),
+			'order_count'        => $order_count,
+			'average_order_value' => $average_order_value,
+			'average_order_value_formatted' => $this->format_currency( $average_order_value ),
+			'items_sold'         => $items_sold,
+			'refund_total'       => $this->normalize_amount( $refund_total ),
+			'refund_total_formatted' => $this->format_currency( $refund_total ),
+			'net_revenue'        => $net_revenue,
+			'net_revenue_formatted' => $this->format_currency( $net_revenue ),
+			'top_products'       => $this->query_top_products( $range, $statuses ),
+			'top_categories'     => $this->query_top_categories( $range, $statuses ),
+		);
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_totals( array $range, array $statuses ) {
+		global $wpdb;
+
+		$table             = $wpdb->prefix . 'wc_order_stats';
+		$has_total_sales   = $this->table_has_column( $table, 'total_sales' );
+		$has_items_sold    = $this->table_has_column( $table, 'num_items_sold' );
+		$total_column      = $has_total_sales ? 'total_sales' : 'net_total';
+		$items_select      = $has_items_sold ? 'COALESCE(SUM(num_items_sold), 0) AS items_sold' : '0 AS items_sold';
+		$parent_filter_sql = $this->table_has_column( $table, 'parent_id' ) ? ' AND parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params );
+
+		$sql = "
+			SELECT
+				COALESCE(SUM({$total_column}), 0) AS total_revenue,
+				COALESCE(SUM(net_total), 0) AS net_revenue,
+				{$items_select},
+				COUNT(order_id) AS order_count
+			FROM {$table}
+			WHERE date_created >= %s
+				AND date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$row = $wpdb->get_row( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( ! is_array( $row ) ) {
+			$row = array(
+				'total_revenue' => 0,
+				'net_revenue'   => 0,
+				'items_sold'    => 0,
+				'order_count'   => 0,
+			);
+		}
+
+		if ( ! $has_items_sold ) {
+			$row['items_sold'] = $this->query_items_sold( $range, $statuses );
+		}
+
+		return $row;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return int
+	 */
+	private function query_items_sold( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table  = $wpdb->prefix . 'wc_order_stats';
+		$items_table  = $wpdb->prefix . 'wc_order_product_lookup';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		if ( ! $this->table_exists( $items_table ) ) {
+			return 0;
+		}
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT COALESCE(SUM(lookup.product_qty), 0)
+			FROM {$items_table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$total = $wpdb->get_var( $wpdb->prepare( $sql, $params ) );
+		return absint( $total );
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_products( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				lookup.product_id AS product_id,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select},
+				COALESCE(posts.post_title, '') AS product_name
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			LEFT JOIN {$wpdb->posts} AS posts
+				ON posts.ID = lookup.product_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+			GROUP BY lookup.product_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'product_id' => absint( $row['product_id'] ),
+				'name'       => sanitize_text_field( $row['product_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => $revenue,
+				'net_revenue_formatted' => $this->format_currency( $revenue ),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_categories( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				terms.term_id AS term_id,
+				terms.name AS category_name,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select}
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			INNER JOIN {$wpdb->term_relationships} AS rel
+				ON rel.object_id = lookup.product_id
+			INNER JOIN {$wpdb->term_taxonomy} AS tax
+				ON tax.term_taxonomy_id = rel.term_taxonomy_id
+			INNER JOIN {$wpdb->terms} AS terms
+				ON terms.term_id = tax.term_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+				AND tax.taxonomy = 'product_cat'
+			GROUP BY terms.term_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'term_id'    => absint( $row['term_id'] ),
+				'name'       => sanitize_text_field( $row['category_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => $revenue,
+				'net_revenue_formatted' => $this->format_currency( $revenue ),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $current Current report.
+	 * @param array $previous Previous report.
+	 * @return array
+	 */
+	private function build_percentage_change( array $current, array $previous ) {
+		$metrics = array(
+			'total_revenue',
+			'order_count',
+			'average_order_value',
+			'items_sold',
+			'refund_total',
+			'net_revenue',
+		);
+
+		$changes = array();
+		foreach ( $metrics as $metric ) {
+			$current_value  = $this->extract_metric_value( $current, $metric );
+			$previous_value = $this->extract_metric_value( $previous, $metric );
+			$changes[ $metric ] = $this->calculate_percentage_change( $current_value, $previous_value );
+		}
+
+		return $changes;
+	}
+
+	/**
+	 * @param array  $report Report data.
+	 * @param string $metric Metric key.
+	 * @return float
+	 */
+	private function extract_metric_value( array $report, $metric ) {
+		if ( ! isset( $report[ $metric ] ) ) {
+			return 0.0;
+		}
+
+		$value = $report[ $metric ];
+		if ( is_array( $value ) && isset( $value['amount'] ) ) {
+			return (float) $value['amount'];
+		}
+
+		return (float) $value;
+	}
+
+	/**
+	 * @param float $current Current value.
+	 * @param float $previous Previous value.
+	 * @return float|null
+	 */
+	private function calculate_percentage_change( $current, $previous ) {
+		$current  = (float) $current;
+		$previous = (float) $previous;
+
+		if ( 0.0 === $previous ) {
+			return 0.0 === $current ? 0.0 : null;
+		}
+
+		$change = ( ( $current - $previous ) / $previous ) * 100;
+
+		return (float) $this->normalize_amount( $change );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param string $start_input Start date input.
+	 * @param string $end_input End date input.
+	 * @return array|null
+	 */
+	private function resolve_period_range( $period, $start_input, $end_input ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+
+		switch ( $period ) {
+			case 'today':
+				$start = $now->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'yesterday':
+				$start = $now->modify( '-1 day' )->setTime( 0, 0, 0 );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'this_week':
+				$start = $this->start_of_week( $now, $timezone );
+				$end   = $now;
+				break;
+			case 'last_week':
+				$current_week_start = $this->start_of_week( $now, $timezone );
+				$end   = $current_week_start->modify( '-1 second' );
+				$start = $current_week_start->modify( '-7 days' )->setTime( 0, 0, 0 );
+				break;
+			case 'this_month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'last_month':
+				$start = $now->modify( 'first day of last month' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( 'last day of last month' )->setTime( 23, 59, 59 );
+				break;
+			case 'custom':
+				$start_date = $this->parse_date_input( $start_input, $timezone );
+				$end_date   = $this->parse_date_input( $end_input, $timezone );
+				if ( null === $start_date || null === $end_date ) {
+					return null;
+				}
+
+				$start = $start_date->setTime( 0, 0, 0 );
+				$end   = $end_date->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		if ( $end < $start ) {
+			$temp  = $start;
+			$start = $end;
+			$end   = $temp;
+		}
+
+		return $this->format_range( $start, $end );
+	}
+
+	/**
+	 * @param array $range Current range data.
+	 * @return array
+	 */
+	private function build_previous_range( array $range ) {
+		$start = $range['start'];
+		$end   = $range['end'];
+
+		$duration = max( 0, $end->getTimestamp() - $start->getTimestamp() );
+		$prev_end = $start->modify( '-1 second' );
+		$prev_start = $prev_end->modify( '-' . $duration . ' seconds' );
+
+		return $this->format_range( $prev_start, $prev_end );
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start'       => $start,
+			'end'         => $end,
+			'start_mysql' => $start->format( 'Y-m-d H:i:s' ),
+			'end_mysql'   => $end->format( 'Y-m-d H:i:s' ),
+			'start_date'  => $start->format( 'Y-m-d' ),
+			'end_date'    => $end->format( 'Y-m-d' ),
+		);
+	}
+
+	/**
+	 * @param DateTimeImmutable $now Current time.
+	 * @param DateTimeZone      $timezone Timezone.
+	 * @return DateTimeImmutable
+	 */
+	private function start_of_week( DateTimeImmutable $now, DateTimeZone $timezone ) {
+		$week_start = 1;
+		if ( function_exists( 'get_option' ) ) {
+			$week_start = intval( get_option( 'start_of_week', 1 ) );
+		}
+
+		$weekday = intval( $now->format( 'w' ) );
+		$diff    = ( $weekday - $week_start + 7 ) % 7;
+
+		return $now->modify( '-' . $diff . ' days' )->setTime( 0, 0, 0 )->setTimezone( $timezone );
+	}
+
+	/**
+	 * @param string       $value Date string.
+	 * @param DateTimeZone $timezone Timezone.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_input( $value, DateTimeZone $timezone ) {
+		$value = trim( (string) $value );
+		if ( '' === $value ) {
+			return null;
+		}
+
+		$date = DateTimeImmutable::createFromFormat( 'Y-m-d', $value, $timezone );
+		if ( false === $date ) {
+			return null;
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param array $statuses Status list.
+	 * @param array $params Parameters to append to.
+	 * @param string $column Column name.
+	 * @return string
+	 */
+	private function build_status_clause( array $statuses, array &$params, $column = 'status' ) {
+		if ( empty( $statuses ) ) {
+			return '';
+		}
+
+		$placeholders = implode( ', ', array_fill( 0, count( $statuses ), '%s' ) );
+		foreach ( $statuses as $status ) {
+			$params[] = $status;
+		}
+
+		return " AND {$column} IN ({$placeholders})";
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_paid_statuses() {
+		$statuses = function_exists( 'wc_get_is_paid_statuses' )
+			? wc_get_is_paid_statuses()
+			: array( 'processing', 'completed', 'on-hold' );
+
+		$normalized = array();
+		foreach ( $statuses as $status ) {
+			$status = sanitize_text_field( $status );
+			$status = trim( $status );
+			if ( '' === $status ) {
+				continue;
+			}
+
+			$normalized[] = $status;
+			if ( 0 === strpos( $status, 'wc-' ) ) {
+				$normalized[] = substr( $status, 3 );
+			} else {
+				$normalized[] = 'wc-' . $status;
+			}
+		}
+
+		$normalized = array_unique( $normalized );
+		sort( $normalized );
+
+		return $normalized;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Input amount.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return (float) round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return (int) wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return string
+	 */
+	private function format_currency( $value ) {
+		if ( '' === $value || null === $value ) {
+			return '';
+		}
+
+		if ( function_exists( 'wc_price' ) ) {
+			return wp_strip_all_tags( wc_price( $value ) );
+		}
+
+		return (string) $value;
+	}
+
+	/**
+	 * @param array $payload Cache payload.
+	 * @return string
+	 */
+	private function build_cache_key( array $payload ) {
+		$encoded = function_exists( 'wp_json_encode' ) ? wp_json_encode( $payload ) : json_encode( $payload );
+		$hash    = $encoded ? md5( $encoded ) : md5( 'sales_report' );
+
+		return Plugin::TRANSIENT_PREFIX . 'sales_report_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @param array  $payload Cache payload.
+	 * @param int    $ttl Cache TTL.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $payload, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $payload, $ttl );
+	}
+
+	/**
+	 * @param array  $range Date range.
+	 * @param string $period Period.
+	 * @return int
+	 */
+	private function get_cache_ttl( array $range, $period ) {
+		if ( 'today' === $period || $this->range_is_today( $range ) ) {
+			return self::CACHE_TTL_TODAY;
+		}
+
+		return self::CACHE_TTL_DEFAULT;
+	}
+
+	/**
+	 * @param array $range Date range.
+	 * @return bool
+	 */
+	private function range_is_today( array $range ) {
+		$timezone = $this->get_timezone();
+		$today    = ( new DateTimeImmutable( 'now', $timezone ) )->format( 'Y-m-d' );
+
+		return $range['start']->format( 'Y-m-d' ) === $today && $range['end']->format( 'Y-m-d' ) === $today;
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return bool
+	 */
+	private function table_exists( $table ) {
+		global $wpdb;
+
+		$found = $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table ) );
+		return $found === $table;
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @param string $column Column name.
+	 * @return bool
+	 */
+	private function table_has_column( $table, $column ) {
+		static $cache = array();
+		$key = $table . ':' . $column;
+
+		if ( isset( $cache[ $key ] ) ) {
+			return $cache[ $key ];
+		}
+
+		global $wpdb;
+		$result = $wpdb->get_var( $wpdb->prepare( 'SHOW COLUMNS FROM ' . $table . ' LIKE %s', $column ) );
+		$cache[ $key ] = ! empty( $result );
+
+		return $cache[ $key ];
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return string|null
+	 */
+	private function get_product_revenue_column( $table ) {
+		if ( $this->table_has_column( $table, 'product_net_revenue' ) ) {
+			return 'product_net_revenue';
+		}
+
+		if ( $this->table_has_column( $table, 'product_gross_revenue' ) ) {
+			return 'product_gross_revenue';
+		}
+
+		return null;
+	}
+}

file update:
diff --git a/src/Handlers/AnalyticsHandler.php b/src/Handlers/AnalyticsHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..38e71e091a57c9064f796a9af87696859948a87c
--- /dev/null
+++ b/src/Handlers/AnalyticsHandler.php
@@ -0,0 +1,793 @@
+<?php
+/**
+ * Handle sales analytics reports.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class AnalyticsHandler {
+	const CACHE_TTL_TODAY   = 300;
+	const CACHE_TTL_DEFAULT = 3600;
+	const TOP_LIMIT         = 5;
+
+	/**
+	 * Handle analytics requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to fetch analytics.', 400 );
+		}
+
+		global $wpdb;
+		if ( ! $wpdb ) {
+			return Response::error( 'Database is unavailable for analytics.', 500 );
+		}
+
+		$period = isset( $args['period'] ) ? sanitize_text_field( $args['period'] ) : '';
+		$period = strtolower( trim( $period ) );
+
+		$valid_periods = array( 'today', 'yesterday', 'this_week', 'last_week', 'this_month', 'last_month', 'custom' );
+		if ( ! in_array( $period, $valid_periods, true ) ) {
+			return Response::error( 'Invalid period for sales report.', 400 );
+		}
+
+		$start_input = isset( $args['start_date'] ) ? sanitize_text_field( $args['start_date'] ) : '';
+		$end_input   = isset( $args['end_date'] ) ? sanitize_text_field( $args['end_date'] ) : '';
+		$compare     = $this->normalize_bool( isset( $args['compare_previous'] ) ? $args['compare_previous'] : false );
+
+		$range = $this->resolve_period_range( $period, $start_input, $end_input );
+		if ( null === $range ) {
+			return Response::error( 'Invalid date range for sales report.', 400 );
+		}
+
+		$order_stats_table = $wpdb->prefix . 'wc_order_stats';
+		if ( ! $this->table_exists( $order_stats_table ) ) {
+			return Response::error( 'WooCommerce analytics tables are unavailable.', 500 );
+		}
+
+		$cache_key = $this->build_cache_key(
+			array(
+				'period'           => $period,
+				'start'            => $range['start_mysql'],
+				'end'              => $range['end_mysql'],
+				'compare_previous' => $compare,
+			)
+		);
+		$cached    = $this->read_cache( $cache_key );
+		if ( null !== $cached ) {
+			$cached['cached'] = true;
+			return Response::success( $cached );
+		}
+
+		$statuses = $this->get_paid_statuses();
+		$current  = $this->build_report( $period, $range, $statuses );
+
+		if ( $compare ) {
+			$previous_range = $this->build_previous_range( $range );
+			$previous       = $this->build_report( $period, $previous_range, $statuses );
+			$payload        = array(
+				'period'            => $period,
+				'compare_previous'  => true,
+				'current_period'    => $current,
+				'previous_period'   => $previous,
+				'percentage_change' => $this->build_percentage_change( $current, $previous ),
+			);
+		} else {
+			$payload = $current;
+		}
+
+		$payload['cached'] = false;
+
+		$this->write_cache( $cache_key, $payload, $this->get_cache_ttl( $range, $period ) );
+
+		return Response::success( $payload );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param array  $range Date range data.
+	 * @param array  $statuses Status list.
+	 * @return array
+	 */
+	private function build_report( $period, array $range, array $statuses ) {
+		$totals = $this->query_totals( $range, $statuses );
+
+		$total_revenue = $this->normalize_amount( $totals['total_revenue'] );
+		$net_revenue   = $this->normalize_amount( $totals['net_revenue'] );
+		$order_count   = absint( $totals['order_count'] );
+		$items_sold    = absint( $totals['items_sold'] );
+
+		$refund_total = $total_revenue - $net_revenue;
+		if ( $refund_total < 0 ) {
+			$refund_total = 0;
+		}
+
+		$average_order_value = 0.0;
+		if ( $order_count > 0 ) {
+			$average_order_value = $this->normalize_amount( $total_revenue / $order_count );
+		}
+
+		return array(
+			'period'             => $period,
+			'start_date'         => $range['start_date'],
+			'end_date'           => $range['end_date'],
+			'total_revenue'      => $total_revenue,
+			'total_revenue_formatted' => $this->format_currency( $total_revenue ),
+			'order_count'        => $order_count,
+			'average_order_value' => $average_order_value,
+			'average_order_value_formatted' => $this->format_currency( $average_order_value ),
+			'items_sold'         => $items_sold,
+			'refund_total'       => $this->normalize_amount( $refund_total ),
+			'refund_total_formatted' => $this->format_currency( $refund_total ),
+			'net_revenue'        => $net_revenue,
+			'net_revenue_formatted' => $this->format_currency( $net_revenue ),
+			'top_products'       => $this->query_top_products( $range, $statuses ),
+			'top_categories'     => $this->query_top_categories( $range, $statuses ),
+		);
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_totals( array $range, array $statuses ) {
+		global $wpdb;
+
+		$table             = $wpdb->prefix . 'wc_order_stats';
+		$has_total_sales   = $this->table_has_column( $table, 'total_sales' );
+		$has_items_sold    = $this->table_has_column( $table, 'num_items_sold' );
+		$total_column      = $has_total_sales ? 'total_sales' : 'net_total';
+		$items_select      = $has_items_sold ? 'COALESCE(SUM(num_items_sold), 0) AS items_sold' : '0 AS items_sold';
+		$parent_filter_sql = $this->table_has_column( $table, 'parent_id' ) ? ' AND parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params );
+
+		$sql = "
+			SELECT
+				COALESCE(SUM({$total_column}), 0) AS total_revenue,
+				COALESCE(SUM(net_total), 0) AS net_revenue,
+				{$items_select},
+				COUNT(order_id) AS order_count
+			FROM {$table}
+			WHERE date_created >= %s
+				AND date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$row = $wpdb->get_row( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( ! is_array( $row ) ) {
+			$row = array(
+				'total_revenue' => 0,
+				'net_revenue'   => 0,
+				'items_sold'    => 0,
+				'order_count'   => 0,
+			);
+		}
+
+		if ( ! $has_items_sold ) {
+			$row['items_sold'] = $this->query_items_sold( $range, $statuses );
+		}
+
+		return $row;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return int
+	 */
+	private function query_items_sold( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table  = $wpdb->prefix . 'wc_order_stats';
+		$items_table  = $wpdb->prefix . 'wc_order_product_lookup';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		if ( ! $this->table_exists( $items_table ) ) {
+			return 0;
+		}
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT COALESCE(SUM(lookup.product_qty), 0)
+			FROM {$items_table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$total = $wpdb->get_var( $wpdb->prepare( $sql, $params ) );
+		return absint( $total );
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_products( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				lookup.product_id AS product_id,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select},
+				COALESCE(posts.post_title, '') AS product_name
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			LEFT JOIN {$wpdb->posts} AS posts
+				ON posts.ID = lookup.product_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+			GROUP BY lookup.product_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'product_id' => absint( $row['product_id'] ),
+				'name'       => sanitize_text_field( $row['product_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => $revenue,
+				'net_revenue_formatted' => $this->format_currency( $revenue ),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_categories( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				terms.term_id AS term_id,
+				terms.name AS category_name,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select}
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			INNER JOIN {$wpdb->term_relationships} AS rel
+				ON rel.object_id = lookup.product_id
+			INNER JOIN {$wpdb->term_taxonomy} AS tax
+				ON tax.term_taxonomy_id = rel.term_taxonomy_id
+			INNER JOIN {$wpdb->terms} AS terms
+				ON terms.term_id = tax.term_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+				AND tax.taxonomy = 'product_cat'
+			GROUP BY terms.term_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'term_id'    => absint( $row['term_id'] ),
+				'name'       => sanitize_text_field( $row['category_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => $revenue,
+				'net_revenue_formatted' => $this->format_currency( $revenue ),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $current Current report.
+	 * @param array $previous Previous report.
+	 * @return array
+	 */
+	private function build_percentage_change( array $current, array $previous ) {
+		$metrics = array(
+			'total_revenue',
+			'order_count',
+			'average_order_value',
+			'items_sold',
+			'refund_total',
+			'net_revenue',
+		);
+
+		$changes = array();
+		foreach ( $metrics as $metric ) {
+			$current_value  = $this->extract_metric_value( $current, $metric );
+			$previous_value = $this->extract_metric_value( $previous, $metric );
+			$changes[ $metric ] = $this->calculate_percentage_change( $current_value, $previous_value );
+		}
+
+		return $changes;
+	}
+
+	/**
+	 * @param array  $report Report data.
+	 * @param string $metric Metric key.
+	 * @return float
+	 */
+	private function extract_metric_value( array $report, $metric ) {
+		if ( ! isset( $report[ $metric ] ) ) {
+			return 0.0;
+		}
+
+		$value = $report[ $metric ];
+		if ( is_array( $value ) && isset( $value['amount'] ) ) {
+			return (float) $value['amount'];
+		}
+
+		return (float) $value;
+	}
+
+	/**
+	 * @param float $current Current value.
+	 * @param float $previous Previous value.
+	 * @return float|null
+	 */
+	private function calculate_percentage_change( $current, $previous ) {
+		$current  = (float) $current;
+		$previous = (float) $previous;
+
+		if ( 0.0 === $previous ) {
+			return 0.0 === $current ? 0.0 : null;
+		}
+
+		$change = ( ( $current - $previous ) / $previous ) * 100;
+
+		return (float) $this->normalize_amount( $change );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param string $start_input Start date input.
+	 * @param string $end_input End date input.
+	 * @return array|null
+	 */
+	private function resolve_period_range( $period, $start_input, $end_input ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+
+		switch ( $period ) {
+			case 'today':
+				$start = $now->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'yesterday':
+				$start = $now->modify( '-1 day' )->setTime( 0, 0, 0 );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'this_week':
+				$start = $this->start_of_week( $now, $timezone );
+				$end   = $now;
+				break;
+			case 'last_week':
+				$current_week_start = $this->start_of_week( $now, $timezone );
+				$end   = $current_week_start->modify( '-1 second' );
+				$start = $current_week_start->modify( '-7 days' )->setTime( 0, 0, 0 );
+				break;
+			case 'this_month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'last_month':
+				$start = $now->modify( 'first day of last month' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( 'last day of last month' )->setTime( 23, 59, 59 );
+				break;
+			case 'custom':
+				$start_date = $this->parse_date_input( $start_input, $timezone );
+				$end_date   = $this->parse_date_input( $end_input, $timezone );
+				if ( null === $start_date || null === $end_date ) {
+					return null;
+				}
+
+				$start = $start_date->setTime( 0, 0, 0 );
+				$end   = $end_date->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		if ( $end < $start ) {
+			$temp  = $start;
+			$start = $end;
+			$end   = $temp;
+		}
+
+		return $this->format_range( $start, $end );
+	}
+
+	/**
+	 * @param array $range Current range data.
+	 * @return array
+	 */
+	private function build_previous_range( array $range ) {
+		$start = $range['start'];
+		$end   = $range['end'];
+
+		$duration = max( 0, $end->getTimestamp() - $start->getTimestamp() );
+		$prev_end = $start->modify( '-1 second' );
+		$prev_start = $prev_end->modify( '-' . $duration . ' seconds' );
+
+		return $this->format_range( $prev_start, $prev_end );
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start'       => $start,
+			'end'         => $end,
+			'start_mysql' => $start->format( 'Y-m-d H:i:s' ),
+			'end_mysql'   => $end->format( 'Y-m-d H:i:s' ),
+			'start_date'  => $start->format( 'Y-m-d' ),
+			'end_date'    => $end->format( 'Y-m-d' ),
+		);
+	}
+
+	/**
+	 * @param DateTimeImmutable $now Current time.
+	 * @param DateTimeZone      $timezone Timezone.
+	 * @return DateTimeImmutable
+	 */
+	private function start_of_week( DateTimeImmutable $now, DateTimeZone $timezone ) {
+		$week_start = 1;
+		if ( function_exists( 'get_option' ) ) {
+			$week_start = intval( get_option( 'start_of_week', 1 ) );
+		}
+
+		$weekday = intval( $now->format( 'w' ) );
+		$diff    = ( $weekday - $week_start + 7 ) % 7;
+
+		return $now->modify( '-' . $diff . ' days' )->setTime( 0, 0, 0 )->setTimezone( $timezone );
+	}
+
+	/**
+	 * @param string       $value Date string.
+	 * @param DateTimeZone $timezone Timezone.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_input( $value, DateTimeZone $timezone ) {
+		$value = trim( (string) $value );
+		if ( '' === $value ) {
+			return null;
+		}
+
+		$date = DateTimeImmutable::createFromFormat( 'Y-m-d', $value, $timezone );
+		if ( false === $date ) {
+			return null;
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param array $statuses Status list.
+	 * @param array $params Parameters to append to.
+	 * @param string $column Column name.
+	 * @return string
+	 */
+	private function build_status_clause( array $statuses, array &$params, $column = 'status' ) {
+		if ( empty( $statuses ) ) {
+			return '';
+		}
+
+		$placeholders = implode( ', ', array_fill( 0, count( $statuses ), '%s' ) );
+		foreach ( $statuses as $status ) {
+			$params[] = $status;
+		}
+
+		return " AND {$column} IN ({$placeholders})";
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_paid_statuses() {
+		$statuses = function_exists( 'wc_get_is_paid_statuses' )
+			? wc_get_is_paid_statuses()
+			: array( 'processing', 'completed', 'on-hold' );
+
+		$normalized = array();
+		foreach ( $statuses as $status ) {
+			$status = sanitize_text_field( $status );
+			$status = trim( $status );
+			if ( '' === $status ) {
+				continue;
+			}
+
+			$normalized[] = $status;
+			if ( 0 === strpos( $status, 'wc-' ) ) {
+				$normalized[] = substr( $status, 3 );
+			} else {
+				$normalized[] = 'wc-' . $status;
+			}
+		}
+
+		$normalized = array_unique( $normalized );
+		sort( $normalized );
+
+		return $normalized;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Input amount.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return (float) round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return (int) wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return string
+	 */
+	private function format_currency( $value ) {
+		if ( '' === $value || null === $value ) {
+			return '';
+		}
+
+		if ( function_exists( 'wc_price' ) ) {
+			return wp_strip_all_tags( wc_price( $value ) );
+		}
+
+		return (string) $value;
+	}
+
+	/**
+	 * @param array $payload Cache payload.
+	 * @return string
+	 */
+	private function build_cache_key( array $payload ) {
+		$encoded = function_exists( 'wp_json_encode' ) ? wp_json_encode( $payload ) : json_encode( $payload );
+		$hash    = $encoded ? md5( $encoded ) : md5( 'sales_report' );
+
+		return Plugin::TRANSIENT_PREFIX . 'sales_report_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @param array  $payload Cache payload.
+	 * @param int    $ttl Cache TTL.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $payload, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $payload, $ttl );
+	}
+
+	/**
+	 * @param array  $range Date range.
+	 * @param string $period Period.
+	 * @return int
+	 */
+	private function get_cache_ttl( array $range, $period ) {
+		if ( 'today' === $period || $this->range_is_today( $range ) ) {
+			return self::CACHE_TTL_TODAY;
+		}
+
+		return self::CACHE_TTL_DEFAULT;
+	}
+
+	/**
+	 * @param array $range Date range.
+	 * @return bool
+	 */
+	private function range_is_today( array $range ) {
+		$timezone = $this->get_timezone();
+		$today    = ( new DateTimeImmutable( 'now', $timezone ) )->format( 'Y-m-d' );
+
+		return $range['start']->format( 'Y-m-d' ) === $today && $range['end']->format( 'Y-m-d' ) === $today;
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return bool
+	 */
+	private function table_exists( $table ) {
+		global $wpdb;
+
+		$found = $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table ) );
+		return $found === $table;
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @param string $column Column name.
+	 * @return bool
+	 */
+	private function table_has_column( $table, $column ) {
+		static $cache = array();
+		$key = $table . ':' . $column;
+
+		if ( isset( $cache[ $key ] ) ) {
+			return $cache[ $key ];
+		}
+
+		global $wpdb;
+		$result = $wpdb->get_var( $wpdb->prepare( 'SHOW COLUMNS FROM ' . $table . ' LIKE %s', $column ) );
+		$cache[ $key ] = ! empty( $result );
+
+		return $cache[ $key ];
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return string|null
+	 */
+	private function get_product_revenue_column( $table ) {
+		if ( $this->table_has_column( $table, 'product_net_revenue' ) ) {
+			return 'product_net_revenue';
+		}
+
+		if ( $this->table_has_column( $table, 'product_gross_revenue' ) ) {
+			return 'product_gross_revenue';
+		}
+
+		return null;
+	}
+}


thinking
**Reviewing metric calculations and handler integration**
exec
/bin/zsh -lc "sed -n '1,220p' src/Handlers/AnalyticsHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Handle sales analytics reports.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;
use DateTimeImmutable;
use DateTimeZone;
use Exception;

class AnalyticsHandler {
	const CACHE_TTL_TODAY   = 300;
	const CACHE_TTL_DEFAULT = 3600;
	const TOP_LIMIT         = 5;

file update:
diff --git a/src/Handlers/AnalyticsHandler.php b/src/Handlers/AnalyticsHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..38e71e091a57c9064f796a9af87696859948a87c
--- /dev/null
+++ b/src/Handlers/AnalyticsHandler.php
@@ -0,0 +1,793 @@
+<?php
+/**
+ * Handle sales analytics reports.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class AnalyticsHandler {
+	const CACHE_TTL_TODAY   = 300;
+	const CACHE_TTL_DEFAULT = 3600;
+	const TOP_LIMIT         = 5;
+
+	/**
+	 * Handle analytics requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to fetch analytics.', 400 );
+		}
+
+		global $wpdb;
+		if ( ! $wpdb ) {
+			return Response::error( 'Database is unavailable for analytics.', 500 );
+		}
+
+		$period = isset( $args['period'] ) ? sanitize_text_field( $args['period'] ) : '';
+		$period = strtolower( trim( $period ) );
+
+		$valid_periods = array( 'today', 'yesterday', 'this_week', 'last_week', 'this_month', 'last_month', 'custom' );
+		if ( ! in_array( $period, $valid_periods, true ) ) {
+			return Response::error( 'Invalid period for sales report.', 400 );
+		}
+
+		$start_input = isset( $args['start_date'] ) ? sanitize_text_field( $args['start_date'] ) : '';
+		$end_input   = isset( $args['end_date'] ) ? sanitize_text_field( $args['end_date'] ) : '';
+		$compare     = $this->normalize_bool( isset( $args['compare_previous'] ) ? $args['compare_previous'] : false );
+
+		$range = $this->resolve_period_range( $period, $start_input, $end_input );
+		if ( null === $range ) {
+			return Response::error( 'Invalid date range for sales report.', 400 );
+		}
+
+		$order_stats_table = $wpdb->prefix . 'wc_order_stats';
+		if ( ! $this->table_exists( $order_stats_table ) ) {
+			return Response::error( 'WooCommerce analytics tables are unavailable.', 500 );
+		}
+
+		$cache_key = $this->build_cache_key(
+			array(
+				'period'           => $period,
+				'start'            => $range['start_mysql'],
+				'end'              => $range['end_mysql'],
+				'compare_previous' => $compare,
+			)
+		);
+		$cached    = $this->read_cache( $cache_key );
+		if ( null !== $cached ) {
+			$cached['cached'] = true;
+			return Response::success( $cached );
+		}
+
+		$statuses = $this->get_paid_statuses();
+		$current  = $this->build_report( $period, $range, $statuses );
+
+		if ( $compare ) {
+			$previous_range = $this->build_previous_range( $range );
+			$previous       = $this->build_report( $period, $previous_range, $statuses );
+			$payload        = array(
+				'period'            => $period,
+				'compare_previous'  => true,
+				'current_period'    => $current,
+				'previous_period'   => $previous,
+				'percentage_change' => $this->build_percentage_change( $current, $previous ),
+			);
+		} else {
+			$payload = $current;
+		}
+
+		$payload['cached'] = false;
+
+		$this->write_cache( $cache_key, $payload, $this->get_cache_ttl( $range, $period ) );
+
+		return Response::success( $payload );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param array  $range Date range data.
+	 * @param array  $statuses Status list.
+	 * @return array
+	 */
+	private function build_report( $period, array $range, array $statuses ) {
+		$totals = $this->query_totals( $range, $statuses );
+
+		$total_revenue = $this->normalize_amount( $totals['total_revenue'] );
+		$net_revenue   = $this->normalize_amount( $totals['net_revenue'] );
+		$order_count   = absint( $totals['order_count'] );
+		$items_sold    = absint( $totals['items_sold'] );
+
+		$refund_total = $total_revenue - $net_revenue;
+		if ( $refund_total < 0 ) {
+			$refund_total = 0;
+		}
+
+		$average_order_value = 0.0;
+		if ( $order_count > 0 ) {
+			$average_order_value = $this->normalize_amount( $total_revenue / $order_count );
+		}
+
+		return array(
+			'period'             => $period,
+			'start_date'         => $range['start_date'],
+			'end_date'           => $range['end_date'],
+			'total_revenue'      => $total_revenue,
+			'total_revenue_formatted' => $this->format_currency( $total_revenue ),
+			'order_count'        => $order_count,
+			'average_order_value' => $average_order_value,
+			'average_order_value_formatted' => $this->format_currency( $average_order_value ),
+			'items_sold'         => $items_sold,
+			'refund_total'       => $this->normalize_amount( $refund_total ),
+			'refund_total_formatted' => $this->format_currency( $refund_total ),
+			'net_revenue'        => $net_revenue,
+			'net_revenue_formatted' => $this->format_currency( $net_revenue ),
+			'top_products'       => $this->query_top_products( $range, $statuses ),
+			'top_categories'     => $this->query_top_categories( $range, $statuses ),
+		);
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_totals( array $range, array $statuses ) {
+		global $wpdb;
+
+		$table             = $wpdb->prefix . 'wc_order_stats';
+		$has_total_sales   = $this->table_has_column( $table, 'total_sales' );
+		$has_items_sold    = $this->table_has_column( $table, 'num_items_sold' );
+		$total_column      = $has_total_sales ? 'total_sales' : 'net_total';
+		$items_select      = $has_items_sold ? 'COALESCE(SUM(num_items_sold), 0) AS items_sold' : '0 AS items_sold';
+		$parent_filter_sql = $this->table_has_column( $table, 'parent_id' ) ? ' AND parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params );
+
+		$sql = "
+			SELECT
+				COALESCE(SUM({$total_column}), 0) AS total_revenue,
+				COALESCE(SUM(net_total), 0) AS net_revenue,
+				{$items_select},
+				COUNT(order_id) AS order_count
+			FROM {$table}
+			WHERE date_created >= %s
+				AND date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$row = $wpdb->get_row( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( ! is_array( $row ) ) {
+			$row = array(
+				'total_revenue' => 0,
+				'net_revenue'   => 0,
+				'items_sold'    => 0,
+				'order_count'   => 0,
+			);
+		}
+
+		if ( ! $has_items_sold ) {
+			$row['items_sold'] = $this->query_items_sold( $range, $statuses );
+		}
+
+		return $row;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return int
+	 */
+	private function query_items_sold( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table  = $wpdb->prefix . 'wc_order_stats';
+		$items_table  = $wpdb->prefix . 'wc_order_product_lookup';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		if ( ! $this->table_exists( $items_table ) ) {
+			return 0;
+		}
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT COALESCE(SUM(lookup.product_qty), 0)
+			FROM {$items_table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$total = $wpdb->get_var( $wpdb->prepare( $sql, $params ) );
+		return absint( $total );
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_products( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				lookup.product_id AS product_id,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select},
+				COALESCE(posts.post_title, '') AS product_name
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			LEFT JOIN {$wpdb->posts} AS posts
+				ON posts.ID = lookup.product_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+			GROUP BY lookup.product_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'product_id' => absint( $row['product_id'] ),
+				'name'       => sanitize_text_field( $row['product_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => $revenue,
+				'net_revenue_formatted' => $this->format_currency( $revenue ),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_categories( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				terms.term_id AS term_id,
+				terms.name AS category_name,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select}
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			INNER JOIN {$wpdb->term_relationships} AS rel
+				ON rel.object_id = lookup.product_id
+			INNER JOIN {$wpdb->term_taxonomy} AS tax
+				ON tax.term_taxonomy_id = rel.term_taxonomy_id
+			INNER JOIN {$wpdb->terms} AS terms
+				ON terms.term_id = tax.term_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+				AND tax.taxonomy = 'product_cat'
+			GROUP BY terms.term_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'term_id'    => absint( $row['term_id'] ),
+				'name'       => sanitize_text_field( $row['category_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => $revenue,
+				'net_revenue_formatted' => $this->format_currency( $revenue ),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $current Current report.
+	 * @param array $previous Previous report.
+	 * @return array
+	 */
+	private function build_percentage_change( array $current, array $previous ) {
+		$metrics = array(
+			'total_revenue',
+			'order_count',
+			'average_order_value',
+			'items_sold',
+			'refund_total',
+			'net_revenue',
+		);
+
+		$changes = array();
+		foreach ( $metrics as $metric ) {
+			$current_value  = $this->extract_metric_value( $current, $metric );
+			$previous_value = $this->extract_metric_value( $previous, $metric );
+			$changes[ $metric ] = $this->calculate_percentage_change( $current_value, $previous_value );
+		}
+
+		return $changes;
+	}
+
+	/**
+	 * @param array  $report Report data.
+	 * @param string $metric Metric key.
+	 * @return float
+	 */
+	private function extract_metric_value( array $report, $metric ) {
+		if ( ! isset( $report[ $metric ] ) ) {
+			return 0.0;
+		}
+
+		$value = $report[ $metric ];
+		if ( is_array( $value ) && isset( $value['amount'] ) ) {
+			return (float) $value['amount'];
+		}
+
+		return (float) $value;
+	}
+
+	/**
+	 * @param float $current Current value.
+	 * @param float $previous Previous value.
+	 * @return float|null
+	 */
+	private function calculate_percentage_change( $current, $previous ) {
+		$current  = (float) $current;
+		$previous = (float) $previous;
+
+		if ( 0.0 === $previous ) {
+			return 0.0 === $current ? 0.0 : null;
+		}
+
+		$change = ( ( $current - $previous ) / $previous ) * 100;
+
+		return (float) $this->normalize_amount( $change );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param string $start_input Start date input.
+	 * @param string $end_input End date input.
+	 * @return array|null
+	 */
+	private function resolve_period_range( $period, $start_input, $end_input ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+
+		switch ( $period ) {
+			case 'today':
+				$start = $now->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'yesterday':
+				$start = $now->modify( '-1 day' )->setTime( 0, 0, 0 );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'this_week':
+				$start = $this->start_of_week( $now, $timezone );
+				$end   = $now;
+				break;
+			case 'last_week':
+				$current_week_start = $this->start_of_week( $now, $timezone );
+				$end   = $current_week_start->modify( '-1 second' );
+				$start = $current_week_start->modify( '-7 days' )->setTime( 0, 0, 0 );
+				break;
+			case 'this_month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'last_month':
+				$start = $now->modify( 'first day of last month' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( 'last day of last month' )->setTime( 23, 59, 59 );
+				break;
+			case 'custom':
+				$start_date = $this->parse_date_input( $start_input, $timezone );
+				$end_date   = $this->parse_date_input( $end_input, $timezone );
+				if ( null === $start_date || null === $end_date ) {
+					return null;
+				}
+
+				$start = $start_date->setTime( 0, 0, 0 );
+				$end   = $end_date->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		if ( $end < $start ) {
+			$temp  = $start;
+			$start = $end;
+			$end   = $temp;
+		}
+
+		return $this->format_range( $start, $end );
+	}
+
+	/**
+	 * @param array $range Current range data.
+	 * @return array
+	 */
+	private function build_previous_range( array $range ) {
+		$start = $range['start'];
+		$end   = $range['end'];
+
+		$duration = max( 0, $end->getTimestamp() - $start->getTimestamp() );
+		$prev_end = $start->modify( '-1 second' );
+		$prev_start = $prev_end->modify( '-' . $duration . ' seconds' );
+
+		return $this->format_range( $prev_start, $prev_end );
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start'       => $start,
+			'end'         => $end,
+			'start_mysql' => $start->format( 'Y-m-d H:i:s' ),
+			'end_mysql'   => $end->format( 'Y-m-d H:i:s' ),
+			'start_date'  => $start->format( 'Y-m-d' ),
+			'end_date'    => $end->format( 'Y-m-d' ),
+		);
+	}
+
+	/**
+	 * @param DateTimeImmutable $now Current time.
+	 * @param DateTimeZone      $timezone Timezone.
+	 * @return DateTimeImmutable
+	 */
+	private function start_of_week( DateTimeImmutable $now, DateTimeZone $timezone ) {
+		$week_start = 1;
+		if ( function_exists( 'get_option' ) ) {
+			$week_start = intval( get_option( 'start_of_week', 1 ) );
+		}
+
+		$weekday = intval( $now->format( 'w' ) );
+		$diff    = ( $weekday - $week_start + 7 ) % 7;
+
+		return $now->modify( '-' . $diff . ' days' )->setTime( 0, 0, 0 )->setTimezone( $timezone );
+	}
+
+	/**
+	 * @param string       $value Date string.
+	 * @param DateTimeZone $timezone Timezone.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_input( $value, DateTimeZone $timezone ) {
+		$value = trim( (string) $value );
+		if ( '' === $value ) {
+			return null;
+		}
+
+		$date = DateTimeImmutable::createFromFormat( 'Y-m-d', $value, $timezone );
+		if ( false === $date ) {
+			return null;
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param array $statuses Status list.
+	 * @param array $params Parameters to append to.
+	 * @param string $column Column name.
+	 * @return string
+	 */
+	private function build_status_clause( array $statuses, array &$params, $column = 'status' ) {
+		if ( empty( $statuses ) ) {
+			return '';
+		}
+
+		$placeholders = implode( ', ', array_fill( 0, count( $statuses ), '%s' ) );
+		foreach ( $statuses as $status ) {
+			$params[] = $status;
+		}
+
+		return " AND {$column} IN ({$placeholders})";
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_paid_statuses() {
+		$statuses = function_exists( 'wc_get_is_paid_statuses' )
+			? wc_get_is_paid_statuses()
+			: array( 'processing', 'completed', 'on-hold' );
+
+		$normalized = array();
+		foreach ( $statuses as $status ) {
+			$status = sanitize_text_field( $status );
+			$status = trim( $status );
+			if ( '' === $status ) {
+				continue;
+			}
+
+			$normalized[] = $status;
+			if ( 0 === strpos( $status, 'wc-' ) ) {
+				$normalized[] = substr( $status, 3 );
+			} else {
+				$normalized[] = 'wc-' . $status;
+			}
+		}
+
+		$normalized = array_unique( $normalized );
+		sort( $normalized );
+
+		return $normalized;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Input amount.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return (float) round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return (int) wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return string
+	 */
+	private function format_currency( $value ) {
+		if ( '' === $value || null === $value ) {
+			return '';
+		}
+
+		if ( function_exists( 'wc_price' ) ) {
+			return wp_strip_all_tags( wc_price( $value ) );
+		}
+
+		return (string) $value;
+	}
+
+	/**
+	 * @param array $payload Cache payload.
+	 * @return string
+	 */
+	private function build_cache_key( array $payload ) {
+		$encoded = function_exists( 'wp_json_encode' ) ? wp_json_encode( $payload ) : json_encode( $payload );
+		$hash    = $encoded ? md5( $encoded ) : md5( 'sales_report' );
+
+		return Plugin::TRANSIENT_PREFIX . 'sales_report_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @param array  $payload Cache payload.
+	 * @param int    $ttl Cache TTL.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $payload, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $payload, $ttl );
+	}
+
+	/**
+	 * @param array  $range Date range.
+	 * @param string $period Period.
+	 * @return int
+	 */
+	private function get_cache_ttl( array $range, $period ) {
+		if ( 'today' === $period || $this->range_is_today( $range ) ) {
+			return self::CACHE_TTL_TODAY;
+		}
+
+		return self::CACHE_TTL_DEFAULT;
+	}
+
+	/**
+	 * @param array $range Date range.
+	 * @return bool
+	 */
+	private function range_is_today( array $range ) {
+		$timezone = $this->get_timezone();
+		$today    = ( new DateTimeImmutable( 'now', $timezone ) )->format( 'Y-m-d' );
+
+		return $range['start']->format( 'Y-m-d' ) === $today && $range['end']->format( 'Y-m-d' ) === $today;
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return bool
+	 */
+	private function table_exists( $table ) {
+		global $wpdb;
+
+		$found = $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table ) );
+		return $found === $table;
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @param string $column Column name.
+	 * @return bool
+	 */
+	private function table_has_column( $table, $column ) {
+		static $cache = array();
+		$key = $table . ':' . $column;
+
+		if ( isset( $cache[ $key ] ) ) {
+			return $cache[ $key ];
+		}
+
+		global $wpdb;
+		$result = $wpdb->get_var( $wpdb->prepare( 'SHOW COLUMNS FROM ' . $table . ' LIKE %s', $column ) );
+		$cache[ $key ] = ! empty( $result );
+
+		return $cache[ $key ];
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return string|null
+	 */
+	private function get_product_revenue_column( $table ) {
+		if ( $this->table_has_column( $table, 'product_net_revenue' ) ) {
+			return 'product_net_revenue';
+		}
+
+		if ( $this->table_has_column( $table, 'product_gross_revenue' ) ) {
+			return 'product_gross_revenue';
+		}
+
+		return null;
+	}
+}


thinking
**Reviewing key-value spacing**
exec
/bin/zsh -lc "sed -n '220,520p' src/Handlers/AnalyticsHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
	}

	/**
	 * @param array $range Date range data.
	 * @param array $statuses Status list.
	 * @return array
	 */
	private function query_top_products( array $range, array $statuses ) {
		global $wpdb;

		$stats_table = $wpdb->prefix . 'wc_order_stats';
		$table       = $wpdb->prefix . 'wc_order_product_lookup';

		if ( ! $this->table_exists( $table ) ) {
			return array();
		}

		$revenue_column = $this->get_product_revenue_column( $table );
		$revenue_select = $revenue_column
			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
file update:
diff --git a/src/Handlers/AnalyticsHandler.php b/src/Handlers/AnalyticsHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..38e71e091a57c9064f796a9af87696859948a87c
--- /dev/null
+++ b/src/Handlers/AnalyticsHandler.php
@@ -0,0 +1,793 @@
+<?php
+/**
+ * Handle sales analytics reports.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class AnalyticsHandler {
+	const CACHE_TTL_TODAY   = 300;
+	const CACHE_TTL_DEFAULT = 3600;
+	const TOP_LIMIT         = 5;
+
+	/**
+	 * Handle analytics requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to fetch analytics.', 400 );
+		}
+
+		global $wpdb;
+		if ( ! $wpdb ) {
+			return Response::error( 'Database is unavailable for analytics.', 500 );
+		}
+
+		$period = isset( $args['period'] ) ? sanitize_text_field( $args['period'] ) : '';
+		$period = strtolower( trim( $period ) );
+
+		$valid_periods = array( 'today', 'yesterday', 'this_week', 'last_week', 'this_month', 'last_month', 'custom' );
+		if ( ! in_array( $period, $valid_periods, true ) ) {
+			return Response::error( 'Invalid period for sales report.', 400 );
+		}
+
+		$start_input = isset( $args['start_date'] ) ? sanitize_text_field( $args['start_date'] ) : '';
+		$end_input   = isset( $args['end_date'] ) ? sanitize_text_field( $args['end_date'] ) : '';
+		$compare     = $this->normalize_bool( isset( $args['compare_previous'] ) ? $args['compare_previous'] : false );
+
+		$range = $this->resolve_period_range( $period, $start_input, $end_input );
+		if ( null === $range ) {
+			return Response::error( 'Invalid date range for sales report.', 400 );
+		}
+
+		$order_stats_table = $wpdb->prefix . 'wc_order_stats';
+		if ( ! $this->table_exists( $order_stats_table ) ) {
+			return Response::error( 'WooCommerce analytics tables are unavailable.', 500 );
+		}
+
+		$cache_key = $this->build_cache_key(
+			array(
+				'period'           => $period,
+				'start'            => $range['start_mysql'],
+				'end'              => $range['end_mysql'],
+				'compare_previous' => $compare,
+			)
+		);
+		$cached    = $this->read_cache( $cache_key );
+		if ( null !== $cached ) {
+			$cached['cached'] = true;
+			return Response::success( $cached );
+		}
+
+		$statuses = $this->get_paid_statuses();
+		$current  = $this->build_report( $period, $range, $statuses );
+
+		if ( $compare ) {
+			$previous_range = $this->build_previous_range( $range );
+			$previous       = $this->build_report( $period, $previous_range, $statuses );
+			$payload        = array(
+				'period'            => $period,
+				'compare_previous'  => true,
+				'current_period'    => $current,
+				'previous_period'   => $previous,
+				'percentage_change' => $this->build_percentage_change( $current, $previous ),
+			);
+		} else {
+			$payload = $current;
+		}
+
+		$payload['cached'] = false;
+
+		$this->write_cache( $cache_key, $payload, $this->get_cache_ttl( $range, $period ) );
+
+		return Response::success( $payload );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param array  $range Date range data.
+	 * @param array  $statuses Status list.
+	 * @return array
+	 */
+	private function build_report( $period, array $range, array $statuses ) {
+		$totals = $this->query_totals( $range, $statuses );
+
+		$total_revenue = $this->normalize_amount( $totals['total_revenue'] );
+		$net_revenue   = $this->normalize_amount( $totals['net_revenue'] );
+		$order_count   = absint( $totals['order_count'] );
+		$items_sold    = absint( $totals['items_sold'] );
+
+		$refund_total = $total_revenue - $net_revenue;
+		if ( $refund_total < 0 ) {
+			$refund_total = 0;
+		}
+
+		$average_order_value = 0.0;
+		if ( $order_count > 0 ) {
+			$average_order_value = $this->normalize_amount( $total_revenue / $order_count );
+		}
+
+		return array(
+			'period'             => $period,
+			'start_date'         => $range['start_date'],
+			'end_date'           => $range['end_date'],
+			'total_revenue'      => $total_revenue,
+			'total_revenue_formatted' => $this->format_currency( $total_revenue ),
+			'order_count'        => $order_count,
+			'average_order_value' => $average_order_value,
+			'average_order_value_formatted' => $this->format_currency( $average_order_value ),
+			'items_sold'         => $items_sold,
+			'refund_total'       => $this->normalize_amount( $refund_total ),
+			'refund_total_formatted' => $this->format_currency( $refund_total ),
+			'net_revenue'        => $net_revenue,
+			'net_revenue_formatted' => $this->format_currency( $net_revenue ),
+			'top_products'       => $this->query_top_products( $range, $statuses ),
+			'top_categories'     => $this->query_top_categories( $range, $statuses ),
+		);
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_totals( array $range, array $statuses ) {
+		global $wpdb;
+
+		$table             = $wpdb->prefix . 'wc_order_stats';
+		$has_total_sales   = $this->table_has_column( $table, 'total_sales' );
+		$has_items_sold    = $this->table_has_column( $table, 'num_items_sold' );
+		$total_column      = $has_total_sales ? 'total_sales' : 'net_total';
+		$items_select      = $has_items_sold ? 'COALESCE(SUM(num_items_sold), 0) AS items_sold' : '0 AS items_sold';
+		$parent_filter_sql = $this->table_has_column( $table, 'parent_id' ) ? ' AND parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params );
+
+		$sql = "
+			SELECT
+				COALESCE(SUM({$total_column}), 0) AS total_revenue,
+				COALESCE(SUM(net_total), 0) AS net_revenue,
+				{$items_select},
+				COUNT(order_id) AS order_count
+			FROM {$table}
+			WHERE date_created >= %s
+				AND date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$row = $wpdb->get_row( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( ! is_array( $row ) ) {
+			$row = array(
+				'total_revenue' => 0,
+				'net_revenue'   => 0,
+				'items_sold'    => 0,
+				'order_count'   => 0,
+			);
+		}
+
+		if ( ! $has_items_sold ) {
+			$row['items_sold'] = $this->query_items_sold( $range, $statuses );
+		}
+
+		return $row;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return int
+	 */
+	private function query_items_sold( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table  = $wpdb->prefix . 'wc_order_stats';
+		$items_table  = $wpdb->prefix . 'wc_order_product_lookup';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		if ( ! $this->table_exists( $items_table ) ) {
+			return 0;
+		}
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT COALESCE(SUM(lookup.product_qty), 0)
+			FROM {$items_table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$total = $wpdb->get_var( $wpdb->prepare( $sql, $params ) );
+		return absint( $total );
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_products( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				lookup.product_id AS product_id,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select},
+				COALESCE(posts.post_title, '') AS product_name
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			LEFT JOIN {$wpdb->posts} AS posts
+				ON posts.ID = lookup.product_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+			GROUP BY lookup.product_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'product_id' => absint( $row['product_id'] ),
+				'name'       => sanitize_text_field( $row['product_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => $revenue,
+				'net_revenue_formatted' => $this->format_currency( $revenue ),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_categories( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				terms.term_id AS term_id,
+				terms.name AS category_name,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select}
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			INNER JOIN {$wpdb->term_relationships} AS rel
+				ON rel.object_id = lookup.product_id
+			INNER JOIN {$wpdb->term_taxonomy} AS tax
+				ON tax.term_taxonomy_id = rel.term_taxonomy_id
+			INNER JOIN {$wpdb->terms} AS terms
+				ON terms.term_id = tax.term_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+				AND tax.taxonomy = 'product_cat'
+			GROUP BY terms.term_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'term_id'    => absint( $row['term_id'] ),
+				'name'       => sanitize_text_field( $row['category_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => $revenue,
+				'net_revenue_formatted' => $this->format_currency( $revenue ),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $current Current report.
+	 * @param array $previous Previous report.
+	 * @return array
+	 */
+	private function build_percentage_change( array $current, array $previous ) {
+		$metrics = array(
+			'total_revenue',
+			'order_count',
+			'average_order_value',
+			'items_sold',
+			'refund_total',
+			'net_revenue',
+		);
+
+		$changes = array();
+		foreach ( $metrics as $metric ) {
+			$current_value  = $this->extract_metric_value( $current, $metric );
+			$previous_value = $this->extract_metric_value( $previous, $metric );
+			$changes[ $metric ] = $this->calculate_percentage_change( $current_value, $previous_value );
+		}
+
+		return $changes;
+	}
+
+	/**
+	 * @param array  $report Report data.
+	 * @param string $metric Metric key.
+	 * @return float
+	 */
+	private function extract_metric_value( array $report, $metric ) {
+		if ( ! isset( $report[ $metric ] ) ) {
+			return 0.0;
+		}
+
+		$value = $report[ $metric ];
+		if ( is_array( $value ) && isset( $value['amount'] ) ) {
+			return (float) $value['amount'];
+		}
+
+		return (float) $value;
+	}
+
+	/**
+	 * @param float $current Current value.
+	 * @param float $previous Previous value.
+	 * @return float|null
+	 */
+	private function calculate_percentage_change( $current, $previous ) {
+		$current  = (float) $current;
+		$previous = (float) $previous;
+
+		if ( 0.0 === $previous ) {
+			return 0.0 === $current ? 0.0 : null;
+		}
+
+		$change = ( ( $current - $previous ) / $previous ) * 100;
+
+		return (float) $this->normalize_amount( $change );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param string $start_input Start date input.
+	 * @param string $end_input End date input.
+	 * @return array|null
+	 */
+	private function resolve_period_range( $period, $start_input, $end_input ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+
+		switch ( $period ) {
+			case 'today':
+				$start = $now->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'yesterday':
+				$start = $now->modify( '-1 day' )->setTime( 0, 0, 0 );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'this_week':
+				$start = $this->start_of_week( $now, $timezone );
+				$end   = $now;
+				break;
+			case 'last_week':
+				$current_week_start = $this->start_of_week( $now, $timezone );
+				$end   = $current_week_start->modify( '-1 second' );
+				$start = $current_week_start->modify( '-7 days' )->setTime( 0, 0, 0 );
+				break;
+			case 'this_month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'last_month':
+				$start = $now->modify( 'first day of last month' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( 'last day of last month' )->setTime( 23, 59, 59 );
+				break;
+			case 'custom':
+				$start_date = $this->parse_date_input( $start_input, $timezone );
+				$end_date   = $this->parse_date_input( $end_input, $timezone );
+				if ( null === $start_date || null === $end_date ) {
+					return null;
+				}
+
+				$start = $start_date->setTime( 0, 0, 0 );
+				$end   = $end_date->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		if ( $end < $start ) {
+			$temp  = $start;
+			$start = $end;
+			$end   = $temp;
+		}
+
+		return $this->format_range( $start, $end );
+	}
+
+	/**
+	 * @param array $range Current range data.
+	 * @return array
+	 */
+	private function build_previous_range( array $range ) {
+		$start = $range['start'];
+		$end   = $range['end'];
+
+		$duration = max( 0, $end->getTimestamp() - $start->getTimestamp() );
+		$prev_end = $start->modify( '-1 second' );
+		$prev_start = $prev_end->modify( '-' . $duration . ' seconds' );
+
+		return $this->format_range( $prev_start, $prev_end );
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start'       => $start,
+			'end'         => $end,
+			'start_mysql' => $start->format( 'Y-m-d H:i:s' ),
+			'end_mysql'   => $end->format( 'Y-m-d H:i:s' ),
+			'start_date'  => $start->format( 'Y-m-d' ),
+			'end_date'    => $end->format( 'Y-m-d' ),
+		);
+	}
+
+	/**
+	 * @param DateTimeImmutable $now Current time.
+	 * @param DateTimeZone      $timezone Timezone.
+	 * @return DateTimeImmutable
+	 */
+	private function start_of_week( DateTimeImmutable $now, DateTimeZone $timezone ) {
+		$week_start = 1;
+		if ( function_exists( 'get_option' ) ) {
+			$week_start = intval( get_option( 'start_of_week', 1 ) );
+		}
+
+		$weekday = intval( $now->format( 'w' ) );
+		$diff    = ( $weekday - $week_start + 7 ) % 7;
+
+		return $now->modify( '-' . $diff . ' days' )->setTime( 0, 0, 0 )->setTimezone( $timezone );
+	}
+
+	/**
+	 * @param string       $value Date string.
+	 * @param DateTimeZone $timezone Timezone.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_input( $value, DateTimeZone $timezone ) {
+		$value = trim( (string) $value );
+		if ( '' === $value ) {
+			return null;
+		}
+
+		$date = DateTimeImmutable::createFromFormat( 'Y-m-d', $value, $timezone );
+		if ( false === $date ) {
+			return null;
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param array $statuses Status list.
+	 * @param array $params Parameters to append to.
+	 * @param string $column Column name.
+	 * @return string
+	 */
+	private function build_status_clause( array $statuses, array &$params, $column = 'status' ) {
+		if ( empty( $statuses ) ) {
+			return '';
+		}
+
+		$placeholders = implode( ', ', array_fill( 0, count( $statuses ), '%s' ) );
+		foreach ( $statuses as $status ) {
+			$params[] = $status;
+		}
+
+		return " AND {$column} IN ({$placeholders})";
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_paid_statuses() {
+		$statuses = function_exists( 'wc_get_is_paid_statuses' )
+			? wc_get_is_paid_statuses()
+			: array( 'processing', 'completed', 'on-hold' );
+
+		$normalized = array();
+		foreach ( $statuses as $status ) {
+			$status = sanitize_text_field( $status );
+			$status = trim( $status );
+			if ( '' === $status ) {
+				continue;
+			}
+
+			$normalized[] = $status;
+			if ( 0 === strpos( $status, 'wc-' ) ) {
+				$normalized[] = substr( $status, 3 );
+			} else {
+				$normalized[] = 'wc-' . $status;
+			}
+		}
+
+		$normalized = array_unique( $normalized );
+		sort( $normalized );
+
+		return $normalized;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Input amount.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return (float) round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return (int) wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return string
+	 */
+	private function format_currency( $value ) {
+		if ( '' === $value || null === $value ) {
+			return '';
+		}
+
+		if ( function_exists( 'wc_price' ) ) {
+			return wp_strip_all_tags( wc_price( $value ) );
+		}
+
+		return (string) $value;
+	}
+
+	/**
+	 * @param array $payload Cache payload.
+	 * @return string
+	 */
+	private function build_cache_key( array $payload ) {
+		$encoded = function_exists( 'wp_json_encode' ) ? wp_json_encode( $payload ) : json_encode( $payload );
+		$hash    = $encoded ? md5( $encoded ) : md5( 'sales_report' );
+
+		return Plugin::TRANSIENT_PREFIX . 'sales_report_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @param array  $payload Cache payload.
+	 * @param int    $ttl Cache TTL.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $payload, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $payload, $ttl );
+	}
+
+	/**
+	 * @param array  $range Date range.
+	 * @param string $period Period.
+	 * @return int
+	 */
+	private function get_cache_ttl( array $range, $period ) {
+		if ( 'today' === $period || $this->range_is_today( $range ) ) {
+			return self::CACHE_TTL_TODAY;
+		}
+
+		return self::CACHE_TTL_DEFAULT;
+	}
+
+	/**
+	 * @param array $range Date range.
+	 * @return bool
+	 */
+	private function range_is_today( array $range ) {
+		$timezone = $this->get_timezone();
+		$today    = ( new DateTimeImmutable( 'now', $timezone ) )->format( 'Y-m-d' );
+
+		return $range['start']->format( 'Y-m-d' ) === $today && $range['end']->format( 'Y-m-d' ) === $today;
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return bool
+	 */
+	private function table_exists( $table ) {
+		global $wpdb;
+
+		$found = $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table ) );
+		return $found === $table;
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @param string $column Column name.
+	 * @return bool
+	 */
+	private function table_has_column( $table, $column ) {
+		static $cache = array();
+		$key = $table . ':' . $column;
+
+		if ( isset( $cache[ $key ] ) ) {
+			return $cache[ $key ];
+		}
+
+		global $wpdb;
+		$result = $wpdb->get_var( $wpdb->prepare( 'SHOW COLUMNS FROM ' . $table . ' LIKE %s', $column ) );
+		$cache[ $key ] = ! empty( $result );
+
+		return $cache[ $key ];
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return string|null
+	 */
+	private function get_product_revenue_column( $table ) {
+		if ( $this->table_has_column( $table, 'product_net_revenue' ) ) {
+			return 'product_net_revenue';
+		}
+
+		if ( $this->table_has_column( $table, 'product_gross_revenue' ) ) {
+			return 'product_gross_revenue';
+		}
+
+		return null;
+	}
+}


thinking
**Reviewing code details and finalizing response**
codex
Status: DONE
Summary of changes:
- Implemented sales analytics reporting with WooCommerce analytics table queries, period handling, comparison mode, caching, and currency formatting in `src/Handlers/AnalyticsHandler.php`.
- Added top products/categories aggregation and percentage-change calculations, with formatted currency companion fields in `src/Handlers/AnalyticsHandler.php`.

How to verify (exact commands):
- No verification commands provided.

Risks / follow-ups:
- WooCommerce analytics table schemas can vary; if `total_sales`/`product_net_revenue` columns are unavailable, totals fall back to `net_total` and top lists default to revenue=0.
- If you want percentage change to always show two decimals (independent of currency precision), adjust `calculate_percentage_change` in `src/Handlers/AnalyticsHandler.php`.
file update:
diff --git a/src/Handlers/AnalyticsHandler.php b/src/Handlers/AnalyticsHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..38e71e091a57c9064f796a9af87696859948a87c
--- /dev/null
+++ b/src/Handlers/AnalyticsHandler.php
@@ -0,0 +1,793 @@
+<?php
+/**
+ * Handle sales analytics reports.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class AnalyticsHandler {
+	const CACHE_TTL_TODAY   = 300;
+	const CACHE_TTL_DEFAULT = 3600;
+	const TOP_LIMIT         = 5;
+
+	/**
+	 * Handle analytics requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to fetch analytics.', 400 );
+		}
+
+		global $wpdb;
+		if ( ! $wpdb ) {
+			return Response::error( 'Database is unavailable for analytics.', 500 );
+		}
+
+		$period = isset( $args['period'] ) ? sanitize_text_field( $args['period'] ) : '';
+		$period = strtolower( trim( $period ) );
+
+		$valid_periods = array( 'today', 'yesterday', 'this_week', 'last_week', 'this_month', 'last_month', 'custom' );
+		if ( ! in_array( $period, $valid_periods, true ) ) {
+			return Response::error( 'Invalid period for sales report.', 400 );
+		}
+
+		$start_input = isset( $args['start_date'] ) ? sanitize_text_field( $args['start_date'] ) : '';
+		$end_input   = isset( $args['end_date'] ) ? sanitize_text_field( $args['end_date'] ) : '';
+		$compare     = $this->normalize_bool( isset( $args['compare_previous'] ) ? $args['compare_previous'] : false );
+
+		$range = $this->resolve_period_range( $period, $start_input, $end_input );
+		if ( null === $range ) {
+			return Response::error( 'Invalid date range for sales report.', 400 );
+		}
+
+		$order_stats_table = $wpdb->prefix . 'wc_order_stats';
+		if ( ! $this->table_exists( $order_stats_table ) ) {
+			return Response::error( 'WooCommerce analytics tables are unavailable.', 500 );
+		}
+
+		$cache_key = $this->build_cache_key(
+			array(
+				'period'           => $period,
+				'start'            => $range['start_mysql'],
+				'end'              => $range['end_mysql'],
+				'compare_previous' => $compare,
+			)
+		);
+		$cached    = $this->read_cache( $cache_key );
+		if ( null !== $cached ) {
+			$cached['cached'] = true;
+			return Response::success( $cached );
+		}
+
+		$statuses = $this->get_paid_statuses();
+		$current  = $this->build_report( $period, $range, $statuses );
+
+		if ( $compare ) {
+			$previous_range = $this->build_previous_range( $range );
+			$previous       = $this->build_report( $period, $previous_range, $statuses );
+			$payload        = array(
+				'period'            => $period,
+				'compare_previous'  => true,
+				'current_period'    => $current,
+				'previous_period'   => $previous,
+				'percentage_change' => $this->build_percentage_change( $current, $previous ),
+			);
+		} else {
+			$payload = $current;
+		}
+
+		$payload['cached'] = false;
+
+		$this->write_cache( $cache_key, $payload, $this->get_cache_ttl( $range, $period ) );
+
+		return Response::success( $payload );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param array  $range Date range data.
+	 * @param array  $statuses Status list.
+	 * @return array
+	 */
+	private function build_report( $period, array $range, array $statuses ) {
+		$totals = $this->query_totals( $range, $statuses );
+
+		$total_revenue = $this->normalize_amount( $totals['total_revenue'] );
+		$net_revenue   = $this->normalize_amount( $totals['net_revenue'] );
+		$order_count   = absint( $totals['order_count'] );
+		$items_sold    = absint( $totals['items_sold'] );
+
+		$refund_total = $total_revenue - $net_revenue;
+		if ( $refund_total < 0 ) {
+			$refund_total = 0;
+		}
+
+		$average_order_value = 0.0;
+		if ( $order_count > 0 ) {
+			$average_order_value = $this->normalize_amount( $total_revenue / $order_count );
+		}
+
+		return array(
+			'period'             => $period,
+			'start_date'         => $range['start_date'],
+			'end_date'           => $range['end_date'],
+			'total_revenue'      => $total_revenue,
+			'total_revenue_formatted' => $this->format_currency( $total_revenue ),
+			'order_count'        => $order_count,
+			'average_order_value' => $average_order_value,
+			'average_order_value_formatted' => $this->format_currency( $average_order_value ),
+			'items_sold'         => $items_sold,
+			'refund_total'       => $this->normalize_amount( $refund_total ),
+			'refund_total_formatted' => $this->format_currency( $refund_total ),
+			'net_revenue'        => $net_revenue,
+			'net_revenue_formatted' => $this->format_currency( $net_revenue ),
+			'top_products'       => $this->query_top_products( $range, $statuses ),
+			'top_categories'     => $this->query_top_categories( $range, $statuses ),
+		);
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_totals( array $range, array $statuses ) {
+		global $wpdb;
+
+		$table             = $wpdb->prefix . 'wc_order_stats';
+		$has_total_sales   = $this->table_has_column( $table, 'total_sales' );
+		$has_items_sold    = $this->table_has_column( $table, 'num_items_sold' );
+		$total_column      = $has_total_sales ? 'total_sales' : 'net_total';
+		$items_select      = $has_items_sold ? 'COALESCE(SUM(num_items_sold), 0) AS items_sold' : '0 AS items_sold';
+		$parent_filter_sql = $this->table_has_column( $table, 'parent_id' ) ? ' AND parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params );
+
+		$sql = "
+			SELECT
+				COALESCE(SUM({$total_column}), 0) AS total_revenue,
+				COALESCE(SUM(net_total), 0) AS net_revenue,
+				{$items_select},
+				COUNT(order_id) AS order_count
+			FROM {$table}
+			WHERE date_created >= %s
+				AND date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$row = $wpdb->get_row( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( ! is_array( $row ) ) {
+			$row = array(
+				'total_revenue' => 0,
+				'net_revenue'   => 0,
+				'items_sold'    => 0,
+				'order_count'   => 0,
+			);
+		}
+
+		if ( ! $has_items_sold ) {
+			$row['items_sold'] = $this->query_items_sold( $range, $statuses );
+		}
+
+		return $row;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return int
+	 */
+	private function query_items_sold( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table  = $wpdb->prefix . 'wc_order_stats';
+		$items_table  = $wpdb->prefix . 'wc_order_product_lookup';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		if ( ! $this->table_exists( $items_table ) ) {
+			return 0;
+		}
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT COALESCE(SUM(lookup.product_qty), 0)
+			FROM {$items_table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+		";
+
+		$total = $wpdb->get_var( $wpdb->prepare( $sql, $params ) );
+		return absint( $total );
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_products( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				lookup.product_id AS product_id,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select},
+				COALESCE(posts.post_title, '') AS product_name
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			LEFT JOIN {$wpdb->posts} AS posts
+				ON posts.ID = lookup.product_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+			GROUP BY lookup.product_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'product_id' => absint( $row['product_id'] ),
+				'name'       => sanitize_text_field( $row['product_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => $revenue,
+				'net_revenue_formatted' => $this->format_currency( $revenue ),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $range Date range data.
+	 * @param array $statuses Status list.
+	 * @return array
+	 */
+	private function query_top_categories( array $range, array $statuses ) {
+		global $wpdb;
+
+		$stats_table = $wpdb->prefix . 'wc_order_stats';
+		$table       = $wpdb->prefix . 'wc_order_product_lookup';
+
+		if ( ! $this->table_exists( $table ) ) {
+			return array();
+		}
+
+		$revenue_column = $this->get_product_revenue_column( $table );
+		$revenue_select = $revenue_column
+			? "COALESCE(SUM(lookup.{$revenue_column}), 0) AS net_revenue"
+			: '0 AS net_revenue';
+		$order_by = $revenue_column ? 'net_revenue' : 'items_sold';
+		$parent_filter_sql = $this->table_has_column( $stats_table, 'parent_id' ) ? ' AND stats.parent_id = 0' : '';
+
+		$params = array( $range['start_mysql'], $range['end_mysql'] );
+		$status_clause = $this->build_status_clause( $statuses, $params, 'stats.status' );
+
+		$sql = "
+			SELECT
+				terms.term_id AS term_id,
+				terms.name AS category_name,
+				COALESCE(SUM(lookup.product_qty), 0) AS items_sold,
+				{$revenue_select}
+			FROM {$table} AS lookup
+			INNER JOIN {$stats_table} AS stats
+				ON lookup.order_id = stats.order_id
+			INNER JOIN {$wpdb->term_relationships} AS rel
+				ON rel.object_id = lookup.product_id
+			INNER JOIN {$wpdb->term_taxonomy} AS tax
+				ON tax.term_taxonomy_id = rel.term_taxonomy_id
+			INNER JOIN {$wpdb->terms} AS terms
+				ON terms.term_id = tax.term_id
+			WHERE stats.date_created >= %s
+				AND stats.date_created <= %s
+				{$parent_filter_sql}
+				{$status_clause}
+				AND lookup.product_id > 0
+				AND tax.taxonomy = 'product_cat'
+			GROUP BY terms.term_id
+			ORDER BY {$order_by} DESC
+			LIMIT %d
+		";
+
+		$params[] = self::TOP_LIMIT;
+
+		$rows = $wpdb->get_results( $wpdb->prepare( $sql, $params ), ARRAY_A );
+		if ( empty( $rows ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $rows as $row ) {
+			$revenue = $this->normalize_amount( isset( $row['net_revenue'] ) ? $row['net_revenue'] : 0 );
+			$results[] = array(
+				'term_id'    => absint( $row['term_id'] ),
+				'name'       => sanitize_text_field( $row['category_name'] ),
+				'items_sold' => absint( $row['items_sold'] ),
+				'net_revenue' => $revenue,
+				'net_revenue_formatted' => $this->format_currency( $revenue ),
+			);
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $current Current report.
+	 * @param array $previous Previous report.
+	 * @return array
+	 */
+	private function build_percentage_change( array $current, array $previous ) {
+		$metrics = array(
+			'total_revenue',
+			'order_count',
+			'average_order_value',
+			'items_sold',
+			'refund_total',
+			'net_revenue',
+		);
+
+		$changes = array();
+		foreach ( $metrics as $metric ) {
+			$current_value  = $this->extract_metric_value( $current, $metric );
+			$previous_value = $this->extract_metric_value( $previous, $metric );
+			$changes[ $metric ] = $this->calculate_percentage_change( $current_value, $previous_value );
+		}
+
+		return $changes;
+	}
+
+	/**
+	 * @param array  $report Report data.
+	 * @param string $metric Metric key.
+	 * @return float
+	 */
+	private function extract_metric_value( array $report, $metric ) {
+		if ( ! isset( $report[ $metric ] ) ) {
+			return 0.0;
+		}
+
+		$value = $report[ $metric ];
+		if ( is_array( $value ) && isset( $value['amount'] ) ) {
+			return (float) $value['amount'];
+		}
+
+		return (float) $value;
+	}
+
+	/**
+	 * @param float $current Current value.
+	 * @param float $previous Previous value.
+	 * @return float|null
+	 */
+	private function calculate_percentage_change( $current, $previous ) {
+		$current  = (float) $current;
+		$previous = (float) $previous;
+
+		if ( 0.0 === $previous ) {
+			return 0.0 === $current ? 0.0 : null;
+		}
+
+		$change = ( ( $current - $previous ) / $previous ) * 100;
+
+		return (float) $this->normalize_amount( $change );
+	}
+
+	/**
+	 * @param string $period Period key.
+	 * @param string $start_input Start date input.
+	 * @param string $end_input End date input.
+	 * @return array|null
+	 */
+	private function resolve_period_range( $period, $start_input, $end_input ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+
+		switch ( $period ) {
+			case 'today':
+				$start = $now->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'yesterday':
+				$start = $now->modify( '-1 day' )->setTime( 0, 0, 0 );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'this_week':
+				$start = $this->start_of_week( $now, $timezone );
+				$end   = $now;
+				break;
+			case 'last_week':
+				$current_week_start = $this->start_of_week( $now, $timezone );
+				$end   = $current_week_start->modify( '-1 second' );
+				$start = $current_week_start->modify( '-7 days' )->setTime( 0, 0, 0 );
+				break;
+			case 'this_month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'last_month':
+				$start = $now->modify( 'first day of last month' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( 'last day of last month' )->setTime( 23, 59, 59 );
+				break;
+			case 'custom':
+				$start_date = $this->parse_date_input( $start_input, $timezone );
+				$end_date   = $this->parse_date_input( $end_input, $timezone );
+				if ( null === $start_date || null === $end_date ) {
+					return null;
+				}
+
+				$start = $start_date->setTime( 0, 0, 0 );
+				$end   = $end_date->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		if ( $end < $start ) {
+			$temp  = $start;
+			$start = $end;
+			$end   = $temp;
+		}
+
+		return $this->format_range( $start, $end );
+	}
+
+	/**
+	 * @param array $range Current range data.
+	 * @return array
+	 */
+	private function build_previous_range( array $range ) {
+		$start = $range['start'];
+		$end   = $range['end'];
+
+		$duration = max( 0, $end->getTimestamp() - $start->getTimestamp() );
+		$prev_end = $start->modify( '-1 second' );
+		$prev_start = $prev_end->modify( '-' . $duration . ' seconds' );
+
+		return $this->format_range( $prev_start, $prev_end );
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start'       => $start,
+			'end'         => $end,
+			'start_mysql' => $start->format( 'Y-m-d H:i:s' ),
+			'end_mysql'   => $end->format( 'Y-m-d H:i:s' ),
+			'start_date'  => $start->format( 'Y-m-d' ),
+			'end_date'    => $end->format( 'Y-m-d' ),
+		);
+	}
+
+	/**
+	 * @param DateTimeImmutable $now Current time.
+	 * @param DateTimeZone      $timezone Timezone.
+	 * @return DateTimeImmutable
+	 */
+	private function start_of_week( DateTimeImmutable $now, DateTimeZone $timezone ) {
+		$week_start = 1;
+		if ( function_exists( 'get_option' ) ) {
+			$week_start = intval( get_option( 'start_of_week', 1 ) );
+		}
+
+		$weekday = intval( $now->format( 'w' ) );
+		$diff    = ( $weekday - $week_start + 7 ) % 7;
+
+		return $now->modify( '-' . $diff . ' days' )->setTime( 0, 0, 0 )->setTimezone( $timezone );
+	}
+
+	/**
+	 * @param string       $value Date string.
+	 * @param DateTimeZone $timezone Timezone.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_input( $value, DateTimeZone $timezone ) {
+		$value = trim( (string) $value );
+		if ( '' === $value ) {
+			return null;
+		}
+
+		$date = DateTimeImmutable::createFromFormat( 'Y-m-d', $value, $timezone );
+		if ( false === $date ) {
+			return null;
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param array $statuses Status list.
+	 * @param array $params Parameters to append to.
+	 * @param string $column Column name.
+	 * @return string
+	 */
+	private function build_status_clause( array $statuses, array &$params, $column = 'status' ) {
+		if ( empty( $statuses ) ) {
+			return '';
+		}
+
+		$placeholders = implode( ', ', array_fill( 0, count( $statuses ), '%s' ) );
+		foreach ( $statuses as $status ) {
+			$params[] = $status;
+		}
+
+		return " AND {$column} IN ({$placeholders})";
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_paid_statuses() {
+		$statuses = function_exists( 'wc_get_is_paid_statuses' )
+			? wc_get_is_paid_statuses()
+			: array( 'processing', 'completed', 'on-hold' );
+
+		$normalized = array();
+		foreach ( $statuses as $status ) {
+			$status = sanitize_text_field( $status );
+			$status = trim( $status );
+			if ( '' === $status ) {
+				continue;
+			}
+
+			$normalized[] = $status;
+			if ( 0 === strpos( $status, 'wc-' ) ) {
+				$normalized[] = substr( $status, 3 );
+			} else {
+				$normalized[] = 'wc-' . $status;
+			}
+		}
+
+		$normalized = array_unique( $normalized );
+		sort( $normalized );
+
+		return $normalized;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Input amount.
+	 * @return float
+	 */
+	private function normalize_amount( $amount ) {
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return (float) round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return (int) wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return string
+	 */
+	private function format_currency( $value ) {
+		if ( '' === $value || null === $value ) {
+			return '';
+		}
+
+		if ( function_exists( 'wc_price' ) ) {
+			return wp_strip_all_tags( wc_price( $value ) );
+		}
+
+		return (string) $value;
+	}
+
+	/**
+	 * @param array $payload Cache payload.
+	 * @return string
+	 */
+	private function build_cache_key( array $payload ) {
+		$encoded = function_exists( 'wp_json_encode' ) ? wp_json_encode( $payload ) : json_encode( $payload );
+		$hash    = $encoded ? md5( $encoded ) : md5( 'sales_report' );
+
+		return Plugin::TRANSIENT_PREFIX . 'sales_report_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Cache key.
+	 * @param array  $payload Cache payload.
+	 * @param int    $ttl Cache TTL.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $payload, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $payload, $ttl );
+	}
+
+	/**
+	 * @param array  $range Date range.
+	 * @param string $period Period.
+	 * @return int
+	 */
+	private function get_cache_ttl( array $range, $period ) {
+		if ( 'today' === $period || $this->range_is_today( $range ) ) {
+			return self::CACHE_TTL_TODAY;
+		}
+
+		return self::CACHE_TTL_DEFAULT;
+	}
+
+	/**
+	 * @param array $range Date range.
+	 * @return bool
+	 */
+	private function range_is_today( array $range ) {
+		$timezone = $this->get_timezone();
+		$today    = ( new DateTimeImmutable( 'now', $timezone ) )->format( 'Y-m-d' );
+
+		return $range['start']->format( 'Y-m-d' ) === $today && $range['end']->format( 'Y-m-d' ) === $today;
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return bool
+	 */
+	private function table_exists( $table ) {
+		global $wpdb;
+
+		$found = $wpdb->get_var( $wpdb->prepare( 'SHOW TABLES LIKE %s', $table ) );
+		return $found === $table;
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @param string $column Column name.
+	 * @return bool
+	 */
+	private function table_has_column( $table, $column ) {
+		static $cache = array();
+		$key = $table . ':' . $column;
+
+		if ( isset( $cache[ $key ] ) ) {
+			return $cache[ $key ];
+		}
+
+		global $wpdb;
+		$result = $wpdb->get_var( $wpdb->prepare( 'SHOW COLUMNS FROM ' . $table . ' LIKE %s', $column ) );
+		$cache[ $key ] = ! empty( $result );
+
+		return $cache[ $key ];
+	}
+
+	/**
+	 * @param string $table Table name.
+	 * @return string|null
+	 */
+	private function get_product_revenue_column( $table ) {
+		if ( $this->table_has_column( $table, 'product_net_revenue' ) ) {
+			return 'product_net_revenue';
+		}
+
+		if ( $this->table_has_column( $table, 'product_gross_revenue' ) ) {
+			return 'product_gross_revenue';
+		}
+
+		return null;
+	}
+}

tokens used
133,931
