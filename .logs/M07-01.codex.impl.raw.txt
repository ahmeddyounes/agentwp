Implemented bulk action workflow and background processing with draft/confirm previews, criteria parsing, progress polling, rollback storage, and CSV export in `src/Handlers/BulkHandler.php`, and registered the Action Scheduler hook in `src/Plugin.php` to run queued jobs.

Status: DONE

Summary of changes
- Added bulk operations handler with selection, draft/confirm, async processing, polling progress, rollback, and CSV export in `src/Handlers/BulkHandler.php`.
- Registered the bulk job Action Scheduler hook in `src/Plugin.php`.

How to verify
- No verification commands provided.

Risks / follow-ups
- Async processing depends on Action Scheduler availability; if missing, large batches run synchronously.
- Order tags use `shop_order_tag` when available and fall back to `_agentwp_order_tags` meta; adjust via `agentwp_order_tag_taxonomy` if needed.
- Consider adding a dedicated REST endpoint for progress/rollback polling if clients need a stable API surface.

OpenAI Codex v0.79.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/agentwp
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019b9847-a0c8-7863-b10d-c73a683184ec
--------
user
You are implementing task M07-01 in this git repository.

1) Read the spec: .plans/M07-01.md
2) Read handoff/context: .t2/handoff/M07-01.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: 
- test: 

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers

thinking
**Deciding how to read spec**
exec
/bin/zsh -lc ls in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 35ms:
agentwp.php
assets
composer.json
docker
docker-compose.demo.yml
docker-compose.yml
docs
includes
languages
package.json
phpcs.xml
phpstan.neon
phpunit.xml.dist
playwright.config.cjs
react
README.md
scripts
SECURITY.md
setup.sh
src

thinking
**Reading necessary files**
exec
/bin/zsh -lc 'cat .plans/M07-01.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 44ms:
# M07-01 — Bulk Actions Development

Implement bulk operation features for V1.1: 1) Create AgentWP\Handlers\BulkHandler class. 2) OpenAI function schemas: select_orders(criteria: {status?, date_range?, customer_email?, total_min?, total_max?, country?}), bulk_update(order_ids: int[], action: string, params: object). 3) Supported bulk actions: update_status, add_tag, add_note, export_csv. 4) Draft-Confirm protocol for bulk operations showing: matched orders count, sample (first 5), action preview. 5) Background processing using Action Scheduler for >20 orders. 6) Progress tracking: WebSocket or polling for real-time updates. 7) Rollback support: store pre-action state for undo (24hr retention). 8) Natural language criteria: 'Select all orders from Germany over €100 this month'. Acceptance Criteria: Bulk operations handle up to 1000 orders, progress updates every 2 seconds, rollback successfully reverts changes, criteria parsing handles complex conditions.
exec
/bin/zsh -lc 'cat .t2/handoff/M07-01.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
# Handoff: M07-01

Created: 2026-01-07T11:46:29.671405Z

Spec: .plans/M07-01.md

thinking
**Searching repository for "bulk"**
exec
/bin/zsh -lc 'rg -n "Bulk|bulk" src includes react' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
src/Handlers/OrderStatusHandler.php:29:			return $this->prepare_bulk_status_update( $args );
src/Handlers/OrderStatusHandler.php:123:	 * Prepare a draft bulk status update without applying it.
src/Handlers/OrderStatusHandler.php:128:	public function prepare_bulk_status_update( array $args ): Response {
src/Handlers/OrderStatusHandler.php:130:			return Response::error( 'WooCommerce is required to prepare bulk status updates.', 400 );
src/Handlers/OrderStatusHandler.php:135:			return Response::error( 'Missing order IDs for bulk status update.', 400 );
src/Handlers/OrderStatusHandler.php:139:			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
src/Handlers/OrderStatusHandler.php:144:			return Response::error( 'Missing new status for bulk update.', 400 );
src/Handlers/OrderStatusHandler.php:230:			return Response::error( 'Unable to store bulk status update draft.', 500 );
src/Handlers/OrderStatusHandler.php:269:			return $this->confirm_bulk_status_update( $draft_id, $payload );
src/Handlers/OrderStatusHandler.php:329:	private function confirm_bulk_status_update( $draft_id, array $payload ): Response {
src/Handlers/OrderStatusHandler.php:332:			return Response::error( 'Bulk status update draft is missing order IDs.', 400 );
src/Handlers/OrderStatusHandler.php:336:			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
src/Handlers/OrderStatusHandler.php:445:	 * @param bool   $is_bulk Bulk flag.
src/Handlers/OrderStatusHandler.php:448:	private function build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, $is_bulk ) {
src/Handlers/OrderStatusHandler.php:451:			$is_bulk ? 'Bulk' : 'Order',
src/AI/Functions/PrepareBulkStatusUpdate.php:3: * Function schema for bulk order status updates.
src/AI/Functions/PrepareBulkStatusUpdate.php:10:class PrepareBulkStatusUpdate extends AbstractFunction {
src/AI/Functions/PrepareBulkStatusUpdate.php:17:		return 'prepare_bulk_status_update';
src/AI/Functions/PrepareBulkStatusUpdate.php:26:		return 'Prepare a draft bulk status update for multiple orders.';
src/AI/Functions/SelectOrders.php:3: * Function schema for selecting orders for bulk actions.

thinking
**Checking existing functions**
exec
/bin/zsh -lc "sed -n '1,220p' src/AI/Functions/SelectOrders.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Function schema for selecting orders for bulk actions.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class SelectOrders extends AbstractFunction {
	/**
	 * Get the function name.
	 *
	 * @return string
	 */
	public function get_name() {
		return 'select_orders';
	}

	/**

thinking
**Verifying and considering BulkUpdate**
exec
/bin/zsh -lc "sed -n '1,220p' src/AI/Functions/BulkUpdate.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
<?php
/**
 * Function schema for executing bulk order actions.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class BulkUpdate extends AbstractFunction {
	/**
	 * Get the function name.
	 *
	 * @return string
	 */
	public function get_name() {
		return 'bulk_update';
	}

	/**

thinking
**Checking handlers for bulk updates**
exec
/bin/zsh -lc 'ls src/Handlers' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 43ms:
AnalyticsHandler.php
CustomerHandler.php
EmailDraftHandler.php
OrderSearchHandler.php
OrderStatusHandler.php
RefundHandler.php
StockHandler.php

thinking
**Planning BulkHandler creation**
exec
/bin/zsh -lc "sed -n '1,260p' src/Handlers/OrderStatusHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Handle order status draft preparation and confirmation.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;

class OrderStatusHandler {
	const DRAFT_TYPE = 'status_update';
	const MAX_BULK   = 50;

	/**
	 * Handle order status requests.
	 *
	 * @param array $args Request args.
exec
/bin/zsh -lc "sed -n '260,620p' src/Handlers/OrderStatusHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
			return Response::error( 'Status update draft not found or expired.', 404 );
		}

		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
			return Response::error( 'Draft type mismatch for status update confirmation.', 400 );
		}

		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
		if ( isset( $payload['order_ids'] ) ) {
			return $this->confirm_bulk_status_update( $draft_id, $payload );
		}

		return $this->confirm_single_status_update( $draft_id, $payload );
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @param array  $payload Draft payload.
	 * @return Response
	 */
exec
/bin/zsh -lc "sed -n '620,1040p' src/Handlers/OrderStatusHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 45ms:
		return $ttl_minutes * $minute_seconds;
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @param array  $draft Draft payload.
	 * @param int    $ttl_seconds Expiration seconds.
	 * @return bool
	 */
	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
		if ( ! function_exists( 'set_transient' ) ) {
			return false;
		}

		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return array|null

thinking
**Reviewing OrderStatusHandler and response patterns**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Response.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * OpenAI response wrapper.
 *
 * @package AgentWP
 */

namespace AgentWP\AI;

class Response {
	/**
	 * @var bool
	 */
	private $success;

	/**
	 * @var int
	 */
	private $status;


thinking
**Reviewing order handling components**
exec
/bin/zsh -lc "sed -n '1,240p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
<?php
/**
 * Handle order search requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;
use DateTimeImmutable;
use DateTimeZone;
use Exception;

class OrderSearchHandler {
	const DEFAULT_LIMIT = 10;
	const CACHE_TTL     = 3600;
	const MAX_LIMIT     = 50;
	const OBJECT_CACHE_GROUP = 'agentwp_order_search';
exec
/bin/zsh -lc "sed -n '240,520p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
			'order'   => $normalized['order'],
			'return'  => 'ids',
		);

		if ( '' !== $normalized['status'] ) {
			$query_args['status'] = $normalized['status'];
		}

		if ( is_array( $normalized['date_range'] ) ) {
			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
		}

		if ( '' !== $normalized['email'] ) {
			$query_args['meta_query'] = array(
				'relation' => 'OR',
				array(
					'key'     => '_billing_email',
					'value'   => $normalized['email'],
					'compare' => '=',
				),
exec
/bin/zsh -lc "sed -n '520,1040p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
	}

	/**
	 * @param string $query Query string.
	 * @return string
	 */
	private function detect_status( $query ) {
		$map = array(
			'pending'    => array( 'pending', 'awaiting payment' ),
			'processing' => array( 'processing', 'in progress' ),
			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
			'cancelled'  => array( 'cancelled', 'canceled' ),
			'refunded'   => array( 'refunded', 'refund' ),
			'failed'     => array( 'failed', 'declined' ),
		);

		foreach ( $map as $status => $terms ) {
			foreach ( $terms as $term ) {
				if ( false !== strpos( $query, $term ) ) {

thinking
**Planning BulkHandler for bulk operations**
exec
/bin/zsh -lc "sed -n '1,240p' src/Intent/Engine.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Intent engine for routing requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

use AgentWP\AI\Response;
use AgentWP\Intent\Handlers\AnalyticsQueryHandler;
use AgentWP\Intent\Handlers\CustomerLookupHandler;
use AgentWP\Intent\Handlers\EmailDraftHandler;
use AgentWP\Intent\Handlers\FallbackHandler;
use AgentWP\Intent\Handlers\OrderRefundHandler;
use AgentWP\Intent\Handlers\OrderSearchHandler;
use AgentWP\Intent\Handlers\OrderStatusHandler;
use AgentWP\Intent\Handlers\ProductStockHandler;

class Engine {

thinking
**Checking Intent Handlers directory**
exec
/bin/zsh -lc 'ls src/Intent/Handlers' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
AnalyticsQueryHandler.php
BaseHandler.php
CustomerLookupHandler.php
EmailDraftHandler.php
FallbackHandler.php
OrderRefundHandler.php
OrderSearchHandler.php
OrderStatusHandler.php
ProductStockHandler.php

thinking
**Exploring intent-level handlers**
exec
/bin/zsh -lc "sed -n '1,220p' src/Intent/Handlers/OrderStatusHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * Handle order status intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Intent;

class OrderStatusHandler extends BaseHandler {
	/**
	 * Initialize order status intent handler.
	 *
	 * @return void
	 */
	public function __construct() {
		parent::__construct( Intent::ORDER_STATUS );

thinking
**Checking intent handler capabilities**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/BaseHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Base handler for intent responses.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Handler;
use AgentWP\Intent\Intent;

abstract class BaseHandler implements Handler {
	/**
	 * @var string
	 */
	protected $intent;

	/**

thinking
**Investigating function handler usage**
exec
/bin/zsh -lc 'rg -n "FunctionRegistry|function" src/Intent src/AI' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
src/AI/Functions/GetSalesReport.php:12:	 * Get the function name.
src/AI/Functions/GetSalesReport.php:16:	public function get_name() {
src/AI/Functions/GetSalesReport.php:21:	 * Get the function description.
src/AI/Functions/GetSalesReport.php:25:	public function get_description() {
src/AI/Functions/GetSalesReport.php:30:	 * Get the JSON schema for function parameters.
src/AI/Functions/GetSalesReport.php:34:	public function get_parameters() {
src/Intent/IntentClassifier.php:16:	public function classify( $input, array $context = array() ) {
src/Intent/IntentClassifier.php:56:	private function score_refund( $text ) {
src/Intent/IntentClassifier.php:73:	private function score_status( $text ) {
src/Intent/IntentClassifier.php:93:	private function score_stock( $text ) {
src/Intent/IntentClassifier.php:111:	private function score_email( $text ) {
src/Intent/IntentClassifier.php:134:	private function score_analytics( $text ) {
src/Intent/IntentClassifier.php:154:	private function score_customer( $text ) {
src/Intent/IntentClassifier.php:171:	private function score_search( $text ) {
src/Intent/IntentClassifier.php:191:	private function match_score( $text, array $phrases ) {
src/Intent/IntentClassifier.php:207:	private function contains_phrase( $text, $phrase ) {
src/AI/Functions/SearchOrders.php:12:	 * Get the function name.
src/AI/Functions/SearchOrders.php:16:	public function get_name() {
src/AI/Functions/SearchOrders.php:21:	 * Get the function description.
src/AI/Functions/SearchOrders.php:25:	public function get_description() {

thinking
**Investigating function-to-handler mapping**
exec
/bin/zsh -lc 'rg -n "prepare_status_update|search_orders|prepare_refund|bulk_update|select_orders" src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 38ms:
src/Handlers/RefundHandler.php:27:		return $this->prepare_refund( $args );
src/Handlers/RefundHandler.php:36:	public function prepare_refund( array $args ): Response {
src/Handlers/OrderStatusHandler.php:32:		return $this->prepare_status_update( $args );
src/Handlers/OrderStatusHandler.php:41:	public function prepare_status_update( array $args ): Response {
src/AI/Functions/SearchOrders.php:17:		return 'search_orders';
src/AI/Functions/SelectOrders.php:17:		return 'select_orders';
src/AI/Functions/PrepareRefund.php:17:		return 'prepare_refund';
src/Intent/Engine.php:183:			Intent::ORDER_SEARCH    => array( 'search_orders', 'select_orders' ),
src/Intent/Engine.php:184:			Intent::ORDER_REFUND    => array( 'prepare_refund', 'confirm_refund' ),
src/Intent/Engine.php:185:			Intent::ORDER_STATUS    => array( 'prepare_status_update', 'prepare_bulk_status_update', 'bulk_update' ),
src/AI/Functions/BulkUpdate.php:17:		return 'bulk_update';
src/AI/Functions/PrepareStatusUpdate.php:17:		return 'prepare_status_update';

thinking
**Investigating handler usage**
exec
/bin/zsh -lc "rg -n \"Handlers\\\\\" src includes" in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 53ms:
rg: regex parse error:
    (?:Handlers\)
    ^
error: unclosed group

thinking
**Correcting grep usage with fixed string option**
exec
/bin/zsh -lc "rg -n -F \"Handlers\\\\\" src includes" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
src/Intent/Handlers/CustomerLookupHandler.php:11:use AgentWP\Handlers\CustomerHandler;
src/Intent/Handlers/ProductStockHandler.php:11:use AgentWP\Handlers\StockHandler;
src/Intent/Handlers/OrderSearchHandler.php:11:use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
src/Intent/Engine.php:11:use AgentWP\Intent\Handlers\AnalyticsQueryHandler;
src/Intent/Engine.php:12:use AgentWP\Intent\Handlers\CustomerLookupHandler;
src/Intent/Engine.php:13:use AgentWP\Intent\Handlers\EmailDraftHandler;
src/Intent/Engine.php:14:use AgentWP\Intent\Handlers\FallbackHandler;
src/Intent/Engine.php:15:use AgentWP\Intent\Handlers\OrderRefundHandler;
src/Intent/Engine.php:16:use AgentWP\Intent\Handlers\OrderSearchHandler;
src/Intent/Engine.php:17:use AgentWP\Intent\Handlers\OrderStatusHandler;
src/Intent/Engine.php:18:use AgentWP\Intent\Handlers\ProductStockHandler;

thinking
**Inspecting OrderSearchHandler**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
<?php
/**
 * Handle order search intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
use AgentWP\Intent\Intent;

class OrderSearchHandler extends BaseHandler {
	/**
	 * Initialize order search intent handler.
	 *
	 * @return void
	 */
	public function __construct() {

thinking
**Planning bulk operation integration**
exec
/bin/zsh -lc "sed -n '1,200p' src/Handlers/CustomerHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 46ms:
<?php
/**
 * Handle customer profile requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;

class CustomerHandler {
	const RECENT_LIMIT = 5;
	const TOP_LIMIT    = 5;
	const ORDER_BATCH  = 200;
	const MAX_ORDER_IDS = 2000;
	const PRODUCT_CATEGORY_CACHE_GROUP = 'agentwp_product_categories';
	const PRODUCT_CATEGORY_CACHE_TTL   = 3600;

	/**

thinking
**Searching for handler usage in includes**
exec
/bin/zsh -lc 'rg -n "bulk_update|prepare_bulk_status_update|select_orders|search_orders|prepare_refund" includes src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
src/Handlers/RefundHandler.php:27:		return $this->prepare_refund( $args );
src/Handlers/RefundHandler.php:36:	public function prepare_refund( array $args ): Response {
src/Handlers/OrderStatusHandler.php:29:			return $this->prepare_bulk_status_update( $args );
src/Handlers/OrderStatusHandler.php:128:	public function prepare_bulk_status_update( array $args ): Response {
src/AI/Functions/SearchOrders.php:17:		return 'search_orders';
src/AI/Functions/PrepareRefund.php:17:		return 'prepare_refund';
src/AI/Functions/PrepareBulkStatusUpdate.php:17:		return 'prepare_bulk_status_update';
src/AI/Functions/BulkUpdate.php:17:		return 'bulk_update';
src/AI/Functions/SelectOrders.php:17:		return 'select_orders';
src/Intent/Engine.php:183:			Intent::ORDER_SEARCH    => array( 'search_orders', 'select_orders' ),
src/Intent/Engine.php:184:			Intent::ORDER_REFUND    => array( 'prepare_refund', 'confirm_refund' ),
src/Intent/Engine.php:185:			Intent::ORDER_STATUS    => array( 'prepare_status_update', 'prepare_bulk_status_update', 'bulk_update' ),

thinking
**Searching for function invocations**
exec
/bin/zsh -lc 'rg -n "tool|function_call|OpenAI|chat" src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
src/Billing/UsageTracker.php:3: * Track OpenAI usage and costs.
src/Rest/SettingsController.php:280:	 * Validate API key against OpenAI.
src/Rest/SettingsController.php:298:			return new WP_Error( 'agentwp_openai_unreachable', __( 'OpenAI API is unreachable.', 'agentwp' ) );
src/Rest/SettingsController.php:303:			return new WP_Error( 'agentwp_openai_invalid', __( 'OpenAI rejected the API key.', 'agentwp' ) );
src/Handlers/EmailDraftHandler.php:11:use AgentWP\AI\OpenAIClient;
src/Handlers/EmailDraftHandler.php:341:		$client   = new OpenAIClient(
src/Handlers/EmailDraftHandler.php:350:		$result = $client->chat( $messages, array() );
src/AI/Functions/FunctionSchema.php:29:	public function to_tool_definition();
src/AI/Functions/AbstractFunction.php:3: * Base class for tool definitions.
src/AI/Functions/AbstractFunction.php:19:	public function to_tool_definition() {
src/Intent/FunctionRegistry.php:3: * OpenAI function registry for intent handlers.
src/Intent/FunctionRegistry.php:17:	 * @param string  $function_name OpenAI function name.
src/Intent/FunctionRegistry.php:31:	 * @param string $function_name OpenAI function name.
src/AI/TokenCounter.php:17:	 * Count tokens for a chat request payload.
src/AI/TokenCounter.php:20:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:24:	public function count_request_tokens( array $messages, array $tools, $model ) {
src/AI/TokenCounter.php:28:			+ $this->count_tool_tokens( $tools, $model );
src/AI/TokenCounter.php:32:	 * Count tokens for messages using OpenAI chat heuristics.
src/AI/TokenCounter.php:67:	 * Count tokens for tool definitions.
src/AI/TokenCounter.php:69:	 * @param array  $tools Tool definitions.

thinking
**Searching for function call executions**
exec
/bin/zsh -lc 'rg -n "tool_calls|function_call" src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 34ms:
src/AI/OpenAIClient.php:189:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:430:				'tool_calls' => array(),
src/AI/OpenAIClient.php:441:		$tool_calls = isset( $message['tool_calls'] ) && is_array( $message['tool_calls'] ) ? $message['tool_calls'] : array();
src/AI/OpenAIClient.php:443:		if ( empty( $tool_calls ) && isset( $message['function_call'] ) && is_array( $message['function_call'] ) ) {
src/AI/OpenAIClient.php:444:			$tool_calls = array(
src/AI/OpenAIClient.php:448:					'function' => $message['function_call'],
src/AI/OpenAIClient.php:457:			'tool_calls' => $tool_calls,
src/AI/OpenAIClient.php:471:		$tool_calls = array();
src/AI/OpenAIClient.php:517:			if ( isset( $delta['tool_calls'] ) && is_array( $delta['tool_calls'] ) ) {
src/AI/OpenAIClient.php:518:				$tool_calls = $this->merge_tool_call_deltas( $tool_calls, $delta['tool_calls'] );
src/AI/OpenAIClient.php:521:			if ( isset( $delta['function_call'] ) && is_array( $delta['function_call'] ) ) {
src/AI/OpenAIClient.php:522:				$tool_calls = $this->merge_tool_call_deltas(
src/AI/OpenAIClient.php:523:					$tool_calls,
src/AI/OpenAIClient.php:528:							'function' => $delta['function_call'],
src/AI/OpenAIClient.php:539:			'tool_calls' => array_values( $tool_calls ),
src/AI/OpenAIClient.php:547:	 * @param array $tool_calls Existing tool calls.
src/AI/OpenAIClient.php:551:	private function merge_tool_call_deltas( array $tool_calls, array $deltas ) {
src/AI/OpenAIClient.php:555:			if ( ! isset( $tool_calls[ $index ] ) ) {
src/AI/OpenAIClient.php:556:				$tool_calls[ $index ] = array(
src/AI/OpenAIClient.php:567:				$tool_calls[ $index ]['id'] = $delta['id'];

thinking
**Searching for tool handling in REST endpoints**
exec
/bin/zsh -lc 'rg -n "tool|function" src/Rest includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
src/Rest/IntentController.php:20:	public function register_routes() {
src/Rest/IntentController.php:40:	public function create_intent( $request ) {
src/Rest/IntentController.php:91:	private function get_intent_schema() {
src/Rest/HealthController.php:19:	public function register_routes() {
src/Rest/HealthController.php:39:	public function get_health( $request ) {
src/Rest/SearchController.php:20:	public function register_routes() {
src/Rest/SearchController.php:40:	public function search( $request ) {
src/Rest/SearchController.php:74:	private function get_search_schema() {
src/Rest/SettingsController.php:24:	public function register_routes() {
src/Rest/SettingsController.php:71:	public function get_settings( $request ) {
src/Rest/SettingsController.php:96:	public function update_settings( $request ) {
src/Rest/SettingsController.php:125:	public function update_api_key( $request ) {
src/Rest/SettingsController.php:182:	public function get_usage( $request ) {
src/Rest/SettingsController.php:217:	private function read_settings() {
src/Rest/SettingsController.php:231:	private function apply_settings_updates( array $settings, array $payload ) {
src/Rest/SettingsController.php:285:	private function validate_openai_api_key( $api_key ) {
src/Rest/SettingsController.php:315:	private function encrypt_api_key( $api_key ) {
src/Rest/SettingsController.php:331:	private function maybe_rotate_api_key() {
src/Rest/SettingsController.php:352:	private function get_settings_update_schema() {
src/Rest/SettingsController.php:391:	private function get_api_key_schema() {
exec
/bin/zsh -lc "sed -n '1,200p' src/Rest/IntentController.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Intent REST controller.
 *
 * @package AgentWP
 */

namespace AgentWP\Rest;

use AgentWP\API\RestController;
use AgentWP\Intent\Engine;
use WP_REST_Server;

class IntentController extends RestController {
	/**
	 * Register REST routes.
	 *
	 * @return void
	 */
	public function register_routes() {

thinking
**Investigating tool execution pathways**
exec
/bin/zsh -lc "rg -n \"new .*Handler\\(\" src/Rest src/Handlers src/Intent/Handlers" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
src/Intent/Handlers/CustomerLookupHandler.php:48:		$customer = new CustomerHandler();
src/Intent/Handlers/ProductStockHandler.php:37:		$search = new StockHandler();

thinking
**Searching for function implementations and bulk update handlers**
exec
/bin/zsh -lc 'rg -n "bulk_update|select_orders|prepare_bulk_status_update" .' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
./src/Handlers/OrderStatusHandler.php:29:			return $this->prepare_bulk_status_update( $args );
./src/Handlers/OrderStatusHandler.php:128:	public function prepare_bulk_status_update( array $args ): Response {
./src/AI/Functions/PrepareBulkStatusUpdate.php:17:		return 'prepare_bulk_status_update';
./src/AI/Functions/SelectOrders.php:17:		return 'select_orders';
./src/AI/Functions/BulkUpdate.php:17:		return 'bulk_update';
./src/Intent/Engine.php:183:			Intent::ORDER_SEARCH    => array( 'search_orders', 'select_orders' ),
./src/Intent/Engine.php:185:			Intent::ORDER_STATUS    => array( 'prepare_status_update', 'prepare_bulk_status_update', 'bulk_update' ),
./tasks.csv:14:M02-04,"Order Status Updates","Implement order status change functionality: 1) Create AgentWP\Handlers\OrderStatusHandler class. 2) OpenAI function schema: prepare_status_update(order_id: int, new_status: string, note?: string, notify_customer?: bool). 3) Valid statuses from wc_get_order_statuses(): pending, processing, on-hold, completed, cancelled, refunded, failed. 4) Draft-Confirm protocol: return preview showing current_status → new_status with warning for irreversible changes (cancelled, refunded). 5) Support bulk updates: prepare_bulk_status_update(order_ids: int[], new_status: string). 6) Add order note with '[AgentWP]' prefix for audit trail. 7) Trigger WooCommerce status change hooks for email notifications. Acceptance Criteria: Status only changes after confirmation, customer notification respects notify_customer flag, bulk updates handle up to 50 orders, invalid status transitions rejected with explanation."
./tasks.csv:36:M07-01,"Bulk Actions Development","Implement bulk operation features for V1.1: 1) Create AgentWP\Handlers\BulkHandler class. 2) OpenAI function schemas: select_orders(criteria: {status?, date_range?, customer_email?, total_min?, total_max?, country?}), bulk_update(order_ids: int[], action: string, params: object). 3) Supported bulk actions: update_status, add_tag, add_note, export_csv. 4) Draft-Confirm protocol for bulk operations showing: matched orders count, sample (first 5), action preview. 5) Background processing using Action Scheduler for >20 orders. 6) Progress tracking: WebSocket or polling for real-time updates. 7) Rollback support: store pre-action state for undo (24hr retention). 8) Natural language criteria: 'Select all orders from Germany over €100 this month'. Acceptance Criteria: Bulk operations handle up to 1000 orders, progress updates every 2 seconds, rollback successfully reverts changes, criteria parsing handles complex conditions."

thinking
**Investigating function execution and endpoints**
exec
/bin/zsh -lc 'rg -n "function" src/Rest includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
src/Rest/IntentController.php:20:	public function register_routes() {
src/Rest/IntentController.php:40:	public function create_intent( $request ) {
src/Rest/IntentController.php:91:	private function get_intent_schema() {
src/Rest/HealthController.php:19:	public function register_routes() {
src/Rest/HealthController.php:39:	public function get_health( $request ) {
src/Rest/SearchController.php:20:	public function register_routes() {
src/Rest/SearchController.php:40:	public function search( $request ) {
src/Rest/SearchController.php:74:	private function get_search_schema() {
src/Rest/SettingsController.php:24:	public function register_routes() {
src/Rest/SettingsController.php:71:	public function get_settings( $request ) {
src/Rest/SettingsController.php:96:	public function update_settings( $request ) {
src/Rest/SettingsController.php:125:	public function update_api_key( $request ) {
src/Rest/SettingsController.php:182:	public function get_usage( $request ) {
src/Rest/SettingsController.php:217:	private function read_settings() {
src/Rest/SettingsController.php:231:	private function apply_settings_updates( array $settings, array $payload ) {
src/Rest/SettingsController.php:285:	private function validate_openai_api_key( $api_key ) {
src/Rest/SettingsController.php:315:	private function encrypt_api_key( $api_key ) {
src/Rest/SettingsController.php:331:	private function maybe_rotate_api_key() {
src/Rest/SettingsController.php:352:	private function get_settings_update_schema() {
src/Rest/SettingsController.php:391:	private function get_api_key_schema() {

thinking
**Inspecting SearchController**
exec
/bin/zsh -lc "sed -n '1,200p' src/Rest/SearchController.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 41ms:
<?php
/**
 * Search REST controller.
 *
 * @package AgentWP
 */

namespace AgentWP\Rest;

use AgentWP\API\RestController;
use AgentWP\Search\Index;
use WP_REST_Server;

class SearchController extends RestController {
	/**
	 * Register REST routes.
	 *
	 * @return void
	 */
	public function register_routes() {

thinking
**Searching for action scheduler registrations**
exec
/bin/zsh -lc 'rg -n "Action Scheduler|action_scheduler|ActionScheduler" src includes' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 52ms:


thinking
**Checking for background processing dependencies**
exec
/bin/zsh -lc 'cat composer.json' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
{
  "name": "agentwp/agentwp",
  "description": "AgentWP WordPress plugin.",
  "type": "wordpress-plugin",
  "license": "GPL-2.0-or-later",
  "autoload": {
    "psr-4": {
      "AgentWP\\": "src/"
    }
  },
  "require": {
    "php": ">=8.0",
    "yethee/tiktoken": "^0.1.2"
  },
  "require-dev": {
    "10up/wp_mock": "^1.0",
    "automattic/vipwpcs": "^3.0",
    "dealerdirect/phpcodesniffer-composer-installer": "^1.0",
    "mockery/mockery": "^1.6",
    "phpstan/phpstan": "^1.10",

thinking
**Planning bulk action implementation with progress tracking**

I'm considering using the Action Scheduler plugin from WooCommerce to handle bulk actions over 20 orders. Since there's no REST endpoint for progress, I think implementing progress tracking via polling with transients might work, returning a progress token from the bulk update handler. I'll also check existing features like refunds to see if a similar draft-confirm or progress pattern is used.
exec
/bin/zsh -lc "sed -n '1,260p' src/Handlers/RefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Handle refund draft preparation and confirmation.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;

class RefundHandler {
	const DRAFT_TYPE = 'refund';

	/**
	 * Handle refund-related requests.
	 *
	 * @param array $args Request args.
	 * @return Response

thinking
**Planning bulk handler and parsing criteria**
exec
/bin/zsh -lc 'rg -n "intent|function_suggestions|bulk" react src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
src/Billing/UsageTracker.php:47:	 * @param string $intent_type Intent identifier.
src/Billing/UsageTracker.php:51:	public static function log_usage( $model, $input_tokens, $output_tokens, $intent_type, $timestamp = '' ) {
src/Billing/UsageTracker.php:63:		$intent_type   = self::normalize_intent( $intent_type );
src/Billing/UsageTracker.php:75:				'intent_type'  => $intent_type,
src/Billing/UsageTracker.php:106:			'breakdown_by_intent' => array(),
src/Billing/UsageTracker.php:117:				"SELECT intent_type, model, input_tokens, output_tokens, created_at FROM {$table} WHERE created_at >= %s AND created_at <= %s ORDER BY created_at ASC",
src/Billing/UsageTracker.php:147:			$intent = self::normalize_intent( isset( $row['intent_type'] ) ? $row['intent_type'] : '' );
src/Billing/UsageTracker.php:148:			if ( ! isset( $breakdown[ $intent ] ) ) {
src/Billing/UsageTracker.php:149:				$breakdown[ $intent ] = array(
src/Billing/UsageTracker.php:150:					'intent_type'    => $intent,
src/Billing/UsageTracker.php:155:			$breakdown[ $intent ]['total_tokens'] += $total_tokens;
src/Billing/UsageTracker.php:156:			$breakdown[ $intent ]['total_cost_usd'] += $cost;
src/Billing/UsageTracker.php:188:		$summary['breakdown_by_intent'] = $breakdown_list;
src/Billing/UsageTracker.php:217:			intent_type varchar(64) NOT NULL,
src/Billing/UsageTracker.php:225:			KEY intent_idx (intent_type),
src/Billing/UsageTracker.php:274:	 * @param string $intent Intent identifier.
src/Billing/UsageTracker.php:277:	private static function normalize_intent( $intent ) {
src/Billing/UsageTracker.php:278:		$intent = is_string( $intent ) ? sanitize_text_field( $intent ) : '';
src/Billing/UsageTracker.php:279:		$intent = strtoupper( trim( $intent ) );
src/Billing/UsageTracker.php:281:		return '' !== $intent ? $intent : 'UNKNOWN';

thinking
**Searching for AI function registrations**
exec
/bin/zsh -lc "rg -n \"AI\\\\Functions|FunctionSchema\" src" in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 53ms:
rg: regex parse error:
    (?:AI\Functions|FunctionSchema)
         ^^
error: unrecognized escape sequence

thinking
**Considering use of -F flag**
exec
/bin/zsh -lc "rg -n -F \"AI\\\\Functions\" src" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 60ms:
src/AI/Functions/GetSalesReport.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/SearchOrders.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/PrepareBulkStatusUpdate.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/SelectOrders.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/ConfirmRefund.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/FunctionSchema.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/SearchProduct.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/GetCustomerProfile.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/AbstractFunction.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/PrepareStockUpdate.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/PrepareRefund.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/BulkUpdate.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/DraftEmail.php:8:namespace AgentWP\AI\Functions;
src/AI/Functions/PrepareStatusUpdate.php:8:namespace AgentWP\AI\Functions;
src/AI/OpenAIClient.php:10:use AgentWP\AI\Functions\FunctionSchema;

thinking
**Searching for function registry or endpoint**
exec
/bin/zsh -lc 'rg -n "tool definition|tools" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 44ms:
src/AI/Functions/AbstractFunction.php:3: * Base class for tool definitions.
src/AI/TokenCounter.php:20:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:24:	public function count_request_tokens( array $messages, array $tools, $model ) {
src/AI/TokenCounter.php:28:			+ $this->count_tool_tokens( $tools, $model );
src/AI/TokenCounter.php:67:	 * Count tokens for tool definitions.
src/AI/TokenCounter.php:69:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:73:	public function count_tool_tokens( array $tools, $model ) {
src/AI/TokenCounter.php:74:		if ( empty( $tools ) ) {
src/AI/TokenCounter.php:78:		$payload = wp_json_encode( $tools );
src/AI/OpenAIClient.php:106:		$tools = $this->normalize_tools( $functions );
src/AI/OpenAIClient.php:113:		if ( ! empty( $tools ) ) {
src/AI/OpenAIClient.php:114:			$payload['tools']       = $tools;
src/AI/OpenAIClient.php:123:		$input_tokens = $this->token_counter->count_request_tokens( $messages, $tools, $this->model );
src/AI/OpenAIClient.php:337:	private function normalize_tools( array $functions ) {
src/AI/OpenAIClient.php:338:		$tools = array();
src/AI/OpenAIClient.php:342:				$tools[] = $function->to_tool_definition();
src/AI/OpenAIClient.php:347:				$tools[] = $function->to_tool_definition();
src/AI/OpenAIClient.php:360:				$tools[] = $tool;
src/AI/OpenAIClient.php:370:				$tools[]                   = $tool;
src/AI/OpenAIClient.php:374:		return $tools;

thinking
**Examining function handling and integration**
exec
/bin/zsh -lc 'rg -n "Function" src/API src/Rest' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 57ms:


thinking
**Checking WordPress plugin handlers**
exec
/bin/zsh -lc "sed -n '1,260p' agentwp.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
<?php
/**
 * Plugin Name: AgentWP
 * Plugin URI: https://agentwp.example
 * Description: React-powered admin UI for WooCommerce automation.
 * Version: 0.1.0
 * Requires at least: 6.4
 * Requires PHP: 8.0
 * WC requires at least: 8.0
 * Author: AgentWP
 * Text Domain: agentwp
 * Domain Path: /languages
 */

if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

define( 'AGENTWP_VERSION', '0.1.0' );
define( 'AGENTWP_PLUGIN_FILE', __FILE__ );

thinking
**Inspecting Plugin initialization**
exec
/bin/zsh -lc "sed -n '1,260p' src/Plugin.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 40ms:
<?php
/**
 * Core plugin bootstrap.
 *
 * @package AgentWP
 */

namespace AgentWP;

class Plugin {
	const OPTION_SETTINGS     = 'agentwp_settings';
	const OPTION_API_KEY      = 'agentwp_api_key';
	const OPTION_API_KEY_LAST4 = 'agentwp_api_key_last4';
	const OPTION_DEMO_API_KEY = 'agentwp_demo_api_key';
	const OPTION_DEMO_API_KEY_LAST4 = 'agentwp_demo_api_key_last4';
	const OPTION_BUDGET_LIMIT = 'agentwp_budget_limit';
	const OPTION_DRAFT_TTL    = 'agentwp_draft_ttl_minutes';
	const OPTION_USAGE_STATS  = 'agentwp_usage_stats';
	const TRANSIENT_PREFIX    = 'agentwp_';


thinking
**Investigating function execution paths**
exec
/bin/zsh -lc 'rg -n "OpenAI|tool|function" react/src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
react/src/App.jsx:190:  invalid_api_key: 'The OpenAI API key is invalid. Update it in settings.',
react/src/App.jsx:191:  insufficient_quota: 'OpenAI billing quota has been exhausted. Check your plan or usage.',
react/src/App.jsx:192:  rate_limit_exceeded: 'OpenAI rate limit reached. Please wait and retry.',
react/src/App.jsx:198:  authentication_error: 'OpenAI authentication failed. Check your API key.',
react/src/App.jsx:199:  rate_limit_error: 'OpenAI rate limit reached. Please wait and retry.',
react/src/App.jsx:200:  invalid_request_error: 'This request was rejected by OpenAI. Please try again.',
react/src/App.jsx:201:  server_error: 'OpenAI is having trouble right now. Please retry.',
react/src/App.jsx:202:  overloaded_error: 'OpenAI is overloaded right now. Please retry.',
react/src/App.jsx:207:  agentwp_invalid_key: 'The OpenAI API key is invalid. Update it in settings.',
react/src/App.jsx:416:  if (typeof event.composedPath === 'function') {
react/src/App.jsx:509:  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
react/src/App.jsx:811:    if (activeElement && typeof activeElement.focus === 'function') {
react/src/App.jsx:816:  if (html && selection && typeof document.createRange === 'function') {
react/src/App.jsx:945:export default function App({ shadowRoot = null, portalRoot = null, themeTarget = null }) {
react/src/App.jsx:1880:    if (lastActive && typeof lastActive.focus === 'function') {
react/src/main.jsx:64:  if (typeof event.composedPath === 'function') {
react/src/index.css:119:  --awp-chart-tooltip-bg: #ffffff;
react/src/index.css:120:  --awp-chart-tooltip-border: rgba(148, 163, 184, 0.6);
react/src/index.css:121:  --awp-chart-tooltip-text: #0f172a;
react/src/index.css:236:  --awp-chart-tooltip-bg: #0f172a;

thinking
**Analyzing BulkHandler and criteria parsing design**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/PrepareStatusUpdate.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Function schema for order status updates.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class PrepareStatusUpdate extends AbstractFunction {
	/**
	 * Get the function name.
	 *
	 * @return string
	 */
	public function get_name() {
		return 'prepare_status_update';
	}

	/**

thinking
**Analyzing draft_id handling and schema constraints**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/ConfirmRefund.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
<?php
/**
 * Function schema for refund confirmation.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class ConfirmRefund extends AbstractFunction {
	/**
	 * Get the function name.
	 *
	 * @return string
	 */
	public function get_name() {
		return 'confirm_refund';
	}

	/**

thinking
**Analyzing bulk update confirm flow**
exec
/bin/zsh -lc 'rg -n "order tag|shop_order_tag|tag" src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
src/Search/Index.php:620:		$text = wp_strip_all_tags( (string) $text );
src/Security/Encryption.php:109:				$legacy['tag']
src/Security/Encryption.php:218:			'tag'        => substr( $decoded, self::LEGACY_NONCE_LENGTH, self::LEGACY_TAG_LENGTH ),
src/Context/EmailContextBuilder.php:991:		if ( function_exists( 'wp_strip_all_tags' ) ) {
src/Context/EmailContextBuilder.php:992:			return wp_strip_all_tags( $content );
src/Context/EmailContextBuilder.php:995:		return strip_tags( (string) $content );
src/Handlers/AnalyticsHandler.php:84:				'percentage_change' => $this->build_percentage_change( $current, $previous ),
src/Handlers/AnalyticsHandler.php:368:	private function build_percentage_change( array $current, array $previous ) {
src/Handlers/AnalyticsHandler.php:382:			$changes[ $metric ] = $this->calculate_percentage_change( $current_value, $previous_value );
src/Handlers/AnalyticsHandler.php:411:	private function calculate_percentage_change( $current, $previous ) {
src/Handlers/AnalyticsHandler.php:647:			return wp_strip_all_tags( wc_price( $value ) );
src/Handlers/EmailDraftHandler.php:482:			'You are a customer support assistant for %s. Draft a customer email response. Return JSON with keys subject_line, email_body, plain_text_version. The email_body must be valid HTML using simple tags like <p>, <ul>, <li>, <strong>, and <a>. Mention specific products and tracking details when available. Avoid placeholder text when data exists.',
src/Handlers/EmailDraftHandler.php:1116:			return wp_strip_all_tags( wc_price( $value ) );
src/Handlers/EmailDraftHandler.php:1256:		$text = strip_tags( $text );
src/AI/Functions/BulkUpdate.php:49:					'enum'        => array( 'update_status', 'add_tag', 'add_note', 'export_csv' ),






thinking
**Designing bulk action handling**

I'm figuring out how to implement the "add_tag" action since WooCommerce doesn't natively support order tags; I'll prefer using a custom taxonomy if it exists or fall back to order meta storage. I'll also plan the overall BulkHandler design to handle selecting orders, executing bulk actions with rollback and progress tracking, using transients for temporary state, and integrating Action Scheduler for async processing when handling many orders. I'll parse criteria for selecting orders with various filters like status, date, email, totals, and country, mimicking WooCommerce query patterns while limiting to 1000 results. This approach should provide a robust, flexible bulk operation system.
thinking
**Detailing bulk update workflow and rollback**

I'm laying out how to build order summaries for previews, handle draft and confirm steps for bulk updates with progress tracking, and support rollback by storing pre-action state. I'll design flexible params to handle confirm, progress polling, and rollback via optional keys inside the params object to stay aligned with the spec. The plan includes synchronous or async processing depending on order count, scheduling with Action Scheduler if needed, and carefully structuring progress and rollback data for up to 24 hours. Also, I’ll consider interaction with existing order status handlers and building audit notes for status updates to keep a consistent, robust bulk operation experience.
thinking
**Designing async job scheduling and criteria parsing**

I’m outlining how to register and handle async bulk jobs with Action Scheduler, storing job data in transients and managing progress and rollback records. I’m also planning a flexible criteria parser to extract filters like status, date ranges, totals, emails, and countries from natural language input to support order selection. This setup aims for robust bulk action processing with smooth integration into the plugin’s lifecycle.
thinking
**Planning detailed parsing and processing logic**

I’m mapping out how to parse numeric totals and countries reliably from text and design progress tracking structures for bulk jobs with error limits and timestamps. I'm also detailing rollback mechanics, CSV export workflows, and efficient order selection with WooCommerce queries. The plan covers throttled progress updates, synchronous vs asynchronous processing, criteria normalization, and granular handling for actions like status updates, tags, and notes—all aiming for solid bulk action reliability and undo support.
thinking
**Outlining bulk handler features and structure**

I’m organizing detailed plans for the BulkHandler including CSV export setup, progress and rollback transient management, action parameter normalization, scheduling with Action Scheduler, response formats, order sample formatting, and rollback data tracking for update_status, add_tag, and add_note actions. The plan also covers handling limits, polling intervals, error checking, and WooCommerce integration to ensure reliable async and sync bulk operations.
thinking
**Finalizing parsing and concurrency details**

I’m refining country code detection using regex with word boundaries to avoid false matches, parsing number strings by stripping commas and spaces before normalizing amounts, and ensuring order ID normalization matches existing handlers. I’m also planning to handle concurrency and missing functions gracefully by erroring early, including a 2-second poll interval in progress responses, and adhering to ASCII-only coding conventions. Next, I’m ready to implement the full BulkHandler file with a patch.
file update
A /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/BulkHandler.php
<?php
/**
 * Handle bulk order operations.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;
use DateTimeImmutable;
use DateTimeZone;
use Exception;

class BulkHandler {
	const ACTION_HOOK      = 'agentwp_bulk_process';
	const ASYNC_THRESHOLD  = 20;
	const DRAFT_TYPE       = 'bulk_action';
	const JOB_TTL_SECONDS  = 86400;
	const MAX_BULK         = 1000;
	const PROGRESS_TTL     = 86400;
	const ROLLBACK_TTL     = 86400;
	const POLL_INTERVAL    = 2;

	/**
	 * Register background processing hooks.
	 *
	 * @return void
	 */
	public static function register_hooks() {
		add_action( self::ACTION_HOOK, array( __CLASS__, 'handle_scheduled_action' ), 10, 1 );
	}

	/**
	 * Execute scheduled bulk jobs.
	 *
	 * @param string $job_id Job identifier.
	 * @return void
	 */
	public static function handle_scheduled_action( $job_id ) {
		$handler = new self();
		$handler->process_scheduled_job( $job_id );
	}

	/**
	 * Handle bulk actions and selections.
	 *
	 * @param array $args Request args.
	 * @return Response
	 */
	public function handle( array $args ): Response {
		if ( isset( $args['criteria'] ) ) {
			return $this->select_orders( $args );
		}

		$progress_id = $this->extract_progress_id( $args );
		if ( '' !== $progress_id ) {
			return $this->get_progress_response( $progress_id );
		}

		$rollback_id = $this->extract_rollback_id( $args );
		if ( '' !== $rollback_id ) {
			return $this->rollback_bulk_action( $rollback_id );
		}

		$draft_id = $this->extract_draft_id( $args );
		if ( '' !== $draft_id ) {
			return $this->confirm_bulk_update( $draft_id );
		}

		return $this->prepare_bulk_update( $args );
	}

	/**
	 * Select orders based on criteria.
	 *
	 * @param array $args Request args.
	 * @return Response
	 */
	public function select_orders( array $args ): Response {
		if ( ! function_exists( 'wc_get_orders' ) ) {
			return Response::error( 'WooCommerce is required to select orders.', 400 );
		}

		$criteria  = $this->normalize_criteria( isset( $args['criteria'] ) ? $args['criteria'] : array() );
		$order_ids = $this->query_order_ids( $criteria );
		$sample    = $this->build_sample_orders( $order_ids );

		return Response::success(
			array(
				'order_ids'  => $order_ids,
				'count'      => count( $order_ids ),
				'criteria'   => $criteria,
				'sample'     => $sample,
				'truncated'  => count( $order_ids ) >= self::MAX_BULK,
				'max_limit'  => self::MAX_BULK,
			)
		);
	}

	/**
	 * Prepare a bulk update draft.
	 *
	 * @param array $args Request args.
	 * @return Response
	 */
	private function prepare_bulk_update( array $args ): Response {
		if ( ! function_exists( 'wc_get_order' ) ) {
			return Response::error( 'WooCommerce is required to prepare bulk updates.', 400 );
		}

		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
		if ( empty( $order_ids ) ) {
			return Response::error( 'Missing order IDs for bulk update.', 400 );
		}

		if ( count( $order_ids ) > self::MAX_BULK ) {
			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
		}

		$action = $this->normalize_action( isset( $args['action'] ) ? $args['action'] : '' );
		if ( '' === $action ) {
			return Response::error( 'Missing or invalid bulk action.', 400 );
		}

		$params = $this->normalize_params( $action, isset( $args['params'] ) ? $args['params'] : array() );
		if ( isset( $params['error'] ) ) {
			return Response::error( $params['error'], 400 );
		}

		$missing_orders = $this->find_missing_orders( $order_ids );
		if ( ! empty( $missing_orders ) ) {
			return Response::error(
				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
				404,
				array( 'missing_orders' => $missing_orders )
			);
		}

		$sample = $this->build_sample_orders( $order_ids );
		$preview = array(
			'order_count'    => count( $order_ids ),
			'sample'         => $sample,
			'action'         => $action,
			'action_preview' => $this->build_action_preview( $action, $params ),
		);

		$draft_payload = array(
			'order_ids' => $order_ids,
			'action'    => $action,
			'params'    => $params,
			'preview'   => $preview,
		);

		$draft_id   = $this->generate_uuid();
		$ttl        = $this->get_draft_ttl_seconds();
		$expires_at = gmdate( 'c', time() + $ttl );
		$stored     = $this->store_draft(
			$draft_id,
			array(
				'id'         => $draft_id,
				'type'       => self::DRAFT_TYPE,
				'payload'    => $draft_payload,
				'expires_at' => $expires_at,
			),
			$ttl
		);

		if ( ! $stored ) {
			return Response::error( 'Unable to store bulk update draft.', 500 );
		}

		return Response::success(
			array(
				'draft_id'   => $draft_id,
				'draft'      => $draft_payload,
				'expires_at' => $expires_at,
			)
		);
	}

	/**
	 * Confirm and execute a bulk update draft.
	 *
	 * @param string $draft_id Draft identifier.
	 * @return Response
	 */
	private function confirm_bulk_update( $draft_id ): Response {
		if ( ! function_exists( 'wc_get_order' ) ) {
			return Response::error( 'WooCommerce is required to process bulk updates.', 400 );
		}

		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
		if ( '' === $draft_id ) {
			return Response::error( 'Missing bulk update draft ID.', 400 );
		}

		$draft = $this->load_draft( $draft_id );
		if ( null === $draft ) {
			return Response::error( 'Bulk update draft not found or expired.', 404 );
		}

		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
			return Response::error( 'Draft type mismatch for bulk update confirmation.', 400 );
		}

		$payload  = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
		if ( empty( $order_ids ) ) {
			return Response::error( 'Bulk update draft is missing order IDs.', 400 );
		}

		if ( count( $order_ids ) > self::MAX_BULK ) {
			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
		}

		$action = $this->normalize_action( isset( $payload['action'] ) ? $payload['action'] : '' );
		if ( '' === $action ) {
			return Response::error( 'Bulk update draft is missing an action.', 400 );
		}

		$params = $this->normalize_params( $action, isset( $payload['params'] ) ? $payload['params'] : array() );
		if ( isset( $params['error'] ) ) {
			return Response::error( $params['error'], 400 );
		}

		$job_id      = $this->generate_uuid();
		$progress_id = $this->generate_uuid();
		$rollback_id = $this->generate_uuid();

		$rollback_expires = gmdate( 'c', time() + self::ROLLBACK_TTL );
		$this->store_rollback(
			$rollback_id,
			array(
				'id'         => $rollback_id,
				'action'     => $action,
				'created_at' => gmdate( 'c' ),
				'expires_at' => $rollback_expires,
				'orders'     => array(),
			),
			self::ROLLBACK_TTL
		);

		$progress = array(
			'id'                  => $progress_id,
			'status'              => 'queued',
			'action'              => $action,
			'order_count'         => count( $order_ids ),
			'processed'           => 0,
			'updated'             => 0,
			'failed'              => 0,
			'errors'              => array(),
			'created_at'          => gmdate( 'c' ),
			'started_at'          => '',
			'last_updated'        => gmdate( 'c' ),
			'completed_at'        => '',
			'draft_id'            => $draft_id,
			'rollback_id'         => $rollback_id,
			'undo_available_until'=> $rollback_expires,
		);
		$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );

		$job = array(
			'id'          => $job_id,
			'order_ids'   => $order_ids,
			'action'      => $action,
			'params'      => $params,
			'progress_id' => $progress_id,
			'rollback_id' => $rollback_id,
			'draft_id'    => $draft_id,
		);
		$this->store_job( $job_id, $job, self::JOB_TTL_SECONDS );

		$async = count( $order_ids ) > self::ASYNC_THRESHOLD && $this->action_scheduler_available();
		if ( $async ) {
			$action_id = $this->schedule_job( $job_id );
			if ( ! $action_id ) {
				return Response::error( 'Unable to schedule bulk update.', 500 );
			}

			$this->delete_draft( $draft_id );

			return Response::success(
				array(
					'status'     => 'scheduled',
					'draft_id'   => $draft_id,
					'job_id'     => $job_id,
					'progress'   => $progress,
					'polling'    => array(
						'progress_id'      => $progress_id,
						'interval_seconds' => self::POLL_INTERVAL,
					),
					'rollback_id' => $rollback_id,
					'undo_available_until' => $rollback_expires,
				)
			);
		}

		$progress = $this->update_progress(
			$progress_id,
			array(
				'status'     => 'running',
				'started_at' => gmdate( 'c' ),
			),
			true
		);

		$result = $this->run_bulk_job( $job );

		$progress = $this->update_progress(
			$progress_id,
			array(
				'status'       => 'completed',
				'completed_at' => gmdate( 'c' ),
				'result'       => $result,
			),
			true
		);

		$this->delete_job( $job_id );
		$this->delete_draft( $draft_id );

		return Response::success(
			array(
				'status'      => 'completed',
				'draft_id'    => $draft_id,
				'result'      => $result,
				'progress'    => $progress,
				'polling'     => array(
					'progress_id'      => $progress_id,
					'interval_seconds' => self::POLL_INTERVAL,
				),
				'rollback_id' => $rollback_id,
				'undo_available_until' => $rollback_expires,
			)
		);
	}

	/**
	 * Process a scheduled bulk job.
	 *
	 * @param string $job_id Job identifier.
	 * @return void
	 */
	private function process_scheduled_job( $job_id ) {
		$job_id = is_string( $job_id ) ? trim( $job_id ) : '';
		if ( '' === $job_id ) {
			return;
		}

		$job = $this->load_job( $job_id );
		if ( ! is_array( $job ) ) {
			return;
		}

		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
		if ( '' !== $progress_id ) {
			$this->update_progress(
				$progress_id,
				array(
					'status'     => 'running',
					'started_at' => gmdate( 'c' ),
				),
				true
			);
		}

		$result = $this->run_bulk_job( $job );

		if ( '' !== $progress_id ) {
			$this->update_progress(
				$progress_id,
				array(
					'status'       => 'completed',
					'completed_at' => gmdate( 'c' ),
					'result'       => $result,
				),
				true
			);
		}

		$draft_id = isset( $job['draft_id'] ) ? (string) $job['draft_id'] : '';
		if ( '' !== $draft_id ) {
			$this->delete_draft( $draft_id );
		}

		$this->delete_job( $job_id );
	}

	/**
	 * Execute a bulk job.
	 *
	 * @param array $job Job payload.
	 * @return array
	 */
	private function run_bulk_job( array $job ) {
		$order_ids   = isset( $job['order_ids'] ) ? $this->normalize_order_ids( $job['order_ids'] ) : array();
		$action      = isset( $job['action'] ) ? $this->normalize_action( $job['action'] ) : '';
		$params      = isset( $job['params'] ) && is_array( $job['params'] ) ? $job['params'] : array();
		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
		$rollback_id = isset( $job['rollback_id'] ) ? (string) $job['rollback_id'] : '';

		$result = array(
			'action'    => $action,
			'order_ids' => $order_ids,
			'updated'   => array(),
			'failed'    => array(),
			'errors'    => array(),
		);

		$rollback = $this->load_rollback( $rollback_id );
		if ( ! is_array( $rollback ) ) {
			$rollback = array(
				'id'         => $rollback_id,
				'action'     => $action,
				'created_at' => gmdate( 'c' ),
				'expires_at' => gmdate( 'c', time() + self::ROLLBACK_TTL ),
				'orders'     => array(),
			);
		}

		$processed = 0;
		$updated   = 0;
		$failed    = 0;
		$errors    = array();
		$rows      = array();

		foreach ( $order_ids as $order_id ) {
			$processed++;
			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
			if ( ! $order ) {
				$failed++;
				$errors[] = array(
					'order_id' => $order_id,
					'message'  => 'Order not found.',
				);
				$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
				continue;
			}

			switch ( $action ) {
				case 'update_status':
					$current_status = $this->normalize_status( $order->get_status() );
					$new_status     = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
					if ( '' === $new_status ) {
						$failed++;
						$errors[] = array(
							'order_id' => $order_id,
							'message'  => 'Missing target status.',
						);
						break;
					}

					$rollback['orders'][ $order_id ] = array(
						'status' => $current_status,
					);

					$note            = isset( $params['note'] ) ? (string) $params['note'] : '';
					$notify_customer = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
					$updated_flag    = $this->apply_status_update( $order, $new_status, $note, $notify_customer );

					if ( $updated_flag ) {
						$updated++;
						$result['updated'][] = $order_id;
					} else {
						$failed++;
						$errors[] = array(
							'order_id' => $order_id,
							'message'  => 'Unable to update status.',
						);
					}
					break;
				case 'add_tag':
					$tags = isset( $params['tags'] ) ? $params['tags'] : array();
					$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
					$tags = $this->normalize_tags( $tags, $tag );
					if ( empty( $tags ) ) {
						$failed++;
						$errors[] = array(
							'order_id' => $order_id,
							'message'  => 'Missing tags to add.',
						);
						break;
					}

					$before_tags = $this->get_order_tags( $order_id );
					$rollback['orders'][ $order_id ] = array(
						'tags' => $before_tags,
					);

					$updated_flag = $this->apply_tags_update( $order, $tags );
					if ( $updated_flag ) {
						$updated++;
						$result['updated'][] = $order_id;
					} else {
						$failed++;
						$errors[] = array(
							'order_id' => $order_id,
							'message'  => 'Unable to add tags.',
						);
					}
					break;
				case 'add_note':
					$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
					if ( '' === $note ) {
						$failed++;
						$errors[] = array(
							'order_id' => $order_id,
							'message'  => 'Missing note content.',
						);
						break;
					}

					$is_customer_note = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
					$note_id          = $this->apply_order_note( $order, $note, $is_customer_note );
					if ( $note_id > 0 ) {
						$updated++;
						$result['updated'][] = $order_id;
						$rollback['orders'][ $order_id ] = array(
							'notes' => array( $note_id ),
						);
					} else {
						$failed++;
						$errors[] = array(
							'order_id' => $order_id,
							'message'  => 'Unable to add note.',
						);
					}
					break;
				case 'export_csv':
					$rows[] = $this->format_export_row( $order );
					$updated++;
					$result['updated'][] = $order_id;
					break;
				default:
					$failed++;
					$errors[] = array(
						'order_id' => $order_id,
						'message'  => 'Unsupported bulk action.',
					);
			}

			$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
		}

		$result['errors'] = $errors;
		$result['failed'] = array_unique( array_merge( $result['failed'], wp_list_pluck( $errors, 'order_id' ) ) );

		if ( 'export_csv' === $action ) {
			$export = $this->export_csv( $rows, isset( $params['fields'] ) ? $params['fields'] : array() );
			if ( isset( $export['error'] ) ) {
				$errors[]         = array( 'order_id' => 0, 'message' => $export['error'] );
				$result['errors'] = $errors;
			} else {
				$result['export'] = $export;
			}
		}

		$this->store_rollback( $rollback_id, $rollback, self::ROLLBACK_TTL );

		if ( '' !== $progress_id ) {
			$this->update_progress(
				$progress_id,
				array(
					'processed' => $processed,
					'updated'   => $updated,
					'failed'    => $failed,
					'errors'    => $errors,
				),
				true
			);
		}

		return $result;
	}

	/**
	 * Provide progress updates to polling clients.
	 *
	 * @param string $progress_id Progress identifier.
	 * @return Response
	 */
	private function get_progress_response( $progress_id ): Response {
		$progress = $this->load_progress( $progress_id );
		if ( null === $progress ) {
			return Response::error( 'Bulk progress not found or expired.', 404 );
		}

		return Response::success(
			array(
				'progress' => $progress,
				'polling'  => array(
					'progress_id'      => $progress_id,
					'interval_seconds' => self::POLL_INTERVAL,
				),
			)
		);
	}

	/**
	 * Roll back a bulk action.
	 *
	 * @param string $rollback_id Rollback identifier.
	 * @return Response
	 */
	private function rollback_bulk_action( $rollback_id ): Response {
		$rollback_id = is_string( $rollback_id ) ? trim( $rollback_id ) : '';
		if ( '' === $rollback_id ) {
			return Response::error( 'Missing rollback ID.', 400 );
		}

		$rollback = $this->load_rollback( $rollback_id );
		if ( ! is_array( $rollback ) ) {
			return Response::error( 'Rollback data not found or expired.', 404 );
		}

		$action  = isset( $rollback['action'] ) ? $this->normalize_action( $rollback['action'] ) : '';
		$orders  = isset( $rollback['orders'] ) && is_array( $rollback['orders'] ) ? $rollback['orders'] : array();
		$undone  = array();
		$failed  = array();
		$errors  = array();

		foreach ( $orders as $order_id => $data ) {
			$order_id = absint( $order_id );
			$order    = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
			if ( ! $order ) {
				$failed[] = $order_id;
				$errors[] = array(
					'order_id' => $order_id,
					'message'  => 'Order not found for rollback.',
				);
				continue;
			}

			switch ( $action ) {
				case 'update_status':
					$previous_status = isset( $data['status'] ) ? $this->normalize_status( $data['status'] ) : '';
					if ( '' === $previous_status ) {
						$failed[] = $order_id;
						$errors[] = array(
							'order_id' => $order_id,
							'message'  => 'Missing previous status.',
						);
						break;
					}

					$updated = $this->apply_status_update( $order, $previous_status, 'Rollback to previous status.', false );
					if ( $updated ) {
						$undone[] = $order_id;
					} else {
						$failed[] = $order_id;
						$errors[] = array(
							'order_id' => $order_id,
							'message'  => 'Unable to restore previous status.',
						);
					}
					break;
				case 'add_tag':
					$tags = isset( $data['tags'] ) ? $data['tags'] : array();
					$restored = $this->restore_order_tags( $order_id, $tags );
					if ( $restored ) {
						$undone[] = $order_id;
					} else {
						$failed[] = $order_id;
						$errors[] = array(
							'order_id' => $order_id,
							'message'  => 'Unable to restore tags.',
						);
					}
					break;
				case 'add_note':
					$notes = isset( $data['notes'] ) ? (array) $data['notes'] : array();
					$deleted = $this->delete_order_notes( $notes );
					if ( $deleted ) {
						$undone[] = $order_id;
					} else {
						$failed[] = $order_id;
						$errors[] = array(
							'order_id' => $order_id,
							'message'  => 'Unable to remove notes.',
						);
					}
					break;
				default:
					$failed[] = $order_id;
					$errors[] = array(
						'order_id' => $order_id,
						'message'  => 'Rollback not supported for this action.',
					);
			}
		}

		return Response::success(
			array(
				'rollback_id' => $rollback_id,
				'action'      => $action,
				'undone'      => $undone,
				'failed'      => $failed,
				'errors'      => $errors,
			)
		);
	}

	/**
	 * @param array $criteria Criteria input.
	 * @return array
	 */
	private function normalize_criteria( $criteria ) {
		$parsed = array();
		$query  = '';

		if ( is_string( $criteria ) ) {
			$query = sanitize_text_field( $criteria );
		} elseif ( is_array( $criteria ) ) {
			$query = isset( $criteria['query'] ) ? sanitize_text_field( $criteria['query'] ) : '';
			$parsed['status'] = isset( $criteria['status'] ) ? $this->normalize_status( $criteria['status'] ) : '';
			$parsed['date_range'] = $this->normalize_date_range_input( isset( $criteria['date_range'] ) ? $criteria['date_range'] : null );
			$parsed['customer_email'] = isset( $criteria['customer_email'] ) ? sanitize_email( $criteria['customer_email'] ) : '';
			$parsed['total_min'] = isset( $criteria['total_min'] ) ? $this->normalize_amount( $criteria['total_min'] ) : null;
			$parsed['total_max'] = isset( $criteria['total_max'] ) ? $this->normalize_amount( $criteria['total_max'] ) : null;
			$parsed['country'] = isset( $criteria['country'] ) ? $this->normalize_country( $criteria['country'] ) : '';
		}

		if ( '' !== $query ) {
			$text_parsed = $this->parse_criteria_text( $query );
			foreach ( $text_parsed as $key => $value ) {
				if ( ! isset( $parsed[ $key ] ) || '' === $parsed[ $key ] || null === $parsed[ $key ] ) {
					$parsed[ $key ] = $value;
				}
			}
		}

		if ( '' === $parsed['status'] ) {
			unset( $parsed['status'] );
		}
		if ( '' === $parsed['customer_email'] ) {
			unset( $parsed['customer_email'] );
		}
		if ( '' === $parsed['country'] ) {
			unset( $parsed['country'] );
		}
		if ( null === $parsed['total_min'] ) {
			unset( $parsed['total_min'] );
		}
		if ( null === $parsed['total_max'] ) {
			unset( $parsed['total_max'] );
		}
		if ( null === $parsed['date_range'] ) {
			unset( $parsed['date_range'] );
		}

		return $parsed;
	}

	/**
	 * @param string $query Query string.
	 * @return array
	 */
	private function parse_criteria_text( $query ) {
		$query  = trim( (string) $query );
		$lower  = strtolower( $query );
		$result = array();

		$status = $this->detect_status( $lower );
		if ( '' !== $status ) {
			$result['status'] = $status;
		}

		$date_range = $this->parse_date_range_from_query( $lower );
		if ( null !== $date_range ) {
			$result['date_range'] = $date_range;
		}

		$email = $this->extract_email( $query );
		if ( '' !== $email ) {
			$result['customer_email'] = $email;
		}

		$totals = $this->extract_total_range( $lower );
		if ( isset( $totals['min'] ) ) {
			$result['total_min'] = $totals['min'];
		}
		if ( isset( $totals['max'] ) ) {
			$result['total_max'] = $totals['max'];
		}

		$country = $this->extract_country( $query );
		if ( '' !== $country ) {
			$result['country'] = $country;
		}

		return $result;
	}

	/**
	 * @param array $criteria Query criteria.
	 * @return array
	 */
	private function query_order_ids( array $criteria ) {
		if ( ! function_exists( 'wc_get_orders' ) ) {
			return array();
		}

		$args = array(
			'limit'   => self::MAX_BULK,
			'return'  => 'ids',
			'orderby' => 'date',
			'order'   => 'DESC',
		);

		if ( isset( $criteria['status'] ) && '' !== $criteria['status'] ) {
			$args['status'] = $criteria['status'];
		}

		if ( isset( $criteria['date_range'] ) && is_array( $criteria['date_range'] ) ) {
			$args['date_created'] = $criteria['date_range']['start'] . '...' . $criteria['date_range']['end'];
		}

		$meta_query = array( 'relation' => 'AND' );

		if ( isset( $criteria['customer_email'] ) && '' !== $criteria['customer_email'] ) {
			$meta_query[] = array(
				'relation' => 'OR',
				array(
					'key'     => '_billing_email',
					'value'   => $criteria['customer_email'],
					'compare' => '=',
				),
				array(
					'key'     => '_shipping_email',
					'value'   => $criteria['customer_email'],
					'compare' => '=',
				),
			);
		}

		if ( isset( $criteria['country'] ) && '' !== $criteria['country'] ) {
			$meta_query[] = array(
				'relation' => 'OR',
				array(
					'key'     => '_billing_country',
					'value'   => $criteria['country'],
					'compare' => '=',
				),
				array(
					'key'     => '_shipping_country',
					'value'   => $criteria['country'],
					'compare' => '=',
				),
			);
		}

		if ( isset( $criteria['total_min'] ) ) {
			$meta_query[] = array(
				'key'     => '_order_total',
				'value'   => $criteria['total_min'],
				'compare' => '>=',
				'type'    => 'NUMERIC',
			);
		}

		if ( isset( $criteria['total_max'] ) ) {
			$meta_query[] = array(
				'key'     => '_order_total',
				'value'   => $criteria['total_max'],
				'compare' => '<=',
				'type'    => 'NUMERIC',
			);
		}

		if ( count( $meta_query ) > 1 ) {
			$args['meta_query'] = $meta_query;
		}

		$order_ids = wc_get_orders( $args );
		if ( ! is_array( $order_ids ) ) {
			return array();
		}

		$order_ids = array_map( 'absint', $order_ids );
		$order_ids = array_filter( $order_ids );
		$order_ids = array_values( array_unique( $order_ids ) );

		return $order_ids;
	}

	/**
	 * @param array $order_ids Order IDs.
	 * @return array
	 */
	private function build_sample_orders( array $order_ids ) {
		$sample = array();
		$order_ids = array_slice( $order_ids, 0, 5 );

		foreach ( $order_ids as $order_id ) {
			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
			if ( $order ) {
				$sample[] = $this->format_order_summary( $order );
			}
		}

		return $sample;
	}

	/**
	 * @param object $order Order object.
	 * @return array
	 */
	private function format_order_summary( $order ) {
		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;

		return array(
			'order_id'       => intval( $order->get_id() ),
			'status'         => sanitize_text_field( $order->get_status() ),
			'total'          => $order->get_total(),
			'currency'       => method_exists( $order, 'get_currency' ) ? sanitize_text_field( $order->get_currency() ) : '',
			'customer_name'  => sanitize_text_field( $this->get_customer_name( $order ) ),
			'customer_email' => sanitize_email( $this->get_customer_email( $order ) ),
			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
			'country'        => sanitize_text_field( $this->get_order_country( $order ) ),
		);
	}

	/**
	 * @param mixed $order_ids Order ID input.
	 * @return array
	 */
	private function normalize_order_ids( $order_ids ) {
		$ids = array();

		if ( is_string( $order_ids ) ) {
			$order_ids = preg_split( '/[\s,]+/', $order_ids );
		}

		if ( ! is_array( $order_ids ) ) {
			return $ids;
		}

		foreach ( $order_ids as $order_id ) {
			$normalized = absint( $order_id );
			if ( $normalized > 0 ) {
				$ids[] = $normalized;
			}
		}

		$ids = array_values( array_unique( $ids ) );

		return $ids;
	}

	/**
	 * @param mixed $action Raw action.
	 * @return string
	 */
	private function normalize_action( $action ) {
		$action = is_string( $action ) ? strtolower( trim( $action ) ) : '';
		$allowed = array( 'update_status', 'add_tag', 'add_note', 'export_csv' );

		return in_array( $action, $allowed, true ) ? $action : '';
	}

	/**
	 * @param string $action Action name.
	 * @param mixed  $params Raw params.
	 * @return array
	 */
	private function normalize_params( $action, $params ) {
		$params = is_array( $params ) ? $params : array();
		$normalized = array();

		switch ( $action ) {
			case 'update_status':
				$new_status = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
				if ( '' === $new_status ) {
					return array( 'error' => 'Missing new status for bulk update.' );
				}

				$valid_statuses = $this->get_valid_statuses();
				if ( ! in_array( $new_status, $valid_statuses, true ) ) {
					return array( 'error' => 'Invalid status for bulk update.' );
				}

				$normalized['new_status'] = $new_status;
				$normalized['note'] = isset( $params['note'] ) ? sanitize_text_field( wp_unslash( $params['note'] ) ) : '';
				$normalized['notify_customer'] = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
				break;
			case 'add_tag':
				$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
				$tags = isset( $params['tags'] ) ? $params['tags'] : array();
				$normalized['tags'] = $this->normalize_tags( $tags, $tag );
				if ( empty( $normalized['tags'] ) ) {
					return array( 'error' => 'Missing tags for bulk update.' );
				}
				break;
			case 'add_note':
				$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
				if ( '' === $note ) {
					return array( 'error' => 'Missing note for bulk update.' );
				}
				$normalized['note'] = sanitize_text_field( wp_unslash( $note ) );
				$normalized['is_customer_note'] = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
				break;
			case 'export_csv':
				$fields = isset( $params['fields'] ) ? $params['fields'] : array();
				$normalized['fields'] = $this->normalize_fields( $fields );
				break;
			default:
				return array( 'error' => 'Unsupported bulk action.' );
		}

		return $normalized;
	}

	/**
	 * @param string $action Action name.
	 * @param array  $params Params.
	 * @return array
	 */
	private function build_action_preview( $action, array $params ) {
		switch ( $action ) {
			case 'update_status':
				return array(
					'new_status'      => isset( $params['new_status'] ) ? $params['new_status'] : '',
					'notify_customer' => ! empty( $params['notify_customer'] ),
					'note'            => isset( $params['note'] ) ? $params['note'] : '',
				);
			case 'add_tag':
				return array(
					'tags' => isset( $params['tags'] ) ? $params['tags'] : array(),
				);
			case 'add_note':
				return array(
					'note' => isset( $params['note'] ) ? $params['note'] : '',
				);
			case 'export_csv':
				return array(
					'fields' => isset( $params['fields'] ) ? $params['fields'] : $this->normalize_fields( array() ),
				);
			default:
				return array();
		}
	}

	/**
	 * @param array $order_ids Order IDs.
	 * @return array
	 */
	private function find_missing_orders( array $order_ids ) {
		$missing = array();

		foreach ( $order_ids as $order_id ) {
			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
			if ( ! $order ) {
				$missing[] = $order_id;
			}
		}

		return $missing;
	}

	/**
	 * @param string $progress_id Progress identifier.
	 * @param int    $processed Processed count.
	 * @param int    $updated Updated count.
	 * @param int    $failed Failed count.
	 * @param array  $errors Error list.
	 * @return void
	 */
	private function maybe_update_progress( $progress_id, $processed, $updated, $failed, array $errors ) {
		if ( '' === $progress_id ) {
			return;
		}

		$this->update_progress(
			$progress_id,
			array(
				'processed' => $processed,
				'updated'   => $updated,
				'failed'    => $failed,
				'errors'    => $errors,
			),
			false
		);
	}

	/**
	 * @param string $progress_id Progress ID.
	 * @param array  $updates Updates.
	 * @param bool   $force Force update.
	 * @return array
	 */
	private function update_progress( $progress_id, array $updates, $force ) {
		$progress = $this->load_progress( $progress_id );
		if ( null === $progress ) {
			$progress = array(
				'id'           => $progress_id,
				'status'       => 'queued',
				'processed'    => 0,
				'updated'      => 0,
				'failed'       => 0,
				'errors'       => array(),
				'created_at'   => gmdate( 'c' ),
				'last_updated' => gmdate( 'c' ),
			);
		}

		$last_updated = isset( $progress['last_updated'] ) ? strtotime( $progress['last_updated'] ) : 0;
		$should_update = $force || ( time() - $last_updated >= self::POLL_INTERVAL );

		foreach ( $updates as $key => $value ) {
			$progress[ $key ] = $value;
		}

		if ( $should_update ) {
			$progress['last_updated'] = gmdate( 'c' );
			$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
		}

		return $progress;
	}

	/**
	 * @param string $progress_id Progress ID.
	 * @return array|null
	 */
	private function load_progress( $progress_id ) {
		if ( ! function_exists( 'get_transient' ) ) {
			return null;
		}

		$progress = get_transient( $this->build_progress_key( $progress_id ) );
		if ( false === $progress || ! is_array( $progress ) ) {
			return null;
		}

		return $progress;
	}

	/**
	 * @param string $progress_id Progress ID.
	 * @param array  $progress Progress payload.
	 * @param int    $ttl TTL seconds.
	 * @return bool
	 */
	private function store_progress( $progress_id, array $progress, $ttl ) {
		if ( ! function_exists( 'set_transient' ) ) {
			return false;
		}

		return set_transient( $this->build_progress_key( $progress_id ), $progress, $ttl );
	}

	/**
	 * @param string $job_id Job ID.
	 * @return array|null
	 */
	private function load_job( $job_id ) {
		if ( ! function_exists( 'get_transient' ) ) {
			return null;
		}

		$job = get_transient( $this->build_job_key( $job_id ) );
		if ( false === $job || ! is_array( $job ) ) {
			return null;
		}

		return $job;
	}

	/**
	 * @param string $job_id Job ID.
	 * @param array  $job Job payload.
	 * @param int    $ttl TTL seconds.
	 * @return bool
	 */
	private function store_job( $job_id, array $job, $ttl ) {
		if ( ! function_exists( 'set_transient' ) ) {
			return false;
		}

		return set_transient( $this->build_job_key( $job_id ), $job, $ttl );
	}

	/**
	 * @param string $job_id Job ID.
	 * @return void
	 */
	private function delete_job( $job_id ) {
		if ( function_exists( 'delete_transient' ) ) {
			delete_transient( $this->build_job_key( $job_id ) );
		}
	}

	/**
	 * @param string $rollback_id Rollback ID.
	 * @return array|null
	 */
	private function load_rollback( $rollback_id ) {
		if ( ! function_exists( 'get_transient' ) ) {
			return null;
		}

		$rollback = get_transient( $this->build_rollback_key( $rollback_id ) );
		if ( false === $rollback || ! is_array( $rollback ) ) {
			return null;
		}

		return $rollback;
	}

	/**
	 * @param string $rollback_id Rollback ID.
	 * @param array  $rollback Rollback data.
	 * @param int    $ttl TTL seconds.
	 * @return bool
	 */
	private function store_rollback( $rollback_id, array $rollback, $ttl ) {
		if ( ! function_exists( 'set_transient' ) ) {
			return false;
		}

		return set_transient( $this->build_rollback_key( $rollback_id ), $rollback, $ttl );
	}

	/**
	 * @return string
	 */
	private function generate_uuid() {
		if ( function_exists( 'wp_generate_uuid4' ) ) {
			return wp_generate_uuid4();
		}

		return uniqid( 'bulk_', true );
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return string
	 */
	private function build_draft_key( $draft_id ) {
		return Plugin::TRANSIENT_PREFIX . 'bulk_draft_' . $draft_id;
	}

	/**
	 * @param string $progress_id Progress identifier.
	 * @return string
	 */
	private function build_progress_key( $progress_id ) {
		return Plugin::TRANSIENT_PREFIX . 'bulk_progress_' . $progress_id;
	}

	/**
	 * @param string $job_id Job identifier.
	 * @return string
	 */
	private function build_job_key( $job_id ) {
		return Plugin::TRANSIENT_PREFIX . 'bulk_job_' . $job_id;
	}

	/**
	 * @param string $rollback_id Rollback identifier.
	 * @return string
	 */
	private function build_rollback_key( $rollback_id ) {
		return Plugin::TRANSIENT_PREFIX . 'bulk_rollback_' . $rollback_id;
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @param array  $draft Draft payload.
	 * @param int    $ttl TTL seconds.
	 * @return bool
	 */
	private function store_draft( $draft_id, array $draft, $ttl ) {
		if ( ! function_exists( 'set_transient' ) ) {
			return false;
		}

		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl );
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return array|null
	 */
	private function load_draft( $draft_id ) {
		if ( ! function_exists( 'get_transient' ) ) {
			return null;
		}

		$draft = get_transient( $this->build_draft_key( $draft_id ) );
		if ( false === $draft || ! is_array( $draft ) ) {
			return null;
		}

		return $draft;
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return void
	 */
	private function delete_draft( $draft_id ) {
		if ( function_exists( 'delete_transient' ) ) {
			delete_transient( $this->build_draft_key( $draft_id ) );
		}
	}

	/**
	 * @return int
	 */
	private function get_draft_ttl_seconds() {
		$ttl_minutes = null;

		if ( function_exists( 'get_option' ) ) {
			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
			if ( null !== $option_ttl && '' !== $option_ttl ) {
				$ttl_minutes = intval( $option_ttl );
			}
		}

		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
			$ttl_minutes = 10;
		}

		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;

		return $ttl_minutes * $minute_seconds;
	}

	/**
	 * @param mixed $status Raw status.
	 * @return string
	 */
	private function normalize_status( $status ) {
		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
		if ( '' === $status ) {
			return '';
		}

		if ( 0 === strpos( $status, 'wc-' ) ) {
			$status = substr( $status, 3 );
		}

		return sanitize_key( $status );
	}

	/**
	 * @return array
	 */
	private function get_valid_statuses() {
		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
		$normalized = array();

		if ( function_exists( 'wc_get_order_statuses' ) ) {
			$statuses = wc_get_order_statuses();
			if ( is_array( $statuses ) ) {
				foreach ( array_keys( $statuses ) as $status ) {
					$normalized_status = $this->normalize_status( $status );
					if ( '' !== $normalized_status ) {
						$normalized[] = $normalized_status;
					}
				}
			}
		}

		if ( ! empty( $normalized ) ) {
			$allowed = array_values( array_intersect( $allowed, $normalized ) );
		}

		sort( $allowed );

		return $allowed;
	}

	/**
	 * @param mixed $value Input.
	 * @return bool
	 */
	private function normalize_bool( $value ) {
		if ( function_exists( 'rest_sanitize_boolean' ) ) {
			return rest_sanitize_boolean( $value );
		}

		return (bool) $value;
	}

	/**
	 * @param mixed $amount Amount input.
	 * @return float|null
	 */
	private function normalize_amount( $amount ) {
		if ( null === $amount || '' === $amount ) {
			return null;
		}

		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
		$decimals = $this->get_price_decimals();

		if ( function_exists( 'wc_format_decimal' ) ) {
			return (float) wc_format_decimal( $amount, $decimals );
		}

		return round( $amount, $decimals );
	}

	/**
	 * @return int
	 */
	private function get_price_decimals() {
		if ( function_exists( 'wc_get_price_decimals' ) ) {
			return wc_get_price_decimals();
		}

		return 2;
	}

	/**
	 * @param mixed $country Country input.
	 * @return string
	 */
	private function normalize_country( $country ) {
		$country = is_string( $country ) ? strtoupper( trim( $country ) ) : '';
		if ( '' === $country ) {
			return '';
		}

		if ( strlen( $country ) === 2 ) {
			return $country;
		}

		$map = $this->get_country_map();
		$key = strtolower( $country );

		return isset( $map[ $key ] ) ? $map[ $key ] : '';
	}

	/**
	 * @param mixed $tags Tags list.
	 * @param mixed $tag Single tag.
	 * @return array
	 */
	private function normalize_tags( $tags, $tag ) {
		$list = array();

		if ( is_string( $tags ) ) {
			$tags = preg_split( '/[\s,]+/', $tags );
		}

		if ( is_array( $tags ) ) {
			foreach ( $tags as $item ) {
				$item = sanitize_text_field( (string) $item );
				if ( '' !== $item ) {
					$list[] = $item;
				}
			}
		}

		if ( is_string( $tag ) ) {
			$tag = sanitize_text_field( $tag );
			if ( '' !== $tag ) {
				$list[] = $tag;
			}
		}

		$list = array_values( array_unique( $list ) );

		return $list;
	}

	/**
	 * @param mixed $fields Fields input.
	 * @return array
	 */
	private function normalize_fields( $fields ) {
		$default = array( 'order_id', 'status', 'total', 'currency', 'customer_name', 'customer_email', 'date_created', 'billing_country', 'shipping_country' );
		if ( empty( $fields ) ) {
			return $default;
		}

		if ( is_string( $fields ) ) {
			$fields = preg_split( '/[\s,]+/', $fields );
		}

		if ( ! is_array( $fields ) ) {
			return $default;
		}

		$sanitized = array();
		foreach ( $fields as $field ) {
			$field = sanitize_key( $field );
			if ( '' !== $field ) {
				$sanitized[] = $field;
			}
		}

		return array_values( array_unique( $sanitized ) );
	}

	/**
	 * @param array $order Order object.
	 * @param string $new_status New status.
	 * @param string $note Note for audit.
	 * @param bool $notify_customer Notify flag.
	 * @return bool
	 */
	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
			return false;
		}

		$current_status = $this->normalize_status( $order->get_status() );
		if ( $current_status === $new_status ) {
			return false;
		}

		$note = trim( (string) $note );
		$audit_note = sprintf( '[AgentWP] Bulk status update: %s -> %s.', $current_status, $new_status );
		if ( '' !== $note ) {
			$audit_note .= ' Note: ' . $note . '.';
		}

		$notify_customer = $this->normalize_bool( $notify_customer );
		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );

		$filter = null;
		if ( ! $notify_customer ) {
			$filter = function () {
				return false;
			};
			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
		}

		$order->update_status( $new_status, $audit_note );

		if ( $filter ) {
			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
		}

		return true;
	}

	/**
	 * @param object $order Order object.
	 * @param array  $tags Tags to add.
	 * @return bool
	 */
	private function apply_tags_update( $order, array $tags ) {
		$order_id = method_exists( $order, 'get_id' ) ? $order->get_id() : 0;
		if ( $order_id <= 0 ) {
			return false;
		}

		$taxonomy = $this->get_order_tag_taxonomy();
		if ( '' !== $taxonomy ) {
			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
			if ( is_wp_error( $existing ) ) {
				$existing = array();
			}
			$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
			wp_set_object_terms( $order_id, $merged, $taxonomy, false );
			return true;
		}

		if ( ! method_exists( $order, 'get_meta' ) || ! method_exists( $order, 'update_meta_data' ) ) {
			return false;
		}

		$existing = $order->get_meta( '_agentwp_order_tags', true );
		if ( ! is_array( $existing ) ) {
			$existing = array();
		}

		$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
		$order->update_meta_data( '_agentwp_order_tags', $merged );
		if ( method_exists( $order, 'save' ) ) {
			$order->save();
		}

		return true;
	}

	/**
	 * @param object $order Order object.
	 * @param string $note Note text.
	 * @param bool   $is_customer_note Customer visibility.
	 * @return int
	 */
	private function apply_order_note( $order, $note, $is_customer_note ) {
		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
			return 0;
		}

		$note = trim( (string) $note );
		if ( '' === $note ) {
			return 0;
		}

		$note_id = $order->add_order_note( $note, $is_customer_note );

		return absint( $note_id );
	}

	/**
	 * @param object $order Order object.
	 * @return array
	 */
	private function format_export_row( $order ) {
		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;

		return array(
			'order_id'        => intval( $order->get_id() ),
			'status'          => sanitize_text_field( $order->get_status() ),
			'total'           => $order->get_total(),
			'currency'        => method_exists( $order, 'get_currency' ) ? $order->get_currency() : '',
			'customer_name'   => $this->get_customer_name( $order ),
			'customer_email'  => $this->get_customer_email( $order ),
			'date_created'    => $date_created ? $date_created->date( 'c' ) : '',
			'billing_country' => method_exists( $order, 'get_billing_country' ) ? $order->get_billing_country() : '',
			'shipping_country'=> method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '',
		);
	}

	/**
	 * @param array $rows Data rows.
	 * @param array $fields Fields list.
	 * @return array
	 */
	private function export_csv( array $rows, array $fields ) {
		if ( ! function_exists( 'wp_upload_dir' ) ) {
			return array( 'error' => 'Unable to export CSV in this environment.' );
		}

		$fields = $this->normalize_fields( $fields );
		$upload = wp_upload_dir();
		$base   = isset( $upload['basedir'] ) ? $upload['basedir'] : '';
		$url    = isset( $upload['baseurl'] ) ? $upload['baseurl'] : '';

		if ( '' === $base || '' === $url ) {
			return array( 'error' => 'Unable to resolve upload directory.' );
		}

		$dir = trailingslashit( $base ) . 'agentwp-exports';
		if ( function_exists( 'wp_mkdir_p' ) ) {
			wp_mkdir_p( $dir );
		}

		$filename = 'agentwp-bulk-export-' . gmdate( 'Ymd-His' ) . '-' . wp_generate_password( 6, false ) . '.csv';
		$path     = trailingslashit( $dir ) . $filename;
		$file     = @fopen( $path, 'w' );
		if ( ! $file ) {
			return array( 'error' => 'Unable to create CSV export file.' );
		}

		fputcsv( $file, $fields );
		foreach ( $rows as $row ) {
			$line = array();
			foreach ( $fields as $field ) {
				$line[] = isset( $row[ $field ] ) ? $row[ $field ] : '';
			}
			fputcsv( $file, $line );
		}

		fclose( $file );

		return array(
			'file_path' => $path,
			'file_url'  => trailingslashit( $url ) . 'agentwp-exports/' . $filename,
			'rows'      => count( $rows ),
		);
	}

	/**
	 * @param int $order_id Order ID.
	 * @return array
	 */
	private function get_order_tags( $order_id ) {
		$taxonomy = $this->get_order_tag_taxonomy();
		if ( '' !== $taxonomy ) {
			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
			if ( is_wp_error( $existing ) ) {
				return array();
			}
			return $existing;
		}

		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
		if ( ! $order || ! method_exists( $order, 'get_meta' ) ) {
			return array();
		}

		$existing = $order->get_meta( '_agentwp_order_tags', true );
		if ( ! is_array( $existing ) ) {
			return array();
		}

		return $existing;
	}

	/**
	 * @param int   $order_id Order ID.
	 * @param array $tags Tags.
	 * @return bool
	 */
	private function restore_order_tags( $order_id, $tags ) {
		$taxonomy = $this->get_order_tag_taxonomy();
		if ( '' !== $taxonomy ) {
			wp_set_object_terms( $order_id, (array) $tags, $taxonomy, false );
			return true;
		}

		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
		if ( ! $order || ! method_exists( $order, 'update_meta_data' ) ) {
			return false;
		}

		$order->update_meta_data( '_agentwp_order_tags', (array) $tags );
		if ( method_exists( $order, 'save' ) ) {
			$order->save();
		}

		return true;
	}

	/**
	 * @param array $note_ids Note IDs.
	 * @return bool
	 */
	private function delete_order_notes( array $note_ids ) {
		if ( ! function_exists( 'wp_delete_comment' ) ) {
			return false;
		}

		$deleted_any = false;
		foreach ( $note_ids as $note_id ) {
			$note_id = absint( $note_id );
			if ( $note_id > 0 ) {
				wp_delete_comment( $note_id, true );
				$deleted_any = true;
			}
		}

		return $deleted_any;
	}

	/**
	 * @return string
	 */
	private function get_order_tag_taxonomy() {
		$taxonomy = apply_filters( 'agentwp_order_tag_taxonomy', 'shop_order_tag' );
		$taxonomy = is_string( $taxonomy ) ? trim( $taxonomy ) : '';

		if ( '' !== $taxonomy && function_exists( 'taxonomy_exists' ) && taxonomy_exists( $taxonomy ) ) {
			return $taxonomy;
		}

		return '';
	}

	/**
	 * @param array|null $date_range Date range input.
	 * @return array|null
	 */
	private function normalize_date_range_input( $date_range ) {
		if ( ! is_array( $date_range ) ) {
			return null;
		}

		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';

		return $this->normalize_date_range_values( $start, $end );
	}

	/**
	 * @param string $query Query text.
	 * @return array|null
	 */
	private function parse_date_range_from_query( $query ) {
		if ( false !== strpos( $query, 'yesterday' ) ) {
			return $this->relative_date_range( 'yesterday' );
		}

		if ( false !== strpos( $query, 'last week' ) ) {
			return $this->relative_date_range( 'last week' );
		}

		if ( false !== strpos( $query, 'this month' ) ) {
			return $this->relative_date_range( 'this month' );
		}

		$range = $this->extract_explicit_date_range( $query );
		if ( null !== $range ) {
			return $range;
		}

		return null;
	}

	/**
	 * @param string $phrase Relative phrase.
	 * @return array|null
	 */
	private function relative_date_range( $phrase ) {
		$timezone = $this->get_timezone();
		$now      = new DateTimeImmutable( 'now', $timezone );
		$start    = null;
		$end      = null;

		switch ( $phrase ) {
			case 'yesterday':
				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
				$end   = $start->setTime( 23, 59, 59 );
				break;
			case 'last week':
				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
				break;
			case 'this month':
				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
				$end   = $now->setTime( 23, 59, 59 );
				break;
			default:
				return null;
		}

		return $this->format_date_range( $start, $end );
	}

	/**
	 * @param string $query Query string.
	 * @return array|null
	 */
	private function extract_explicit_date_range( $query ) {
		$patterns = array(
			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
		);

		foreach ( $patterns as $pattern ) {
			if ( ! preg_match( $pattern, $query, $matches ) ) {
				continue;
			}

			$start = trim( $matches[1] );
			$end   = trim( $matches[2] );

			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
				continue;
			}

			$range = $this->normalize_date_range_values( $start, $end );
			if ( null !== $range ) {
				return $range;
			}
		}

		return null;
	}

	/**
	 * @param string $start Start date.
	 * @param string $end End date.
	 * @return array|null
	 */
	private function normalize_date_range_values( $start, $end ) {
		$start_date = $this->parse_date_string( $start, false );
		$end_date   = $this->parse_date_string( $end, true );

		if ( null === $start_date || null === $end_date ) {
			return null;
		}

		if ( $end_date < $start_date ) {
			$temp       = $start_date;
			$start_date = $end_date;
			$end_date   = $temp;
		}

		return $this->format_date_range( $start_date, $end_date );
	}

	/**
	 * @param string $date_string Date string.
	 * @param bool   $end_of_day End of day flag.
	 * @return DateTimeImmutable|null
	 */
	private function parse_date_string( $date_string, $end_of_day ) {
		$date_string = trim( (string) $date_string );
		if ( '' === $date_string ) {
			return null;
		}

		$timezone = $this->get_timezone();
		$base_ts  = $this->get_base_timestamp();
		$ts       = strtotime( $date_string, $base_ts );

		if ( false === $ts ) {
			return null;
		}

		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
		$date = $end_of_day ? $date->setTime( 23, 59, 59 ) : $date->setTime( 0, 0, 0 );

		return $date;
	}

	/**
	 * @param DateTimeImmutable $start Start date.
	 * @param DateTimeImmutable $end End date.
	 * @return array
	 */
	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
		return array(
			'start' => $start->format( 'Y-m-d H:i:s' ),
			'end'   => $end->format( 'Y-m-d H:i:s' ),
		);
	}

	/**
	 * @return DateTimeZone
	 */
	private function get_timezone() {
		if ( function_exists( 'wp_timezone' ) ) {
			return wp_timezone();
		}

		$timezone = '';
		if ( function_exists( 'wp_timezone_string' ) ) {
			$timezone = wp_timezone_string();
		}

		if ( '' === $timezone && function_exists( 'get_option' ) ) {
			$timezone = (string) get_option( 'timezone_string' );
		}

		if ( '' === $timezone ) {
			$timezone = 'UTC';
		}

		try {
			return new DateTimeZone( $timezone );
		} catch ( Exception $exception ) {
			return new DateTimeZone( 'UTC' );
		}
	}

	/**
	 * @return int
	 */
	private function get_base_timestamp() {
		if ( function_exists( 'current_time' ) ) {
			return (int) current_time( 'timestamp' );
		}

		return time();
	}

	/**
	 * @param string $query Query string.
	 * @return string
	 */
	private function detect_status( $query ) {
		$map = array(
			'pending'    => array( 'pending', 'awaiting payment' ),
			'processing' => array( 'processing', 'in progress' ),
			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
			'cancelled'  => array( 'cancelled', 'canceled' ),
			'refunded'   => array( 'refunded', 'refund' ),
			'failed'     => array( 'failed', 'declined' ),
		);

		foreach ( $map as $status => $terms ) {
			foreach ( $terms as $term ) {
				if ( false !== strpos( $query, $term ) ) {
					return $status;
				}
			}
		}

		return '';
	}

	/**
	 * @param string $query Query string.
	 * @return string
	 */
	private function extract_email( $query ) {
		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
			return sanitize_email( $matches[0] );
		}

		return '';
	}

	/**
	 * @param string $query Query string.
	 * @return array
	 */
	private function extract_total_range( $query ) {
		$result = array();

		if ( preg_match( '/\bbetween\s+[\$£\x{20AC}]?([0-9\.,]+)\s+(?:and|to)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
			$result['min'] = $this->parse_amount_string( $matches[1] );
			$result['max'] = $this->parse_amount_string( $matches[2] );
			return $result;
		}

		if ( preg_match( '/\b(over|above|more than|greater than|at least|minimum|min)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
			$result['min'] = $this->parse_amount_string( $matches[2] );
		}

		if ( preg_match( '/\b(under|below|less than|at most|maximum|max)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
			$result['max'] = $this->parse_amount_string( $matches[2] );
		}

		if ( preg_match( '/\b>=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
			$result['min'] = $this->parse_amount_string( $matches[1] );
		}

		if ( preg_match( '/\b<=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
			$result['max'] = $this->parse_amount_string( $matches[1] );
		}

		return $result;
	}

	/**
	 * @param string $value Amount string.
	 * @return float|null
	 */
	private function parse_amount_string( $value ) {
		$value = str_replace( array( ',', ' ' ), '', (string) $value );
		return $this->normalize_amount( $value );
	}

	/**
	 * @param string $query Query string.
	 * @return string
	 */
	private function extract_country( $query ) {
		$query_lower = strtolower( $query );
		$map         = $this->get_country_map();

		foreach ( $map as $name => $code ) {
			$pattern = '/\b' . preg_quote( $name, '/' ) . '\b/i';
			if ( preg_match( $pattern, $query_lower ) ) {
				return $code;
			}
		}

		if ( preg_match_all( '/\b([A-Z]{2})\b/', strtoupper( $query ), $matches ) ) {
			foreach ( $matches[1] as $code ) {
				if ( isset( $map[ strtolower( $code ) ] ) ) {
					return $map[ strtolower( $code ) ];
				}
			}
		}

		return '';
	}

	/**
	 * @return array
	 */
	private function get_country_map() {
		static $map = null;
		if ( null !== $map ) {
			return $map;
		}

		$countries = array();
		if ( function_exists( 'WC' ) ) {
			$wc = WC();
			if ( $wc && isset( $wc->countries ) && method_exists( $wc->countries, 'get_countries' ) ) {
				$countries = $wc->countries->get_countries();
			}
		}

		if ( empty( $countries ) && class_exists( 'WC_Countries' ) ) {
			$wc_countries = new \WC_Countries();
			$countries    = $wc_countries->get_countries();
		}

		$map = array();
		if ( is_array( $countries ) ) {
			foreach ( $countries as $code => $name ) {
				$map[ strtolower( $name ) ] = strtoupper( $code );
				$map[ strtolower( $code ) ] = strtoupper( $code );
			}
		}

		$map['usa'] = 'US';
		$map['us']  = 'US';
		$map['uk']  = 'GB';

		return $map;
	}

	/**
	 * @param object $order Order object.
	 * @return string
	 */
	private function get_customer_name( $order ) {
		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
		$name  = trim( $first . ' ' . $last );

		if ( '' !== $name ) {
			return $name;
		}

		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';

		return trim( $first . ' ' . $last );
	}

	/**
	 * @param object $order Order object.
	 * @return string
	 */
	private function get_customer_email( $order ) {
		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
		if ( '' !== $email ) {
			return $email;
		}

		if ( method_exists( $order, 'get_meta' ) ) {
			$email = $order->get_meta( '_shipping_email' );
		}

		return is_string( $email ) ? $email : '';
	}

	/**
	 * @param object $order Order object.
	 * @return string
	 */
	private function get_order_country( $order ) {
		$country = method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '';
		if ( '' !== $country ) {
			return $country;
		}

		if ( method_exists( $order, 'get_billing_country' ) ) {
			$country = $order->get_billing_country();
		}

		return is_string( $country ) ? $country : '';
	}

	/**
	 * @param array $args Request args.
	 * @return string
	 */
	private function extract_draft_id( array $args ) {
		$draft_id = isset( $args['draft_id'] ) ? $args['draft_id'] : '';
		if ( '' === $draft_id && isset( $args['params']['draft_id'] ) ) {
			$draft_id = $args['params']['draft_id'];
		}

		return is_string( $draft_id ) ? trim( $draft_id ) : '';
	}

	/**
	 * @param array $args Request args.
	 * @return string
	 */
	private function extract_progress_id( array $args ) {
		$progress_id = isset( $args['progress_id'] ) ? $args['progress_id'] : '';
		if ( '' === $progress_id && isset( $args['params']['progress_id'] ) ) {
			$progress_id = $args['params']['progress_id'];
		}

		return is_string( $progress_id ) ? trim( $progress_id ) : '';
	}

	/**
	 * @param array $args Request args.
	 * @return string
	 */
	private function extract_rollback_id( array $args ) {
		$rollback_id = isset( $args['rollback_id'] ) ? $args['rollback_id'] : '';
		if ( '' === $rollback_id && isset( $args['params']['rollback_id'] ) ) {
			$rollback_id = $args['params']['rollback_id'];
		}

		return is_string( $rollback_id ) ? trim( $rollback_id ) : '';
	}

	/**
	 * @return bool
	 */
	private function action_scheduler_available() {
		return function_exists( 'as_enqueue_async_action' ) || function_exists( 'as_schedule_single_action' );
	}

	/**
	 * @param string $job_id Job identifier.
	 * @return int
	 */
	private function schedule_job( $job_id ) {
		if ( function_exists( 'as_enqueue_async_action' ) ) {
			return (int) as_enqueue_async_action( self::ACTION_HOOK, array( 'job_id' => $job_id ) );
		}

		if ( function_exists( 'as_schedule_single_action' ) ) {
			return (int) as_schedule_single_action( time(), self::ACTION_HOOK, array( 'job_id' => $job_id ) );
		}

		return 0;
	}
}
apply_patch(auto_approved=true) exited 0 in 28ms:
Success. Updated the following files:
A src/Handlers/BulkHandler.php
file update:
diff --git a/src/Handlers/BulkHandler.php b/src/Handlers/BulkHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..888e1fd17c14ddb7d62e46e7fc025caced54ff81
--- /dev/null
+++ b/src/Handlers/BulkHandler.php
@@ -0,0 +1,2216 @@
+<?php
+/**
+ * Handle bulk order operations.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class BulkHandler {
+	const ACTION_HOOK      = 'agentwp_bulk_process';
+	const ASYNC_THRESHOLD  = 20;
+	const DRAFT_TYPE       = 'bulk_action';
+	const JOB_TTL_SECONDS  = 86400;
+	const MAX_BULK         = 1000;
+	const PROGRESS_TTL     = 86400;
+	const ROLLBACK_TTL     = 86400;
+	const POLL_INTERVAL    = 2;
+
+	/**
+	 * Register background processing hooks.
+	 *
+	 * @return void
+	 */
+	public static function register_hooks() {
+		add_action( self::ACTION_HOOK, array( __CLASS__, 'handle_scheduled_action' ), 10, 1 );
+	}
+
+	/**
+	 * Execute scheduled bulk jobs.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	public static function handle_scheduled_action( $job_id ) {
+		$handler = new self();
+		$handler->process_scheduled_job( $job_id );
+	}
+
+	/**
+	 * Handle bulk actions and selections.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['criteria'] ) ) {
+			return $this->select_orders( $args );
+		}
+
+		$progress_id = $this->extract_progress_id( $args );
+		if ( '' !== $progress_id ) {
+			return $this->get_progress_response( $progress_id );
+		}
+
+		$rollback_id = $this->extract_rollback_id( $args );
+		if ( '' !== $rollback_id ) {
+			return $this->rollback_bulk_action( $rollback_id );
+		}
+
+		$draft_id = $this->extract_draft_id( $args );
+		if ( '' !== $draft_id ) {
+			return $this->confirm_bulk_update( $draft_id );
+		}
+
+		return $this->prepare_bulk_update( $args );
+	}
+
+	/**
+	 * Select orders based on criteria.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function select_orders( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to select orders.', 400 );
+		}
+
+		$criteria  = $this->normalize_criteria( isset( $args['criteria'] ) ? $args['criteria'] : array() );
+		$order_ids = $this->query_order_ids( $criteria );
+		$sample    = $this->build_sample_orders( $order_ids );
+
+		return Response::success(
+			array(
+				'order_ids'  => $order_ids,
+				'count'      => count( $order_ids ),
+				'criteria'   => $criteria,
+				'sample'     => $sample,
+				'truncated'  => count( $order_ids ) >= self::MAX_BULK,
+				'max_limit'  => self::MAX_BULK,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a bulk update draft.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	private function prepare_bulk_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $args['action'] ) ? $args['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Missing or invalid bulk action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $args['params'] ) ? $args['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$missing_orders = $this->find_missing_orders( $order_ids );
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		$sample = $this->build_sample_orders( $order_ids );
+		$preview = array(
+			'order_count'    => count( $order_ids ),
+			'sample'         => $sample,
+			'action'         => $action,
+			'action_preview' => $this->build_action_preview( $action, $params ),
+		);
+
+		$draft_payload = array(
+			'order_ids' => $order_ids,
+			'action'    => $action,
+			'params'    => $params,
+			'preview'   => $preview,
+		);
+
+		$draft_id   = $this->generate_uuid();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a bulk update draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	private function confirm_bulk_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to process bulk updates.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing bulk update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Bulk update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for bulk update confirmation.', 400 );
+		}
+
+		$payload  = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $payload['action'] ) ? $payload['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Bulk update draft is missing an action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $payload['params'] ) ? $payload['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$job_id      = $this->generate_uuid();
+		$progress_id = $this->generate_uuid();
+		$rollback_id = $this->generate_uuid();
+
+		$rollback_expires = gmdate( 'c', time() + self::ROLLBACK_TTL );
+		$this->store_rollback(
+			$rollback_id,
+			array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => $rollback_expires,
+				'orders'     => array(),
+			),
+			self::ROLLBACK_TTL
+		);
+
+		$progress = array(
+			'id'                  => $progress_id,
+			'status'              => 'queued',
+			'action'              => $action,
+			'order_count'         => count( $order_ids ),
+			'processed'           => 0,
+			'updated'             => 0,
+			'failed'              => 0,
+			'errors'              => array(),
+			'created_at'          => gmdate( 'c' ),
+			'started_at'          => '',
+			'last_updated'        => gmdate( 'c' ),
+			'completed_at'        => '',
+			'draft_id'            => $draft_id,
+			'rollback_id'         => $rollback_id,
+			'undo_available_until'=> $rollback_expires,
+		);
+		$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+
+		$job = array(
+			'id'          => $job_id,
+			'order_ids'   => $order_ids,
+			'action'      => $action,
+			'params'      => $params,
+			'progress_id' => $progress_id,
+			'rollback_id' => $rollback_id,
+			'draft_id'    => $draft_id,
+		);
+		$this->store_job( $job_id, $job, self::JOB_TTL_SECONDS );
+
+		$async = count( $order_ids ) > self::ASYNC_THRESHOLD && $this->action_scheduler_available();
+		if ( $async ) {
+			$action_id = $this->schedule_job( $job_id );
+			if ( ! $action_id ) {
+				return Response::error( 'Unable to schedule bulk update.', 500 );
+			}
+
+			$this->delete_draft( $draft_id );
+
+			return Response::success(
+				array(
+					'status'     => 'scheduled',
+					'draft_id'   => $draft_id,
+					'job_id'     => $job_id,
+					'progress'   => $progress,
+					'polling'    => array(
+						'progress_id'      => $progress_id,
+						'interval_seconds' => self::POLL_INTERVAL,
+					),
+					'rollback_id' => $rollback_id,
+					'undo_available_until' => $rollback_expires,
+				)
+			);
+		}
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'     => 'running',
+				'started_at' => gmdate( 'c' ),
+			),
+			true
+		);
+
+		$result = $this->run_bulk_job( $job );
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'       => 'completed',
+				'completed_at' => gmdate( 'c' ),
+				'result'       => $result,
+			),
+			true
+		);
+
+		$this->delete_job( $job_id );
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'status'      => 'completed',
+				'draft_id'    => $draft_id,
+				'result'      => $result,
+				'progress'    => $progress,
+				'polling'     => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+				'rollback_id' => $rollback_id,
+				'undo_available_until' => $rollback_expires,
+			)
+		);
+	}
+
+	/**
+	 * Process a scheduled bulk job.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	private function process_scheduled_job( $job_id ) {
+		$job_id = is_string( $job_id ) ? trim( $job_id ) : '';
+		if ( '' === $job_id ) {
+			return;
+		}
+
+		$job = $this->load_job( $job_id );
+		if ( ! is_array( $job ) ) {
+			return;
+		}
+
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'     => 'running',
+					'started_at' => gmdate( 'c' ),
+				),
+				true
+			);
+		}
+
+		$result = $this->run_bulk_job( $job );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'       => 'completed',
+					'completed_at' => gmdate( 'c' ),
+					'result'       => $result,
+				),
+				true
+			);
+		}
+
+		$draft_id = isset( $job['draft_id'] ) ? (string) $job['draft_id'] : '';
+		if ( '' !== $draft_id ) {
+			$this->delete_draft( $draft_id );
+		}
+
+		$this->delete_job( $job_id );
+	}
+
+	/**
+	 * Execute a bulk job.
+	 *
+	 * @param array $job Job payload.
+	 * @return array
+	 */
+	private function run_bulk_job( array $job ) {
+		$order_ids   = isset( $job['order_ids'] ) ? $this->normalize_order_ids( $job['order_ids'] ) : array();
+		$action      = isset( $job['action'] ) ? $this->normalize_action( $job['action'] ) : '';
+		$params      = isset( $job['params'] ) && is_array( $job['params'] ) ? $job['params'] : array();
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		$rollback_id = isset( $job['rollback_id'] ) ? (string) $job['rollback_id'] : '';
+
+		$result = array(
+			'action'    => $action,
+			'order_ids' => $order_ids,
+			'updated'   => array(),
+			'failed'    => array(),
+			'errors'    => array(),
+		);
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			$rollback = array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => gmdate( 'c', time() + self::ROLLBACK_TTL ),
+				'orders'     => array(),
+			);
+		}
+
+		$processed = 0;
+		$updated   = 0;
+		$failed    = 0;
+		$errors    = array();
+		$rows      = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$processed++;
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed++;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found.',
+				);
+				$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$current_status = $this->normalize_status( $order->get_status() );
+					$new_status     = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+					if ( '' === $new_status ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing target status.',
+						);
+						break;
+					}
+
+					$rollback['orders'][ $order_id ] = array(
+						'status' => $current_status,
+					);
+
+					$note            = isset( $params['note'] ) ? (string) $params['note'] : '';
+					$notify_customer = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+					$updated_flag    = $this->apply_status_update( $order, $new_status, $note, $notify_customer );
+
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to update status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+					$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+					$tags = $this->normalize_tags( $tags, $tag );
+					if ( empty( $tags ) ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing tags to add.',
+						);
+						break;
+					}
+
+					$before_tags = $this->get_order_tags( $order_id );
+					$rollback['orders'][ $order_id ] = array(
+						'tags' => $before_tags,
+					);
+
+					$updated_flag = $this->apply_tags_update( $order, $tags );
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+					if ( '' === $note ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing note content.',
+						);
+						break;
+					}
+
+					$is_customer_note = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+					$note_id          = $this->apply_order_note( $order, $note, $is_customer_note );
+					if ( $note_id > 0 ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+						$rollback['orders'][ $order_id ] = array(
+							'notes' => array( $note_id ),
+						);
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add note.',
+						);
+					}
+					break;
+				case 'export_csv':
+					$rows[] = $this->format_export_row( $order );
+					$updated++;
+					$result['updated'][] = $order_id;
+					break;
+				default:
+					$failed++;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Unsupported bulk action.',
+					);
+			}
+
+			$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+		}
+
+		$result['errors'] = $errors;
+		$result['failed'] = array_unique( array_merge( $result['failed'], wp_list_pluck( $errors, 'order_id' ) ) );
+
+		if ( 'export_csv' === $action ) {
+			$export = $this->export_csv( $rows, isset( $params['fields'] ) ? $params['fields'] : array() );
+			if ( isset( $export['error'] ) ) {
+				$errors[]         = array( 'order_id' => 0, 'message' => $export['error'] );
+				$result['errors'] = $errors;
+			} else {
+				$result['export'] = $export;
+			}
+		}
+
+		$this->store_rollback( $rollback_id, $rollback, self::ROLLBACK_TTL );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'processed' => $processed,
+					'updated'   => $updated,
+					'failed'    => $failed,
+					'errors'    => $errors,
+				),
+				true
+			);
+		}
+
+		return $result;
+	}
+
+	/**
+	 * Provide progress updates to polling clients.
+	 *
+	 * @param string $progress_id Progress identifier.
+	 * @return Response
+	 */
+	private function get_progress_response( $progress_id ): Response {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			return Response::error( 'Bulk progress not found or expired.', 404 );
+		}
+
+		return Response::success(
+			array(
+				'progress' => $progress,
+				'polling'  => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Roll back a bulk action.
+	 *
+	 * @param string $rollback_id Rollback identifier.
+	 * @return Response
+	 */
+	private function rollback_bulk_action( $rollback_id ): Response {
+		$rollback_id = is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+		if ( '' === $rollback_id ) {
+			return Response::error( 'Missing rollback ID.', 400 );
+		}
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			return Response::error( 'Rollback data not found or expired.', 404 );
+		}
+
+		$action  = isset( $rollback['action'] ) ? $this->normalize_action( $rollback['action'] ) : '';
+		$orders  = isset( $rollback['orders'] ) && is_array( $rollback['orders'] ) ? $rollback['orders'] : array();
+		$undone  = array();
+		$failed  = array();
+		$errors  = array();
+
+		foreach ( $orders as $order_id => $data ) {
+			$order_id = absint( $order_id );
+			$order    = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed[] = $order_id;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found for rollback.',
+				);
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$previous_status = isset( $data['status'] ) ? $this->normalize_status( $data['status'] ) : '';
+					if ( '' === $previous_status ) {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing previous status.',
+						);
+						break;
+					}
+
+					$updated = $this->apply_status_update( $order, $previous_status, 'Rollback to previous status.', false );
+					if ( $updated ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore previous status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $data['tags'] ) ? $data['tags'] : array();
+					$restored = $this->restore_order_tags( $order_id, $tags );
+					if ( $restored ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$notes = isset( $data['notes'] ) ? (array) $data['notes'] : array();
+					$deleted = $this->delete_order_notes( $notes );
+					if ( $deleted ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to remove notes.',
+						);
+					}
+					break;
+				default:
+					$failed[] = $order_id;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Rollback not supported for this action.',
+					);
+			}
+		}
+
+		return Response::success(
+			array(
+				'rollback_id' => $rollback_id,
+				'action'      => $action,
+				'undone'      => $undone,
+				'failed'      => $failed,
+				'errors'      => $errors,
+			)
+		);
+	}
+
+	/**
+	 * @param array $criteria Criteria input.
+	 * @return array
+	 */
+	private function normalize_criteria( $criteria ) {
+		$parsed = array();
+		$query  = '';
+
+		if ( is_string( $criteria ) ) {
+			$query = sanitize_text_field( $criteria );
+		} elseif ( is_array( $criteria ) ) {
+			$query = isset( $criteria['query'] ) ? sanitize_text_field( $criteria['query'] ) : '';
+			$parsed['status'] = isset( $criteria['status'] ) ? $this->normalize_status( $criteria['status'] ) : '';
+			$parsed['date_range'] = $this->normalize_date_range_input( isset( $criteria['date_range'] ) ? $criteria['date_range'] : null );
+			$parsed['customer_email'] = isset( $criteria['customer_email'] ) ? sanitize_email( $criteria['customer_email'] ) : '';
+			$parsed['total_min'] = isset( $criteria['total_min'] ) ? $this->normalize_amount( $criteria['total_min'] ) : null;
+			$parsed['total_max'] = isset( $criteria['total_max'] ) ? $this->normalize_amount( $criteria['total_max'] ) : null;
+			$parsed['country'] = isset( $criteria['country'] ) ? $this->normalize_country( $criteria['country'] ) : '';
+		}
+
+		if ( '' !== $query ) {
+			$text_parsed = $this->parse_criteria_text( $query );
+			foreach ( $text_parsed as $key => $value ) {
+				if ( ! isset( $parsed[ $key ] ) || '' === $parsed[ $key ] || null === $parsed[ $key ] ) {
+					$parsed[ $key ] = $value;
+				}
+			}
+		}
+
+		if ( '' === $parsed['status'] ) {
+			unset( $parsed['status'] );
+		}
+		if ( '' === $parsed['customer_email'] ) {
+			unset( $parsed['customer_email'] );
+		}
+		if ( '' === $parsed['country'] ) {
+			unset( $parsed['country'] );
+		}
+		if ( null === $parsed['total_min'] ) {
+			unset( $parsed['total_min'] );
+		}
+		if ( null === $parsed['total_max'] ) {
+			unset( $parsed['total_max'] );
+		}
+		if ( null === $parsed['date_range'] ) {
+			unset( $parsed['date_range'] );
+		}
+
+		return $parsed;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function parse_criteria_text( $query ) {
+		$query  = trim( (string) $query );
+		$lower  = strtolower( $query );
+		$result = array();
+
+		$status = $this->detect_status( $lower );
+		if ( '' !== $status ) {
+			$result['status'] = $status;
+		}
+
+		$date_range = $this->parse_date_range_from_query( $lower );
+		if ( null !== $date_range ) {
+			$result['date_range'] = $date_range;
+		}
+
+		$email = $this->extract_email( $query );
+		if ( '' !== $email ) {
+			$result['customer_email'] = $email;
+		}
+
+		$totals = $this->extract_total_range( $lower );
+		if ( isset( $totals['min'] ) ) {
+			$result['total_min'] = $totals['min'];
+		}
+		if ( isset( $totals['max'] ) ) {
+			$result['total_max'] = $totals['max'];
+		}
+
+		$country = $this->extract_country( $query );
+		if ( '' !== $country ) {
+			$result['country'] = $country;
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param array $criteria Query criteria.
+	 * @return array
+	 */
+	private function query_order_ids( array $criteria ) {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		$args = array(
+			'limit'   => self::MAX_BULK,
+			'return'  => 'ids',
+			'orderby' => 'date',
+			'order'   => 'DESC',
+		);
+
+		if ( isset( $criteria['status'] ) && '' !== $criteria['status'] ) {
+			$args['status'] = $criteria['status'];
+		}
+
+		if ( isset( $criteria['date_range'] ) && is_array( $criteria['date_range'] ) ) {
+			$args['date_created'] = $criteria['date_range']['start'] . '...' . $criteria['date_range']['end'];
+		}
+
+		$meta_query = array( 'relation' => 'AND' );
+
+		if ( isset( $criteria['customer_email'] ) && '' !== $criteria['customer_email'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['country'] ) && '' !== $criteria['country'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['total_min'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_min'],
+				'compare' => '>=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( isset( $criteria['total_max'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_max'],
+				'compare' => '<=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( count( $meta_query ) > 1 ) {
+			$args['meta_query'] = $meta_query;
+		}
+
+		$order_ids = wc_get_orders( $args );
+		if ( ! is_array( $order_ids ) ) {
+			return array();
+		}
+
+		$order_ids = array_map( 'absint', $order_ids );
+		$order_ids = array_filter( $order_ids );
+		$order_ids = array_values( array_unique( $order_ids ) );
+
+		return $order_ids;
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function build_sample_orders( array $order_ids ) {
+		$sample = array();
+		$order_ids = array_slice( $order_ids, 0, 5 );
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( $order ) {
+				$sample[] = $this->format_order_summary( $order );
+			}
+		}
+
+		return $sample;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_order_summary( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'       => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'currency'       => method_exists( $order, 'get_currency' ) ? sanitize_text_field( $order->get_currency() ) : '',
+			'customer_name'  => sanitize_text_field( $this->get_customer_name( $order ) ),
+			'customer_email' => sanitize_email( $this->get_customer_email( $order ) ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'country'        => sanitize_text_field( $this->get_order_country( $order ) ),
+		);
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @param mixed $action Raw action.
+	 * @return string
+	 */
+	private function normalize_action( $action ) {
+		$action = is_string( $action ) ? strtolower( trim( $action ) ) : '';
+		$allowed = array( 'update_status', 'add_tag', 'add_note', 'export_csv' );
+
+		return in_array( $action, $allowed, true ) ? $action : '';
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param mixed  $params Raw params.
+	 * @return array
+	 */
+	private function normalize_params( $action, $params ) {
+		$params = is_array( $params ) ? $params : array();
+		$normalized = array();
+
+		switch ( $action ) {
+			case 'update_status':
+				$new_status = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+				if ( '' === $new_status ) {
+					return array( 'error' => 'Missing new status for bulk update.' );
+				}
+
+				$valid_statuses = $this->get_valid_statuses();
+				if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+					return array( 'error' => 'Invalid status for bulk update.' );
+				}
+
+				$normalized['new_status'] = $new_status;
+				$normalized['note'] = isset( $params['note'] ) ? sanitize_text_field( wp_unslash( $params['note'] ) ) : '';
+				$normalized['notify_customer'] = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+				break;
+			case 'add_tag':
+				$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+				$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+				$normalized['tags'] = $this->normalize_tags( $tags, $tag );
+				if ( empty( $normalized['tags'] ) ) {
+					return array( 'error' => 'Missing tags for bulk update.' );
+				}
+				break;
+			case 'add_note':
+				$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+				if ( '' === $note ) {
+					return array( 'error' => 'Missing note for bulk update.' );
+				}
+				$normalized['note'] = sanitize_text_field( wp_unslash( $note ) );
+				$normalized['is_customer_note'] = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+				break;
+			case 'export_csv':
+				$fields = isset( $params['fields'] ) ? $params['fields'] : array();
+				$normalized['fields'] = $this->normalize_fields( $fields );
+				break;
+			default:
+				return array( 'error' => 'Unsupported bulk action.' );
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param array  $params Params.
+	 * @return array
+	 */
+	private function build_action_preview( $action, array $params ) {
+		switch ( $action ) {
+			case 'update_status':
+				return array(
+					'new_status'      => isset( $params['new_status'] ) ? $params['new_status'] : '',
+					'notify_customer' => ! empty( $params['notify_customer'] ),
+					'note'            => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'add_tag':
+				return array(
+					'tags' => isset( $params['tags'] ) ? $params['tags'] : array(),
+				);
+			case 'add_note':
+				return array(
+					'note' => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'export_csv':
+				return array(
+					'fields' => isset( $params['fields'] ) ? $params['fields'] : $this->normalize_fields( array() ),
+				);
+			default:
+				return array();
+		}
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function find_missing_orders( array $order_ids ) {
+		$missing = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$missing[] = $order_id;
+			}
+		}
+
+		return $missing;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @param int    $processed Processed count.
+	 * @param int    $updated Updated count.
+	 * @param int    $failed Failed count.
+	 * @param array  $errors Error list.
+	 * @return void
+	 */
+	private function maybe_update_progress( $progress_id, $processed, $updated, $failed, array $errors ) {
+		if ( '' === $progress_id ) {
+			return;
+		}
+
+		$this->update_progress(
+			$progress_id,
+			array(
+				'processed' => $processed,
+				'updated'   => $updated,
+				'failed'    => $failed,
+				'errors'    => $errors,
+			),
+			false
+		);
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $updates Updates.
+	 * @param bool   $force Force update.
+	 * @return array
+	 */
+	private function update_progress( $progress_id, array $updates, $force ) {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			$progress = array(
+				'id'           => $progress_id,
+				'status'       => 'queued',
+				'processed'    => 0,
+				'updated'      => 0,
+				'failed'       => 0,
+				'errors'       => array(),
+				'created_at'   => gmdate( 'c' ),
+				'last_updated' => gmdate( 'c' ),
+			);
+		}
+
+		$last_updated = isset( $progress['last_updated'] ) ? strtotime( $progress['last_updated'] ) : 0;
+		$should_update = $force || ( time() - $last_updated >= self::POLL_INTERVAL );
+
+		foreach ( $updates as $key => $value ) {
+			$progress[ $key ] = $value;
+		}
+
+		if ( $should_update ) {
+			$progress['last_updated'] = gmdate( 'c' );
+			$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @return array|null
+	 */
+	private function load_progress( $progress_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$progress = get_transient( $this->build_progress_key( $progress_id ) );
+		if ( false === $progress || ! is_array( $progress ) ) {
+			return null;
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $progress Progress payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_progress( $progress_id, array $progress, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_progress_key( $progress_id ), $progress, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return array|null
+	 */
+	private function load_job( $job_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$job = get_transient( $this->build_job_key( $job_id ) );
+		if ( false === $job || ! is_array( $job ) ) {
+			return null;
+		}
+
+		return $job;
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @param array  $job Job payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_job( $job_id, array $job, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_job_key( $job_id ), $job, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return void
+	 */
+	private function delete_job( $job_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_job_key( $job_id ) );
+		}
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @return array|null
+	 */
+	private function load_rollback( $rollback_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$rollback = get_transient( $this->build_rollback_key( $rollback_id ) );
+		if ( false === $rollback || ! is_array( $rollback ) ) {
+			return null;
+		}
+
+		return $rollback;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @param array  $rollback Rollback data.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_rollback( $rollback_id, array $rollback, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_rollback_key( $rollback_id ), $rollback, $ttl );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_uuid() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'bulk_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_draft_' . $draft_id;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @return string
+	 */
+	private function build_progress_key( $progress_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_progress_' . $progress_id;
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return string
+	 */
+	private function build_job_key( $job_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_job_' . $job_id;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback identifier.
+	 * @return string
+	 */
+	private function build_rollback_key( $rollback_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_rollback_' . $rollback_id;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param mixed $status Raw status.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float|null
+	 */
+	private function normalize_amount( $amount ) {
+		if ( null === $amount || '' === $amount ) {
+			return null;
+		}
+
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $country Country input.
+	 * @return string
+	 */
+	private function normalize_country( $country ) {
+		$country = is_string( $country ) ? strtoupper( trim( $country ) ) : '';
+		if ( '' === $country ) {
+			return '';
+		}
+
+		if ( strlen( $country ) === 2 ) {
+			return $country;
+		}
+
+		$map = $this->get_country_map();
+		$key = strtolower( $country );
+
+		return isset( $map[ $key ] ) ? $map[ $key ] : '';
+	}
+
+	/**
+	 * @param mixed $tags Tags list.
+	 * @param mixed $tag Single tag.
+	 * @return array
+	 */
+	private function normalize_tags( $tags, $tag ) {
+		$list = array();
+
+		if ( is_string( $tags ) ) {
+			$tags = preg_split( '/[\s,]+/', $tags );
+		}
+
+		if ( is_array( $tags ) ) {
+			foreach ( $tags as $item ) {
+				$item = sanitize_text_field( (string) $item );
+				if ( '' !== $item ) {
+					$list[] = $item;
+				}
+			}
+		}
+
+		if ( is_string( $tag ) ) {
+			$tag = sanitize_text_field( $tag );
+			if ( '' !== $tag ) {
+				$list[] = $tag;
+			}
+		}
+
+		$list = array_values( array_unique( $list ) );
+
+		return $list;
+	}
+
+	/**
+	 * @param mixed $fields Fields input.
+	 * @return array
+	 */
+	private function normalize_fields( $fields ) {
+		$default = array( 'order_id', 'status', 'total', 'currency', 'customer_name', 'customer_email', 'date_created', 'billing_country', 'shipping_country' );
+		if ( empty( $fields ) ) {
+			return $default;
+		}
+
+		if ( is_string( $fields ) ) {
+			$fields = preg_split( '/[\s,]+/', $fields );
+		}
+
+		if ( ! is_array( $fields ) ) {
+			return $default;
+		}
+
+		$sanitized = array();
+		foreach ( $fields as $field ) {
+			$field = sanitize_key( $field );
+			if ( '' !== $field ) {
+				$sanitized[] = $field;
+			}
+		}
+
+		return array_values( array_unique( $sanitized ) );
+	}
+
+	/**
+	 * @param array $order Order object.
+	 * @param string $new_status New status.
+	 * @param string $note Note for audit.
+	 * @param bool $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $current_status === $new_status ) {
+			return false;
+		}
+
+		$note = trim( (string) $note );
+		$audit_note = sprintf( '[AgentWP] Bulk status update: %s -> %s.', $current_status, $new_status );
+		if ( '' !== $note ) {
+			$audit_note .= ' Note: ' . $note . '.';
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $audit_note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param array  $tags Tags to add.
+	 * @return bool
+	 */
+	private function apply_tags_update( $order, array $tags ) {
+		$order_id = method_exists( $order, 'get_id' ) ? $order->get_id() : 0;
+		if ( $order_id <= 0 ) {
+			return false;
+		}
+
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				$existing = array();
+			}
+			$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+			wp_set_object_terms( $order_id, $merged, $taxonomy, false );
+			return true;
+		}
+
+		if ( ! method_exists( $order, 'get_meta' ) || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			$existing = array();
+		}
+
+		$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+		$order->update_meta_data( '_agentwp_order_tags', $merged );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param string $note Note text.
+	 * @param bool   $is_customer_note Customer visibility.
+	 * @return int
+	 */
+	private function apply_order_note( $order, $note, $is_customer_note ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return 0;
+		}
+
+		$note = trim( (string) $note );
+		if ( '' === $note ) {
+			return 0;
+		}
+
+		$note_id = $order->add_order_note( $note, $is_customer_note );
+
+		return absint( $note_id );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_export_row( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'        => intval( $order->get_id() ),
+			'status'          => sanitize_text_field( $order->get_status() ),
+			'total'           => $order->get_total(),
+			'currency'        => method_exists( $order, 'get_currency' ) ? $order->get_currency() : '',
+			'customer_name'   => $this->get_customer_name( $order ),
+			'customer_email'  => $this->get_customer_email( $order ),
+			'date_created'    => $date_created ? $date_created->date( 'c' ) : '',
+			'billing_country' => method_exists( $order, 'get_billing_country' ) ? $order->get_billing_country() : '',
+			'shipping_country'=> method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '',
+		);
+	}
+
+	/**
+	 * @param array $rows Data rows.
+	 * @param array $fields Fields list.
+	 * @return array
+	 */
+	private function export_csv( array $rows, array $fields ) {
+		if ( ! function_exists( 'wp_upload_dir' ) ) {
+			return array( 'error' => 'Unable to export CSV in this environment.' );
+		}
+
+		$fields = $this->normalize_fields( $fields );
+		$upload = wp_upload_dir();
+		$base   = isset( $upload['basedir'] ) ? $upload['basedir'] : '';
+		$url    = isset( $upload['baseurl'] ) ? $upload['baseurl'] : '';
+
+		if ( '' === $base || '' === $url ) {
+			return array( 'error' => 'Unable to resolve upload directory.' );
+		}
+
+		$dir = trailingslashit( $base ) . 'agentwp-exports';
+		if ( function_exists( 'wp_mkdir_p' ) ) {
+			wp_mkdir_p( $dir );
+		}
+
+		$filename = 'agentwp-bulk-export-' . gmdate( 'Ymd-His' ) . '-' . wp_generate_password( 6, false ) . '.csv';
+		$path     = trailingslashit( $dir ) . $filename;
+		$file     = @fopen( $path, 'w' );
+		if ( ! $file ) {
+			return array( 'error' => 'Unable to create CSV export file.' );
+		}
+
+		fputcsv( $file, $fields );
+		foreach ( $rows as $row ) {
+			$line = array();
+			foreach ( $fields as $field ) {
+				$line[] = isset( $row[ $field ] ) ? $row[ $field ] : '';
+			}
+			fputcsv( $file, $line );
+		}
+
+		fclose( $file );
+
+		return array(
+			'file_path' => $path,
+			'file_url'  => trailingslashit( $url ) . 'agentwp-exports/' . $filename,
+			'rows'      => count( $rows ),
+		);
+	}
+
+	/**
+	 * @param int $order_id Order ID.
+	 * @return array
+	 */
+	private function get_order_tags( $order_id ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				return array();
+			}
+			return $existing;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'get_meta' ) ) {
+			return array();
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			return array();
+		}
+
+		return $existing;
+	}
+
+	/**
+	 * @param int   $order_id Order ID.
+	 * @param array $tags Tags.
+	 * @return bool
+	 */
+	private function restore_order_tags( $order_id, $tags ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			wp_set_object_terms( $order_id, (array) $tags, $taxonomy, false );
+			return true;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$order->update_meta_data( '_agentwp_order_tags', (array) $tags );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param array $note_ids Note IDs.
+	 * @return bool
+	 */
+	private function delete_order_notes( array $note_ids ) {
+		if ( ! function_exists( 'wp_delete_comment' ) ) {
+			return false;
+		}
+
+		$deleted_any = false;
+		foreach ( $note_ids as $note_id ) {
+			$note_id = absint( $note_id );
+			if ( $note_id > 0 ) {
+				wp_delete_comment( $note_id, true );
+				$deleted_any = true;
+			}
+		}
+
+		return $deleted_any;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function get_order_tag_taxonomy() {
+		$taxonomy = apply_filters( 'agentwp_order_tag_taxonomy', 'shop_order_tag' );
+		$taxonomy = is_string( $taxonomy ) ? trim( $taxonomy ) : '';
+
+		if ( '' !== $taxonomy && function_exists( 'taxonomy_exists' ) && taxonomy_exists( $taxonomy ) ) {
+			return $taxonomy;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param array|null $date_range Date range input.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query text.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date.
+	 * @param string $end End date.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Date string.
+	 * @param bool   $end_of_day End of day flag.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		$date = $end_of_day ? $date->setTime( 23, 59, 59 ) : $date->setTime( 0, 0, 0 );
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function extract_total_range( $query ) {
+		$result = array();
+
+		if ( preg_match( '/\bbetween\s+[\$£\x{20AC}]?([0-9\.,]+)\s+(?:and|to)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+			return $result;
+		}
+
+		if ( preg_match( '/\b(over|above|more than|greater than|at least|minimum|min)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b(under|below|less than|at most|maximum|max)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b>=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		if ( preg_match( '/\b<=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param string $value Amount string.
+	 * @return float|null
+	 */
+	private function parse_amount_string( $value ) {
+		$value = str_replace( array( ',', ' ' ), '', (string) $value );
+		return $this->normalize_amount( $value );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_country( $query ) {
+		$query_lower = strtolower( $query );
+		$map         = $this->get_country_map();
+
+		foreach ( $map as $name => $code ) {
+			$pattern = '/\b' . preg_quote( $name, '/' ) . '\b/i';
+			if ( preg_match( $pattern, $query_lower ) ) {
+				return $code;
+			}
+		}
+
+		if ( preg_match_all( '/\b([A-Z]{2})\b/', strtoupper( $query ), $matches ) ) {
+			foreach ( $matches[1] as $code ) {
+				if ( isset( $map[ strtolower( $code ) ] ) ) {
+					return $map[ strtolower( $code ) ];
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_country_map() {
+		static $map = null;
+		if ( null !== $map ) {
+			return $map;
+		}
+
+		$countries = array();
+		if ( function_exists( 'WC' ) ) {
+			$wc = WC();
+			if ( $wc && isset( $wc->countries ) && method_exists( $wc->countries, 'get_countries' ) ) {
+				$countries = $wc->countries->get_countries();
+			}
+		}
+
+		if ( empty( $countries ) && class_exists( 'WC_Countries' ) ) {
+			$wc_countries = new \WC_Countries();
+			$countries    = $wc_countries->get_countries();
+		}
+
+		$map = array();
+		if ( is_array( $countries ) ) {
+			foreach ( $countries as $code => $name ) {
+				$map[ strtolower( $name ) ] = strtoupper( $code );
+				$map[ strtolower( $code ) ] = strtoupper( $code );
+			}
+		}
+
+		$map['usa'] = 'US';
+		$map['us']  = 'US';
+		$map['uk']  = 'GB';
+
+		return $map;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_order_country( $order ) {
+		$country = method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '';
+		if ( '' !== $country ) {
+			return $country;
+		}
+
+		if ( method_exists( $order, 'get_billing_country' ) ) {
+			$country = $order->get_billing_country();
+		}
+
+		return is_string( $country ) ? $country : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_draft_id( array $args ) {
+		$draft_id = isset( $args['draft_id'] ) ? $args['draft_id'] : '';
+		if ( '' === $draft_id && isset( $args['params']['draft_id'] ) ) {
+			$draft_id = $args['params']['draft_id'];
+		}
+
+		return is_string( $draft_id ) ? trim( $draft_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_progress_id( array $args ) {
+		$progress_id = isset( $args['progress_id'] ) ? $args['progress_id'] : '';
+		if ( '' === $progress_id && isset( $args['params']['progress_id'] ) ) {
+			$progress_id = $args['params']['progress_id'];
+		}
+
+		return is_string( $progress_id ) ? trim( $progress_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_rollback_id( array $args ) {
+		$rollback_id = isset( $args['rollback_id'] ) ? $args['rollback_id'] : '';
+		if ( '' === $rollback_id && isset( $args['params']['rollback_id'] ) ) {
+			$rollback_id = $args['params']['rollback_id'];
+		}
+
+		return is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+	}
+
+	/**
+	 * @return bool
+	 */
+	private function action_scheduler_available() {
+		return function_exists( 'as_enqueue_async_action' ) || function_exists( 'as_schedule_single_action' );
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return int
+	 */
+	private function schedule_job( $job_id ) {
+		if ( function_exists( 'as_enqueue_async_action' ) ) {
+			return (int) as_enqueue_async_action( self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		if ( function_exists( 'as_schedule_single_action' ) ) {
+			return (int) as_schedule_single_action( time(), self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		return 0;
+	}
+}

file update:
diff --git a/src/Handlers/BulkHandler.php b/src/Handlers/BulkHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..888e1fd17c14ddb7d62e46e7fc025caced54ff81
--- /dev/null
+++ b/src/Handlers/BulkHandler.php
@@ -0,0 +1,2216 @@
+<?php
+/**
+ * Handle bulk order operations.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class BulkHandler {
+	const ACTION_HOOK      = 'agentwp_bulk_process';
+	const ASYNC_THRESHOLD  = 20;
+	const DRAFT_TYPE       = 'bulk_action';
+	const JOB_TTL_SECONDS  = 86400;
+	const MAX_BULK         = 1000;
+	const PROGRESS_TTL     = 86400;
+	const ROLLBACK_TTL     = 86400;
+	const POLL_INTERVAL    = 2;
+
+	/**
+	 * Register background processing hooks.
+	 *
+	 * @return void
+	 */
+	public static function register_hooks() {
+		add_action( self::ACTION_HOOK, array( __CLASS__, 'handle_scheduled_action' ), 10, 1 );
+	}
+
+	/**
+	 * Execute scheduled bulk jobs.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	public static function handle_scheduled_action( $job_id ) {
+		$handler = new self();
+		$handler->process_scheduled_job( $job_id );
+	}
+
+	/**
+	 * Handle bulk actions and selections.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['criteria'] ) ) {
+			return $this->select_orders( $args );
+		}
+
+		$progress_id = $this->extract_progress_id( $args );
+		if ( '' !== $progress_id ) {
+			return $this->get_progress_response( $progress_id );
+		}
+
+		$rollback_id = $this->extract_rollback_id( $args );
+		if ( '' !== $rollback_id ) {
+			return $this->rollback_bulk_action( $rollback_id );
+		}
+
+		$draft_id = $this->extract_draft_id( $args );
+		if ( '' !== $draft_id ) {
+			return $this->confirm_bulk_update( $draft_id );
+		}
+
+		return $this->prepare_bulk_update( $args );
+	}
+
+	/**
+	 * Select orders based on criteria.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function select_orders( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to select orders.', 400 );
+		}
+
+		$criteria  = $this->normalize_criteria( isset( $args['criteria'] ) ? $args['criteria'] : array() );
+		$order_ids = $this->query_order_ids( $criteria );
+		$sample    = $this->build_sample_orders( $order_ids );
+
+		return Response::success(
+			array(
+				'order_ids'  => $order_ids,
+				'count'      => count( $order_ids ),
+				'criteria'   => $criteria,
+				'sample'     => $sample,
+				'truncated'  => count( $order_ids ) >= self::MAX_BULK,
+				'max_limit'  => self::MAX_BULK,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a bulk update draft.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	private function prepare_bulk_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $args['action'] ) ? $args['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Missing or invalid bulk action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $args['params'] ) ? $args['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$missing_orders = $this->find_missing_orders( $order_ids );
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		$sample = $this->build_sample_orders( $order_ids );
+		$preview = array(
+			'order_count'    => count( $order_ids ),
+			'sample'         => $sample,
+			'action'         => $action,
+			'action_preview' => $this->build_action_preview( $action, $params ),
+		);
+
+		$draft_payload = array(
+			'order_ids' => $order_ids,
+			'action'    => $action,
+			'params'    => $params,
+			'preview'   => $preview,
+		);
+
+		$draft_id   = $this->generate_uuid();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a bulk update draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	private function confirm_bulk_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to process bulk updates.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing bulk update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Bulk update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for bulk update confirmation.', 400 );
+		}
+
+		$payload  = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $payload['action'] ) ? $payload['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Bulk update draft is missing an action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $payload['params'] ) ? $payload['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$job_id      = $this->generate_uuid();
+		$progress_id = $this->generate_uuid();
+		$rollback_id = $this->generate_uuid();
+
+		$rollback_expires = gmdate( 'c', time() + self::ROLLBACK_TTL );
+		$this->store_rollback(
+			$rollback_id,
+			array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => $rollback_expires,
+				'orders'     => array(),
+			),
+			self::ROLLBACK_TTL
+		);
+
+		$progress = array(
+			'id'                  => $progress_id,
+			'status'              => 'queued',
+			'action'              => $action,
+			'order_count'         => count( $order_ids ),
+			'processed'           => 0,
+			'updated'             => 0,
+			'failed'              => 0,
+			'errors'              => array(),
+			'created_at'          => gmdate( 'c' ),
+			'started_at'          => '',
+			'last_updated'        => gmdate( 'c' ),
+			'completed_at'        => '',
+			'draft_id'            => $draft_id,
+			'rollback_id'         => $rollback_id,
+			'undo_available_until'=> $rollback_expires,
+		);
+		$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+
+		$job = array(
+			'id'          => $job_id,
+			'order_ids'   => $order_ids,
+			'action'      => $action,
+			'params'      => $params,
+			'progress_id' => $progress_id,
+			'rollback_id' => $rollback_id,
+			'draft_id'    => $draft_id,
+		);
+		$this->store_job( $job_id, $job, self::JOB_TTL_SECONDS );
+
+		$async = count( $order_ids ) > self::ASYNC_THRESHOLD && $this->action_scheduler_available();
+		if ( $async ) {
+			$action_id = $this->schedule_job( $job_id );
+			if ( ! $action_id ) {
+				return Response::error( 'Unable to schedule bulk update.', 500 );
+			}
+
+			$this->delete_draft( $draft_id );
+
+			return Response::success(
+				array(
+					'status'     => 'scheduled',
+					'draft_id'   => $draft_id,
+					'job_id'     => $job_id,
+					'progress'   => $progress,
+					'polling'    => array(
+						'progress_id'      => $progress_id,
+						'interval_seconds' => self::POLL_INTERVAL,
+					),
+					'rollback_id' => $rollback_id,
+					'undo_available_until' => $rollback_expires,
+				)
+			);
+		}
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'     => 'running',
+				'started_at' => gmdate( 'c' ),
+			),
+			true
+		);
+
+		$result = $this->run_bulk_job( $job );
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'       => 'completed',
+				'completed_at' => gmdate( 'c' ),
+				'result'       => $result,
+			),
+			true
+		);
+
+		$this->delete_job( $job_id );
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'status'      => 'completed',
+				'draft_id'    => $draft_id,
+				'result'      => $result,
+				'progress'    => $progress,
+				'polling'     => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+				'rollback_id' => $rollback_id,
+				'undo_available_until' => $rollback_expires,
+			)
+		);
+	}
+
+	/**
+	 * Process a scheduled bulk job.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	private function process_scheduled_job( $job_id ) {
+		$job_id = is_string( $job_id ) ? trim( $job_id ) : '';
+		if ( '' === $job_id ) {
+			return;
+		}
+
+		$job = $this->load_job( $job_id );
+		if ( ! is_array( $job ) ) {
+			return;
+		}
+
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'     => 'running',
+					'started_at' => gmdate( 'c' ),
+				),
+				true
+			);
+		}
+
+		$result = $this->run_bulk_job( $job );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'       => 'completed',
+					'completed_at' => gmdate( 'c' ),
+					'result'       => $result,
+				),
+				true
+			);
+		}
+
+		$draft_id = isset( $job['draft_id'] ) ? (string) $job['draft_id'] : '';
+		if ( '' !== $draft_id ) {
+			$this->delete_draft( $draft_id );
+		}
+
+		$this->delete_job( $job_id );
+	}
+
+	/**
+	 * Execute a bulk job.
+	 *
+	 * @param array $job Job payload.
+	 * @return array
+	 */
+	private function run_bulk_job( array $job ) {
+		$order_ids   = isset( $job['order_ids'] ) ? $this->normalize_order_ids( $job['order_ids'] ) : array();
+		$action      = isset( $job['action'] ) ? $this->normalize_action( $job['action'] ) : '';
+		$params      = isset( $job['params'] ) && is_array( $job['params'] ) ? $job['params'] : array();
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		$rollback_id = isset( $job['rollback_id'] ) ? (string) $job['rollback_id'] : '';
+
+		$result = array(
+			'action'    => $action,
+			'order_ids' => $order_ids,
+			'updated'   => array(),
+			'failed'    => array(),
+			'errors'    => array(),
+		);
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			$rollback = array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => gmdate( 'c', time() + self::ROLLBACK_TTL ),
+				'orders'     => array(),
+			);
+		}
+
+		$processed = 0;
+		$updated   = 0;
+		$failed    = 0;
+		$errors    = array();
+		$rows      = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$processed++;
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed++;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found.',
+				);
+				$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$current_status = $this->normalize_status( $order->get_status() );
+					$new_status     = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+					if ( '' === $new_status ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing target status.',
+						);
+						break;
+					}
+
+					$rollback['orders'][ $order_id ] = array(
+						'status' => $current_status,
+					);
+
+					$note            = isset( $params['note'] ) ? (string) $params['note'] : '';
+					$notify_customer = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+					$updated_flag    = $this->apply_status_update( $order, $new_status, $note, $notify_customer );
+
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to update status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+					$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+					$tags = $this->normalize_tags( $tags, $tag );
+					if ( empty( $tags ) ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing tags to add.',
+						);
+						break;
+					}
+
+					$before_tags = $this->get_order_tags( $order_id );
+					$rollback['orders'][ $order_id ] = array(
+						'tags' => $before_tags,
+					);
+
+					$updated_flag = $this->apply_tags_update( $order, $tags );
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+					if ( '' === $note ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing note content.',
+						);
+						break;
+					}
+
+					$is_customer_note = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+					$note_id          = $this->apply_order_note( $order, $note, $is_customer_note );
+					if ( $note_id > 0 ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+						$rollback['orders'][ $order_id ] = array(
+							'notes' => array( $note_id ),
+						);
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add note.',
+						);
+					}
+					break;
+				case 'export_csv':
+					$rows[] = $this->format_export_row( $order );
+					$updated++;
+					$result['updated'][] = $order_id;
+					break;
+				default:
+					$failed++;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Unsupported bulk action.',
+					);
+			}
+
+			$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+		}
+
+		$result['errors'] = $errors;
+		$result['failed'] = array_unique( array_merge( $result['failed'], wp_list_pluck( $errors, 'order_id' ) ) );
+
+		if ( 'export_csv' === $action ) {
+			$export = $this->export_csv( $rows, isset( $params['fields'] ) ? $params['fields'] : array() );
+			if ( isset( $export['error'] ) ) {
+				$errors[]         = array( 'order_id' => 0, 'message' => $export['error'] );
+				$result['errors'] = $errors;
+			} else {
+				$result['export'] = $export;
+			}
+		}
+
+		$this->store_rollback( $rollback_id, $rollback, self::ROLLBACK_TTL );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'processed' => $processed,
+					'updated'   => $updated,
+					'failed'    => $failed,
+					'errors'    => $errors,
+				),
+				true
+			);
+		}
+
+		return $result;
+	}
+
+	/**
+	 * Provide progress updates to polling clients.
+	 *
+	 * @param string $progress_id Progress identifier.
+	 * @return Response
+	 */
+	private function get_progress_response( $progress_id ): Response {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			return Response::error( 'Bulk progress not found or expired.', 404 );
+		}
+
+		return Response::success(
+			array(
+				'progress' => $progress,
+				'polling'  => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Roll back a bulk action.
+	 *
+	 * @param string $rollback_id Rollback identifier.
+	 * @return Response
+	 */
+	private function rollback_bulk_action( $rollback_id ): Response {
+		$rollback_id = is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+		if ( '' === $rollback_id ) {
+			return Response::error( 'Missing rollback ID.', 400 );
+		}
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			return Response::error( 'Rollback data not found or expired.', 404 );
+		}
+
+		$action  = isset( $rollback['action'] ) ? $this->normalize_action( $rollback['action'] ) : '';
+		$orders  = isset( $rollback['orders'] ) && is_array( $rollback['orders'] ) ? $rollback['orders'] : array();
+		$undone  = array();
+		$failed  = array();
+		$errors  = array();
+
+		foreach ( $orders as $order_id => $data ) {
+			$order_id = absint( $order_id );
+			$order    = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed[] = $order_id;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found for rollback.',
+				);
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$previous_status = isset( $data['status'] ) ? $this->normalize_status( $data['status'] ) : '';
+					if ( '' === $previous_status ) {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing previous status.',
+						);
+						break;
+					}
+
+					$updated = $this->apply_status_update( $order, $previous_status, 'Rollback to previous status.', false );
+					if ( $updated ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore previous status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $data['tags'] ) ? $data['tags'] : array();
+					$restored = $this->restore_order_tags( $order_id, $tags );
+					if ( $restored ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$notes = isset( $data['notes'] ) ? (array) $data['notes'] : array();
+					$deleted = $this->delete_order_notes( $notes );
+					if ( $deleted ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to remove notes.',
+						);
+					}
+					break;
+				default:
+					$failed[] = $order_id;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Rollback not supported for this action.',
+					);
+			}
+		}
+
+		return Response::success(
+			array(
+				'rollback_id' => $rollback_id,
+				'action'      => $action,
+				'undone'      => $undone,
+				'failed'      => $failed,
+				'errors'      => $errors,
+			)
+		);
+	}
+
+	/**
+	 * @param array $criteria Criteria input.
+	 * @return array
+	 */
+	private function normalize_criteria( $criteria ) {
+		$parsed = array();
+		$query  = '';
+
+		if ( is_string( $criteria ) ) {
+			$query = sanitize_text_field( $criteria );
+		} elseif ( is_array( $criteria ) ) {
+			$query = isset( $criteria['query'] ) ? sanitize_text_field( $criteria['query'] ) : '';
+			$parsed['status'] = isset( $criteria['status'] ) ? $this->normalize_status( $criteria['status'] ) : '';
+			$parsed['date_range'] = $this->normalize_date_range_input( isset( $criteria['date_range'] ) ? $criteria['date_range'] : null );
+			$parsed['customer_email'] = isset( $criteria['customer_email'] ) ? sanitize_email( $criteria['customer_email'] ) : '';
+			$parsed['total_min'] = isset( $criteria['total_min'] ) ? $this->normalize_amount( $criteria['total_min'] ) : null;
+			$parsed['total_max'] = isset( $criteria['total_max'] ) ? $this->normalize_amount( $criteria['total_max'] ) : null;
+			$parsed['country'] = isset( $criteria['country'] ) ? $this->normalize_country( $criteria['country'] ) : '';
+		}
+
+		if ( '' !== $query ) {
+			$text_parsed = $this->parse_criteria_text( $query );
+			foreach ( $text_parsed as $key => $value ) {
+				if ( ! isset( $parsed[ $key ] ) || '' === $parsed[ $key ] || null === $parsed[ $key ] ) {
+					$parsed[ $key ] = $value;
+				}
+			}
+		}
+
+		if ( '' === $parsed['status'] ) {
+			unset( $parsed['status'] );
+		}
+		if ( '' === $parsed['customer_email'] ) {
+			unset( $parsed['customer_email'] );
+		}
+		if ( '' === $parsed['country'] ) {
+			unset( $parsed['country'] );
+		}
+		if ( null === $parsed['total_min'] ) {
+			unset( $parsed['total_min'] );
+		}
+		if ( null === $parsed['total_max'] ) {
+			unset( $parsed['total_max'] );
+		}
+		if ( null === $parsed['date_range'] ) {
+			unset( $parsed['date_range'] );
+		}
+
+		return $parsed;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function parse_criteria_text( $query ) {
+		$query  = trim( (string) $query );
+		$lower  = strtolower( $query );
+		$result = array();
+
+		$status = $this->detect_status( $lower );
+		if ( '' !== $status ) {
+			$result['status'] = $status;
+		}
+
+		$date_range = $this->parse_date_range_from_query( $lower );
+		if ( null !== $date_range ) {
+			$result['date_range'] = $date_range;
+		}
+
+		$email = $this->extract_email( $query );
+		if ( '' !== $email ) {
+			$result['customer_email'] = $email;
+		}
+
+		$totals = $this->extract_total_range( $lower );
+		if ( isset( $totals['min'] ) ) {
+			$result['total_min'] = $totals['min'];
+		}
+		if ( isset( $totals['max'] ) ) {
+			$result['total_max'] = $totals['max'];
+		}
+
+		$country = $this->extract_country( $query );
+		if ( '' !== $country ) {
+			$result['country'] = $country;
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param array $criteria Query criteria.
+	 * @return array
+	 */
+	private function query_order_ids( array $criteria ) {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		$args = array(
+			'limit'   => self::MAX_BULK,
+			'return'  => 'ids',
+			'orderby' => 'date',
+			'order'   => 'DESC',
+		);
+
+		if ( isset( $criteria['status'] ) && '' !== $criteria['status'] ) {
+			$args['status'] = $criteria['status'];
+		}
+
+		if ( isset( $criteria['date_range'] ) && is_array( $criteria['date_range'] ) ) {
+			$args['date_created'] = $criteria['date_range']['start'] . '...' . $criteria['date_range']['end'];
+		}
+
+		$meta_query = array( 'relation' => 'AND' );
+
+		if ( isset( $criteria['customer_email'] ) && '' !== $criteria['customer_email'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['country'] ) && '' !== $criteria['country'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['total_min'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_min'],
+				'compare' => '>=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( isset( $criteria['total_max'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_max'],
+				'compare' => '<=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( count( $meta_query ) > 1 ) {
+			$args['meta_query'] = $meta_query;
+		}
+
+		$order_ids = wc_get_orders( $args );
+		if ( ! is_array( $order_ids ) ) {
+			return array();
+		}
+
+		$order_ids = array_map( 'absint', $order_ids );
+		$order_ids = array_filter( $order_ids );
+		$order_ids = array_values( array_unique( $order_ids ) );
+
+		return $order_ids;
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function build_sample_orders( array $order_ids ) {
+		$sample = array();
+		$order_ids = array_slice( $order_ids, 0, 5 );
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( $order ) {
+				$sample[] = $this->format_order_summary( $order );
+			}
+		}
+
+		return $sample;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_order_summary( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'       => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'currency'       => method_exists( $order, 'get_currency' ) ? sanitize_text_field( $order->get_currency() ) : '',
+			'customer_name'  => sanitize_text_field( $this->get_customer_name( $order ) ),
+			'customer_email' => sanitize_email( $this->get_customer_email( $order ) ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'country'        => sanitize_text_field( $this->get_order_country( $order ) ),
+		);
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @param mixed $action Raw action.
+	 * @return string
+	 */
+	private function normalize_action( $action ) {
+		$action = is_string( $action ) ? strtolower( trim( $action ) ) : '';
+		$allowed = array( 'update_status', 'add_tag', 'add_note', 'export_csv' );
+
+		return in_array( $action, $allowed, true ) ? $action : '';
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param mixed  $params Raw params.
+	 * @return array
+	 */
+	private function normalize_params( $action, $params ) {
+		$params = is_array( $params ) ? $params : array();
+		$normalized = array();
+
+		switch ( $action ) {
+			case 'update_status':
+				$new_status = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+				if ( '' === $new_status ) {
+					return array( 'error' => 'Missing new status for bulk update.' );
+				}
+
+				$valid_statuses = $this->get_valid_statuses();
+				if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+					return array( 'error' => 'Invalid status for bulk update.' );
+				}
+
+				$normalized['new_status'] = $new_status;
+				$normalized['note'] = isset( $params['note'] ) ? sanitize_text_field( wp_unslash( $params['note'] ) ) : '';
+				$normalized['notify_customer'] = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+				break;
+			case 'add_tag':
+				$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+				$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+				$normalized['tags'] = $this->normalize_tags( $tags, $tag );
+				if ( empty( $normalized['tags'] ) ) {
+					return array( 'error' => 'Missing tags for bulk update.' );
+				}
+				break;
+			case 'add_note':
+				$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+				if ( '' === $note ) {
+					return array( 'error' => 'Missing note for bulk update.' );
+				}
+				$normalized['note'] = sanitize_text_field( wp_unslash( $note ) );
+				$normalized['is_customer_note'] = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+				break;
+			case 'export_csv':
+				$fields = isset( $params['fields'] ) ? $params['fields'] : array();
+				$normalized['fields'] = $this->normalize_fields( $fields );
+				break;
+			default:
+				return array( 'error' => 'Unsupported bulk action.' );
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param array  $params Params.
+	 * @return array
+	 */
+	private function build_action_preview( $action, array $params ) {
+		switch ( $action ) {
+			case 'update_status':
+				return array(
+					'new_status'      => isset( $params['new_status'] ) ? $params['new_status'] : '',
+					'notify_customer' => ! empty( $params['notify_customer'] ),
+					'note'            => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'add_tag':
+				return array(
+					'tags' => isset( $params['tags'] ) ? $params['tags'] : array(),
+				);
+			case 'add_note':
+				return array(
+					'note' => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'export_csv':
+				return array(
+					'fields' => isset( $params['fields'] ) ? $params['fields'] : $this->normalize_fields( array() ),
+				);
+			default:
+				return array();
+		}
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function find_missing_orders( array $order_ids ) {
+		$missing = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$missing[] = $order_id;
+			}
+		}
+
+		return $missing;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @param int    $processed Processed count.
+	 * @param int    $updated Updated count.
+	 * @param int    $failed Failed count.
+	 * @param array  $errors Error list.
+	 * @return void
+	 */
+	private function maybe_update_progress( $progress_id, $processed, $updated, $failed, array $errors ) {
+		if ( '' === $progress_id ) {
+			return;
+		}
+
+		$this->update_progress(
+			$progress_id,
+			array(
+				'processed' => $processed,
+				'updated'   => $updated,
+				'failed'    => $failed,
+				'errors'    => $errors,
+			),
+			false
+		);
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $updates Updates.
+	 * @param bool   $force Force update.
+	 * @return array
+	 */
+	private function update_progress( $progress_id, array $updates, $force ) {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			$progress = array(
+				'id'           => $progress_id,
+				'status'       => 'queued',
+				'processed'    => 0,
+				'updated'      => 0,
+				'failed'       => 0,
+				'errors'       => array(),
+				'created_at'   => gmdate( 'c' ),
+				'last_updated' => gmdate( 'c' ),
+			);
+		}
+
+		$last_updated = isset( $progress['last_updated'] ) ? strtotime( $progress['last_updated'] ) : 0;
+		$should_update = $force || ( time() - $last_updated >= self::POLL_INTERVAL );
+
+		foreach ( $updates as $key => $value ) {
+			$progress[ $key ] = $value;
+		}
+
+		if ( $should_update ) {
+			$progress['last_updated'] = gmdate( 'c' );
+			$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @return array|null
+	 */
+	private function load_progress( $progress_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$progress = get_transient( $this->build_progress_key( $progress_id ) );
+		if ( false === $progress || ! is_array( $progress ) ) {
+			return null;
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $progress Progress payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_progress( $progress_id, array $progress, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_progress_key( $progress_id ), $progress, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return array|null
+	 */
+	private function load_job( $job_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$job = get_transient( $this->build_job_key( $job_id ) );
+		if ( false === $job || ! is_array( $job ) ) {
+			return null;
+		}
+
+		return $job;
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @param array  $job Job payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_job( $job_id, array $job, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_job_key( $job_id ), $job, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return void
+	 */
+	private function delete_job( $job_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_job_key( $job_id ) );
+		}
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @return array|null
+	 */
+	private function load_rollback( $rollback_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$rollback = get_transient( $this->build_rollback_key( $rollback_id ) );
+		if ( false === $rollback || ! is_array( $rollback ) ) {
+			return null;
+		}
+
+		return $rollback;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @param array  $rollback Rollback data.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_rollback( $rollback_id, array $rollback, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_rollback_key( $rollback_id ), $rollback, $ttl );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_uuid() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'bulk_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_draft_' . $draft_id;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @return string
+	 */
+	private function build_progress_key( $progress_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_progress_' . $progress_id;
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return string
+	 */
+	private function build_job_key( $job_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_job_' . $job_id;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback identifier.
+	 * @return string
+	 */
+	private function build_rollback_key( $rollback_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_rollback_' . $rollback_id;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param mixed $status Raw status.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float|null
+	 */
+	private function normalize_amount( $amount ) {
+		if ( null === $amount || '' === $amount ) {
+			return null;
+		}
+
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $country Country input.
+	 * @return string
+	 */
+	private function normalize_country( $country ) {
+		$country = is_string( $country ) ? strtoupper( trim( $country ) ) : '';
+		if ( '' === $country ) {
+			return '';
+		}
+
+		if ( strlen( $country ) === 2 ) {
+			return $country;
+		}
+
+		$map = $this->get_country_map();
+		$key = strtolower( $country );
+
+		return isset( $map[ $key ] ) ? $map[ $key ] : '';
+	}
+
+	/**
+	 * @param mixed $tags Tags list.
+	 * @param mixed $tag Single tag.
+	 * @return array
+	 */
+	private function normalize_tags( $tags, $tag ) {
+		$list = array();
+
+		if ( is_string( $tags ) ) {
+			$tags = preg_split( '/[\s,]+/', $tags );
+		}
+
+		if ( is_array( $tags ) ) {
+			foreach ( $tags as $item ) {
+				$item = sanitize_text_field( (string) $item );
+				if ( '' !== $item ) {
+					$list[] = $item;
+				}
+			}
+		}
+
+		if ( is_string( $tag ) ) {
+			$tag = sanitize_text_field( $tag );
+			if ( '' !== $tag ) {
+				$list[] = $tag;
+			}
+		}
+
+		$list = array_values( array_unique( $list ) );
+
+		return $list;
+	}
+
+	/**
+	 * @param mixed $fields Fields input.
+	 * @return array
+	 */
+	private function normalize_fields( $fields ) {
+		$default = array( 'order_id', 'status', 'total', 'currency', 'customer_name', 'customer_email', 'date_created', 'billing_country', 'shipping_country' );
+		if ( empty( $fields ) ) {
+			return $default;
+		}
+
+		if ( is_string( $fields ) ) {
+			$fields = preg_split( '/[\s,]+/', $fields );
+		}
+
+		if ( ! is_array( $fields ) ) {
+			return $default;
+		}
+
+		$sanitized = array();
+		foreach ( $fields as $field ) {
+			$field = sanitize_key( $field );
+			if ( '' !== $field ) {
+				$sanitized[] = $field;
+			}
+		}
+
+		return array_values( array_unique( $sanitized ) );
+	}
+
+	/**
+	 * @param array $order Order object.
+	 * @param string $new_status New status.
+	 * @param string $note Note for audit.
+	 * @param bool $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $current_status === $new_status ) {
+			return false;
+		}
+
+		$note = trim( (string) $note );
+		$audit_note = sprintf( '[AgentWP] Bulk status update: %s -> %s.', $current_status, $new_status );
+		if ( '' !== $note ) {
+			$audit_note .= ' Note: ' . $note . '.';
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $audit_note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param array  $tags Tags to add.
+	 * @return bool
+	 */
+	private function apply_tags_update( $order, array $tags ) {
+		$order_id = method_exists( $order, 'get_id' ) ? $order->get_id() : 0;
+		if ( $order_id <= 0 ) {
+			return false;
+		}
+
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				$existing = array();
+			}
+			$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+			wp_set_object_terms( $order_id, $merged, $taxonomy, false );
+			return true;
+		}
+
+		if ( ! method_exists( $order, 'get_meta' ) || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			$existing = array();
+		}
+
+		$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+		$order->update_meta_data( '_agentwp_order_tags', $merged );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param string $note Note text.
+	 * @param bool   $is_customer_note Customer visibility.
+	 * @return int
+	 */
+	private function apply_order_note( $order, $note, $is_customer_note ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return 0;
+		}
+
+		$note = trim( (string) $note );
+		if ( '' === $note ) {
+			return 0;
+		}
+
+		$note_id = $order->add_order_note( $note, $is_customer_note );
+
+		return absint( $note_id );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_export_row( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'        => intval( $order->get_id() ),
+			'status'          => sanitize_text_field( $order->get_status() ),
+			'total'           => $order->get_total(),
+			'currency'        => method_exists( $order, 'get_currency' ) ? $order->get_currency() : '',
+			'customer_name'   => $this->get_customer_name( $order ),
+			'customer_email'  => $this->get_customer_email( $order ),
+			'date_created'    => $date_created ? $date_created->date( 'c' ) : '',
+			'billing_country' => method_exists( $order, 'get_billing_country' ) ? $order->get_billing_country() : '',
+			'shipping_country'=> method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '',
+		);
+	}
+
+	/**
+	 * @param array $rows Data rows.
+	 * @param array $fields Fields list.
+	 * @return array
+	 */
+	private function export_csv( array $rows, array $fields ) {
+		if ( ! function_exists( 'wp_upload_dir' ) ) {
+			return array( 'error' => 'Unable to export CSV in this environment.' );
+		}
+
+		$fields = $this->normalize_fields( $fields );
+		$upload = wp_upload_dir();
+		$base   = isset( $upload['basedir'] ) ? $upload['basedir'] : '';
+		$url    = isset( $upload['baseurl'] ) ? $upload['baseurl'] : '';
+
+		if ( '' === $base || '' === $url ) {
+			return array( 'error' => 'Unable to resolve upload directory.' );
+		}
+
+		$dir = trailingslashit( $base ) . 'agentwp-exports';
+		if ( function_exists( 'wp_mkdir_p' ) ) {
+			wp_mkdir_p( $dir );
+		}
+
+		$filename = 'agentwp-bulk-export-' . gmdate( 'Ymd-His' ) . '-' . wp_generate_password( 6, false ) . '.csv';
+		$path     = trailingslashit( $dir ) . $filename;
+		$file     = @fopen( $path, 'w' );
+		if ( ! $file ) {
+			return array( 'error' => 'Unable to create CSV export file.' );
+		}
+
+		fputcsv( $file, $fields );
+		foreach ( $rows as $row ) {
+			$line = array();
+			foreach ( $fields as $field ) {
+				$line[] = isset( $row[ $field ] ) ? $row[ $field ] : '';
+			}
+			fputcsv( $file, $line );
+		}
+
+		fclose( $file );
+
+		return array(
+			'file_path' => $path,
+			'file_url'  => trailingslashit( $url ) . 'agentwp-exports/' . $filename,
+			'rows'      => count( $rows ),
+		);
+	}
+
+	/**
+	 * @param int $order_id Order ID.
+	 * @return array
+	 */
+	private function get_order_tags( $order_id ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				return array();
+			}
+			return $existing;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'get_meta' ) ) {
+			return array();
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			return array();
+		}
+
+		return $existing;
+	}
+
+	/**
+	 * @param int   $order_id Order ID.
+	 * @param array $tags Tags.
+	 * @return bool
+	 */
+	private function restore_order_tags( $order_id, $tags ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			wp_set_object_terms( $order_id, (array) $tags, $taxonomy, false );
+			return true;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$order->update_meta_data( '_agentwp_order_tags', (array) $tags );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param array $note_ids Note IDs.
+	 * @return bool
+	 */
+	private function delete_order_notes( array $note_ids ) {
+		if ( ! function_exists( 'wp_delete_comment' ) ) {
+			return false;
+		}
+
+		$deleted_any = false;
+		foreach ( $note_ids as $note_id ) {
+			$note_id = absint( $note_id );
+			if ( $note_id > 0 ) {
+				wp_delete_comment( $note_id, true );
+				$deleted_any = true;
+			}
+		}
+
+		return $deleted_any;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function get_order_tag_taxonomy() {
+		$taxonomy = apply_filters( 'agentwp_order_tag_taxonomy', 'shop_order_tag' );
+		$taxonomy = is_string( $taxonomy ) ? trim( $taxonomy ) : '';
+
+		if ( '' !== $taxonomy && function_exists( 'taxonomy_exists' ) && taxonomy_exists( $taxonomy ) ) {
+			return $taxonomy;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param array|null $date_range Date range input.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query text.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date.
+	 * @param string $end End date.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Date string.
+	 * @param bool   $end_of_day End of day flag.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		$date = $end_of_day ? $date->setTime( 23, 59, 59 ) : $date->setTime( 0, 0, 0 );
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function extract_total_range( $query ) {
+		$result = array();
+
+		if ( preg_match( '/\bbetween\s+[\$£\x{20AC}]?([0-9\.,]+)\s+(?:and|to)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+			return $result;
+		}
+
+		if ( preg_match( '/\b(over|above|more than|greater than|at least|minimum|min)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b(under|below|less than|at most|maximum|max)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b>=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		if ( preg_match( '/\b<=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param string $value Amount string.
+	 * @return float|null
+	 */
+	private function parse_amount_string( $value ) {
+		$value = str_replace( array( ',', ' ' ), '', (string) $value );
+		return $this->normalize_amount( $value );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_country( $query ) {
+		$query_lower = strtolower( $query );
+		$map         = $this->get_country_map();
+
+		foreach ( $map as $name => $code ) {
+			$pattern = '/\b' . preg_quote( $name, '/' ) . '\b/i';
+			if ( preg_match( $pattern, $query_lower ) ) {
+				return $code;
+			}
+		}
+
+		if ( preg_match_all( '/\b([A-Z]{2})\b/', strtoupper( $query ), $matches ) ) {
+			foreach ( $matches[1] as $code ) {
+				if ( isset( $map[ strtolower( $code ) ] ) ) {
+					return $map[ strtolower( $code ) ];
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_country_map() {
+		static $map = null;
+		if ( null !== $map ) {
+			return $map;
+		}
+
+		$countries = array();
+		if ( function_exists( 'WC' ) ) {
+			$wc = WC();
+			if ( $wc && isset( $wc->countries ) && method_exists( $wc->countries, 'get_countries' ) ) {
+				$countries = $wc->countries->get_countries();
+			}
+		}
+
+		if ( empty( $countries ) && class_exists( 'WC_Countries' ) ) {
+			$wc_countries = new \WC_Countries();
+			$countries    = $wc_countries->get_countries();
+		}
+
+		$map = array();
+		if ( is_array( $countries ) ) {
+			foreach ( $countries as $code => $name ) {
+				$map[ strtolower( $name ) ] = strtoupper( $code );
+				$map[ strtolower( $code ) ] = strtoupper( $code );
+			}
+		}
+
+		$map['usa'] = 'US';
+		$map['us']  = 'US';
+		$map['uk']  = 'GB';
+
+		return $map;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_order_country( $order ) {
+		$country = method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '';
+		if ( '' !== $country ) {
+			return $country;
+		}
+
+		if ( method_exists( $order, 'get_billing_country' ) ) {
+			$country = $order->get_billing_country();
+		}
+
+		return is_string( $country ) ? $country : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_draft_id( array $args ) {
+		$draft_id = isset( $args['draft_id'] ) ? $args['draft_id'] : '';
+		if ( '' === $draft_id && isset( $args['params']['draft_id'] ) ) {
+			$draft_id = $args['params']['draft_id'];
+		}
+
+		return is_string( $draft_id ) ? trim( $draft_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_progress_id( array $args ) {
+		$progress_id = isset( $args['progress_id'] ) ? $args['progress_id'] : '';
+		if ( '' === $progress_id && isset( $args['params']['progress_id'] ) ) {
+			$progress_id = $args['params']['progress_id'];
+		}
+
+		return is_string( $progress_id ) ? trim( $progress_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_rollback_id( array $args ) {
+		$rollback_id = isset( $args['rollback_id'] ) ? $args['rollback_id'] : '';
+		if ( '' === $rollback_id && isset( $args['params']['rollback_id'] ) ) {
+			$rollback_id = $args['params']['rollback_id'];
+		}
+
+		return is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+	}
+
+	/**
+	 * @return bool
+	 */
+	private function action_scheduler_available() {
+		return function_exists( 'as_enqueue_async_action' ) || function_exists( 'as_schedule_single_action' );
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return int
+	 */
+	private function schedule_job( $job_id ) {
+		if ( function_exists( 'as_enqueue_async_action' ) ) {
+			return (int) as_enqueue_async_action( self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		if ( function_exists( 'as_schedule_single_action' ) ) {
+			return (int) as_schedule_single_action( time(), self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		return 0;
+	}
+}


thinking
**Reviewing and patching criteria normalization**

I'm carefully checking the code for possible undefined indexes and ensuring that criteria normalization safely initializes all expected keys with defaults. I'll handle missing or empty values properly, especially for status and amount fields, and verify calls to WordPress core functions are safe. This way, I can avoid warnings and maintain expected logic when criteria inputs are incomplete or strings.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/BulkHandler.php
@@ -709,3 +709,10 @@
 	private function normalize_criteria( $criteria ) {
-		$parsed = array();
+		$parsed = array(
+			'status'         => '',
+			'date_range'     => null,
+			'customer_email' => '',
+			'total_min'      => null,
+			'total_max'      => null,
+			'country'        => '',
+		);
 		$query  = '';
apply_patch(auto_approved=true) exited 0 in 34ms:
Success. Updated the following files:
M src/Handlers/BulkHandler.php
file update:
diff --git a/src/Handlers/BulkHandler.php b/src/Handlers/BulkHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..d7994bcd117201a3df0db869c3d04e51a692d784
--- /dev/null
+++ b/src/Handlers/BulkHandler.php
@@ -0,0 +1,2223 @@
+<?php
+/**
+ * Handle bulk order operations.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class BulkHandler {
+	const ACTION_HOOK      = 'agentwp_bulk_process';
+	const ASYNC_THRESHOLD  = 20;
+	const DRAFT_TYPE       = 'bulk_action';
+	const JOB_TTL_SECONDS  = 86400;
+	const MAX_BULK         = 1000;
+	const PROGRESS_TTL     = 86400;
+	const ROLLBACK_TTL     = 86400;
+	const POLL_INTERVAL    = 2;
+
+	/**
+	 * Register background processing hooks.
+	 *
+	 * @return void
+	 */
+	public static function register_hooks() {
+		add_action( self::ACTION_HOOK, array( __CLASS__, 'handle_scheduled_action' ), 10, 1 );
+	}
+
+	/**
+	 * Execute scheduled bulk jobs.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	public static function handle_scheduled_action( $job_id ) {
+		$handler = new self();
+		$handler->process_scheduled_job( $job_id );
+	}
+
+	/**
+	 * Handle bulk actions and selections.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['criteria'] ) ) {
+			return $this->select_orders( $args );
+		}
+
+		$progress_id = $this->extract_progress_id( $args );
+		if ( '' !== $progress_id ) {
+			return $this->get_progress_response( $progress_id );
+		}
+
+		$rollback_id = $this->extract_rollback_id( $args );
+		if ( '' !== $rollback_id ) {
+			return $this->rollback_bulk_action( $rollback_id );
+		}
+
+		$draft_id = $this->extract_draft_id( $args );
+		if ( '' !== $draft_id ) {
+			return $this->confirm_bulk_update( $draft_id );
+		}
+
+		return $this->prepare_bulk_update( $args );
+	}
+
+	/**
+	 * Select orders based on criteria.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function select_orders( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to select orders.', 400 );
+		}
+
+		$criteria  = $this->normalize_criteria( isset( $args['criteria'] ) ? $args['criteria'] : array() );
+		$order_ids = $this->query_order_ids( $criteria );
+		$sample    = $this->build_sample_orders( $order_ids );
+
+		return Response::success(
+			array(
+				'order_ids'  => $order_ids,
+				'count'      => count( $order_ids ),
+				'criteria'   => $criteria,
+				'sample'     => $sample,
+				'truncated'  => count( $order_ids ) >= self::MAX_BULK,
+				'max_limit'  => self::MAX_BULK,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a bulk update draft.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	private function prepare_bulk_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $args['action'] ) ? $args['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Missing or invalid bulk action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $args['params'] ) ? $args['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$missing_orders = $this->find_missing_orders( $order_ids );
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		$sample = $this->build_sample_orders( $order_ids );
+		$preview = array(
+			'order_count'    => count( $order_ids ),
+			'sample'         => $sample,
+			'action'         => $action,
+			'action_preview' => $this->build_action_preview( $action, $params ),
+		);
+
+		$draft_payload = array(
+			'order_ids' => $order_ids,
+			'action'    => $action,
+			'params'    => $params,
+			'preview'   => $preview,
+		);
+
+		$draft_id   = $this->generate_uuid();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a bulk update draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	private function confirm_bulk_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to process bulk updates.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing bulk update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Bulk update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for bulk update confirmation.', 400 );
+		}
+
+		$payload  = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $payload['action'] ) ? $payload['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Bulk update draft is missing an action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $payload['params'] ) ? $payload['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$job_id      = $this->generate_uuid();
+		$progress_id = $this->generate_uuid();
+		$rollback_id = $this->generate_uuid();
+
+		$rollback_expires = gmdate( 'c', time() + self::ROLLBACK_TTL );
+		$this->store_rollback(
+			$rollback_id,
+			array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => $rollback_expires,
+				'orders'     => array(),
+			),
+			self::ROLLBACK_TTL
+		);
+
+		$progress = array(
+			'id'                  => $progress_id,
+			'status'              => 'queued',
+			'action'              => $action,
+			'order_count'         => count( $order_ids ),
+			'processed'           => 0,
+			'updated'             => 0,
+			'failed'              => 0,
+			'errors'              => array(),
+			'created_at'          => gmdate( 'c' ),
+			'started_at'          => '',
+			'last_updated'        => gmdate( 'c' ),
+			'completed_at'        => '',
+			'draft_id'            => $draft_id,
+			'rollback_id'         => $rollback_id,
+			'undo_available_until'=> $rollback_expires,
+		);
+		$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+
+		$job = array(
+			'id'          => $job_id,
+			'order_ids'   => $order_ids,
+			'action'      => $action,
+			'params'      => $params,
+			'progress_id' => $progress_id,
+			'rollback_id' => $rollback_id,
+			'draft_id'    => $draft_id,
+		);
+		$this->store_job( $job_id, $job, self::JOB_TTL_SECONDS );
+
+		$async = count( $order_ids ) > self::ASYNC_THRESHOLD && $this->action_scheduler_available();
+		if ( $async ) {
+			$action_id = $this->schedule_job( $job_id );
+			if ( ! $action_id ) {
+				return Response::error( 'Unable to schedule bulk update.', 500 );
+			}
+
+			$this->delete_draft( $draft_id );
+
+			return Response::success(
+				array(
+					'status'     => 'scheduled',
+					'draft_id'   => $draft_id,
+					'job_id'     => $job_id,
+					'progress'   => $progress,
+					'polling'    => array(
+						'progress_id'      => $progress_id,
+						'interval_seconds' => self::POLL_INTERVAL,
+					),
+					'rollback_id' => $rollback_id,
+					'undo_available_until' => $rollback_expires,
+				)
+			);
+		}
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'     => 'running',
+				'started_at' => gmdate( 'c' ),
+			),
+			true
+		);
+
+		$result = $this->run_bulk_job( $job );
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'       => 'completed',
+				'completed_at' => gmdate( 'c' ),
+				'result'       => $result,
+			),
+			true
+		);
+
+		$this->delete_job( $job_id );
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'status'      => 'completed',
+				'draft_id'    => $draft_id,
+				'result'      => $result,
+				'progress'    => $progress,
+				'polling'     => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+				'rollback_id' => $rollback_id,
+				'undo_available_until' => $rollback_expires,
+			)
+		);
+	}
+
+	/**
+	 * Process a scheduled bulk job.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	private function process_scheduled_job( $job_id ) {
+		$job_id = is_string( $job_id ) ? trim( $job_id ) : '';
+		if ( '' === $job_id ) {
+			return;
+		}
+
+		$job = $this->load_job( $job_id );
+		if ( ! is_array( $job ) ) {
+			return;
+		}
+
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'     => 'running',
+					'started_at' => gmdate( 'c' ),
+				),
+				true
+			);
+		}
+
+		$result = $this->run_bulk_job( $job );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'       => 'completed',
+					'completed_at' => gmdate( 'c' ),
+					'result'       => $result,
+				),
+				true
+			);
+		}
+
+		$draft_id = isset( $job['draft_id'] ) ? (string) $job['draft_id'] : '';
+		if ( '' !== $draft_id ) {
+			$this->delete_draft( $draft_id );
+		}
+
+		$this->delete_job( $job_id );
+	}
+
+	/**
+	 * Execute a bulk job.
+	 *
+	 * @param array $job Job payload.
+	 * @return array
+	 */
+	private function run_bulk_job( array $job ) {
+		$order_ids   = isset( $job['order_ids'] ) ? $this->normalize_order_ids( $job['order_ids'] ) : array();
+		$action      = isset( $job['action'] ) ? $this->normalize_action( $job['action'] ) : '';
+		$params      = isset( $job['params'] ) && is_array( $job['params'] ) ? $job['params'] : array();
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		$rollback_id = isset( $job['rollback_id'] ) ? (string) $job['rollback_id'] : '';
+
+		$result = array(
+			'action'    => $action,
+			'order_ids' => $order_ids,
+			'updated'   => array(),
+			'failed'    => array(),
+			'errors'    => array(),
+		);
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			$rollback = array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => gmdate( 'c', time() + self::ROLLBACK_TTL ),
+				'orders'     => array(),
+			);
+		}
+
+		$processed = 0;
+		$updated   = 0;
+		$failed    = 0;
+		$errors    = array();
+		$rows      = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$processed++;
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed++;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found.',
+				);
+				$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$current_status = $this->normalize_status( $order->get_status() );
+					$new_status     = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+					if ( '' === $new_status ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing target status.',
+						);
+						break;
+					}
+
+					$rollback['orders'][ $order_id ] = array(
+						'status' => $current_status,
+					);
+
+					$note            = isset( $params['note'] ) ? (string) $params['note'] : '';
+					$notify_customer = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+					$updated_flag    = $this->apply_status_update( $order, $new_status, $note, $notify_customer );
+
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to update status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+					$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+					$tags = $this->normalize_tags( $tags, $tag );
+					if ( empty( $tags ) ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing tags to add.',
+						);
+						break;
+					}
+
+					$before_tags = $this->get_order_tags( $order_id );
+					$rollback['orders'][ $order_id ] = array(
+						'tags' => $before_tags,
+					);
+
+					$updated_flag = $this->apply_tags_update( $order, $tags );
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+					if ( '' === $note ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing note content.',
+						);
+						break;
+					}
+
+					$is_customer_note = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+					$note_id          = $this->apply_order_note( $order, $note, $is_customer_note );
+					if ( $note_id > 0 ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+						$rollback['orders'][ $order_id ] = array(
+							'notes' => array( $note_id ),
+						);
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add note.',
+						);
+					}
+					break;
+				case 'export_csv':
+					$rows[] = $this->format_export_row( $order );
+					$updated++;
+					$result['updated'][] = $order_id;
+					break;
+				default:
+					$failed++;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Unsupported bulk action.',
+					);
+			}
+
+			$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+		}
+
+		$result['errors'] = $errors;
+		$result['failed'] = array_unique( array_merge( $result['failed'], wp_list_pluck( $errors, 'order_id' ) ) );
+
+		if ( 'export_csv' === $action ) {
+			$export = $this->export_csv( $rows, isset( $params['fields'] ) ? $params['fields'] : array() );
+			if ( isset( $export['error'] ) ) {
+				$errors[]         = array( 'order_id' => 0, 'message' => $export['error'] );
+				$result['errors'] = $errors;
+			} else {
+				$result['export'] = $export;
+			}
+		}
+
+		$this->store_rollback( $rollback_id, $rollback, self::ROLLBACK_TTL );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'processed' => $processed,
+					'updated'   => $updated,
+					'failed'    => $failed,
+					'errors'    => $errors,
+				),
+				true
+			);
+		}
+
+		return $result;
+	}
+
+	/**
+	 * Provide progress updates to polling clients.
+	 *
+	 * @param string $progress_id Progress identifier.
+	 * @return Response
+	 */
+	private function get_progress_response( $progress_id ): Response {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			return Response::error( 'Bulk progress not found or expired.', 404 );
+		}
+
+		return Response::success(
+			array(
+				'progress' => $progress,
+				'polling'  => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Roll back a bulk action.
+	 *
+	 * @param string $rollback_id Rollback identifier.
+	 * @return Response
+	 */
+	private function rollback_bulk_action( $rollback_id ): Response {
+		$rollback_id = is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+		if ( '' === $rollback_id ) {
+			return Response::error( 'Missing rollback ID.', 400 );
+		}
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			return Response::error( 'Rollback data not found or expired.', 404 );
+		}
+
+		$action  = isset( $rollback['action'] ) ? $this->normalize_action( $rollback['action'] ) : '';
+		$orders  = isset( $rollback['orders'] ) && is_array( $rollback['orders'] ) ? $rollback['orders'] : array();
+		$undone  = array();
+		$failed  = array();
+		$errors  = array();
+
+		foreach ( $orders as $order_id => $data ) {
+			$order_id = absint( $order_id );
+			$order    = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed[] = $order_id;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found for rollback.',
+				);
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$previous_status = isset( $data['status'] ) ? $this->normalize_status( $data['status'] ) : '';
+					if ( '' === $previous_status ) {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing previous status.',
+						);
+						break;
+					}
+
+					$updated = $this->apply_status_update( $order, $previous_status, 'Rollback to previous status.', false );
+					if ( $updated ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore previous status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $data['tags'] ) ? $data['tags'] : array();
+					$restored = $this->restore_order_tags( $order_id, $tags );
+					if ( $restored ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$notes = isset( $data['notes'] ) ? (array) $data['notes'] : array();
+					$deleted = $this->delete_order_notes( $notes );
+					if ( $deleted ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to remove notes.',
+						);
+					}
+					break;
+				default:
+					$failed[] = $order_id;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Rollback not supported for this action.',
+					);
+			}
+		}
+
+		return Response::success(
+			array(
+				'rollback_id' => $rollback_id,
+				'action'      => $action,
+				'undone'      => $undone,
+				'failed'      => $failed,
+				'errors'      => $errors,
+			)
+		);
+	}
+
+	/**
+	 * @param array $criteria Criteria input.
+	 * @return array
+	 */
+	private function normalize_criteria( $criteria ) {
+		$parsed = array(
+			'status'         => '',
+			'date_range'     => null,
+			'customer_email' => '',
+			'total_min'      => null,
+			'total_max'      => null,
+			'country'        => '',
+		);
+		$query  = '';
+
+		if ( is_string( $criteria ) ) {
+			$query = sanitize_text_field( $criteria );
+		} elseif ( is_array( $criteria ) ) {
+			$query = isset( $criteria['query'] ) ? sanitize_text_field( $criteria['query'] ) : '';
+			$parsed['status'] = isset( $criteria['status'] ) ? $this->normalize_status( $criteria['status'] ) : '';
+			$parsed['date_range'] = $this->normalize_date_range_input( isset( $criteria['date_range'] ) ? $criteria['date_range'] : null );
+			$parsed['customer_email'] = isset( $criteria['customer_email'] ) ? sanitize_email( $criteria['customer_email'] ) : '';
+			$parsed['total_min'] = isset( $criteria['total_min'] ) ? $this->normalize_amount( $criteria['total_min'] ) : null;
+			$parsed['total_max'] = isset( $criteria['total_max'] ) ? $this->normalize_amount( $criteria['total_max'] ) : null;
+			$parsed['country'] = isset( $criteria['country'] ) ? $this->normalize_country( $criteria['country'] ) : '';
+		}
+
+		if ( '' !== $query ) {
+			$text_parsed = $this->parse_criteria_text( $query );
+			foreach ( $text_parsed as $key => $value ) {
+				if ( ! isset( $parsed[ $key ] ) || '' === $parsed[ $key ] || null === $parsed[ $key ] ) {
+					$parsed[ $key ] = $value;
+				}
+			}
+		}
+
+		if ( '' === $parsed['status'] ) {
+			unset( $parsed['status'] );
+		}
+		if ( '' === $parsed['customer_email'] ) {
+			unset( $parsed['customer_email'] );
+		}
+		if ( '' === $parsed['country'] ) {
+			unset( $parsed['country'] );
+		}
+		if ( null === $parsed['total_min'] ) {
+			unset( $parsed['total_min'] );
+		}
+		if ( null === $parsed['total_max'] ) {
+			unset( $parsed['total_max'] );
+		}
+		if ( null === $parsed['date_range'] ) {
+			unset( $parsed['date_range'] );
+		}
+
+		return $parsed;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function parse_criteria_text( $query ) {
+		$query  = trim( (string) $query );
+		$lower  = strtolower( $query );
+		$result = array();
+
+		$status = $this->detect_status( $lower );
+		if ( '' !== $status ) {
+			$result['status'] = $status;
+		}
+
+		$date_range = $this->parse_date_range_from_query( $lower );
+		if ( null !== $date_range ) {
+			$result['date_range'] = $date_range;
+		}
+
+		$email = $this->extract_email( $query );
+		if ( '' !== $email ) {
+			$result['customer_email'] = $email;
+		}
+
+		$totals = $this->extract_total_range( $lower );
+		if ( isset( $totals['min'] ) ) {
+			$result['total_min'] = $totals['min'];
+		}
+		if ( isset( $totals['max'] ) ) {
+			$result['total_max'] = $totals['max'];
+		}
+
+		$country = $this->extract_country( $query );
+		if ( '' !== $country ) {
+			$result['country'] = $country;
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param array $criteria Query criteria.
+	 * @return array
+	 */
+	private function query_order_ids( array $criteria ) {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		$args = array(
+			'limit'   => self::MAX_BULK,
+			'return'  => 'ids',
+			'orderby' => 'date',
+			'order'   => 'DESC',
+		);
+
+		if ( isset( $criteria['status'] ) && '' !== $criteria['status'] ) {
+			$args['status'] = $criteria['status'];
+		}
+
+		if ( isset( $criteria['date_range'] ) && is_array( $criteria['date_range'] ) ) {
+			$args['date_created'] = $criteria['date_range']['start'] . '...' . $criteria['date_range']['end'];
+		}
+
+		$meta_query = array( 'relation' => 'AND' );
+
+		if ( isset( $criteria['customer_email'] ) && '' !== $criteria['customer_email'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['country'] ) && '' !== $criteria['country'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['total_min'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_min'],
+				'compare' => '>=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( isset( $criteria['total_max'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_max'],
+				'compare' => '<=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( count( $meta_query ) > 1 ) {
+			$args['meta_query'] = $meta_query;
+		}
+
+		$order_ids = wc_get_orders( $args );
+		if ( ! is_array( $order_ids ) ) {
+			return array();
+		}
+
+		$order_ids = array_map( 'absint', $order_ids );
+		$order_ids = array_filter( $order_ids );
+		$order_ids = array_values( array_unique( $order_ids ) );
+
+		return $order_ids;
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function build_sample_orders( array $order_ids ) {
+		$sample = array();
+		$order_ids = array_slice( $order_ids, 0, 5 );
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( $order ) {
+				$sample[] = $this->format_order_summary( $order );
+			}
+		}
+
+		return $sample;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_order_summary( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'       => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'currency'       => method_exists( $order, 'get_currency' ) ? sanitize_text_field( $order->get_currency() ) : '',
+			'customer_name'  => sanitize_text_field( $this->get_customer_name( $order ) ),
+			'customer_email' => sanitize_email( $this->get_customer_email( $order ) ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'country'        => sanitize_text_field( $this->get_order_country( $order ) ),
+		);
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @param mixed $action Raw action.
+	 * @return string
+	 */
+	private function normalize_action( $action ) {
+		$action = is_string( $action ) ? strtolower( trim( $action ) ) : '';
+		$allowed = array( 'update_status', 'add_tag', 'add_note', 'export_csv' );
+
+		return in_array( $action, $allowed, true ) ? $action : '';
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param mixed  $params Raw params.
+	 * @return array
+	 */
+	private function normalize_params( $action, $params ) {
+		$params = is_array( $params ) ? $params : array();
+		$normalized = array();
+
+		switch ( $action ) {
+			case 'update_status':
+				$new_status = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+				if ( '' === $new_status ) {
+					return array( 'error' => 'Missing new status for bulk update.' );
+				}
+
+				$valid_statuses = $this->get_valid_statuses();
+				if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+					return array( 'error' => 'Invalid status for bulk update.' );
+				}
+
+				$normalized['new_status'] = $new_status;
+				$normalized['note'] = isset( $params['note'] ) ? sanitize_text_field( wp_unslash( $params['note'] ) ) : '';
+				$normalized['notify_customer'] = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+				break;
+			case 'add_tag':
+				$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+				$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+				$normalized['tags'] = $this->normalize_tags( $tags, $tag );
+				if ( empty( $normalized['tags'] ) ) {
+					return array( 'error' => 'Missing tags for bulk update.' );
+				}
+				break;
+			case 'add_note':
+				$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+				if ( '' === $note ) {
+					return array( 'error' => 'Missing note for bulk update.' );
+				}
+				$normalized['note'] = sanitize_text_field( wp_unslash( $note ) );
+				$normalized['is_customer_note'] = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+				break;
+			case 'export_csv':
+				$fields = isset( $params['fields'] ) ? $params['fields'] : array();
+				$normalized['fields'] = $this->normalize_fields( $fields );
+				break;
+			default:
+				return array( 'error' => 'Unsupported bulk action.' );
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param array  $params Params.
+	 * @return array
+	 */
+	private function build_action_preview( $action, array $params ) {
+		switch ( $action ) {
+			case 'update_status':
+				return array(
+					'new_status'      => isset( $params['new_status'] ) ? $params['new_status'] : '',
+					'notify_customer' => ! empty( $params['notify_customer'] ),
+					'note'            => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'add_tag':
+				return array(
+					'tags' => isset( $params['tags'] ) ? $params['tags'] : array(),
+				);
+			case 'add_note':
+				return array(
+					'note' => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'export_csv':
+				return array(
+					'fields' => isset( $params['fields'] ) ? $params['fields'] : $this->normalize_fields( array() ),
+				);
+			default:
+				return array();
+		}
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function find_missing_orders( array $order_ids ) {
+		$missing = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$missing[] = $order_id;
+			}
+		}
+
+		return $missing;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @param int    $processed Processed count.
+	 * @param int    $updated Updated count.
+	 * @param int    $failed Failed count.
+	 * @param array  $errors Error list.
+	 * @return void
+	 */
+	private function maybe_update_progress( $progress_id, $processed, $updated, $failed, array $errors ) {
+		if ( '' === $progress_id ) {
+			return;
+		}
+
+		$this->update_progress(
+			$progress_id,
+			array(
+				'processed' => $processed,
+				'updated'   => $updated,
+				'failed'    => $failed,
+				'errors'    => $errors,
+			),
+			false
+		);
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $updates Updates.
+	 * @param bool   $force Force update.
+	 * @return array
+	 */
+	private function update_progress( $progress_id, array $updates, $force ) {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			$progress = array(
+				'id'           => $progress_id,
+				'status'       => 'queued',
+				'processed'    => 0,
+				'updated'      => 0,
+				'failed'       => 0,
+				'errors'       => array(),
+				'created_at'   => gmdate( 'c' ),
+				'last_updated' => gmdate( 'c' ),
+			);
+		}
+
+		$last_updated = isset( $progress['last_updated'] ) ? strtotime( $progress['last_updated'] ) : 0;
+		$should_update = $force || ( time() - $last_updated >= self::POLL_INTERVAL );
+
+		foreach ( $updates as $key => $value ) {
+			$progress[ $key ] = $value;
+		}
+
+		if ( $should_update ) {
+			$progress['last_updated'] = gmdate( 'c' );
+			$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @return array|null
+	 */
+	private function load_progress( $progress_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$progress = get_transient( $this->build_progress_key( $progress_id ) );
+		if ( false === $progress || ! is_array( $progress ) ) {
+			return null;
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $progress Progress payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_progress( $progress_id, array $progress, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_progress_key( $progress_id ), $progress, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return array|null
+	 */
+	private function load_job( $job_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$job = get_transient( $this->build_job_key( $job_id ) );
+		if ( false === $job || ! is_array( $job ) ) {
+			return null;
+		}
+
+		return $job;
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @param array  $job Job payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_job( $job_id, array $job, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_job_key( $job_id ), $job, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return void
+	 */
+	private function delete_job( $job_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_job_key( $job_id ) );
+		}
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @return array|null
+	 */
+	private function load_rollback( $rollback_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$rollback = get_transient( $this->build_rollback_key( $rollback_id ) );
+		if ( false === $rollback || ! is_array( $rollback ) ) {
+			return null;
+		}
+
+		return $rollback;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @param array  $rollback Rollback data.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_rollback( $rollback_id, array $rollback, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_rollback_key( $rollback_id ), $rollback, $ttl );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_uuid() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'bulk_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_draft_' . $draft_id;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @return string
+	 */
+	private function build_progress_key( $progress_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_progress_' . $progress_id;
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return string
+	 */
+	private function build_job_key( $job_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_job_' . $job_id;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback identifier.
+	 * @return string
+	 */
+	private function build_rollback_key( $rollback_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_rollback_' . $rollback_id;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param mixed $status Raw status.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float|null
+	 */
+	private function normalize_amount( $amount ) {
+		if ( null === $amount || '' === $amount ) {
+			return null;
+		}
+
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $country Country input.
+	 * @return string
+	 */
+	private function normalize_country( $country ) {
+		$country = is_string( $country ) ? strtoupper( trim( $country ) ) : '';
+		if ( '' === $country ) {
+			return '';
+		}
+
+		if ( strlen( $country ) === 2 ) {
+			return $country;
+		}
+
+		$map = $this->get_country_map();
+		$key = strtolower( $country );
+
+		return isset( $map[ $key ] ) ? $map[ $key ] : '';
+	}
+
+	/**
+	 * @param mixed $tags Tags list.
+	 * @param mixed $tag Single tag.
+	 * @return array
+	 */
+	private function normalize_tags( $tags, $tag ) {
+		$list = array();
+
+		if ( is_string( $tags ) ) {
+			$tags = preg_split( '/[\s,]+/', $tags );
+		}
+
+		if ( is_array( $tags ) ) {
+			foreach ( $tags as $item ) {
+				$item = sanitize_text_field( (string) $item );
+				if ( '' !== $item ) {
+					$list[] = $item;
+				}
+			}
+		}
+
+		if ( is_string( $tag ) ) {
+			$tag = sanitize_text_field( $tag );
+			if ( '' !== $tag ) {
+				$list[] = $tag;
+			}
+		}
+
+		$list = array_values( array_unique( $list ) );
+
+		return $list;
+	}
+
+	/**
+	 * @param mixed $fields Fields input.
+	 * @return array
+	 */
+	private function normalize_fields( $fields ) {
+		$default = array( 'order_id', 'status', 'total', 'currency', 'customer_name', 'customer_email', 'date_created', 'billing_country', 'shipping_country' );
+		if ( empty( $fields ) ) {
+			return $default;
+		}
+
+		if ( is_string( $fields ) ) {
+			$fields = preg_split( '/[\s,]+/', $fields );
+		}
+
+		if ( ! is_array( $fields ) ) {
+			return $default;
+		}
+
+		$sanitized = array();
+		foreach ( $fields as $field ) {
+			$field = sanitize_key( $field );
+			if ( '' !== $field ) {
+				$sanitized[] = $field;
+			}
+		}
+
+		return array_values( array_unique( $sanitized ) );
+	}
+
+	/**
+	 * @param array $order Order object.
+	 * @param string $new_status New status.
+	 * @param string $note Note for audit.
+	 * @param bool $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $current_status === $new_status ) {
+			return false;
+		}
+
+		$note = trim( (string) $note );
+		$audit_note = sprintf( '[AgentWP] Bulk status update: %s -> %s.', $current_status, $new_status );
+		if ( '' !== $note ) {
+			$audit_note .= ' Note: ' . $note . '.';
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $audit_note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param array  $tags Tags to add.
+	 * @return bool
+	 */
+	private function apply_tags_update( $order, array $tags ) {
+		$order_id = method_exists( $order, 'get_id' ) ? $order->get_id() : 0;
+		if ( $order_id <= 0 ) {
+			return false;
+		}
+
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				$existing = array();
+			}
+			$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+			wp_set_object_terms( $order_id, $merged, $taxonomy, false );
+			return true;
+		}
+
+		if ( ! method_exists( $order, 'get_meta' ) || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			$existing = array();
+		}
+
+		$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+		$order->update_meta_data( '_agentwp_order_tags', $merged );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param string $note Note text.
+	 * @param bool   $is_customer_note Customer visibility.
+	 * @return int
+	 */
+	private function apply_order_note( $order, $note, $is_customer_note ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return 0;
+		}
+
+		$note = trim( (string) $note );
+		if ( '' === $note ) {
+			return 0;
+		}
+
+		$note_id = $order->add_order_note( $note, $is_customer_note );
+
+		return absint( $note_id );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_export_row( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'        => intval( $order->get_id() ),
+			'status'          => sanitize_text_field( $order->get_status() ),
+			'total'           => $order->get_total(),
+			'currency'        => method_exists( $order, 'get_currency' ) ? $order->get_currency() : '',
+			'customer_name'   => $this->get_customer_name( $order ),
+			'customer_email'  => $this->get_customer_email( $order ),
+			'date_created'    => $date_created ? $date_created->date( 'c' ) : '',
+			'billing_country' => method_exists( $order, 'get_billing_country' ) ? $order->get_billing_country() : '',
+			'shipping_country'=> method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '',
+		);
+	}
+
+	/**
+	 * @param array $rows Data rows.
+	 * @param array $fields Fields list.
+	 * @return array
+	 */
+	private function export_csv( array $rows, array $fields ) {
+		if ( ! function_exists( 'wp_upload_dir' ) ) {
+			return array( 'error' => 'Unable to export CSV in this environment.' );
+		}
+
+		$fields = $this->normalize_fields( $fields );
+		$upload = wp_upload_dir();
+		$base   = isset( $upload['basedir'] ) ? $upload['basedir'] : '';
+		$url    = isset( $upload['baseurl'] ) ? $upload['baseurl'] : '';
+
+		if ( '' === $base || '' === $url ) {
+			return array( 'error' => 'Unable to resolve upload directory.' );
+		}
+
+		$dir = trailingslashit( $base ) . 'agentwp-exports';
+		if ( function_exists( 'wp_mkdir_p' ) ) {
+			wp_mkdir_p( $dir );
+		}
+
+		$filename = 'agentwp-bulk-export-' . gmdate( 'Ymd-His' ) . '-' . wp_generate_password( 6, false ) . '.csv';
+		$path     = trailingslashit( $dir ) . $filename;
+		$file     = @fopen( $path, 'w' );
+		if ( ! $file ) {
+			return array( 'error' => 'Unable to create CSV export file.' );
+		}
+
+		fputcsv( $file, $fields );
+		foreach ( $rows as $row ) {
+			$line = array();
+			foreach ( $fields as $field ) {
+				$line[] = isset( $row[ $field ] ) ? $row[ $field ] : '';
+			}
+			fputcsv( $file, $line );
+		}
+
+		fclose( $file );
+
+		return array(
+			'file_path' => $path,
+			'file_url'  => trailingslashit( $url ) . 'agentwp-exports/' . $filename,
+			'rows'      => count( $rows ),
+		);
+	}
+
+	/**
+	 * @param int $order_id Order ID.
+	 * @return array
+	 */
+	private function get_order_tags( $order_id ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				return array();
+			}
+			return $existing;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'get_meta' ) ) {
+			return array();
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			return array();
+		}
+
+		return $existing;
+	}
+
+	/**
+	 * @param int   $order_id Order ID.
+	 * @param array $tags Tags.
+	 * @return bool
+	 */
+	private function restore_order_tags( $order_id, $tags ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			wp_set_object_terms( $order_id, (array) $tags, $taxonomy, false );
+			return true;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$order->update_meta_data( '_agentwp_order_tags', (array) $tags );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param array $note_ids Note IDs.
+	 * @return bool
+	 */
+	private function delete_order_notes( array $note_ids ) {
+		if ( ! function_exists( 'wp_delete_comment' ) ) {
+			return false;
+		}
+
+		$deleted_any = false;
+		foreach ( $note_ids as $note_id ) {
+			$note_id = absint( $note_id );
+			if ( $note_id > 0 ) {
+				wp_delete_comment( $note_id, true );
+				$deleted_any = true;
+			}
+		}
+
+		return $deleted_any;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function get_order_tag_taxonomy() {
+		$taxonomy = apply_filters( 'agentwp_order_tag_taxonomy', 'shop_order_tag' );
+		$taxonomy = is_string( $taxonomy ) ? trim( $taxonomy ) : '';
+
+		if ( '' !== $taxonomy && function_exists( 'taxonomy_exists' ) && taxonomy_exists( $taxonomy ) ) {
+			return $taxonomy;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param array|null $date_range Date range input.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query text.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date.
+	 * @param string $end End date.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Date string.
+	 * @param bool   $end_of_day End of day flag.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		$date = $end_of_day ? $date->setTime( 23, 59, 59 ) : $date->setTime( 0, 0, 0 );
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function extract_total_range( $query ) {
+		$result = array();
+
+		if ( preg_match( '/\bbetween\s+[\$£\x{20AC}]?([0-9\.,]+)\s+(?:and|to)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+			return $result;
+		}
+
+		if ( preg_match( '/\b(over|above|more than|greater than|at least|minimum|min)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b(under|below|less than|at most|maximum|max)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b>=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		if ( preg_match( '/\b<=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param string $value Amount string.
+	 * @return float|null
+	 */
+	private function parse_amount_string( $value ) {
+		$value = str_replace( array( ',', ' ' ), '', (string) $value );
+		return $this->normalize_amount( $value );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_country( $query ) {
+		$query_lower = strtolower( $query );
+		$map         = $this->get_country_map();
+
+		foreach ( $map as $name => $code ) {
+			$pattern = '/\b' . preg_quote( $name, '/' ) . '\b/i';
+			if ( preg_match( $pattern, $query_lower ) ) {
+				return $code;
+			}
+		}
+
+		if ( preg_match_all( '/\b([A-Z]{2})\b/', strtoupper( $query ), $matches ) ) {
+			foreach ( $matches[1] as $code ) {
+				if ( isset( $map[ strtolower( $code ) ] ) ) {
+					return $map[ strtolower( $code ) ];
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_country_map() {
+		static $map = null;
+		if ( null !== $map ) {
+			return $map;
+		}
+
+		$countries = array();
+		if ( function_exists( 'WC' ) ) {
+			$wc = WC();
+			if ( $wc && isset( $wc->countries ) && method_exists( $wc->countries, 'get_countries' ) ) {
+				$countries = $wc->countries->get_countries();
+			}
+		}
+
+		if ( empty( $countries ) && class_exists( 'WC_Countries' ) ) {
+			$wc_countries = new \WC_Countries();
+			$countries    = $wc_countries->get_countries();
+		}
+
+		$map = array();
+		if ( is_array( $countries ) ) {
+			foreach ( $countries as $code => $name ) {
+				$map[ strtolower( $name ) ] = strtoupper( $code );
+				$map[ strtolower( $code ) ] = strtoupper( $code );
+			}
+		}
+
+		$map['usa'] = 'US';
+		$map['us']  = 'US';
+		$map['uk']  = 'GB';
+
+		return $map;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_order_country( $order ) {
+		$country = method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '';
+		if ( '' !== $country ) {
+			return $country;
+		}
+
+		if ( method_exists( $order, 'get_billing_country' ) ) {
+			$country = $order->get_billing_country();
+		}
+
+		return is_string( $country ) ? $country : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_draft_id( array $args ) {
+		$draft_id = isset( $args['draft_id'] ) ? $args['draft_id'] : '';
+		if ( '' === $draft_id && isset( $args['params']['draft_id'] ) ) {
+			$draft_id = $args['params']['draft_id'];
+		}
+
+		return is_string( $draft_id ) ? trim( $draft_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_progress_id( array $args ) {
+		$progress_id = isset( $args['progress_id'] ) ? $args['progress_id'] : '';
+		if ( '' === $progress_id && isset( $args['params']['progress_id'] ) ) {
+			$progress_id = $args['params']['progress_id'];
+		}
+
+		return is_string( $progress_id ) ? trim( $progress_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_rollback_id( array $args ) {
+		$rollback_id = isset( $args['rollback_id'] ) ? $args['rollback_id'] : '';
+		if ( '' === $rollback_id && isset( $args['params']['rollback_id'] ) ) {
+			$rollback_id = $args['params']['rollback_id'];
+		}
+
+		return is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+	}
+
+	/**
+	 * @return bool
+	 */
+	private function action_scheduler_available() {
+		return function_exists( 'as_enqueue_async_action' ) || function_exists( 'as_schedule_single_action' );
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return int
+	 */
+	private function schedule_job( $job_id ) {
+		if ( function_exists( 'as_enqueue_async_action' ) ) {
+			return (int) as_enqueue_async_action( self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		if ( function_exists( 'as_schedule_single_action' ) ) {
+			return (int) as_schedule_single_action( time(), self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		return 0;
+	}
+}

file update:
diff --git a/src/Handlers/BulkHandler.php b/src/Handlers/BulkHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..d7994bcd117201a3df0db869c3d04e51a692d784
--- /dev/null
+++ b/src/Handlers/BulkHandler.php
@@ -0,0 +1,2223 @@
+<?php
+/**
+ * Handle bulk order operations.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class BulkHandler {
+	const ACTION_HOOK      = 'agentwp_bulk_process';
+	const ASYNC_THRESHOLD  = 20;
+	const DRAFT_TYPE       = 'bulk_action';
+	const JOB_TTL_SECONDS  = 86400;
+	const MAX_BULK         = 1000;
+	const PROGRESS_TTL     = 86400;
+	const ROLLBACK_TTL     = 86400;
+	const POLL_INTERVAL    = 2;
+
+	/**
+	 * Register background processing hooks.
+	 *
+	 * @return void
+	 */
+	public static function register_hooks() {
+		add_action( self::ACTION_HOOK, array( __CLASS__, 'handle_scheduled_action' ), 10, 1 );
+	}
+
+	/**
+	 * Execute scheduled bulk jobs.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	public static function handle_scheduled_action( $job_id ) {
+		$handler = new self();
+		$handler->process_scheduled_job( $job_id );
+	}
+
+	/**
+	 * Handle bulk actions and selections.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['criteria'] ) ) {
+			return $this->select_orders( $args );
+		}
+
+		$progress_id = $this->extract_progress_id( $args );
+		if ( '' !== $progress_id ) {
+			return $this->get_progress_response( $progress_id );
+		}
+
+		$rollback_id = $this->extract_rollback_id( $args );
+		if ( '' !== $rollback_id ) {
+			return $this->rollback_bulk_action( $rollback_id );
+		}
+
+		$draft_id = $this->extract_draft_id( $args );
+		if ( '' !== $draft_id ) {
+			return $this->confirm_bulk_update( $draft_id );
+		}
+
+		return $this->prepare_bulk_update( $args );
+	}
+
+	/**
+	 * Select orders based on criteria.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function select_orders( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to select orders.', 400 );
+		}
+
+		$criteria  = $this->normalize_criteria( isset( $args['criteria'] ) ? $args['criteria'] : array() );
+		$order_ids = $this->query_order_ids( $criteria );
+		$sample    = $this->build_sample_orders( $order_ids );
+
+		return Response::success(
+			array(
+				'order_ids'  => $order_ids,
+				'count'      => count( $order_ids ),
+				'criteria'   => $criteria,
+				'sample'     => $sample,
+				'truncated'  => count( $order_ids ) >= self::MAX_BULK,
+				'max_limit'  => self::MAX_BULK,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a bulk update draft.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	private function prepare_bulk_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $args['action'] ) ? $args['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Missing or invalid bulk action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $args['params'] ) ? $args['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$missing_orders = $this->find_missing_orders( $order_ids );
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		$sample = $this->build_sample_orders( $order_ids );
+		$preview = array(
+			'order_count'    => count( $order_ids ),
+			'sample'         => $sample,
+			'action'         => $action,
+			'action_preview' => $this->build_action_preview( $action, $params ),
+		);
+
+		$draft_payload = array(
+			'order_ids' => $order_ids,
+			'action'    => $action,
+			'params'    => $params,
+			'preview'   => $preview,
+		);
+
+		$draft_id   = $this->generate_uuid();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a bulk update draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	private function confirm_bulk_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to process bulk updates.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing bulk update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Bulk update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for bulk update confirmation.', 400 );
+		}
+
+		$payload  = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $payload['action'] ) ? $payload['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Bulk update draft is missing an action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $payload['params'] ) ? $payload['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$job_id      = $this->generate_uuid();
+		$progress_id = $this->generate_uuid();
+		$rollback_id = $this->generate_uuid();
+
+		$rollback_expires = gmdate( 'c', time() + self::ROLLBACK_TTL );
+		$this->store_rollback(
+			$rollback_id,
+			array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => $rollback_expires,
+				'orders'     => array(),
+			),
+			self::ROLLBACK_TTL
+		);
+
+		$progress = array(
+			'id'                  => $progress_id,
+			'status'              => 'queued',
+			'action'              => $action,
+			'order_count'         => count( $order_ids ),
+			'processed'           => 0,
+			'updated'             => 0,
+			'failed'              => 0,
+			'errors'              => array(),
+			'created_at'          => gmdate( 'c' ),
+			'started_at'          => '',
+			'last_updated'        => gmdate( 'c' ),
+			'completed_at'        => '',
+			'draft_id'            => $draft_id,
+			'rollback_id'         => $rollback_id,
+			'undo_available_until'=> $rollback_expires,
+		);
+		$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+
+		$job = array(
+			'id'          => $job_id,
+			'order_ids'   => $order_ids,
+			'action'      => $action,
+			'params'      => $params,
+			'progress_id' => $progress_id,
+			'rollback_id' => $rollback_id,
+			'draft_id'    => $draft_id,
+		);
+		$this->store_job( $job_id, $job, self::JOB_TTL_SECONDS );
+
+		$async = count( $order_ids ) > self::ASYNC_THRESHOLD && $this->action_scheduler_available();
+		if ( $async ) {
+			$action_id = $this->schedule_job( $job_id );
+			if ( ! $action_id ) {
+				return Response::error( 'Unable to schedule bulk update.', 500 );
+			}
+
+			$this->delete_draft( $draft_id );
+
+			return Response::success(
+				array(
+					'status'     => 'scheduled',
+					'draft_id'   => $draft_id,
+					'job_id'     => $job_id,
+					'progress'   => $progress,
+					'polling'    => array(
+						'progress_id'      => $progress_id,
+						'interval_seconds' => self::POLL_INTERVAL,
+					),
+					'rollback_id' => $rollback_id,
+					'undo_available_until' => $rollback_expires,
+				)
+			);
+		}
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'     => 'running',
+				'started_at' => gmdate( 'c' ),
+			),
+			true
+		);
+
+		$result = $this->run_bulk_job( $job );
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'       => 'completed',
+				'completed_at' => gmdate( 'c' ),
+				'result'       => $result,
+			),
+			true
+		);
+
+		$this->delete_job( $job_id );
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'status'      => 'completed',
+				'draft_id'    => $draft_id,
+				'result'      => $result,
+				'progress'    => $progress,
+				'polling'     => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+				'rollback_id' => $rollback_id,
+				'undo_available_until' => $rollback_expires,
+			)
+		);
+	}
+
+	/**
+	 * Process a scheduled bulk job.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	private function process_scheduled_job( $job_id ) {
+		$job_id = is_string( $job_id ) ? trim( $job_id ) : '';
+		if ( '' === $job_id ) {
+			return;
+		}
+
+		$job = $this->load_job( $job_id );
+		if ( ! is_array( $job ) ) {
+			return;
+		}
+
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'     => 'running',
+					'started_at' => gmdate( 'c' ),
+				),
+				true
+			);
+		}
+
+		$result = $this->run_bulk_job( $job );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'       => 'completed',
+					'completed_at' => gmdate( 'c' ),
+					'result'       => $result,
+				),
+				true
+			);
+		}
+
+		$draft_id = isset( $job['draft_id'] ) ? (string) $job['draft_id'] : '';
+		if ( '' !== $draft_id ) {
+			$this->delete_draft( $draft_id );
+		}
+
+		$this->delete_job( $job_id );
+	}
+
+	/**
+	 * Execute a bulk job.
+	 *
+	 * @param array $job Job payload.
+	 * @return array
+	 */
+	private function run_bulk_job( array $job ) {
+		$order_ids   = isset( $job['order_ids'] ) ? $this->normalize_order_ids( $job['order_ids'] ) : array();
+		$action      = isset( $job['action'] ) ? $this->normalize_action( $job['action'] ) : '';
+		$params      = isset( $job['params'] ) && is_array( $job['params'] ) ? $job['params'] : array();
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		$rollback_id = isset( $job['rollback_id'] ) ? (string) $job['rollback_id'] : '';
+
+		$result = array(
+			'action'    => $action,
+			'order_ids' => $order_ids,
+			'updated'   => array(),
+			'failed'    => array(),
+			'errors'    => array(),
+		);
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			$rollback = array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => gmdate( 'c', time() + self::ROLLBACK_TTL ),
+				'orders'     => array(),
+			);
+		}
+
+		$processed = 0;
+		$updated   = 0;
+		$failed    = 0;
+		$errors    = array();
+		$rows      = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$processed++;
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed++;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found.',
+				);
+				$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$current_status = $this->normalize_status( $order->get_status() );
+					$new_status     = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+					if ( '' === $new_status ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing target status.',
+						);
+						break;
+					}
+
+					$rollback['orders'][ $order_id ] = array(
+						'status' => $current_status,
+					);
+
+					$note            = isset( $params['note'] ) ? (string) $params['note'] : '';
+					$notify_customer = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+					$updated_flag    = $this->apply_status_update( $order, $new_status, $note, $notify_customer );
+
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to update status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+					$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+					$tags = $this->normalize_tags( $tags, $tag );
+					if ( empty( $tags ) ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing tags to add.',
+						);
+						break;
+					}
+
+					$before_tags = $this->get_order_tags( $order_id );
+					$rollback['orders'][ $order_id ] = array(
+						'tags' => $before_tags,
+					);
+
+					$updated_flag = $this->apply_tags_update( $order, $tags );
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+					if ( '' === $note ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing note content.',
+						);
+						break;
+					}
+
+					$is_customer_note = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+					$note_id          = $this->apply_order_note( $order, $note, $is_customer_note );
+					if ( $note_id > 0 ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+						$rollback['orders'][ $order_id ] = array(
+							'notes' => array( $note_id ),
+						);
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add note.',
+						);
+					}
+					break;
+				case 'export_csv':
+					$rows[] = $this->format_export_row( $order );
+					$updated++;
+					$result['updated'][] = $order_id;
+					break;
+				default:
+					$failed++;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Unsupported bulk action.',
+					);
+			}
+
+			$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+		}
+
+		$result['errors'] = $errors;
+		$result['failed'] = array_unique( array_merge( $result['failed'], wp_list_pluck( $errors, 'order_id' ) ) );
+
+		if ( 'export_csv' === $action ) {
+			$export = $this->export_csv( $rows, isset( $params['fields'] ) ? $params['fields'] : array() );
+			if ( isset( $export['error'] ) ) {
+				$errors[]         = array( 'order_id' => 0, 'message' => $export['error'] );
+				$result['errors'] = $errors;
+			} else {
+				$result['export'] = $export;
+			}
+		}
+
+		$this->store_rollback( $rollback_id, $rollback, self::ROLLBACK_TTL );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'processed' => $processed,
+					'updated'   => $updated,
+					'failed'    => $failed,
+					'errors'    => $errors,
+				),
+				true
+			);
+		}
+
+		return $result;
+	}
+
+	/**
+	 * Provide progress updates to polling clients.
+	 *
+	 * @param string $progress_id Progress identifier.
+	 * @return Response
+	 */
+	private function get_progress_response( $progress_id ): Response {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			return Response::error( 'Bulk progress not found or expired.', 404 );
+		}
+
+		return Response::success(
+			array(
+				'progress' => $progress,
+				'polling'  => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Roll back a bulk action.
+	 *
+	 * @param string $rollback_id Rollback identifier.
+	 * @return Response
+	 */
+	private function rollback_bulk_action( $rollback_id ): Response {
+		$rollback_id = is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+		if ( '' === $rollback_id ) {
+			return Response::error( 'Missing rollback ID.', 400 );
+		}
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			return Response::error( 'Rollback data not found or expired.', 404 );
+		}
+
+		$action  = isset( $rollback['action'] ) ? $this->normalize_action( $rollback['action'] ) : '';
+		$orders  = isset( $rollback['orders'] ) && is_array( $rollback['orders'] ) ? $rollback['orders'] : array();
+		$undone  = array();
+		$failed  = array();
+		$errors  = array();
+
+		foreach ( $orders as $order_id => $data ) {
+			$order_id = absint( $order_id );
+			$order    = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed[] = $order_id;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found for rollback.',
+				);
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$previous_status = isset( $data['status'] ) ? $this->normalize_status( $data['status'] ) : '';
+					if ( '' === $previous_status ) {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing previous status.',
+						);
+						break;
+					}
+
+					$updated = $this->apply_status_update( $order, $previous_status, 'Rollback to previous status.', false );
+					if ( $updated ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore previous status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $data['tags'] ) ? $data['tags'] : array();
+					$restored = $this->restore_order_tags( $order_id, $tags );
+					if ( $restored ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$notes = isset( $data['notes'] ) ? (array) $data['notes'] : array();
+					$deleted = $this->delete_order_notes( $notes );
+					if ( $deleted ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to remove notes.',
+						);
+					}
+					break;
+				default:
+					$failed[] = $order_id;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Rollback not supported for this action.',
+					);
+			}
+		}
+
+		return Response::success(
+			array(
+				'rollback_id' => $rollback_id,
+				'action'      => $action,
+				'undone'      => $undone,
+				'failed'      => $failed,
+				'errors'      => $errors,
+			)
+		);
+	}
+
+	/**
+	 * @param array $criteria Criteria input.
+	 * @return array
+	 */
+	private function normalize_criteria( $criteria ) {
+		$parsed = array(
+			'status'         => '',
+			'date_range'     => null,
+			'customer_email' => '',
+			'total_min'      => null,
+			'total_max'      => null,
+			'country'        => '',
+		);
+		$query  = '';
+
+		if ( is_string( $criteria ) ) {
+			$query = sanitize_text_field( $criteria );
+		} elseif ( is_array( $criteria ) ) {
+			$query = isset( $criteria['query'] ) ? sanitize_text_field( $criteria['query'] ) : '';
+			$parsed['status'] = isset( $criteria['status'] ) ? $this->normalize_status( $criteria['status'] ) : '';
+			$parsed['date_range'] = $this->normalize_date_range_input( isset( $criteria['date_range'] ) ? $criteria['date_range'] : null );
+			$parsed['customer_email'] = isset( $criteria['customer_email'] ) ? sanitize_email( $criteria['customer_email'] ) : '';
+			$parsed['total_min'] = isset( $criteria['total_min'] ) ? $this->normalize_amount( $criteria['total_min'] ) : null;
+			$parsed['total_max'] = isset( $criteria['total_max'] ) ? $this->normalize_amount( $criteria['total_max'] ) : null;
+			$parsed['country'] = isset( $criteria['country'] ) ? $this->normalize_country( $criteria['country'] ) : '';
+		}
+
+		if ( '' !== $query ) {
+			$text_parsed = $this->parse_criteria_text( $query );
+			foreach ( $text_parsed as $key => $value ) {
+				if ( ! isset( $parsed[ $key ] ) || '' === $parsed[ $key ] || null === $parsed[ $key ] ) {
+					$parsed[ $key ] = $value;
+				}
+			}
+		}
+
+		if ( '' === $parsed['status'] ) {
+			unset( $parsed['status'] );
+		}
+		if ( '' === $parsed['customer_email'] ) {
+			unset( $parsed['customer_email'] );
+		}
+		if ( '' === $parsed['country'] ) {
+			unset( $parsed['country'] );
+		}
+		if ( null === $parsed['total_min'] ) {
+			unset( $parsed['total_min'] );
+		}
+		if ( null === $parsed['total_max'] ) {
+			unset( $parsed['total_max'] );
+		}
+		if ( null === $parsed['date_range'] ) {
+			unset( $parsed['date_range'] );
+		}
+
+		return $parsed;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function parse_criteria_text( $query ) {
+		$query  = trim( (string) $query );
+		$lower  = strtolower( $query );
+		$result = array();
+
+		$status = $this->detect_status( $lower );
+		if ( '' !== $status ) {
+			$result['status'] = $status;
+		}
+
+		$date_range = $this->parse_date_range_from_query( $lower );
+		if ( null !== $date_range ) {
+			$result['date_range'] = $date_range;
+		}
+
+		$email = $this->extract_email( $query );
+		if ( '' !== $email ) {
+			$result['customer_email'] = $email;
+		}
+
+		$totals = $this->extract_total_range( $lower );
+		if ( isset( $totals['min'] ) ) {
+			$result['total_min'] = $totals['min'];
+		}
+		if ( isset( $totals['max'] ) ) {
+			$result['total_max'] = $totals['max'];
+		}
+
+		$country = $this->extract_country( $query );
+		if ( '' !== $country ) {
+			$result['country'] = $country;
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param array $criteria Query criteria.
+	 * @return array
+	 */
+	private function query_order_ids( array $criteria ) {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		$args = array(
+			'limit'   => self::MAX_BULK,
+			'return'  => 'ids',
+			'orderby' => 'date',
+			'order'   => 'DESC',
+		);
+
+		if ( isset( $criteria['status'] ) && '' !== $criteria['status'] ) {
+			$args['status'] = $criteria['status'];
+		}
+
+		if ( isset( $criteria['date_range'] ) && is_array( $criteria['date_range'] ) ) {
+			$args['date_created'] = $criteria['date_range']['start'] . '...' . $criteria['date_range']['end'];
+		}
+
+		$meta_query = array( 'relation' => 'AND' );
+
+		if ( isset( $criteria['customer_email'] ) && '' !== $criteria['customer_email'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['country'] ) && '' !== $criteria['country'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['total_min'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_min'],
+				'compare' => '>=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( isset( $criteria['total_max'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_max'],
+				'compare' => '<=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( count( $meta_query ) > 1 ) {
+			$args['meta_query'] = $meta_query;
+		}
+
+		$order_ids = wc_get_orders( $args );
+		if ( ! is_array( $order_ids ) ) {
+			return array();
+		}
+
+		$order_ids = array_map( 'absint', $order_ids );
+		$order_ids = array_filter( $order_ids );
+		$order_ids = array_values( array_unique( $order_ids ) );
+
+		return $order_ids;
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function build_sample_orders( array $order_ids ) {
+		$sample = array();
+		$order_ids = array_slice( $order_ids, 0, 5 );
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( $order ) {
+				$sample[] = $this->format_order_summary( $order );
+			}
+		}
+
+		return $sample;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_order_summary( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'       => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'currency'       => method_exists( $order, 'get_currency' ) ? sanitize_text_field( $order->get_currency() ) : '',
+			'customer_name'  => sanitize_text_field( $this->get_customer_name( $order ) ),
+			'customer_email' => sanitize_email( $this->get_customer_email( $order ) ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'country'        => sanitize_text_field( $this->get_order_country( $order ) ),
+		);
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @param mixed $action Raw action.
+	 * @return string
+	 */
+	private function normalize_action( $action ) {
+		$action = is_string( $action ) ? strtolower( trim( $action ) ) : '';
+		$allowed = array( 'update_status', 'add_tag', 'add_note', 'export_csv' );
+
+		return in_array( $action, $allowed, true ) ? $action : '';
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param mixed  $params Raw params.
+	 * @return array
+	 */
+	private function normalize_params( $action, $params ) {
+		$params = is_array( $params ) ? $params : array();
+		$normalized = array();
+
+		switch ( $action ) {
+			case 'update_status':
+				$new_status = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+				if ( '' === $new_status ) {
+					return array( 'error' => 'Missing new status for bulk update.' );
+				}
+
+				$valid_statuses = $this->get_valid_statuses();
+				if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+					return array( 'error' => 'Invalid status for bulk update.' );
+				}
+
+				$normalized['new_status'] = $new_status;
+				$normalized['note'] = isset( $params['note'] ) ? sanitize_text_field( wp_unslash( $params['note'] ) ) : '';
+				$normalized['notify_customer'] = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+				break;
+			case 'add_tag':
+				$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+				$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+				$normalized['tags'] = $this->normalize_tags( $tags, $tag );
+				if ( empty( $normalized['tags'] ) ) {
+					return array( 'error' => 'Missing tags for bulk update.' );
+				}
+				break;
+			case 'add_note':
+				$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+				if ( '' === $note ) {
+					return array( 'error' => 'Missing note for bulk update.' );
+				}
+				$normalized['note'] = sanitize_text_field( wp_unslash( $note ) );
+				$normalized['is_customer_note'] = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+				break;
+			case 'export_csv':
+				$fields = isset( $params['fields'] ) ? $params['fields'] : array();
+				$normalized['fields'] = $this->normalize_fields( $fields );
+				break;
+			default:
+				return array( 'error' => 'Unsupported bulk action.' );
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param array  $params Params.
+	 * @return array
+	 */
+	private function build_action_preview( $action, array $params ) {
+		switch ( $action ) {
+			case 'update_status':
+				return array(
+					'new_status'      => isset( $params['new_status'] ) ? $params['new_status'] : '',
+					'notify_customer' => ! empty( $params['notify_customer'] ),
+					'note'            => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'add_tag':
+				return array(
+					'tags' => isset( $params['tags'] ) ? $params['tags'] : array(),
+				);
+			case 'add_note':
+				return array(
+					'note' => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'export_csv':
+				return array(
+					'fields' => isset( $params['fields'] ) ? $params['fields'] : $this->normalize_fields( array() ),
+				);
+			default:
+				return array();
+		}
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function find_missing_orders( array $order_ids ) {
+		$missing = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$missing[] = $order_id;
+			}
+		}
+
+		return $missing;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @param int    $processed Processed count.
+	 * @param int    $updated Updated count.
+	 * @param int    $failed Failed count.
+	 * @param array  $errors Error list.
+	 * @return void
+	 */
+	private function maybe_update_progress( $progress_id, $processed, $updated, $failed, array $errors ) {
+		if ( '' === $progress_id ) {
+			return;
+		}
+
+		$this->update_progress(
+			$progress_id,
+			array(
+				'processed' => $processed,
+				'updated'   => $updated,
+				'failed'    => $failed,
+				'errors'    => $errors,
+			),
+			false
+		);
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $updates Updates.
+	 * @param bool   $force Force update.
+	 * @return array
+	 */
+	private function update_progress( $progress_id, array $updates, $force ) {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			$progress = array(
+				'id'           => $progress_id,
+				'status'       => 'queued',
+				'processed'    => 0,
+				'updated'      => 0,
+				'failed'       => 0,
+				'errors'       => array(),
+				'created_at'   => gmdate( 'c' ),
+				'last_updated' => gmdate( 'c' ),
+			);
+		}
+
+		$last_updated = isset( $progress['last_updated'] ) ? strtotime( $progress['last_updated'] ) : 0;
+		$should_update = $force || ( time() - $last_updated >= self::POLL_INTERVAL );
+
+		foreach ( $updates as $key => $value ) {
+			$progress[ $key ] = $value;
+		}
+
+		if ( $should_update ) {
+			$progress['last_updated'] = gmdate( 'c' );
+			$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @return array|null
+	 */
+	private function load_progress( $progress_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$progress = get_transient( $this->build_progress_key( $progress_id ) );
+		if ( false === $progress || ! is_array( $progress ) ) {
+			return null;
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $progress Progress payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_progress( $progress_id, array $progress, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_progress_key( $progress_id ), $progress, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return array|null
+	 */
+	private function load_job( $job_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$job = get_transient( $this->build_job_key( $job_id ) );
+		if ( false === $job || ! is_array( $job ) ) {
+			return null;
+		}
+
+		return $job;
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @param array  $job Job payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_job( $job_id, array $job, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_job_key( $job_id ), $job, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return void
+	 */
+	private function delete_job( $job_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_job_key( $job_id ) );
+		}
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @return array|null
+	 */
+	private function load_rollback( $rollback_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$rollback = get_transient( $this->build_rollback_key( $rollback_id ) );
+		if ( false === $rollback || ! is_array( $rollback ) ) {
+			return null;
+		}
+
+		return $rollback;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @param array  $rollback Rollback data.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_rollback( $rollback_id, array $rollback, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_rollback_key( $rollback_id ), $rollback, $ttl );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_uuid() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'bulk_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_draft_' . $draft_id;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @return string
+	 */
+	private function build_progress_key( $progress_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_progress_' . $progress_id;
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return string
+	 */
+	private function build_job_key( $job_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_job_' . $job_id;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback identifier.
+	 * @return string
+	 */
+	private function build_rollback_key( $rollback_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_rollback_' . $rollback_id;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param mixed $status Raw status.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float|null
+	 */
+	private function normalize_amount( $amount ) {
+		if ( null === $amount || '' === $amount ) {
+			return null;
+		}
+
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $country Country input.
+	 * @return string
+	 */
+	private function normalize_country( $country ) {
+		$country = is_string( $country ) ? strtoupper( trim( $country ) ) : '';
+		if ( '' === $country ) {
+			return '';
+		}
+
+		if ( strlen( $country ) === 2 ) {
+			return $country;
+		}
+
+		$map = $this->get_country_map();
+		$key = strtolower( $country );
+
+		return isset( $map[ $key ] ) ? $map[ $key ] : '';
+	}
+
+	/**
+	 * @param mixed $tags Tags list.
+	 * @param mixed $tag Single tag.
+	 * @return array
+	 */
+	private function normalize_tags( $tags, $tag ) {
+		$list = array();
+
+		if ( is_string( $tags ) ) {
+			$tags = preg_split( '/[\s,]+/', $tags );
+		}
+
+		if ( is_array( $tags ) ) {
+			foreach ( $tags as $item ) {
+				$item = sanitize_text_field( (string) $item );
+				if ( '' !== $item ) {
+					$list[] = $item;
+				}
+			}
+		}
+
+		if ( is_string( $tag ) ) {
+			$tag = sanitize_text_field( $tag );
+			if ( '' !== $tag ) {
+				$list[] = $tag;
+			}
+		}
+
+		$list = array_values( array_unique( $list ) );
+
+		return $list;
+	}
+
+	/**
+	 * @param mixed $fields Fields input.
+	 * @return array
+	 */
+	private function normalize_fields( $fields ) {
+		$default = array( 'order_id', 'status', 'total', 'currency', 'customer_name', 'customer_email', 'date_created', 'billing_country', 'shipping_country' );
+		if ( empty( $fields ) ) {
+			return $default;
+		}
+
+		if ( is_string( $fields ) ) {
+			$fields = preg_split( '/[\s,]+/', $fields );
+		}
+
+		if ( ! is_array( $fields ) ) {
+			return $default;
+		}
+
+		$sanitized = array();
+		foreach ( $fields as $field ) {
+			$field = sanitize_key( $field );
+			if ( '' !== $field ) {
+				$sanitized[] = $field;
+			}
+		}
+
+		return array_values( array_unique( $sanitized ) );
+	}
+
+	/**
+	 * @param array $order Order object.
+	 * @param string $new_status New status.
+	 * @param string $note Note for audit.
+	 * @param bool $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $current_status === $new_status ) {
+			return false;
+		}
+
+		$note = trim( (string) $note );
+		$audit_note = sprintf( '[AgentWP] Bulk status update: %s -> %s.', $current_status, $new_status );
+		if ( '' !== $note ) {
+			$audit_note .= ' Note: ' . $note . '.';
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $audit_note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param array  $tags Tags to add.
+	 * @return bool
+	 */
+	private function apply_tags_update( $order, array $tags ) {
+		$order_id = method_exists( $order, 'get_id' ) ? $order->get_id() : 0;
+		if ( $order_id <= 0 ) {
+			return false;
+		}
+
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				$existing = array();
+			}
+			$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+			wp_set_object_terms( $order_id, $merged, $taxonomy, false );
+			return true;
+		}
+
+		if ( ! method_exists( $order, 'get_meta' ) || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			$existing = array();
+		}
+
+		$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+		$order->update_meta_data( '_agentwp_order_tags', $merged );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param string $note Note text.
+	 * @param bool   $is_customer_note Customer visibility.
+	 * @return int
+	 */
+	private function apply_order_note( $order, $note, $is_customer_note ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return 0;
+		}
+
+		$note = trim( (string) $note );
+		if ( '' === $note ) {
+			return 0;
+		}
+
+		$note_id = $order->add_order_note( $note, $is_customer_note );
+
+		return absint( $note_id );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_export_row( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'        => intval( $order->get_id() ),
+			'status'          => sanitize_text_field( $order->get_status() ),
+			'total'           => $order->get_total(),
+			'currency'        => method_exists( $order, 'get_currency' ) ? $order->get_currency() : '',
+			'customer_name'   => $this->get_customer_name( $order ),
+			'customer_email'  => $this->get_customer_email( $order ),
+			'date_created'    => $date_created ? $date_created->date( 'c' ) : '',
+			'billing_country' => method_exists( $order, 'get_billing_country' ) ? $order->get_billing_country() : '',
+			'shipping_country'=> method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '',
+		);
+	}
+
+	/**
+	 * @param array $rows Data rows.
+	 * @param array $fields Fields list.
+	 * @return array
+	 */
+	private function export_csv( array $rows, array $fields ) {
+		if ( ! function_exists( 'wp_upload_dir' ) ) {
+			return array( 'error' => 'Unable to export CSV in this environment.' );
+		}
+
+		$fields = $this->normalize_fields( $fields );
+		$upload = wp_upload_dir();
+		$base   = isset( $upload['basedir'] ) ? $upload['basedir'] : '';
+		$url    = isset( $upload['baseurl'] ) ? $upload['baseurl'] : '';
+
+		if ( '' === $base || '' === $url ) {
+			return array( 'error' => 'Unable to resolve upload directory.' );
+		}
+
+		$dir = trailingslashit( $base ) . 'agentwp-exports';
+		if ( function_exists( 'wp_mkdir_p' ) ) {
+			wp_mkdir_p( $dir );
+		}
+
+		$filename = 'agentwp-bulk-export-' . gmdate( 'Ymd-His' ) . '-' . wp_generate_password( 6, false ) . '.csv';
+		$path     = trailingslashit( $dir ) . $filename;
+		$file     = @fopen( $path, 'w' );
+		if ( ! $file ) {
+			return array( 'error' => 'Unable to create CSV export file.' );
+		}
+
+		fputcsv( $file, $fields );
+		foreach ( $rows as $row ) {
+			$line = array();
+			foreach ( $fields as $field ) {
+				$line[] = isset( $row[ $field ] ) ? $row[ $field ] : '';
+			}
+			fputcsv( $file, $line );
+		}
+
+		fclose( $file );
+
+		return array(
+			'file_path' => $path,
+			'file_url'  => trailingslashit( $url ) . 'agentwp-exports/' . $filename,
+			'rows'      => count( $rows ),
+		);
+	}
+
+	/**
+	 * @param int $order_id Order ID.
+	 * @return array
+	 */
+	private function get_order_tags( $order_id ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				return array();
+			}
+			return $existing;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'get_meta' ) ) {
+			return array();
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			return array();
+		}
+
+		return $existing;
+	}
+
+	/**
+	 * @param int   $order_id Order ID.
+	 * @param array $tags Tags.
+	 * @return bool
+	 */
+	private function restore_order_tags( $order_id, $tags ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			wp_set_object_terms( $order_id, (array) $tags, $taxonomy, false );
+			return true;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$order->update_meta_data( '_agentwp_order_tags', (array) $tags );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param array $note_ids Note IDs.
+	 * @return bool
+	 */
+	private function delete_order_notes( array $note_ids ) {
+		if ( ! function_exists( 'wp_delete_comment' ) ) {
+			return false;
+		}
+
+		$deleted_any = false;
+		foreach ( $note_ids as $note_id ) {
+			$note_id = absint( $note_id );
+			if ( $note_id > 0 ) {
+				wp_delete_comment( $note_id, true );
+				$deleted_any = true;
+			}
+		}
+
+		return $deleted_any;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function get_order_tag_taxonomy() {
+		$taxonomy = apply_filters( 'agentwp_order_tag_taxonomy', 'shop_order_tag' );
+		$taxonomy = is_string( $taxonomy ) ? trim( $taxonomy ) : '';
+
+		if ( '' !== $taxonomy && function_exists( 'taxonomy_exists' ) && taxonomy_exists( $taxonomy ) ) {
+			return $taxonomy;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param array|null $date_range Date range input.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query text.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date.
+	 * @param string $end End date.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Date string.
+	 * @param bool   $end_of_day End of day flag.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		$date = $end_of_day ? $date->setTime( 23, 59, 59 ) : $date->setTime( 0, 0, 0 );
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function extract_total_range( $query ) {
+		$result = array();
+
+		if ( preg_match( '/\bbetween\s+[\$£\x{20AC}]?([0-9\.,]+)\s+(?:and|to)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+			return $result;
+		}
+
+		if ( preg_match( '/\b(over|above|more than|greater than|at least|minimum|min)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b(under|below|less than|at most|maximum|max)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b>=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		if ( preg_match( '/\b<=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param string $value Amount string.
+	 * @return float|null
+	 */
+	private function parse_amount_string( $value ) {
+		$value = str_replace( array( ',', ' ' ), '', (string) $value );
+		return $this->normalize_amount( $value );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_country( $query ) {
+		$query_lower = strtolower( $query );
+		$map         = $this->get_country_map();
+
+		foreach ( $map as $name => $code ) {
+			$pattern = '/\b' . preg_quote( $name, '/' ) . '\b/i';
+			if ( preg_match( $pattern, $query_lower ) ) {
+				return $code;
+			}
+		}
+
+		if ( preg_match_all( '/\b([A-Z]{2})\b/', strtoupper( $query ), $matches ) ) {
+			foreach ( $matches[1] as $code ) {
+				if ( isset( $map[ strtolower( $code ) ] ) ) {
+					return $map[ strtolower( $code ) ];
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_country_map() {
+		static $map = null;
+		if ( null !== $map ) {
+			return $map;
+		}
+
+		$countries = array();
+		if ( function_exists( 'WC' ) ) {
+			$wc = WC();
+			if ( $wc && isset( $wc->countries ) && method_exists( $wc->countries, 'get_countries' ) ) {
+				$countries = $wc->countries->get_countries();
+			}
+		}
+
+		if ( empty( $countries ) && class_exists( 'WC_Countries' ) ) {
+			$wc_countries = new \WC_Countries();
+			$countries    = $wc_countries->get_countries();
+		}
+
+		$map = array();
+		if ( is_array( $countries ) ) {
+			foreach ( $countries as $code => $name ) {
+				$map[ strtolower( $name ) ] = strtoupper( $code );
+				$map[ strtolower( $code ) ] = strtoupper( $code );
+			}
+		}
+
+		$map['usa'] = 'US';
+		$map['us']  = 'US';
+		$map['uk']  = 'GB';
+
+		return $map;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_order_country( $order ) {
+		$country = method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '';
+		if ( '' !== $country ) {
+			return $country;
+		}
+
+		if ( method_exists( $order, 'get_billing_country' ) ) {
+			$country = $order->get_billing_country();
+		}
+
+		return is_string( $country ) ? $country : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_draft_id( array $args ) {
+		$draft_id = isset( $args['draft_id'] ) ? $args['draft_id'] : '';
+		if ( '' === $draft_id && isset( $args['params']['draft_id'] ) ) {
+			$draft_id = $args['params']['draft_id'];
+		}
+
+		return is_string( $draft_id ) ? trim( $draft_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_progress_id( array $args ) {
+		$progress_id = isset( $args['progress_id'] ) ? $args['progress_id'] : '';
+		if ( '' === $progress_id && isset( $args['params']['progress_id'] ) ) {
+			$progress_id = $args['params']['progress_id'];
+		}
+
+		return is_string( $progress_id ) ? trim( $progress_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_rollback_id( array $args ) {
+		$rollback_id = isset( $args['rollback_id'] ) ? $args['rollback_id'] : '';
+		if ( '' === $rollback_id && isset( $args['params']['rollback_id'] ) ) {
+			$rollback_id = $args['params']['rollback_id'];
+		}
+
+		return is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+	}
+
+	/**
+	 * @return bool
+	 */
+	private function action_scheduler_available() {
+		return function_exists( 'as_enqueue_async_action' ) || function_exists( 'as_schedule_single_action' );
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return int
+	 */
+	private function schedule_job( $job_id ) {
+		if ( function_exists( 'as_enqueue_async_action' ) ) {
+			return (int) as_enqueue_async_action( self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		if ( function_exists( 'as_schedule_single_action' ) ) {
+			return (int) as_schedule_single_action( time(), self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		return 0;
+	}
+}


thinking
**Checking for syntax errors**
exec
/bin/zsh -lc 'php -l src/Handlers/BulkHandler.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 94ms:
No syntax errors detected in src/Handlers/BulkHandler.php
file update:
diff --git a/src/Handlers/BulkHandler.php b/src/Handlers/BulkHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..d7994bcd117201a3df0db869c3d04e51a692d784
--- /dev/null
+++ b/src/Handlers/BulkHandler.php
@@ -0,0 +1,2223 @@
+<?php
+/**
+ * Handle bulk order operations.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class BulkHandler {
+	const ACTION_HOOK      = 'agentwp_bulk_process';
+	const ASYNC_THRESHOLD  = 20;
+	const DRAFT_TYPE       = 'bulk_action';
+	const JOB_TTL_SECONDS  = 86400;
+	const MAX_BULK         = 1000;
+	const PROGRESS_TTL     = 86400;
+	const ROLLBACK_TTL     = 86400;
+	const POLL_INTERVAL    = 2;
+
+	/**
+	 * Register background processing hooks.
+	 *
+	 * @return void
+	 */
+	public static function register_hooks() {
+		add_action( self::ACTION_HOOK, array( __CLASS__, 'handle_scheduled_action' ), 10, 1 );
+	}
+
+	/**
+	 * Execute scheduled bulk jobs.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	public static function handle_scheduled_action( $job_id ) {
+		$handler = new self();
+		$handler->process_scheduled_job( $job_id );
+	}
+
+	/**
+	 * Handle bulk actions and selections.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['criteria'] ) ) {
+			return $this->select_orders( $args );
+		}
+
+		$progress_id = $this->extract_progress_id( $args );
+		if ( '' !== $progress_id ) {
+			return $this->get_progress_response( $progress_id );
+		}
+
+		$rollback_id = $this->extract_rollback_id( $args );
+		if ( '' !== $rollback_id ) {
+			return $this->rollback_bulk_action( $rollback_id );
+		}
+
+		$draft_id = $this->extract_draft_id( $args );
+		if ( '' !== $draft_id ) {
+			return $this->confirm_bulk_update( $draft_id );
+		}
+
+		return $this->prepare_bulk_update( $args );
+	}
+
+	/**
+	 * Select orders based on criteria.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function select_orders( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to select orders.', 400 );
+		}
+
+		$criteria  = $this->normalize_criteria( isset( $args['criteria'] ) ? $args['criteria'] : array() );
+		$order_ids = $this->query_order_ids( $criteria );
+		$sample    = $this->build_sample_orders( $order_ids );
+
+		return Response::success(
+			array(
+				'order_ids'  => $order_ids,
+				'count'      => count( $order_ids ),
+				'criteria'   => $criteria,
+				'sample'     => $sample,
+				'truncated'  => count( $order_ids ) >= self::MAX_BULK,
+				'max_limit'  => self::MAX_BULK,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a bulk update draft.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	private function prepare_bulk_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $args['action'] ) ? $args['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Missing or invalid bulk action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $args['params'] ) ? $args['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$missing_orders = $this->find_missing_orders( $order_ids );
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		$sample = $this->build_sample_orders( $order_ids );
+		$preview = array(
+			'order_count'    => count( $order_ids ),
+			'sample'         => $sample,
+			'action'         => $action,
+			'action_preview' => $this->build_action_preview( $action, $params ),
+		);
+
+		$draft_payload = array(
+			'order_ids' => $order_ids,
+			'action'    => $action,
+			'params'    => $params,
+			'preview'   => $preview,
+		);
+
+		$draft_id   = $this->generate_uuid();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a bulk update draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	private function confirm_bulk_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to process bulk updates.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing bulk update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Bulk update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for bulk update confirmation.', 400 );
+		}
+
+		$payload  = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $payload['action'] ) ? $payload['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Bulk update draft is missing an action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $payload['params'] ) ? $payload['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$job_id      = $this->generate_uuid();
+		$progress_id = $this->generate_uuid();
+		$rollback_id = $this->generate_uuid();
+
+		$rollback_expires = gmdate( 'c', time() + self::ROLLBACK_TTL );
+		$this->store_rollback(
+			$rollback_id,
+			array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => $rollback_expires,
+				'orders'     => array(),
+			),
+			self::ROLLBACK_TTL
+		);
+
+		$progress = array(
+			'id'                  => $progress_id,
+			'status'              => 'queued',
+			'action'              => $action,
+			'order_count'         => count( $order_ids ),
+			'processed'           => 0,
+			'updated'             => 0,
+			'failed'              => 0,
+			'errors'              => array(),
+			'created_at'          => gmdate( 'c' ),
+			'started_at'          => '',
+			'last_updated'        => gmdate( 'c' ),
+			'completed_at'        => '',
+			'draft_id'            => $draft_id,
+			'rollback_id'         => $rollback_id,
+			'undo_available_until'=> $rollback_expires,
+		);
+		$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+
+		$job = array(
+			'id'          => $job_id,
+			'order_ids'   => $order_ids,
+			'action'      => $action,
+			'params'      => $params,
+			'progress_id' => $progress_id,
+			'rollback_id' => $rollback_id,
+			'draft_id'    => $draft_id,
+		);
+		$this->store_job( $job_id, $job, self::JOB_TTL_SECONDS );
+
+		$async = count( $order_ids ) > self::ASYNC_THRESHOLD && $this->action_scheduler_available();
+		if ( $async ) {
+			$action_id = $this->schedule_job( $job_id );
+			if ( ! $action_id ) {
+				return Response::error( 'Unable to schedule bulk update.', 500 );
+			}
+
+			$this->delete_draft( $draft_id );
+
+			return Response::success(
+				array(
+					'status'     => 'scheduled',
+					'draft_id'   => $draft_id,
+					'job_id'     => $job_id,
+					'progress'   => $progress,
+					'polling'    => array(
+						'progress_id'      => $progress_id,
+						'interval_seconds' => self::POLL_INTERVAL,
+					),
+					'rollback_id' => $rollback_id,
+					'undo_available_until' => $rollback_expires,
+				)
+			);
+		}
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'     => 'running',
+				'started_at' => gmdate( 'c' ),
+			),
+			true
+		);
+
+		$result = $this->run_bulk_job( $job );
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'       => 'completed',
+				'completed_at' => gmdate( 'c' ),
+				'result'       => $result,
+			),
+			true
+		);
+
+		$this->delete_job( $job_id );
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'status'      => 'completed',
+				'draft_id'    => $draft_id,
+				'result'      => $result,
+				'progress'    => $progress,
+				'polling'     => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+				'rollback_id' => $rollback_id,
+				'undo_available_until' => $rollback_expires,
+			)
+		);
+	}
+
+	/**
+	 * Process a scheduled bulk job.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	private function process_scheduled_job( $job_id ) {
+		$job_id = is_string( $job_id ) ? trim( $job_id ) : '';
+		if ( '' === $job_id ) {
+			return;
+		}
+
+		$job = $this->load_job( $job_id );
+		if ( ! is_array( $job ) ) {
+			return;
+		}
+
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'     => 'running',
+					'started_at' => gmdate( 'c' ),
+				),
+				true
+			);
+		}
+
+		$result = $this->run_bulk_job( $job );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'       => 'completed',
+					'completed_at' => gmdate( 'c' ),
+					'result'       => $result,
+				),
+				true
+			);
+		}
+
+		$draft_id = isset( $job['draft_id'] ) ? (string) $job['draft_id'] : '';
+		if ( '' !== $draft_id ) {
+			$this->delete_draft( $draft_id );
+		}
+
+		$this->delete_job( $job_id );
+	}
+
+	/**
+	 * Execute a bulk job.
+	 *
+	 * @param array $job Job payload.
+	 * @return array
+	 */
+	private function run_bulk_job( array $job ) {
+		$order_ids   = isset( $job['order_ids'] ) ? $this->normalize_order_ids( $job['order_ids'] ) : array();
+		$action      = isset( $job['action'] ) ? $this->normalize_action( $job['action'] ) : '';
+		$params      = isset( $job['params'] ) && is_array( $job['params'] ) ? $job['params'] : array();
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		$rollback_id = isset( $job['rollback_id'] ) ? (string) $job['rollback_id'] : '';
+
+		$result = array(
+			'action'    => $action,
+			'order_ids' => $order_ids,
+			'updated'   => array(),
+			'failed'    => array(),
+			'errors'    => array(),
+		);
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			$rollback = array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => gmdate( 'c', time() + self::ROLLBACK_TTL ),
+				'orders'     => array(),
+			);
+		}
+
+		$processed = 0;
+		$updated   = 0;
+		$failed    = 0;
+		$errors    = array();
+		$rows      = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$processed++;
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed++;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found.',
+				);
+				$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$current_status = $this->normalize_status( $order->get_status() );
+					$new_status     = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+					if ( '' === $new_status ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing target status.',
+						);
+						break;
+					}
+
+					$rollback['orders'][ $order_id ] = array(
+						'status' => $current_status,
+					);
+
+					$note            = isset( $params['note'] ) ? (string) $params['note'] : '';
+					$notify_customer = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+					$updated_flag    = $this->apply_status_update( $order, $new_status, $note, $notify_customer );
+
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to update status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+					$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+					$tags = $this->normalize_tags( $tags, $tag );
+					if ( empty( $tags ) ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing tags to add.',
+						);
+						break;
+					}
+
+					$before_tags = $this->get_order_tags( $order_id );
+					$rollback['orders'][ $order_id ] = array(
+						'tags' => $before_tags,
+					);
+
+					$updated_flag = $this->apply_tags_update( $order, $tags );
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+					if ( '' === $note ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing note content.',
+						);
+						break;
+					}
+
+					$is_customer_note = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+					$note_id          = $this->apply_order_note( $order, $note, $is_customer_note );
+					if ( $note_id > 0 ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+						$rollback['orders'][ $order_id ] = array(
+							'notes' => array( $note_id ),
+						);
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add note.',
+						);
+					}
+					break;
+				case 'export_csv':
+					$rows[] = $this->format_export_row( $order );
+					$updated++;
+					$result['updated'][] = $order_id;
+					break;
+				default:
+					$failed++;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Unsupported bulk action.',
+					);
+			}
+
+			$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+		}
+
+		$result['errors'] = $errors;
+		$result['failed'] = array_unique( array_merge( $result['failed'], wp_list_pluck( $errors, 'order_id' ) ) );
+
+		if ( 'export_csv' === $action ) {
+			$export = $this->export_csv( $rows, isset( $params['fields'] ) ? $params['fields'] : array() );
+			if ( isset( $export['error'] ) ) {
+				$errors[]         = array( 'order_id' => 0, 'message' => $export['error'] );
+				$result['errors'] = $errors;
+			} else {
+				$result['export'] = $export;
+			}
+		}
+
+		$this->store_rollback( $rollback_id, $rollback, self::ROLLBACK_TTL );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'processed' => $processed,
+					'updated'   => $updated,
+					'failed'    => $failed,
+					'errors'    => $errors,
+				),
+				true
+			);
+		}
+
+		return $result;
+	}
+
+	/**
+	 * Provide progress updates to polling clients.
+	 *
+	 * @param string $progress_id Progress identifier.
+	 * @return Response
+	 */
+	private function get_progress_response( $progress_id ): Response {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			return Response::error( 'Bulk progress not found or expired.', 404 );
+		}
+
+		return Response::success(
+			array(
+				'progress' => $progress,
+				'polling'  => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Roll back a bulk action.
+	 *
+	 * @param string $rollback_id Rollback identifier.
+	 * @return Response
+	 */
+	private function rollback_bulk_action( $rollback_id ): Response {
+		$rollback_id = is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+		if ( '' === $rollback_id ) {
+			return Response::error( 'Missing rollback ID.', 400 );
+		}
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			return Response::error( 'Rollback data not found or expired.', 404 );
+		}
+
+		$action  = isset( $rollback['action'] ) ? $this->normalize_action( $rollback['action'] ) : '';
+		$orders  = isset( $rollback['orders'] ) && is_array( $rollback['orders'] ) ? $rollback['orders'] : array();
+		$undone  = array();
+		$failed  = array();
+		$errors  = array();
+
+		foreach ( $orders as $order_id => $data ) {
+			$order_id = absint( $order_id );
+			$order    = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed[] = $order_id;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found for rollback.',
+				);
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$previous_status = isset( $data['status'] ) ? $this->normalize_status( $data['status'] ) : '';
+					if ( '' === $previous_status ) {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing previous status.',
+						);
+						break;
+					}
+
+					$updated = $this->apply_status_update( $order, $previous_status, 'Rollback to previous status.', false );
+					if ( $updated ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore previous status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $data['tags'] ) ? $data['tags'] : array();
+					$restored = $this->restore_order_tags( $order_id, $tags );
+					if ( $restored ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$notes = isset( $data['notes'] ) ? (array) $data['notes'] : array();
+					$deleted = $this->delete_order_notes( $notes );
+					if ( $deleted ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to remove notes.',
+						);
+					}
+					break;
+				default:
+					$failed[] = $order_id;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Rollback not supported for this action.',
+					);
+			}
+		}
+
+		return Response::success(
+			array(
+				'rollback_id' => $rollback_id,
+				'action'      => $action,
+				'undone'      => $undone,
+				'failed'      => $failed,
+				'errors'      => $errors,
+			)
+		);
+	}
+
+	/**
+	 * @param array $criteria Criteria input.
+	 * @return array
+	 */
+	private function normalize_criteria( $criteria ) {
+		$parsed = array(
+			'status'         => '',
+			'date_range'     => null,
+			'customer_email' => '',
+			'total_min'      => null,
+			'total_max'      => null,
+			'country'        => '',
+		);
+		$query  = '';
+
+		if ( is_string( $criteria ) ) {
+			$query = sanitize_text_field( $criteria );
+		} elseif ( is_array( $criteria ) ) {
+			$query = isset( $criteria['query'] ) ? sanitize_text_field( $criteria['query'] ) : '';
+			$parsed['status'] = isset( $criteria['status'] ) ? $this->normalize_status( $criteria['status'] ) : '';
+			$parsed['date_range'] = $this->normalize_date_range_input( isset( $criteria['date_range'] ) ? $criteria['date_range'] : null );
+			$parsed['customer_email'] = isset( $criteria['customer_email'] ) ? sanitize_email( $criteria['customer_email'] ) : '';
+			$parsed['total_min'] = isset( $criteria['total_min'] ) ? $this->normalize_amount( $criteria['total_min'] ) : null;
+			$parsed['total_max'] = isset( $criteria['total_max'] ) ? $this->normalize_amount( $criteria['total_max'] ) : null;
+			$parsed['country'] = isset( $criteria['country'] ) ? $this->normalize_country( $criteria['country'] ) : '';
+		}
+
+		if ( '' !== $query ) {
+			$text_parsed = $this->parse_criteria_text( $query );
+			foreach ( $text_parsed as $key => $value ) {
+				if ( ! isset( $parsed[ $key ] ) || '' === $parsed[ $key ] || null === $parsed[ $key ] ) {
+					$parsed[ $key ] = $value;
+				}
+			}
+		}
+
+		if ( '' === $parsed['status'] ) {
+			unset( $parsed['status'] );
+		}
+		if ( '' === $parsed['customer_email'] ) {
+			unset( $parsed['customer_email'] );
+		}
+		if ( '' === $parsed['country'] ) {
+			unset( $parsed['country'] );
+		}
+		if ( null === $parsed['total_min'] ) {
+			unset( $parsed['total_min'] );
+		}
+		if ( null === $parsed['total_max'] ) {
+			unset( $parsed['total_max'] );
+		}
+		if ( null === $parsed['date_range'] ) {
+			unset( $parsed['date_range'] );
+		}
+
+		return $parsed;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function parse_criteria_text( $query ) {
+		$query  = trim( (string) $query );
+		$lower  = strtolower( $query );
+		$result = array();
+
+		$status = $this->detect_status( $lower );
+		if ( '' !== $status ) {
+			$result['status'] = $status;
+		}
+
+		$date_range = $this->parse_date_range_from_query( $lower );
+		if ( null !== $date_range ) {
+			$result['date_range'] = $date_range;
+		}
+
+		$email = $this->extract_email( $query );
+		if ( '' !== $email ) {
+			$result['customer_email'] = $email;
+		}
+
+		$totals = $this->extract_total_range( $lower );
+		if ( isset( $totals['min'] ) ) {
+			$result['total_min'] = $totals['min'];
+		}
+		if ( isset( $totals['max'] ) ) {
+			$result['total_max'] = $totals['max'];
+		}
+
+		$country = $this->extract_country( $query );
+		if ( '' !== $country ) {
+			$result['country'] = $country;
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param array $criteria Query criteria.
+	 * @return array
+	 */
+	private function query_order_ids( array $criteria ) {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		$args = array(
+			'limit'   => self::MAX_BULK,
+			'return'  => 'ids',
+			'orderby' => 'date',
+			'order'   => 'DESC',
+		);
+
+		if ( isset( $criteria['status'] ) && '' !== $criteria['status'] ) {
+			$args['status'] = $criteria['status'];
+		}
+
+		if ( isset( $criteria['date_range'] ) && is_array( $criteria['date_range'] ) ) {
+			$args['date_created'] = $criteria['date_range']['start'] . '...' . $criteria['date_range']['end'];
+		}
+
+		$meta_query = array( 'relation' => 'AND' );
+
+		if ( isset( $criteria['customer_email'] ) && '' !== $criteria['customer_email'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['country'] ) && '' !== $criteria['country'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['total_min'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_min'],
+				'compare' => '>=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( isset( $criteria['total_max'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_max'],
+				'compare' => '<=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( count( $meta_query ) > 1 ) {
+			$args['meta_query'] = $meta_query;
+		}
+
+		$order_ids = wc_get_orders( $args );
+		if ( ! is_array( $order_ids ) ) {
+			return array();
+		}
+
+		$order_ids = array_map( 'absint', $order_ids );
+		$order_ids = array_filter( $order_ids );
+		$order_ids = array_values( array_unique( $order_ids ) );
+
+		return $order_ids;
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function build_sample_orders( array $order_ids ) {
+		$sample = array();
+		$order_ids = array_slice( $order_ids, 0, 5 );
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( $order ) {
+				$sample[] = $this->format_order_summary( $order );
+			}
+		}
+
+		return $sample;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_order_summary( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'       => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'currency'       => method_exists( $order, 'get_currency' ) ? sanitize_text_field( $order->get_currency() ) : '',
+			'customer_name'  => sanitize_text_field( $this->get_customer_name( $order ) ),
+			'customer_email' => sanitize_email( $this->get_customer_email( $order ) ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'country'        => sanitize_text_field( $this->get_order_country( $order ) ),
+		);
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @param mixed $action Raw action.
+	 * @return string
+	 */
+	private function normalize_action( $action ) {
+		$action = is_string( $action ) ? strtolower( trim( $action ) ) : '';
+		$allowed = array( 'update_status', 'add_tag', 'add_note', 'export_csv' );
+
+		return in_array( $action, $allowed, true ) ? $action : '';
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param mixed  $params Raw params.
+	 * @return array
+	 */
+	private function normalize_params( $action, $params ) {
+		$params = is_array( $params ) ? $params : array();
+		$normalized = array();
+
+		switch ( $action ) {
+			case 'update_status':
+				$new_status = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+				if ( '' === $new_status ) {
+					return array( 'error' => 'Missing new status for bulk update.' );
+				}
+
+				$valid_statuses = $this->get_valid_statuses();
+				if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+					return array( 'error' => 'Invalid status for bulk update.' );
+				}
+
+				$normalized['new_status'] = $new_status;
+				$normalized['note'] = isset( $params['note'] ) ? sanitize_text_field( wp_unslash( $params['note'] ) ) : '';
+				$normalized['notify_customer'] = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+				break;
+			case 'add_tag':
+				$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+				$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+				$normalized['tags'] = $this->normalize_tags( $tags, $tag );
+				if ( empty( $normalized['tags'] ) ) {
+					return array( 'error' => 'Missing tags for bulk update.' );
+				}
+				break;
+			case 'add_note':
+				$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+				if ( '' === $note ) {
+					return array( 'error' => 'Missing note for bulk update.' );
+				}
+				$normalized['note'] = sanitize_text_field( wp_unslash( $note ) );
+				$normalized['is_customer_note'] = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+				break;
+			case 'export_csv':
+				$fields = isset( $params['fields'] ) ? $params['fields'] : array();
+				$normalized['fields'] = $this->normalize_fields( $fields );
+				break;
+			default:
+				return array( 'error' => 'Unsupported bulk action.' );
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param array  $params Params.
+	 * @return array
+	 */
+	private function build_action_preview( $action, array $params ) {
+		switch ( $action ) {
+			case 'update_status':
+				return array(
+					'new_status'      => isset( $params['new_status'] ) ? $params['new_status'] : '',
+					'notify_customer' => ! empty( $params['notify_customer'] ),
+					'note'            => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'add_tag':
+				return array(
+					'tags' => isset( $params['tags'] ) ? $params['tags'] : array(),
+				);
+			case 'add_note':
+				return array(
+					'note' => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'export_csv':
+				return array(
+					'fields' => isset( $params['fields'] ) ? $params['fields'] : $this->normalize_fields( array() ),
+				);
+			default:
+				return array();
+		}
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function find_missing_orders( array $order_ids ) {
+		$missing = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$missing[] = $order_id;
+			}
+		}
+
+		return $missing;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @param int    $processed Processed count.
+	 * @param int    $updated Updated count.
+	 * @param int    $failed Failed count.
+	 * @param array  $errors Error list.
+	 * @return void
+	 */
+	private function maybe_update_progress( $progress_id, $processed, $updated, $failed, array $errors ) {
+		if ( '' === $progress_id ) {
+			return;
+		}
+
+		$this->update_progress(
+			$progress_id,
+			array(
+				'processed' => $processed,
+				'updated'   => $updated,
+				'failed'    => $failed,
+				'errors'    => $errors,
+			),
+			false
+		);
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $updates Updates.
+	 * @param bool   $force Force update.
+	 * @return array
+	 */
+	private function update_progress( $progress_id, array $updates, $force ) {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			$progress = array(
+				'id'           => $progress_id,
+				'status'       => 'queued',
+				'processed'    => 0,
+				'updated'      => 0,
+				'failed'       => 0,
+				'errors'       => array(),
+				'created_at'   => gmdate( 'c' ),
+				'last_updated' => gmdate( 'c' ),
+			);
+		}
+
+		$last_updated = isset( $progress['last_updated'] ) ? strtotime( $progress['last_updated'] ) : 0;
+		$should_update = $force || ( time() - $last_updated >= self::POLL_INTERVAL );
+
+		foreach ( $updates as $key => $value ) {
+			$progress[ $key ] = $value;
+		}
+
+		if ( $should_update ) {
+			$progress['last_updated'] = gmdate( 'c' );
+			$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @return array|null
+	 */
+	private function load_progress( $progress_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$progress = get_transient( $this->build_progress_key( $progress_id ) );
+		if ( false === $progress || ! is_array( $progress ) ) {
+			return null;
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $progress Progress payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_progress( $progress_id, array $progress, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_progress_key( $progress_id ), $progress, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return array|null
+	 */
+	private function load_job( $job_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$job = get_transient( $this->build_job_key( $job_id ) );
+		if ( false === $job || ! is_array( $job ) ) {
+			return null;
+		}
+
+		return $job;
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @param array  $job Job payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_job( $job_id, array $job, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_job_key( $job_id ), $job, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return void
+	 */
+	private function delete_job( $job_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_job_key( $job_id ) );
+		}
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @return array|null
+	 */
+	private function load_rollback( $rollback_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$rollback = get_transient( $this->build_rollback_key( $rollback_id ) );
+		if ( false === $rollback || ! is_array( $rollback ) ) {
+			return null;
+		}
+
+		return $rollback;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @param array  $rollback Rollback data.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_rollback( $rollback_id, array $rollback, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_rollback_key( $rollback_id ), $rollback, $ttl );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_uuid() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'bulk_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_draft_' . $draft_id;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @return string
+	 */
+	private function build_progress_key( $progress_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_progress_' . $progress_id;
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return string
+	 */
+	private function build_job_key( $job_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_job_' . $job_id;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback identifier.
+	 * @return string
+	 */
+	private function build_rollback_key( $rollback_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_rollback_' . $rollback_id;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param mixed $status Raw status.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float|null
+	 */
+	private function normalize_amount( $amount ) {
+		if ( null === $amount || '' === $amount ) {
+			return null;
+		}
+
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $country Country input.
+	 * @return string
+	 */
+	private function normalize_country( $country ) {
+		$country = is_string( $country ) ? strtoupper( trim( $country ) ) : '';
+		if ( '' === $country ) {
+			return '';
+		}
+
+		if ( strlen( $country ) === 2 ) {
+			return $country;
+		}
+
+		$map = $this->get_country_map();
+		$key = strtolower( $country );
+
+		return isset( $map[ $key ] ) ? $map[ $key ] : '';
+	}
+
+	/**
+	 * @param mixed $tags Tags list.
+	 * @param mixed $tag Single tag.
+	 * @return array
+	 */
+	private function normalize_tags( $tags, $tag ) {
+		$list = array();
+
+		if ( is_string( $tags ) ) {
+			$tags = preg_split( '/[\s,]+/', $tags );
+		}
+
+		if ( is_array( $tags ) ) {
+			foreach ( $tags as $item ) {
+				$item = sanitize_text_field( (string) $item );
+				if ( '' !== $item ) {
+					$list[] = $item;
+				}
+			}
+		}
+
+		if ( is_string( $tag ) ) {
+			$tag = sanitize_text_field( $tag );
+			if ( '' !== $tag ) {
+				$list[] = $tag;
+			}
+		}
+
+		$list = array_values( array_unique( $list ) );
+
+		return $list;
+	}
+
+	/**
+	 * @param mixed $fields Fields input.
+	 * @return array
+	 */
+	private function normalize_fields( $fields ) {
+		$default = array( 'order_id', 'status', 'total', 'currency', 'customer_name', 'customer_email', 'date_created', 'billing_country', 'shipping_country' );
+		if ( empty( $fields ) ) {
+			return $default;
+		}
+
+		if ( is_string( $fields ) ) {
+			$fields = preg_split( '/[\s,]+/', $fields );
+		}
+
+		if ( ! is_array( $fields ) ) {
+			return $default;
+		}
+
+		$sanitized = array();
+		foreach ( $fields as $field ) {
+			$field = sanitize_key( $field );
+			if ( '' !== $field ) {
+				$sanitized[] = $field;
+			}
+		}
+
+		return array_values( array_unique( $sanitized ) );
+	}
+
+	/**
+	 * @param array $order Order object.
+	 * @param string $new_status New status.
+	 * @param string $note Note for audit.
+	 * @param bool $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $current_status === $new_status ) {
+			return false;
+		}
+
+		$note = trim( (string) $note );
+		$audit_note = sprintf( '[AgentWP] Bulk status update: %s -> %s.', $current_status, $new_status );
+		if ( '' !== $note ) {
+			$audit_note .= ' Note: ' . $note . '.';
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $audit_note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param array  $tags Tags to add.
+	 * @return bool
+	 */
+	private function apply_tags_update( $order, array $tags ) {
+		$order_id = method_exists( $order, 'get_id' ) ? $order->get_id() : 0;
+		if ( $order_id <= 0 ) {
+			return false;
+		}
+
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				$existing = array();
+			}
+			$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+			wp_set_object_terms( $order_id, $merged, $taxonomy, false );
+			return true;
+		}
+
+		if ( ! method_exists( $order, 'get_meta' ) || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			$existing = array();
+		}
+
+		$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+		$order->update_meta_data( '_agentwp_order_tags', $merged );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param string $note Note text.
+	 * @param bool   $is_customer_note Customer visibility.
+	 * @return int
+	 */
+	private function apply_order_note( $order, $note, $is_customer_note ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return 0;
+		}
+
+		$note = trim( (string) $note );
+		if ( '' === $note ) {
+			return 0;
+		}
+
+		$note_id = $order->add_order_note( $note, $is_customer_note );
+
+		return absint( $note_id );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_export_row( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'        => intval( $order->get_id() ),
+			'status'          => sanitize_text_field( $order->get_status() ),
+			'total'           => $order->get_total(),
+			'currency'        => method_exists( $order, 'get_currency' ) ? $order->get_currency() : '',
+			'customer_name'   => $this->get_customer_name( $order ),
+			'customer_email'  => $this->get_customer_email( $order ),
+			'date_created'    => $date_created ? $date_created->date( 'c' ) : '',
+			'billing_country' => method_exists( $order, 'get_billing_country' ) ? $order->get_billing_country() : '',
+			'shipping_country'=> method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '',
+		);
+	}
+
+	/**
+	 * @param array $rows Data rows.
+	 * @param array $fields Fields list.
+	 * @return array
+	 */
+	private function export_csv( array $rows, array $fields ) {
+		if ( ! function_exists( 'wp_upload_dir' ) ) {
+			return array( 'error' => 'Unable to export CSV in this environment.' );
+		}
+
+		$fields = $this->normalize_fields( $fields );
+		$upload = wp_upload_dir();
+		$base   = isset( $upload['basedir'] ) ? $upload['basedir'] : '';
+		$url    = isset( $upload['baseurl'] ) ? $upload['baseurl'] : '';
+
+		if ( '' === $base || '' === $url ) {
+			return array( 'error' => 'Unable to resolve upload directory.' );
+		}
+
+		$dir = trailingslashit( $base ) . 'agentwp-exports';
+		if ( function_exists( 'wp_mkdir_p' ) ) {
+			wp_mkdir_p( $dir );
+		}
+
+		$filename = 'agentwp-bulk-export-' . gmdate( 'Ymd-His' ) . '-' . wp_generate_password( 6, false ) . '.csv';
+		$path     = trailingslashit( $dir ) . $filename;
+		$file     = @fopen( $path, 'w' );
+		if ( ! $file ) {
+			return array( 'error' => 'Unable to create CSV export file.' );
+		}
+
+		fputcsv( $file, $fields );
+		foreach ( $rows as $row ) {
+			$line = array();
+			foreach ( $fields as $field ) {
+				$line[] = isset( $row[ $field ] ) ? $row[ $field ] : '';
+			}
+			fputcsv( $file, $line );
+		}
+
+		fclose( $file );
+
+		return array(
+			'file_path' => $path,
+			'file_url'  => trailingslashit( $url ) . 'agentwp-exports/' . $filename,
+			'rows'      => count( $rows ),
+		);
+	}
+
+	/**
+	 * @param int $order_id Order ID.
+	 * @return array
+	 */
+	private function get_order_tags( $order_id ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				return array();
+			}
+			return $existing;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'get_meta' ) ) {
+			return array();
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			return array();
+		}
+
+		return $existing;
+	}
+
+	/**
+	 * @param int   $order_id Order ID.
+	 * @param array $tags Tags.
+	 * @return bool
+	 */
+	private function restore_order_tags( $order_id, $tags ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			wp_set_object_terms( $order_id, (array) $tags, $taxonomy, false );
+			return true;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$order->update_meta_data( '_agentwp_order_tags', (array) $tags );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param array $note_ids Note IDs.
+	 * @return bool
+	 */
+	private function delete_order_notes( array $note_ids ) {
+		if ( ! function_exists( 'wp_delete_comment' ) ) {
+			return false;
+		}
+
+		$deleted_any = false;
+		foreach ( $note_ids as $note_id ) {
+			$note_id = absint( $note_id );
+			if ( $note_id > 0 ) {
+				wp_delete_comment( $note_id, true );
+				$deleted_any = true;
+			}
+		}
+
+		return $deleted_any;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function get_order_tag_taxonomy() {
+		$taxonomy = apply_filters( 'agentwp_order_tag_taxonomy', 'shop_order_tag' );
+		$taxonomy = is_string( $taxonomy ) ? trim( $taxonomy ) : '';
+
+		if ( '' !== $taxonomy && function_exists( 'taxonomy_exists' ) && taxonomy_exists( $taxonomy ) ) {
+			return $taxonomy;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param array|null $date_range Date range input.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query text.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date.
+	 * @param string $end End date.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Date string.
+	 * @param bool   $end_of_day End of day flag.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		$date = $end_of_day ? $date->setTime( 23, 59, 59 ) : $date->setTime( 0, 0, 0 );
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function extract_total_range( $query ) {
+		$result = array();
+
+		if ( preg_match( '/\bbetween\s+[\$£\x{20AC}]?([0-9\.,]+)\s+(?:and|to)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+			return $result;
+		}
+
+		if ( preg_match( '/\b(over|above|more than|greater than|at least|minimum|min)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b(under|below|less than|at most|maximum|max)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b>=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		if ( preg_match( '/\b<=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param string $value Amount string.
+	 * @return float|null
+	 */
+	private function parse_amount_string( $value ) {
+		$value = str_replace( array( ',', ' ' ), '', (string) $value );
+		return $this->normalize_amount( $value );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_country( $query ) {
+		$query_lower = strtolower( $query );
+		$map         = $this->get_country_map();
+
+		foreach ( $map as $name => $code ) {
+			$pattern = '/\b' . preg_quote( $name, '/' ) . '\b/i';
+			if ( preg_match( $pattern, $query_lower ) ) {
+				return $code;
+			}
+		}
+
+		if ( preg_match_all( '/\b([A-Z]{2})\b/', strtoupper( $query ), $matches ) ) {
+			foreach ( $matches[1] as $code ) {
+				if ( isset( $map[ strtolower( $code ) ] ) ) {
+					return $map[ strtolower( $code ) ];
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_country_map() {
+		static $map = null;
+		if ( null !== $map ) {
+			return $map;
+		}
+
+		$countries = array();
+		if ( function_exists( 'WC' ) ) {
+			$wc = WC();
+			if ( $wc && isset( $wc->countries ) && method_exists( $wc->countries, 'get_countries' ) ) {
+				$countries = $wc->countries->get_countries();
+			}
+		}
+
+		if ( empty( $countries ) && class_exists( 'WC_Countries' ) ) {
+			$wc_countries = new \WC_Countries();
+			$countries    = $wc_countries->get_countries();
+		}
+
+		$map = array();
+		if ( is_array( $countries ) ) {
+			foreach ( $countries as $code => $name ) {
+				$map[ strtolower( $name ) ] = strtoupper( $code );
+				$map[ strtolower( $code ) ] = strtoupper( $code );
+			}
+		}
+
+		$map['usa'] = 'US';
+		$map['us']  = 'US';
+		$map['uk']  = 'GB';
+
+		return $map;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_order_country( $order ) {
+		$country = method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '';
+		if ( '' !== $country ) {
+			return $country;
+		}
+
+		if ( method_exists( $order, 'get_billing_country' ) ) {
+			$country = $order->get_billing_country();
+		}
+
+		return is_string( $country ) ? $country : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_draft_id( array $args ) {
+		$draft_id = isset( $args['draft_id'] ) ? $args['draft_id'] : '';
+		if ( '' === $draft_id && isset( $args['params']['draft_id'] ) ) {
+			$draft_id = $args['params']['draft_id'];
+		}
+
+		return is_string( $draft_id ) ? trim( $draft_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_progress_id( array $args ) {
+		$progress_id = isset( $args['progress_id'] ) ? $args['progress_id'] : '';
+		if ( '' === $progress_id && isset( $args['params']['progress_id'] ) ) {
+			$progress_id = $args['params']['progress_id'];
+		}
+
+		return is_string( $progress_id ) ? trim( $progress_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_rollback_id( array $args ) {
+		$rollback_id = isset( $args['rollback_id'] ) ? $args['rollback_id'] : '';
+		if ( '' === $rollback_id && isset( $args['params']['rollback_id'] ) ) {
+			$rollback_id = $args['params']['rollback_id'];
+		}
+
+		return is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+	}
+
+	/**
+	 * @return bool
+	 */
+	private function action_scheduler_available() {
+		return function_exists( 'as_enqueue_async_action' ) || function_exists( 'as_schedule_single_action' );
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return int
+	 */
+	private function schedule_job( $job_id ) {
+		if ( function_exists( 'as_enqueue_async_action' ) ) {
+			return (int) as_enqueue_async_action( self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		if ( function_exists( 'as_schedule_single_action' ) ) {
+			return (int) as_schedule_single_action( time(), self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		return 0;
+	}
+}


thinking
**Adding register_hooks call to Plugin constructor**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Plugin.php
@@ -101,2 +101,6 @@
 
+		if ( class_exists( 'AgentWP\\Handlers\\BulkHandler' ) ) {
+			Handlers\BulkHandler::register_hooks();
+		}
+
 		if ( class_exists( 'AgentWP\\Demo\\Manager' ) ) {
apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M src/Plugin.php
file update:
diff --git a/src/Handlers/BulkHandler.php b/src/Handlers/BulkHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..d7994bcd117201a3df0db869c3d04e51a692d784
--- /dev/null
+++ b/src/Handlers/BulkHandler.php
@@ -0,0 +1,2223 @@
+<?php
+/**
+ * Handle bulk order operations.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class BulkHandler {
+	const ACTION_HOOK      = 'agentwp_bulk_process';
+	const ASYNC_THRESHOLD  = 20;
+	const DRAFT_TYPE       = 'bulk_action';
+	const JOB_TTL_SECONDS  = 86400;
+	const MAX_BULK         = 1000;
+	const PROGRESS_TTL     = 86400;
+	const ROLLBACK_TTL     = 86400;
+	const POLL_INTERVAL    = 2;
+
+	/**
+	 * Register background processing hooks.
+	 *
+	 * @return void
+	 */
+	public static function register_hooks() {
+		add_action( self::ACTION_HOOK, array( __CLASS__, 'handle_scheduled_action' ), 10, 1 );
+	}
+
+	/**
+	 * Execute scheduled bulk jobs.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	public static function handle_scheduled_action( $job_id ) {
+		$handler = new self();
+		$handler->process_scheduled_job( $job_id );
+	}
+
+	/**
+	 * Handle bulk actions and selections.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['criteria'] ) ) {
+			return $this->select_orders( $args );
+		}
+
+		$progress_id = $this->extract_progress_id( $args );
+		if ( '' !== $progress_id ) {
+			return $this->get_progress_response( $progress_id );
+		}
+
+		$rollback_id = $this->extract_rollback_id( $args );
+		if ( '' !== $rollback_id ) {
+			return $this->rollback_bulk_action( $rollback_id );
+		}
+
+		$draft_id = $this->extract_draft_id( $args );
+		if ( '' !== $draft_id ) {
+			return $this->confirm_bulk_update( $draft_id );
+		}
+
+		return $this->prepare_bulk_update( $args );
+	}
+
+	/**
+	 * Select orders based on criteria.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function select_orders( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to select orders.', 400 );
+		}
+
+		$criteria  = $this->normalize_criteria( isset( $args['criteria'] ) ? $args['criteria'] : array() );
+		$order_ids = $this->query_order_ids( $criteria );
+		$sample    = $this->build_sample_orders( $order_ids );
+
+		return Response::success(
+			array(
+				'order_ids'  => $order_ids,
+				'count'      => count( $order_ids ),
+				'criteria'   => $criteria,
+				'sample'     => $sample,
+				'truncated'  => count( $order_ids ) >= self::MAX_BULK,
+				'max_limit'  => self::MAX_BULK,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a bulk update draft.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	private function prepare_bulk_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $args['action'] ) ? $args['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Missing or invalid bulk action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $args['params'] ) ? $args['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$missing_orders = $this->find_missing_orders( $order_ids );
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		$sample = $this->build_sample_orders( $order_ids );
+		$preview = array(
+			'order_count'    => count( $order_ids ),
+			'sample'         => $sample,
+			'action'         => $action,
+			'action_preview' => $this->build_action_preview( $action, $params ),
+		);
+
+		$draft_payload = array(
+			'order_ids' => $order_ids,
+			'action'    => $action,
+			'params'    => $params,
+			'preview'   => $preview,
+		);
+
+		$draft_id   = $this->generate_uuid();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a bulk update draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	private function confirm_bulk_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to process bulk updates.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing bulk update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Bulk update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for bulk update confirmation.', 400 );
+		}
+
+		$payload  = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $payload['action'] ) ? $payload['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Bulk update draft is missing an action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $payload['params'] ) ? $payload['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$job_id      = $this->generate_uuid();
+		$progress_id = $this->generate_uuid();
+		$rollback_id = $this->generate_uuid();
+
+		$rollback_expires = gmdate( 'c', time() + self::ROLLBACK_TTL );
+		$this->store_rollback(
+			$rollback_id,
+			array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => $rollback_expires,
+				'orders'     => array(),
+			),
+			self::ROLLBACK_TTL
+		);
+
+		$progress = array(
+			'id'                  => $progress_id,
+			'status'              => 'queued',
+			'action'              => $action,
+			'order_count'         => count( $order_ids ),
+			'processed'           => 0,
+			'updated'             => 0,
+			'failed'              => 0,
+			'errors'              => array(),
+			'created_at'          => gmdate( 'c' ),
+			'started_at'          => '',
+			'last_updated'        => gmdate( 'c' ),
+			'completed_at'        => '',
+			'draft_id'            => $draft_id,
+			'rollback_id'         => $rollback_id,
+			'undo_available_until'=> $rollback_expires,
+		);
+		$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+
+		$job = array(
+			'id'          => $job_id,
+			'order_ids'   => $order_ids,
+			'action'      => $action,
+			'params'      => $params,
+			'progress_id' => $progress_id,
+			'rollback_id' => $rollback_id,
+			'draft_id'    => $draft_id,
+		);
+		$this->store_job( $job_id, $job, self::JOB_TTL_SECONDS );
+
+		$async = count( $order_ids ) > self::ASYNC_THRESHOLD && $this->action_scheduler_available();
+		if ( $async ) {
+			$action_id = $this->schedule_job( $job_id );
+			if ( ! $action_id ) {
+				return Response::error( 'Unable to schedule bulk update.', 500 );
+			}
+
+			$this->delete_draft( $draft_id );
+
+			return Response::success(
+				array(
+					'status'     => 'scheduled',
+					'draft_id'   => $draft_id,
+					'job_id'     => $job_id,
+					'progress'   => $progress,
+					'polling'    => array(
+						'progress_id'      => $progress_id,
+						'interval_seconds' => self::POLL_INTERVAL,
+					),
+					'rollback_id' => $rollback_id,
+					'undo_available_until' => $rollback_expires,
+				)
+			);
+		}
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'     => 'running',
+				'started_at' => gmdate( 'c' ),
+			),
+			true
+		);
+
+		$result = $this->run_bulk_job( $job );
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'       => 'completed',
+				'completed_at' => gmdate( 'c' ),
+				'result'       => $result,
+			),
+			true
+		);
+
+		$this->delete_job( $job_id );
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'status'      => 'completed',
+				'draft_id'    => $draft_id,
+				'result'      => $result,
+				'progress'    => $progress,
+				'polling'     => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+				'rollback_id' => $rollback_id,
+				'undo_available_until' => $rollback_expires,
+			)
+		);
+	}
+
+	/**
+	 * Process a scheduled bulk job.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	private function process_scheduled_job( $job_id ) {
+		$job_id = is_string( $job_id ) ? trim( $job_id ) : '';
+		if ( '' === $job_id ) {
+			return;
+		}
+
+		$job = $this->load_job( $job_id );
+		if ( ! is_array( $job ) ) {
+			return;
+		}
+
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'     => 'running',
+					'started_at' => gmdate( 'c' ),
+				),
+				true
+			);
+		}
+
+		$result = $this->run_bulk_job( $job );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'       => 'completed',
+					'completed_at' => gmdate( 'c' ),
+					'result'       => $result,
+				),
+				true
+			);
+		}
+
+		$draft_id = isset( $job['draft_id'] ) ? (string) $job['draft_id'] : '';
+		if ( '' !== $draft_id ) {
+			$this->delete_draft( $draft_id );
+		}
+
+		$this->delete_job( $job_id );
+	}
+
+	/**
+	 * Execute a bulk job.
+	 *
+	 * @param array $job Job payload.
+	 * @return array
+	 */
+	private function run_bulk_job( array $job ) {
+		$order_ids   = isset( $job['order_ids'] ) ? $this->normalize_order_ids( $job['order_ids'] ) : array();
+		$action      = isset( $job['action'] ) ? $this->normalize_action( $job['action'] ) : '';
+		$params      = isset( $job['params'] ) && is_array( $job['params'] ) ? $job['params'] : array();
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		$rollback_id = isset( $job['rollback_id'] ) ? (string) $job['rollback_id'] : '';
+
+		$result = array(
+			'action'    => $action,
+			'order_ids' => $order_ids,
+			'updated'   => array(),
+			'failed'    => array(),
+			'errors'    => array(),
+		);
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			$rollback = array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => gmdate( 'c', time() + self::ROLLBACK_TTL ),
+				'orders'     => array(),
+			);
+		}
+
+		$processed = 0;
+		$updated   = 0;
+		$failed    = 0;
+		$errors    = array();
+		$rows      = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$processed++;
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed++;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found.',
+				);
+				$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$current_status = $this->normalize_status( $order->get_status() );
+					$new_status     = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+					if ( '' === $new_status ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing target status.',
+						);
+						break;
+					}
+
+					$rollback['orders'][ $order_id ] = array(
+						'status' => $current_status,
+					);
+
+					$note            = isset( $params['note'] ) ? (string) $params['note'] : '';
+					$notify_customer = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+					$updated_flag    = $this->apply_status_update( $order, $new_status, $note, $notify_customer );
+
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to update status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+					$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+					$tags = $this->normalize_tags( $tags, $tag );
+					if ( empty( $tags ) ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing tags to add.',
+						);
+						break;
+					}
+
+					$before_tags = $this->get_order_tags( $order_id );
+					$rollback['orders'][ $order_id ] = array(
+						'tags' => $before_tags,
+					);
+
+					$updated_flag = $this->apply_tags_update( $order, $tags );
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+					if ( '' === $note ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing note content.',
+						);
+						break;
+					}
+
+					$is_customer_note = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+					$note_id          = $this->apply_order_note( $order, $note, $is_customer_note );
+					if ( $note_id > 0 ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+						$rollback['orders'][ $order_id ] = array(
+							'notes' => array( $note_id ),
+						);
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add note.',
+						);
+					}
+					break;
+				case 'export_csv':
+					$rows[] = $this->format_export_row( $order );
+					$updated++;
+					$result['updated'][] = $order_id;
+					break;
+				default:
+					$failed++;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Unsupported bulk action.',
+					);
+			}
+
+			$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+		}
+
+		$result['errors'] = $errors;
+		$result['failed'] = array_unique( array_merge( $result['failed'], wp_list_pluck( $errors, 'order_id' ) ) );
+
+		if ( 'export_csv' === $action ) {
+			$export = $this->export_csv( $rows, isset( $params['fields'] ) ? $params['fields'] : array() );
+			if ( isset( $export['error'] ) ) {
+				$errors[]         = array( 'order_id' => 0, 'message' => $export['error'] );
+				$result['errors'] = $errors;
+			} else {
+				$result['export'] = $export;
+			}
+		}
+
+		$this->store_rollback( $rollback_id, $rollback, self::ROLLBACK_TTL );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'processed' => $processed,
+					'updated'   => $updated,
+					'failed'    => $failed,
+					'errors'    => $errors,
+				),
+				true
+			);
+		}
+
+		return $result;
+	}
+
+	/**
+	 * Provide progress updates to polling clients.
+	 *
+	 * @param string $progress_id Progress identifier.
+	 * @return Response
+	 */
+	private function get_progress_response( $progress_id ): Response {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			return Response::error( 'Bulk progress not found or expired.', 404 );
+		}
+
+		return Response::success(
+			array(
+				'progress' => $progress,
+				'polling'  => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Roll back a bulk action.
+	 *
+	 * @param string $rollback_id Rollback identifier.
+	 * @return Response
+	 */
+	private function rollback_bulk_action( $rollback_id ): Response {
+		$rollback_id = is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+		if ( '' === $rollback_id ) {
+			return Response::error( 'Missing rollback ID.', 400 );
+		}
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			return Response::error( 'Rollback data not found or expired.', 404 );
+		}
+
+		$action  = isset( $rollback['action'] ) ? $this->normalize_action( $rollback['action'] ) : '';
+		$orders  = isset( $rollback['orders'] ) && is_array( $rollback['orders'] ) ? $rollback['orders'] : array();
+		$undone  = array();
+		$failed  = array();
+		$errors  = array();
+
+		foreach ( $orders as $order_id => $data ) {
+			$order_id = absint( $order_id );
+			$order    = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed[] = $order_id;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found for rollback.',
+				);
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$previous_status = isset( $data['status'] ) ? $this->normalize_status( $data['status'] ) : '';
+					if ( '' === $previous_status ) {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing previous status.',
+						);
+						break;
+					}
+
+					$updated = $this->apply_status_update( $order, $previous_status, 'Rollback to previous status.', false );
+					if ( $updated ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore previous status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $data['tags'] ) ? $data['tags'] : array();
+					$restored = $this->restore_order_tags( $order_id, $tags );
+					if ( $restored ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$notes = isset( $data['notes'] ) ? (array) $data['notes'] : array();
+					$deleted = $this->delete_order_notes( $notes );
+					if ( $deleted ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to remove notes.',
+						);
+					}
+					break;
+				default:
+					$failed[] = $order_id;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Rollback not supported for this action.',
+					);
+			}
+		}
+
+		return Response::success(
+			array(
+				'rollback_id' => $rollback_id,
+				'action'      => $action,
+				'undone'      => $undone,
+				'failed'      => $failed,
+				'errors'      => $errors,
+			)
+		);
+	}
+
+	/**
+	 * @param array $criteria Criteria input.
+	 * @return array
+	 */
+	private function normalize_criteria( $criteria ) {
+		$parsed = array(
+			'status'         => '',
+			'date_range'     => null,
+			'customer_email' => '',
+			'total_min'      => null,
+			'total_max'      => null,
+			'country'        => '',
+		);
+		$query  = '';
+
+		if ( is_string( $criteria ) ) {
+			$query = sanitize_text_field( $criteria );
+		} elseif ( is_array( $criteria ) ) {
+			$query = isset( $criteria['query'] ) ? sanitize_text_field( $criteria['query'] ) : '';
+			$parsed['status'] = isset( $criteria['status'] ) ? $this->normalize_status( $criteria['status'] ) : '';
+			$parsed['date_range'] = $this->normalize_date_range_input( isset( $criteria['date_range'] ) ? $criteria['date_range'] : null );
+			$parsed['customer_email'] = isset( $criteria['customer_email'] ) ? sanitize_email( $criteria['customer_email'] ) : '';
+			$parsed['total_min'] = isset( $criteria['total_min'] ) ? $this->normalize_amount( $criteria['total_min'] ) : null;
+			$parsed['total_max'] = isset( $criteria['total_max'] ) ? $this->normalize_amount( $criteria['total_max'] ) : null;
+			$parsed['country'] = isset( $criteria['country'] ) ? $this->normalize_country( $criteria['country'] ) : '';
+		}
+
+		if ( '' !== $query ) {
+			$text_parsed = $this->parse_criteria_text( $query );
+			foreach ( $text_parsed as $key => $value ) {
+				if ( ! isset( $parsed[ $key ] ) || '' === $parsed[ $key ] || null === $parsed[ $key ] ) {
+					$parsed[ $key ] = $value;
+				}
+			}
+		}
+
+		if ( '' === $parsed['status'] ) {
+			unset( $parsed['status'] );
+		}
+		if ( '' === $parsed['customer_email'] ) {
+			unset( $parsed['customer_email'] );
+		}
+		if ( '' === $parsed['country'] ) {
+			unset( $parsed['country'] );
+		}
+		if ( null === $parsed['total_min'] ) {
+			unset( $parsed['total_min'] );
+		}
+		if ( null === $parsed['total_max'] ) {
+			unset( $parsed['total_max'] );
+		}
+		if ( null === $parsed['date_range'] ) {
+			unset( $parsed['date_range'] );
+		}
+
+		return $parsed;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function parse_criteria_text( $query ) {
+		$query  = trim( (string) $query );
+		$lower  = strtolower( $query );
+		$result = array();
+
+		$status = $this->detect_status( $lower );
+		if ( '' !== $status ) {
+			$result['status'] = $status;
+		}
+
+		$date_range = $this->parse_date_range_from_query( $lower );
+		if ( null !== $date_range ) {
+			$result['date_range'] = $date_range;
+		}
+
+		$email = $this->extract_email( $query );
+		if ( '' !== $email ) {
+			$result['customer_email'] = $email;
+		}
+
+		$totals = $this->extract_total_range( $lower );
+		if ( isset( $totals['min'] ) ) {
+			$result['total_min'] = $totals['min'];
+		}
+		if ( isset( $totals['max'] ) ) {
+			$result['total_max'] = $totals['max'];
+		}
+
+		$country = $this->extract_country( $query );
+		if ( '' !== $country ) {
+			$result['country'] = $country;
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param array $criteria Query criteria.
+	 * @return array
+	 */
+	private function query_order_ids( array $criteria ) {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		$args = array(
+			'limit'   => self::MAX_BULK,
+			'return'  => 'ids',
+			'orderby' => 'date',
+			'order'   => 'DESC',
+		);
+
+		if ( isset( $criteria['status'] ) && '' !== $criteria['status'] ) {
+			$args['status'] = $criteria['status'];
+		}
+
+		if ( isset( $criteria['date_range'] ) && is_array( $criteria['date_range'] ) ) {
+			$args['date_created'] = $criteria['date_range']['start'] . '...' . $criteria['date_range']['end'];
+		}
+
+		$meta_query = array( 'relation' => 'AND' );
+
+		if ( isset( $criteria['customer_email'] ) && '' !== $criteria['customer_email'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['country'] ) && '' !== $criteria['country'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['total_min'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_min'],
+				'compare' => '>=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( isset( $criteria['total_max'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_max'],
+				'compare' => '<=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( count( $meta_query ) > 1 ) {
+			$args['meta_query'] = $meta_query;
+		}
+
+		$order_ids = wc_get_orders( $args );
+		if ( ! is_array( $order_ids ) ) {
+			return array();
+		}
+
+		$order_ids = array_map( 'absint', $order_ids );
+		$order_ids = array_filter( $order_ids );
+		$order_ids = array_values( array_unique( $order_ids ) );
+
+		return $order_ids;
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function build_sample_orders( array $order_ids ) {
+		$sample = array();
+		$order_ids = array_slice( $order_ids, 0, 5 );
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( $order ) {
+				$sample[] = $this->format_order_summary( $order );
+			}
+		}
+
+		return $sample;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_order_summary( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'       => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'currency'       => method_exists( $order, 'get_currency' ) ? sanitize_text_field( $order->get_currency() ) : '',
+			'customer_name'  => sanitize_text_field( $this->get_customer_name( $order ) ),
+			'customer_email' => sanitize_email( $this->get_customer_email( $order ) ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'country'        => sanitize_text_field( $this->get_order_country( $order ) ),
+		);
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @param mixed $action Raw action.
+	 * @return string
+	 */
+	private function normalize_action( $action ) {
+		$action = is_string( $action ) ? strtolower( trim( $action ) ) : '';
+		$allowed = array( 'update_status', 'add_tag', 'add_note', 'export_csv' );
+
+		return in_array( $action, $allowed, true ) ? $action : '';
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param mixed  $params Raw params.
+	 * @return array
+	 */
+	private function normalize_params( $action, $params ) {
+		$params = is_array( $params ) ? $params : array();
+		$normalized = array();
+
+		switch ( $action ) {
+			case 'update_status':
+				$new_status = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+				if ( '' === $new_status ) {
+					return array( 'error' => 'Missing new status for bulk update.' );
+				}
+
+				$valid_statuses = $this->get_valid_statuses();
+				if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+					return array( 'error' => 'Invalid status for bulk update.' );
+				}
+
+				$normalized['new_status'] = $new_status;
+				$normalized['note'] = isset( $params['note'] ) ? sanitize_text_field( wp_unslash( $params['note'] ) ) : '';
+				$normalized['notify_customer'] = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+				break;
+			case 'add_tag':
+				$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+				$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+				$normalized['tags'] = $this->normalize_tags( $tags, $tag );
+				if ( empty( $normalized['tags'] ) ) {
+					return array( 'error' => 'Missing tags for bulk update.' );
+				}
+				break;
+			case 'add_note':
+				$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+				if ( '' === $note ) {
+					return array( 'error' => 'Missing note for bulk update.' );
+				}
+				$normalized['note'] = sanitize_text_field( wp_unslash( $note ) );
+				$normalized['is_customer_note'] = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+				break;
+			case 'export_csv':
+				$fields = isset( $params['fields'] ) ? $params['fields'] : array();
+				$normalized['fields'] = $this->normalize_fields( $fields );
+				break;
+			default:
+				return array( 'error' => 'Unsupported bulk action.' );
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param array  $params Params.
+	 * @return array
+	 */
+	private function build_action_preview( $action, array $params ) {
+		switch ( $action ) {
+			case 'update_status':
+				return array(
+					'new_status'      => isset( $params['new_status'] ) ? $params['new_status'] : '',
+					'notify_customer' => ! empty( $params['notify_customer'] ),
+					'note'            => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'add_tag':
+				return array(
+					'tags' => isset( $params['tags'] ) ? $params['tags'] : array(),
+				);
+			case 'add_note':
+				return array(
+					'note' => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'export_csv':
+				return array(
+					'fields' => isset( $params['fields'] ) ? $params['fields'] : $this->normalize_fields( array() ),
+				);
+			default:
+				return array();
+		}
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function find_missing_orders( array $order_ids ) {
+		$missing = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$missing[] = $order_id;
+			}
+		}
+
+		return $missing;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @param int    $processed Processed count.
+	 * @param int    $updated Updated count.
+	 * @param int    $failed Failed count.
+	 * @param array  $errors Error list.
+	 * @return void
+	 */
+	private function maybe_update_progress( $progress_id, $processed, $updated, $failed, array $errors ) {
+		if ( '' === $progress_id ) {
+			return;
+		}
+
+		$this->update_progress(
+			$progress_id,
+			array(
+				'processed' => $processed,
+				'updated'   => $updated,
+				'failed'    => $failed,
+				'errors'    => $errors,
+			),
+			false
+		);
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $updates Updates.
+	 * @param bool   $force Force update.
+	 * @return array
+	 */
+	private function update_progress( $progress_id, array $updates, $force ) {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			$progress = array(
+				'id'           => $progress_id,
+				'status'       => 'queued',
+				'processed'    => 0,
+				'updated'      => 0,
+				'failed'       => 0,
+				'errors'       => array(),
+				'created_at'   => gmdate( 'c' ),
+				'last_updated' => gmdate( 'c' ),
+			);
+		}
+
+		$last_updated = isset( $progress['last_updated'] ) ? strtotime( $progress['last_updated'] ) : 0;
+		$should_update = $force || ( time() - $last_updated >= self::POLL_INTERVAL );
+
+		foreach ( $updates as $key => $value ) {
+			$progress[ $key ] = $value;
+		}
+
+		if ( $should_update ) {
+			$progress['last_updated'] = gmdate( 'c' );
+			$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @return array|null
+	 */
+	private function load_progress( $progress_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$progress = get_transient( $this->build_progress_key( $progress_id ) );
+		if ( false === $progress || ! is_array( $progress ) ) {
+			return null;
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $progress Progress payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_progress( $progress_id, array $progress, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_progress_key( $progress_id ), $progress, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return array|null
+	 */
+	private function load_job( $job_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$job = get_transient( $this->build_job_key( $job_id ) );
+		if ( false === $job || ! is_array( $job ) ) {
+			return null;
+		}
+
+		return $job;
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @param array  $job Job payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_job( $job_id, array $job, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_job_key( $job_id ), $job, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return void
+	 */
+	private function delete_job( $job_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_job_key( $job_id ) );
+		}
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @return array|null
+	 */
+	private function load_rollback( $rollback_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$rollback = get_transient( $this->build_rollback_key( $rollback_id ) );
+		if ( false === $rollback || ! is_array( $rollback ) ) {
+			return null;
+		}
+
+		return $rollback;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @param array  $rollback Rollback data.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_rollback( $rollback_id, array $rollback, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_rollback_key( $rollback_id ), $rollback, $ttl );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_uuid() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'bulk_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_draft_' . $draft_id;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @return string
+	 */
+	private function build_progress_key( $progress_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_progress_' . $progress_id;
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return string
+	 */
+	private function build_job_key( $job_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_job_' . $job_id;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback identifier.
+	 * @return string
+	 */
+	private function build_rollback_key( $rollback_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_rollback_' . $rollback_id;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param mixed $status Raw status.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float|null
+	 */
+	private function normalize_amount( $amount ) {
+		if ( null === $amount || '' === $amount ) {
+			return null;
+		}
+
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $country Country input.
+	 * @return string
+	 */
+	private function normalize_country( $country ) {
+		$country = is_string( $country ) ? strtoupper( trim( $country ) ) : '';
+		if ( '' === $country ) {
+			return '';
+		}
+
+		if ( strlen( $country ) === 2 ) {
+			return $country;
+		}
+
+		$map = $this->get_country_map();
+		$key = strtolower( $country );
+
+		return isset( $map[ $key ] ) ? $map[ $key ] : '';
+	}
+
+	/**
+	 * @param mixed $tags Tags list.
+	 * @param mixed $tag Single tag.
+	 * @return array
+	 */
+	private function normalize_tags( $tags, $tag ) {
+		$list = array();
+
+		if ( is_string( $tags ) ) {
+			$tags = preg_split( '/[\s,]+/', $tags );
+		}
+
+		if ( is_array( $tags ) ) {
+			foreach ( $tags as $item ) {
+				$item = sanitize_text_field( (string) $item );
+				if ( '' !== $item ) {
+					$list[] = $item;
+				}
+			}
+		}
+
+		if ( is_string( $tag ) ) {
+			$tag = sanitize_text_field( $tag );
+			if ( '' !== $tag ) {
+				$list[] = $tag;
+			}
+		}
+
+		$list = array_values( array_unique( $list ) );
+
+		return $list;
+	}
+
+	/**
+	 * @param mixed $fields Fields input.
+	 * @return array
+	 */
+	private function normalize_fields( $fields ) {
+		$default = array( 'order_id', 'status', 'total', 'currency', 'customer_name', 'customer_email', 'date_created', 'billing_country', 'shipping_country' );
+		if ( empty( $fields ) ) {
+			return $default;
+		}
+
+		if ( is_string( $fields ) ) {
+			$fields = preg_split( '/[\s,]+/', $fields );
+		}
+
+		if ( ! is_array( $fields ) ) {
+			return $default;
+		}
+
+		$sanitized = array();
+		foreach ( $fields as $field ) {
+			$field = sanitize_key( $field );
+			if ( '' !== $field ) {
+				$sanitized[] = $field;
+			}
+		}
+
+		return array_values( array_unique( $sanitized ) );
+	}
+
+	/**
+	 * @param array $order Order object.
+	 * @param string $new_status New status.
+	 * @param string $note Note for audit.
+	 * @param bool $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $current_status === $new_status ) {
+			return false;
+		}
+
+		$note = trim( (string) $note );
+		$audit_note = sprintf( '[AgentWP] Bulk status update: %s -> %s.', $current_status, $new_status );
+		if ( '' !== $note ) {
+			$audit_note .= ' Note: ' . $note . '.';
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $audit_note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param array  $tags Tags to add.
+	 * @return bool
+	 */
+	private function apply_tags_update( $order, array $tags ) {
+		$order_id = method_exists( $order, 'get_id' ) ? $order->get_id() : 0;
+		if ( $order_id <= 0 ) {
+			return false;
+		}
+
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				$existing = array();
+			}
+			$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+			wp_set_object_terms( $order_id, $merged, $taxonomy, false );
+			return true;
+		}
+
+		if ( ! method_exists( $order, 'get_meta' ) || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			$existing = array();
+		}
+
+		$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+		$order->update_meta_data( '_agentwp_order_tags', $merged );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param string $note Note text.
+	 * @param bool   $is_customer_note Customer visibility.
+	 * @return int
+	 */
+	private function apply_order_note( $order, $note, $is_customer_note ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return 0;
+		}
+
+		$note = trim( (string) $note );
+		if ( '' === $note ) {
+			return 0;
+		}
+
+		$note_id = $order->add_order_note( $note, $is_customer_note );
+
+		return absint( $note_id );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_export_row( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'        => intval( $order->get_id() ),
+			'status'          => sanitize_text_field( $order->get_status() ),
+			'total'           => $order->get_total(),
+			'currency'        => method_exists( $order, 'get_currency' ) ? $order->get_currency() : '',
+			'customer_name'   => $this->get_customer_name( $order ),
+			'customer_email'  => $this->get_customer_email( $order ),
+			'date_created'    => $date_created ? $date_created->date( 'c' ) : '',
+			'billing_country' => method_exists( $order, 'get_billing_country' ) ? $order->get_billing_country() : '',
+			'shipping_country'=> method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '',
+		);
+	}
+
+	/**
+	 * @param array $rows Data rows.
+	 * @param array $fields Fields list.
+	 * @return array
+	 */
+	private function export_csv( array $rows, array $fields ) {
+		if ( ! function_exists( 'wp_upload_dir' ) ) {
+			return array( 'error' => 'Unable to export CSV in this environment.' );
+		}
+
+		$fields = $this->normalize_fields( $fields );
+		$upload = wp_upload_dir();
+		$base   = isset( $upload['basedir'] ) ? $upload['basedir'] : '';
+		$url    = isset( $upload['baseurl'] ) ? $upload['baseurl'] : '';
+
+		if ( '' === $base || '' === $url ) {
+			return array( 'error' => 'Unable to resolve upload directory.' );
+		}
+
+		$dir = trailingslashit( $base ) . 'agentwp-exports';
+		if ( function_exists( 'wp_mkdir_p' ) ) {
+			wp_mkdir_p( $dir );
+		}
+
+		$filename = 'agentwp-bulk-export-' . gmdate( 'Ymd-His' ) . '-' . wp_generate_password( 6, false ) . '.csv';
+		$path     = trailingslashit( $dir ) . $filename;
+		$file     = @fopen( $path, 'w' );
+		if ( ! $file ) {
+			return array( 'error' => 'Unable to create CSV export file.' );
+		}
+
+		fputcsv( $file, $fields );
+		foreach ( $rows as $row ) {
+			$line = array();
+			foreach ( $fields as $field ) {
+				$line[] = isset( $row[ $field ] ) ? $row[ $field ] : '';
+			}
+			fputcsv( $file, $line );
+		}
+
+		fclose( $file );
+
+		return array(
+			'file_path' => $path,
+			'file_url'  => trailingslashit( $url ) . 'agentwp-exports/' . $filename,
+			'rows'      => count( $rows ),
+		);
+	}
+
+	/**
+	 * @param int $order_id Order ID.
+	 * @return array
+	 */
+	private function get_order_tags( $order_id ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				return array();
+			}
+			return $existing;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'get_meta' ) ) {
+			return array();
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			return array();
+		}
+
+		return $existing;
+	}
+
+	/**
+	 * @param int   $order_id Order ID.
+	 * @param array $tags Tags.
+	 * @return bool
+	 */
+	private function restore_order_tags( $order_id, $tags ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			wp_set_object_terms( $order_id, (array) $tags, $taxonomy, false );
+			return true;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$order->update_meta_data( '_agentwp_order_tags', (array) $tags );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param array $note_ids Note IDs.
+	 * @return bool
+	 */
+	private function delete_order_notes( array $note_ids ) {
+		if ( ! function_exists( 'wp_delete_comment' ) ) {
+			return false;
+		}
+
+		$deleted_any = false;
+		foreach ( $note_ids as $note_id ) {
+			$note_id = absint( $note_id );
+			if ( $note_id > 0 ) {
+				wp_delete_comment( $note_id, true );
+				$deleted_any = true;
+			}
+		}
+
+		return $deleted_any;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function get_order_tag_taxonomy() {
+		$taxonomy = apply_filters( 'agentwp_order_tag_taxonomy', 'shop_order_tag' );
+		$taxonomy = is_string( $taxonomy ) ? trim( $taxonomy ) : '';
+
+		if ( '' !== $taxonomy && function_exists( 'taxonomy_exists' ) && taxonomy_exists( $taxonomy ) ) {
+			return $taxonomy;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param array|null $date_range Date range input.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query text.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date.
+	 * @param string $end End date.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Date string.
+	 * @param bool   $end_of_day End of day flag.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		$date = $end_of_day ? $date->setTime( 23, 59, 59 ) : $date->setTime( 0, 0, 0 );
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function extract_total_range( $query ) {
+		$result = array();
+
+		if ( preg_match( '/\bbetween\s+[\$£\x{20AC}]?([0-9\.,]+)\s+(?:and|to)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+			return $result;
+		}
+
+		if ( preg_match( '/\b(over|above|more than|greater than|at least|minimum|min)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b(under|below|less than|at most|maximum|max)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b>=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		if ( preg_match( '/\b<=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param string $value Amount string.
+	 * @return float|null
+	 */
+	private function parse_amount_string( $value ) {
+		$value = str_replace( array( ',', ' ' ), '', (string) $value );
+		return $this->normalize_amount( $value );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_country( $query ) {
+		$query_lower = strtolower( $query );
+		$map         = $this->get_country_map();
+
+		foreach ( $map as $name => $code ) {
+			$pattern = '/\b' . preg_quote( $name, '/' ) . '\b/i';
+			if ( preg_match( $pattern, $query_lower ) ) {
+				return $code;
+			}
+		}
+
+		if ( preg_match_all( '/\b([A-Z]{2})\b/', strtoupper( $query ), $matches ) ) {
+			foreach ( $matches[1] as $code ) {
+				if ( isset( $map[ strtolower( $code ) ] ) ) {
+					return $map[ strtolower( $code ) ];
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_country_map() {
+		static $map = null;
+		if ( null !== $map ) {
+			return $map;
+		}
+
+		$countries = array();
+		if ( function_exists( 'WC' ) ) {
+			$wc = WC();
+			if ( $wc && isset( $wc->countries ) && method_exists( $wc->countries, 'get_countries' ) ) {
+				$countries = $wc->countries->get_countries();
+			}
+		}
+
+		if ( empty( $countries ) && class_exists( 'WC_Countries' ) ) {
+			$wc_countries = new \WC_Countries();
+			$countries    = $wc_countries->get_countries();
+		}
+
+		$map = array();
+		if ( is_array( $countries ) ) {
+			foreach ( $countries as $code => $name ) {
+				$map[ strtolower( $name ) ] = strtoupper( $code );
+				$map[ strtolower( $code ) ] = strtoupper( $code );
+			}
+		}
+
+		$map['usa'] = 'US';
+		$map['us']  = 'US';
+		$map['uk']  = 'GB';
+
+		return $map;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_order_country( $order ) {
+		$country = method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '';
+		if ( '' !== $country ) {
+			return $country;
+		}
+
+		if ( method_exists( $order, 'get_billing_country' ) ) {
+			$country = $order->get_billing_country();
+		}
+
+		return is_string( $country ) ? $country : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_draft_id( array $args ) {
+		$draft_id = isset( $args['draft_id'] ) ? $args['draft_id'] : '';
+		if ( '' === $draft_id && isset( $args['params']['draft_id'] ) ) {
+			$draft_id = $args['params']['draft_id'];
+		}
+
+		return is_string( $draft_id ) ? trim( $draft_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_progress_id( array $args ) {
+		$progress_id = isset( $args['progress_id'] ) ? $args['progress_id'] : '';
+		if ( '' === $progress_id && isset( $args['params']['progress_id'] ) ) {
+			$progress_id = $args['params']['progress_id'];
+		}
+
+		return is_string( $progress_id ) ? trim( $progress_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_rollback_id( array $args ) {
+		$rollback_id = isset( $args['rollback_id'] ) ? $args['rollback_id'] : '';
+		if ( '' === $rollback_id && isset( $args['params']['rollback_id'] ) ) {
+			$rollback_id = $args['params']['rollback_id'];
+		}
+
+		return is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+	}
+
+	/**
+	 * @return bool
+	 */
+	private function action_scheduler_available() {
+		return function_exists( 'as_enqueue_async_action' ) || function_exists( 'as_schedule_single_action' );
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return int
+	 */
+	private function schedule_job( $job_id ) {
+		if ( function_exists( 'as_enqueue_async_action' ) ) {
+			return (int) as_enqueue_async_action( self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		if ( function_exists( 'as_schedule_single_action' ) ) {
+			return (int) as_schedule_single_action( time(), self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		return 0;
+	}
+}
diff --git a/src/Plugin.php b/src/Plugin.php
index 01ae991acdb6f0546a735ab888160091c456700a..4751cc435f813540794ea9968e6b5b99ec25ac66
--- a/src/Plugin.php
+++ b/src/Plugin.php
@@ -99,6 +99,10 @@
 			Search\Index::init();
 		}
 
+		if ( class_exists( 'AgentWP\\Handlers\\BulkHandler' ) ) {
+			Handlers\BulkHandler::register_hooks();
+		}
+
 		if ( class_exists( 'AgentWP\\Demo\\Manager' ) ) {
 			Demo\Manager::init();
 		}

file update:
diff --git a/src/Handlers/BulkHandler.php b/src/Handlers/BulkHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..d7994bcd117201a3df0db869c3d04e51a692d784
--- /dev/null
+++ b/src/Handlers/BulkHandler.php
@@ -0,0 +1,2223 @@
+<?php
+/**
+ * Handle bulk order operations.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class BulkHandler {
+	const ACTION_HOOK      = 'agentwp_bulk_process';
+	const ASYNC_THRESHOLD  = 20;
+	const DRAFT_TYPE       = 'bulk_action';
+	const JOB_TTL_SECONDS  = 86400;
+	const MAX_BULK         = 1000;
+	const PROGRESS_TTL     = 86400;
+	const ROLLBACK_TTL     = 86400;
+	const POLL_INTERVAL    = 2;
+
+	/**
+	 * Register background processing hooks.
+	 *
+	 * @return void
+	 */
+	public static function register_hooks() {
+		add_action( self::ACTION_HOOK, array( __CLASS__, 'handle_scheduled_action' ), 10, 1 );
+	}
+
+	/**
+	 * Execute scheduled bulk jobs.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	public static function handle_scheduled_action( $job_id ) {
+		$handler = new self();
+		$handler->process_scheduled_job( $job_id );
+	}
+
+	/**
+	 * Handle bulk actions and selections.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['criteria'] ) ) {
+			return $this->select_orders( $args );
+		}
+
+		$progress_id = $this->extract_progress_id( $args );
+		if ( '' !== $progress_id ) {
+			return $this->get_progress_response( $progress_id );
+		}
+
+		$rollback_id = $this->extract_rollback_id( $args );
+		if ( '' !== $rollback_id ) {
+			return $this->rollback_bulk_action( $rollback_id );
+		}
+
+		$draft_id = $this->extract_draft_id( $args );
+		if ( '' !== $draft_id ) {
+			return $this->confirm_bulk_update( $draft_id );
+		}
+
+		return $this->prepare_bulk_update( $args );
+	}
+
+	/**
+	 * Select orders based on criteria.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function select_orders( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to select orders.', 400 );
+		}
+
+		$criteria  = $this->normalize_criteria( isset( $args['criteria'] ) ? $args['criteria'] : array() );
+		$order_ids = $this->query_order_ids( $criteria );
+		$sample    = $this->build_sample_orders( $order_ids );
+
+		return Response::success(
+			array(
+				'order_ids'  => $order_ids,
+				'count'      => count( $order_ids ),
+				'criteria'   => $criteria,
+				'sample'     => $sample,
+				'truncated'  => count( $order_ids ) >= self::MAX_BULK,
+				'max_limit'  => self::MAX_BULK,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a bulk update draft.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	private function prepare_bulk_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $args['action'] ) ? $args['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Missing or invalid bulk action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $args['params'] ) ? $args['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$missing_orders = $this->find_missing_orders( $order_ids );
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		$sample = $this->build_sample_orders( $order_ids );
+		$preview = array(
+			'order_count'    => count( $order_ids ),
+			'sample'         => $sample,
+			'action'         => $action,
+			'action_preview' => $this->build_action_preview( $action, $params ),
+		);
+
+		$draft_payload = array(
+			'order_ids' => $order_ids,
+			'action'    => $action,
+			'params'    => $params,
+			'preview'   => $preview,
+		);
+
+		$draft_id   = $this->generate_uuid();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a bulk update draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	private function confirm_bulk_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to process bulk updates.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing bulk update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Bulk update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for bulk update confirmation.', 400 );
+		}
+
+		$payload  = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $payload['action'] ) ? $payload['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Bulk update draft is missing an action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $payload['params'] ) ? $payload['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$job_id      = $this->generate_uuid();
+		$progress_id = $this->generate_uuid();
+		$rollback_id = $this->generate_uuid();
+
+		$rollback_expires = gmdate( 'c', time() + self::ROLLBACK_TTL );
+		$this->store_rollback(
+			$rollback_id,
+			array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => $rollback_expires,
+				'orders'     => array(),
+			),
+			self::ROLLBACK_TTL
+		);
+
+		$progress = array(
+			'id'                  => $progress_id,
+			'status'              => 'queued',
+			'action'              => $action,
+			'order_count'         => count( $order_ids ),
+			'processed'           => 0,
+			'updated'             => 0,
+			'failed'              => 0,
+			'errors'              => array(),
+			'created_at'          => gmdate( 'c' ),
+			'started_at'          => '',
+			'last_updated'        => gmdate( 'c' ),
+			'completed_at'        => '',
+			'draft_id'            => $draft_id,
+			'rollback_id'         => $rollback_id,
+			'undo_available_until'=> $rollback_expires,
+		);
+		$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+
+		$job = array(
+			'id'          => $job_id,
+			'order_ids'   => $order_ids,
+			'action'      => $action,
+			'params'      => $params,
+			'progress_id' => $progress_id,
+			'rollback_id' => $rollback_id,
+			'draft_id'    => $draft_id,
+		);
+		$this->store_job( $job_id, $job, self::JOB_TTL_SECONDS );
+
+		$async = count( $order_ids ) > self::ASYNC_THRESHOLD && $this->action_scheduler_available();
+		if ( $async ) {
+			$action_id = $this->schedule_job( $job_id );
+			if ( ! $action_id ) {
+				return Response::error( 'Unable to schedule bulk update.', 500 );
+			}
+
+			$this->delete_draft( $draft_id );
+
+			return Response::success(
+				array(
+					'status'     => 'scheduled',
+					'draft_id'   => $draft_id,
+					'job_id'     => $job_id,
+					'progress'   => $progress,
+					'polling'    => array(
+						'progress_id'      => $progress_id,
+						'interval_seconds' => self::POLL_INTERVAL,
+					),
+					'rollback_id' => $rollback_id,
+					'undo_available_until' => $rollback_expires,
+				)
+			);
+		}
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'     => 'running',
+				'started_at' => gmdate( 'c' ),
+			),
+			true
+		);
+
+		$result = $this->run_bulk_job( $job );
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'       => 'completed',
+				'completed_at' => gmdate( 'c' ),
+				'result'       => $result,
+			),
+			true
+		);
+
+		$this->delete_job( $job_id );
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'status'      => 'completed',
+				'draft_id'    => $draft_id,
+				'result'      => $result,
+				'progress'    => $progress,
+				'polling'     => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+				'rollback_id' => $rollback_id,
+				'undo_available_until' => $rollback_expires,
+			)
+		);
+	}
+
+	/**
+	 * Process a scheduled bulk job.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	private function process_scheduled_job( $job_id ) {
+		$job_id = is_string( $job_id ) ? trim( $job_id ) : '';
+		if ( '' === $job_id ) {
+			return;
+		}
+
+		$job = $this->load_job( $job_id );
+		if ( ! is_array( $job ) ) {
+			return;
+		}
+
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'     => 'running',
+					'started_at' => gmdate( 'c' ),
+				),
+				true
+			);
+		}
+
+		$result = $this->run_bulk_job( $job );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'       => 'completed',
+					'completed_at' => gmdate( 'c' ),
+					'result'       => $result,
+				),
+				true
+			);
+		}
+
+		$draft_id = isset( $job['draft_id'] ) ? (string) $job['draft_id'] : '';
+		if ( '' !== $draft_id ) {
+			$this->delete_draft( $draft_id );
+		}
+
+		$this->delete_job( $job_id );
+	}
+
+	/**
+	 * Execute a bulk job.
+	 *
+	 * @param array $job Job payload.
+	 * @return array
+	 */
+	private function run_bulk_job( array $job ) {
+		$order_ids   = isset( $job['order_ids'] ) ? $this->normalize_order_ids( $job['order_ids'] ) : array();
+		$action      = isset( $job['action'] ) ? $this->normalize_action( $job['action'] ) : '';
+		$params      = isset( $job['params'] ) && is_array( $job['params'] ) ? $job['params'] : array();
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		$rollback_id = isset( $job['rollback_id'] ) ? (string) $job['rollback_id'] : '';
+
+		$result = array(
+			'action'    => $action,
+			'order_ids' => $order_ids,
+			'updated'   => array(),
+			'failed'    => array(),
+			'errors'    => array(),
+		);
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			$rollback = array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => gmdate( 'c', time() + self::ROLLBACK_TTL ),
+				'orders'     => array(),
+			);
+		}
+
+		$processed = 0;
+		$updated   = 0;
+		$failed    = 0;
+		$errors    = array();
+		$rows      = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$processed++;
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed++;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found.',
+				);
+				$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$current_status = $this->normalize_status( $order->get_status() );
+					$new_status     = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+					if ( '' === $new_status ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing target status.',
+						);
+						break;
+					}
+
+					$rollback['orders'][ $order_id ] = array(
+						'status' => $current_status,
+					);
+
+					$note            = isset( $params['note'] ) ? (string) $params['note'] : '';
+					$notify_customer = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+					$updated_flag    = $this->apply_status_update( $order, $new_status, $note, $notify_customer );
+
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to update status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+					$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+					$tags = $this->normalize_tags( $tags, $tag );
+					if ( empty( $tags ) ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing tags to add.',
+						);
+						break;
+					}
+
+					$before_tags = $this->get_order_tags( $order_id );
+					$rollback['orders'][ $order_id ] = array(
+						'tags' => $before_tags,
+					);
+
+					$updated_flag = $this->apply_tags_update( $order, $tags );
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+					if ( '' === $note ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing note content.',
+						);
+						break;
+					}
+
+					$is_customer_note = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+					$note_id          = $this->apply_order_note( $order, $note, $is_customer_note );
+					if ( $note_id > 0 ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+						$rollback['orders'][ $order_id ] = array(
+							'notes' => array( $note_id ),
+						);
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add note.',
+						);
+					}
+					break;
+				case 'export_csv':
+					$rows[] = $this->format_export_row( $order );
+					$updated++;
+					$result['updated'][] = $order_id;
+					break;
+				default:
+					$failed++;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Unsupported bulk action.',
+					);
+			}
+
+			$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+		}
+
+		$result['errors'] = $errors;
+		$result['failed'] = array_unique( array_merge( $result['failed'], wp_list_pluck( $errors, 'order_id' ) ) );
+
+		if ( 'export_csv' === $action ) {
+			$export = $this->export_csv( $rows, isset( $params['fields'] ) ? $params['fields'] : array() );
+			if ( isset( $export['error'] ) ) {
+				$errors[]         = array( 'order_id' => 0, 'message' => $export['error'] );
+				$result['errors'] = $errors;
+			} else {
+				$result['export'] = $export;
+			}
+		}
+
+		$this->store_rollback( $rollback_id, $rollback, self::ROLLBACK_TTL );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'processed' => $processed,
+					'updated'   => $updated,
+					'failed'    => $failed,
+					'errors'    => $errors,
+				),
+				true
+			);
+		}
+
+		return $result;
+	}
+
+	/**
+	 * Provide progress updates to polling clients.
+	 *
+	 * @param string $progress_id Progress identifier.
+	 * @return Response
+	 */
+	private function get_progress_response( $progress_id ): Response {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			return Response::error( 'Bulk progress not found or expired.', 404 );
+		}
+
+		return Response::success(
+			array(
+				'progress' => $progress,
+				'polling'  => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Roll back a bulk action.
+	 *
+	 * @param string $rollback_id Rollback identifier.
+	 * @return Response
+	 */
+	private function rollback_bulk_action( $rollback_id ): Response {
+		$rollback_id = is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+		if ( '' === $rollback_id ) {
+			return Response::error( 'Missing rollback ID.', 400 );
+		}
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			return Response::error( 'Rollback data not found or expired.', 404 );
+		}
+
+		$action  = isset( $rollback['action'] ) ? $this->normalize_action( $rollback['action'] ) : '';
+		$orders  = isset( $rollback['orders'] ) && is_array( $rollback['orders'] ) ? $rollback['orders'] : array();
+		$undone  = array();
+		$failed  = array();
+		$errors  = array();
+
+		foreach ( $orders as $order_id => $data ) {
+			$order_id = absint( $order_id );
+			$order    = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed[] = $order_id;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found for rollback.',
+				);
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$previous_status = isset( $data['status'] ) ? $this->normalize_status( $data['status'] ) : '';
+					if ( '' === $previous_status ) {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing previous status.',
+						);
+						break;
+					}
+
+					$updated = $this->apply_status_update( $order, $previous_status, 'Rollback to previous status.', false );
+					if ( $updated ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore previous status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $data['tags'] ) ? $data['tags'] : array();
+					$restored = $this->restore_order_tags( $order_id, $tags );
+					if ( $restored ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$notes = isset( $data['notes'] ) ? (array) $data['notes'] : array();
+					$deleted = $this->delete_order_notes( $notes );
+					if ( $deleted ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to remove notes.',
+						);
+					}
+					break;
+				default:
+					$failed[] = $order_id;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Rollback not supported for this action.',
+					);
+			}
+		}
+
+		return Response::success(
+			array(
+				'rollback_id' => $rollback_id,
+				'action'      => $action,
+				'undone'      => $undone,
+				'failed'      => $failed,
+				'errors'      => $errors,
+			)
+		);
+	}
+
+	/**
+	 * @param array $criteria Criteria input.
+	 * @return array
+	 */
+	private function normalize_criteria( $criteria ) {
+		$parsed = array(
+			'status'         => '',
+			'date_range'     => null,
+			'customer_email' => '',
+			'total_min'      => null,
+			'total_max'      => null,
+			'country'        => '',
+		);
+		$query  = '';
+
+		if ( is_string( $criteria ) ) {
+			$query = sanitize_text_field( $criteria );
+		} elseif ( is_array( $criteria ) ) {
+			$query = isset( $criteria['query'] ) ? sanitize_text_field( $criteria['query'] ) : '';
+			$parsed['status'] = isset( $criteria['status'] ) ? $this->normalize_status( $criteria['status'] ) : '';
+			$parsed['date_range'] = $this->normalize_date_range_input( isset( $criteria['date_range'] ) ? $criteria['date_range'] : null );
+			$parsed['customer_email'] = isset( $criteria['customer_email'] ) ? sanitize_email( $criteria['customer_email'] ) : '';
+			$parsed['total_min'] = isset( $criteria['total_min'] ) ? $this->normalize_amount( $criteria['total_min'] ) : null;
+			$parsed['total_max'] = isset( $criteria['total_max'] ) ? $this->normalize_amount( $criteria['total_max'] ) : null;
+			$parsed['country'] = isset( $criteria['country'] ) ? $this->normalize_country( $criteria['country'] ) : '';
+		}
+
+		if ( '' !== $query ) {
+			$text_parsed = $this->parse_criteria_text( $query );
+			foreach ( $text_parsed as $key => $value ) {
+				if ( ! isset( $parsed[ $key ] ) || '' === $parsed[ $key ] || null === $parsed[ $key ] ) {
+					$parsed[ $key ] = $value;
+				}
+			}
+		}
+
+		if ( '' === $parsed['status'] ) {
+			unset( $parsed['status'] );
+		}
+		if ( '' === $parsed['customer_email'] ) {
+			unset( $parsed['customer_email'] );
+		}
+		if ( '' === $parsed['country'] ) {
+			unset( $parsed['country'] );
+		}
+		if ( null === $parsed['total_min'] ) {
+			unset( $parsed['total_min'] );
+		}
+		if ( null === $parsed['total_max'] ) {
+			unset( $parsed['total_max'] );
+		}
+		if ( null === $parsed['date_range'] ) {
+			unset( $parsed['date_range'] );
+		}
+
+		return $parsed;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function parse_criteria_text( $query ) {
+		$query  = trim( (string) $query );
+		$lower  = strtolower( $query );
+		$result = array();
+
+		$status = $this->detect_status( $lower );
+		if ( '' !== $status ) {
+			$result['status'] = $status;
+		}
+
+		$date_range = $this->parse_date_range_from_query( $lower );
+		if ( null !== $date_range ) {
+			$result['date_range'] = $date_range;
+		}
+
+		$email = $this->extract_email( $query );
+		if ( '' !== $email ) {
+			$result['customer_email'] = $email;
+		}
+
+		$totals = $this->extract_total_range( $lower );
+		if ( isset( $totals['min'] ) ) {
+			$result['total_min'] = $totals['min'];
+		}
+		if ( isset( $totals['max'] ) ) {
+			$result['total_max'] = $totals['max'];
+		}
+
+		$country = $this->extract_country( $query );
+		if ( '' !== $country ) {
+			$result['country'] = $country;
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param array $criteria Query criteria.
+	 * @return array
+	 */
+	private function query_order_ids( array $criteria ) {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		$args = array(
+			'limit'   => self::MAX_BULK,
+			'return'  => 'ids',
+			'orderby' => 'date',
+			'order'   => 'DESC',
+		);
+
+		if ( isset( $criteria['status'] ) && '' !== $criteria['status'] ) {
+			$args['status'] = $criteria['status'];
+		}
+
+		if ( isset( $criteria['date_range'] ) && is_array( $criteria['date_range'] ) ) {
+			$args['date_created'] = $criteria['date_range']['start'] . '...' . $criteria['date_range']['end'];
+		}
+
+		$meta_query = array( 'relation' => 'AND' );
+
+		if ( isset( $criteria['customer_email'] ) && '' !== $criteria['customer_email'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['country'] ) && '' !== $criteria['country'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['total_min'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_min'],
+				'compare' => '>=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( isset( $criteria['total_max'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_max'],
+				'compare' => '<=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( count( $meta_query ) > 1 ) {
+			$args['meta_query'] = $meta_query;
+		}
+
+		$order_ids = wc_get_orders( $args );
+		if ( ! is_array( $order_ids ) ) {
+			return array();
+		}
+
+		$order_ids = array_map( 'absint', $order_ids );
+		$order_ids = array_filter( $order_ids );
+		$order_ids = array_values( array_unique( $order_ids ) );
+
+		return $order_ids;
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function build_sample_orders( array $order_ids ) {
+		$sample = array();
+		$order_ids = array_slice( $order_ids, 0, 5 );
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( $order ) {
+				$sample[] = $this->format_order_summary( $order );
+			}
+		}
+
+		return $sample;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_order_summary( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'       => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'currency'       => method_exists( $order, 'get_currency' ) ? sanitize_text_field( $order->get_currency() ) : '',
+			'customer_name'  => sanitize_text_field( $this->get_customer_name( $order ) ),
+			'customer_email' => sanitize_email( $this->get_customer_email( $order ) ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'country'        => sanitize_text_field( $this->get_order_country( $order ) ),
+		);
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @param mixed $action Raw action.
+	 * @return string
+	 */
+	private function normalize_action( $action ) {
+		$action = is_string( $action ) ? strtolower( trim( $action ) ) : '';
+		$allowed = array( 'update_status', 'add_tag', 'add_note', 'export_csv' );
+
+		return in_array( $action, $allowed, true ) ? $action : '';
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param mixed  $params Raw params.
+	 * @return array
+	 */
+	private function normalize_params( $action, $params ) {
+		$params = is_array( $params ) ? $params : array();
+		$normalized = array();
+
+		switch ( $action ) {
+			case 'update_status':
+				$new_status = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+				if ( '' === $new_status ) {
+					return array( 'error' => 'Missing new status for bulk update.' );
+				}
+
+				$valid_statuses = $this->get_valid_statuses();
+				if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+					return array( 'error' => 'Invalid status for bulk update.' );
+				}
+
+				$normalized['new_status'] = $new_status;
+				$normalized['note'] = isset( $params['note'] ) ? sanitize_text_field( wp_unslash( $params['note'] ) ) : '';
+				$normalized['notify_customer'] = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+				break;
+			case 'add_tag':
+				$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+				$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+				$normalized['tags'] = $this->normalize_tags( $tags, $tag );
+				if ( empty( $normalized['tags'] ) ) {
+					return array( 'error' => 'Missing tags for bulk update.' );
+				}
+				break;
+			case 'add_note':
+				$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+				if ( '' === $note ) {
+					return array( 'error' => 'Missing note for bulk update.' );
+				}
+				$normalized['note'] = sanitize_text_field( wp_unslash( $note ) );
+				$normalized['is_customer_note'] = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+				break;
+			case 'export_csv':
+				$fields = isset( $params['fields'] ) ? $params['fields'] : array();
+				$normalized['fields'] = $this->normalize_fields( $fields );
+				break;
+			default:
+				return array( 'error' => 'Unsupported bulk action.' );
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param array  $params Params.
+	 * @return array
+	 */
+	private function build_action_preview( $action, array $params ) {
+		switch ( $action ) {
+			case 'update_status':
+				return array(
+					'new_status'      => isset( $params['new_status'] ) ? $params['new_status'] : '',
+					'notify_customer' => ! empty( $params['notify_customer'] ),
+					'note'            => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'add_tag':
+				return array(
+					'tags' => isset( $params['tags'] ) ? $params['tags'] : array(),
+				);
+			case 'add_note':
+				return array(
+					'note' => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'export_csv':
+				return array(
+					'fields' => isset( $params['fields'] ) ? $params['fields'] : $this->normalize_fields( array() ),
+				);
+			default:
+				return array();
+		}
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function find_missing_orders( array $order_ids ) {
+		$missing = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$missing[] = $order_id;
+			}
+		}
+
+		return $missing;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @param int    $processed Processed count.
+	 * @param int    $updated Updated count.
+	 * @param int    $failed Failed count.
+	 * @param array  $errors Error list.
+	 * @return void
+	 */
+	private function maybe_update_progress( $progress_id, $processed, $updated, $failed, array $errors ) {
+		if ( '' === $progress_id ) {
+			return;
+		}
+
+		$this->update_progress(
+			$progress_id,
+			array(
+				'processed' => $processed,
+				'updated'   => $updated,
+				'failed'    => $failed,
+				'errors'    => $errors,
+			),
+			false
+		);
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $updates Updates.
+	 * @param bool   $force Force update.
+	 * @return array
+	 */
+	private function update_progress( $progress_id, array $updates, $force ) {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			$progress = array(
+				'id'           => $progress_id,
+				'status'       => 'queued',
+				'processed'    => 0,
+				'updated'      => 0,
+				'failed'       => 0,
+				'errors'       => array(),
+				'created_at'   => gmdate( 'c' ),
+				'last_updated' => gmdate( 'c' ),
+			);
+		}
+
+		$last_updated = isset( $progress['last_updated'] ) ? strtotime( $progress['last_updated'] ) : 0;
+		$should_update = $force || ( time() - $last_updated >= self::POLL_INTERVAL );
+
+		foreach ( $updates as $key => $value ) {
+			$progress[ $key ] = $value;
+		}
+
+		if ( $should_update ) {
+			$progress['last_updated'] = gmdate( 'c' );
+			$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @return array|null
+	 */
+	private function load_progress( $progress_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$progress = get_transient( $this->build_progress_key( $progress_id ) );
+		if ( false === $progress || ! is_array( $progress ) ) {
+			return null;
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $progress Progress payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_progress( $progress_id, array $progress, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_progress_key( $progress_id ), $progress, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return array|null
+	 */
+	private function load_job( $job_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$job = get_transient( $this->build_job_key( $job_id ) );
+		if ( false === $job || ! is_array( $job ) ) {
+			return null;
+		}
+
+		return $job;
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @param array  $job Job payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_job( $job_id, array $job, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_job_key( $job_id ), $job, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return void
+	 */
+	private function delete_job( $job_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_job_key( $job_id ) );
+		}
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @return array|null
+	 */
+	private function load_rollback( $rollback_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$rollback = get_transient( $this->build_rollback_key( $rollback_id ) );
+		if ( false === $rollback || ! is_array( $rollback ) ) {
+			return null;
+		}
+
+		return $rollback;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @param array  $rollback Rollback data.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_rollback( $rollback_id, array $rollback, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_rollback_key( $rollback_id ), $rollback, $ttl );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_uuid() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'bulk_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_draft_' . $draft_id;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @return string
+	 */
+	private function build_progress_key( $progress_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_progress_' . $progress_id;
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return string
+	 */
+	private function build_job_key( $job_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_job_' . $job_id;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback identifier.
+	 * @return string
+	 */
+	private function build_rollback_key( $rollback_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_rollback_' . $rollback_id;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param mixed $status Raw status.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float|null
+	 */
+	private function normalize_amount( $amount ) {
+		if ( null === $amount || '' === $amount ) {
+			return null;
+		}
+
+		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $country Country input.
+	 * @return string
+	 */
+	private function normalize_country( $country ) {
+		$country = is_string( $country ) ? strtoupper( trim( $country ) ) : '';
+		if ( '' === $country ) {
+			return '';
+		}
+
+		if ( strlen( $country ) === 2 ) {
+			return $country;
+		}
+
+		$map = $this->get_country_map();
+		$key = strtolower( $country );
+
+		return isset( $map[ $key ] ) ? $map[ $key ] : '';
+	}
+
+	/**
+	 * @param mixed $tags Tags list.
+	 * @param mixed $tag Single tag.
+	 * @return array
+	 */
+	private function normalize_tags( $tags, $tag ) {
+		$list = array();
+
+		if ( is_string( $tags ) ) {
+			$tags = preg_split( '/[\s,]+/', $tags );
+		}
+
+		if ( is_array( $tags ) ) {
+			foreach ( $tags as $item ) {
+				$item = sanitize_text_field( (string) $item );
+				if ( '' !== $item ) {
+					$list[] = $item;
+				}
+			}
+		}
+
+		if ( is_string( $tag ) ) {
+			$tag = sanitize_text_field( $tag );
+			if ( '' !== $tag ) {
+				$list[] = $tag;
+			}
+		}
+
+		$list = array_values( array_unique( $list ) );
+
+		return $list;
+	}
+
+	/**
+	 * @param mixed $fields Fields input.
+	 * @return array
+	 */
+	private function normalize_fields( $fields ) {
+		$default = array( 'order_id', 'status', 'total', 'currency', 'customer_name', 'customer_email', 'date_created', 'billing_country', 'shipping_country' );
+		if ( empty( $fields ) ) {
+			return $default;
+		}
+
+		if ( is_string( $fields ) ) {
+			$fields = preg_split( '/[\s,]+/', $fields );
+		}
+
+		if ( ! is_array( $fields ) ) {
+			return $default;
+		}
+
+		$sanitized = array();
+		foreach ( $fields as $field ) {
+			$field = sanitize_key( $field );
+			if ( '' !== $field ) {
+				$sanitized[] = $field;
+			}
+		}
+
+		return array_values( array_unique( $sanitized ) );
+	}
+
+	/**
+	 * @param array $order Order object.
+	 * @param string $new_status New status.
+	 * @param string $note Note for audit.
+	 * @param bool $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $current_status === $new_status ) {
+			return false;
+		}
+
+		$note = trim( (string) $note );
+		$audit_note = sprintf( '[AgentWP] Bulk status update: %s -> %s.', $current_status, $new_status );
+		if ( '' !== $note ) {
+			$audit_note .= ' Note: ' . $note . '.';
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $audit_note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param array  $tags Tags to add.
+	 * @return bool
+	 */
+	private function apply_tags_update( $order, array $tags ) {
+		$order_id = method_exists( $order, 'get_id' ) ? $order->get_id() : 0;
+		if ( $order_id <= 0 ) {
+			return false;
+		}
+
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				$existing = array();
+			}
+			$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+			wp_set_object_terms( $order_id, $merged, $taxonomy, false );
+			return true;
+		}
+
+		if ( ! method_exists( $order, 'get_meta' ) || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			$existing = array();
+		}
+
+		$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+		$order->update_meta_data( '_agentwp_order_tags', $merged );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param string $note Note text.
+	 * @param bool   $is_customer_note Customer visibility.
+	 * @return int
+	 */
+	private function apply_order_note( $order, $note, $is_customer_note ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return 0;
+		}
+
+		$note = trim( (string) $note );
+		if ( '' === $note ) {
+			return 0;
+		}
+
+		$note_id = $order->add_order_note( $note, $is_customer_note );
+
+		return absint( $note_id );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_export_row( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'        => intval( $order->get_id() ),
+			'status'          => sanitize_text_field( $order->get_status() ),
+			'total'           => $order->get_total(),
+			'currency'        => method_exists( $order, 'get_currency' ) ? $order->get_currency() : '',
+			'customer_name'   => $this->get_customer_name( $order ),
+			'customer_email'  => $this->get_customer_email( $order ),
+			'date_created'    => $date_created ? $date_created->date( 'c' ) : '',
+			'billing_country' => method_exists( $order, 'get_billing_country' ) ? $order->get_billing_country() : '',
+			'shipping_country'=> method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '',
+		);
+	}
+
+	/**
+	 * @param array $rows Data rows.
+	 * @param array $fields Fields list.
+	 * @return array
+	 */
+	private function export_csv( array $rows, array $fields ) {
+		if ( ! function_exists( 'wp_upload_dir' ) ) {
+			return array( 'error' => 'Unable to export CSV in this environment.' );
+		}
+
+		$fields = $this->normalize_fields( $fields );
+		$upload = wp_upload_dir();
+		$base   = isset( $upload['basedir'] ) ? $upload['basedir'] : '';
+		$url    = isset( $upload['baseurl'] ) ? $upload['baseurl'] : '';
+
+		if ( '' === $base || '' === $url ) {
+			return array( 'error' => 'Unable to resolve upload directory.' );
+		}
+
+		$dir = trailingslashit( $base ) . 'agentwp-exports';
+		if ( function_exists( 'wp_mkdir_p' ) ) {
+			wp_mkdir_p( $dir );
+		}
+
+		$filename = 'agentwp-bulk-export-' . gmdate( 'Ymd-His' ) . '-' . wp_generate_password( 6, false ) . '.csv';
+		$path     = trailingslashit( $dir ) . $filename;
+		$file     = @fopen( $path, 'w' );
+		if ( ! $file ) {
+			return array( 'error' => 'Unable to create CSV export file.' );
+		}
+
+		fputcsv( $file, $fields );
+		foreach ( $rows as $row ) {
+			$line = array();
+			foreach ( $fields as $field ) {
+				$line[] = isset( $row[ $field ] ) ? $row[ $field ] : '';
+			}
+			fputcsv( $file, $line );
+		}
+
+		fclose( $file );
+
+		return array(
+			'file_path' => $path,
+			'file_url'  => trailingslashit( $url ) . 'agentwp-exports/' . $filename,
+			'rows'      => count( $rows ),
+		);
+	}
+
+	/**
+	 * @param int $order_id Order ID.
+	 * @return array
+	 */
+	private function get_order_tags( $order_id ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				return array();
+			}
+			return $existing;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'get_meta' ) ) {
+			return array();
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			return array();
+		}
+
+		return $existing;
+	}
+
+	/**
+	 * @param int   $order_id Order ID.
+	 * @param array $tags Tags.
+	 * @return bool
+	 */
+	private function restore_order_tags( $order_id, $tags ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			wp_set_object_terms( $order_id, (array) $tags, $taxonomy, false );
+			return true;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$order->update_meta_data( '_agentwp_order_tags', (array) $tags );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param array $note_ids Note IDs.
+	 * @return bool
+	 */
+	private function delete_order_notes( array $note_ids ) {
+		if ( ! function_exists( 'wp_delete_comment' ) ) {
+			return false;
+		}
+
+		$deleted_any = false;
+		foreach ( $note_ids as $note_id ) {
+			$note_id = absint( $note_id );
+			if ( $note_id > 0 ) {
+				wp_delete_comment( $note_id, true );
+				$deleted_any = true;
+			}
+		}
+
+		return $deleted_any;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function get_order_tag_taxonomy() {
+		$taxonomy = apply_filters( 'agentwp_order_tag_taxonomy', 'shop_order_tag' );
+		$taxonomy = is_string( $taxonomy ) ? trim( $taxonomy ) : '';
+
+		if ( '' !== $taxonomy && function_exists( 'taxonomy_exists' ) && taxonomy_exists( $taxonomy ) ) {
+			return $taxonomy;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param array|null $date_range Date range input.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query text.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date.
+	 * @param string $end End date.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Date string.
+	 * @param bool   $end_of_day End of day flag.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		$date = $end_of_day ? $date->setTime( 23, 59, 59 ) : $date->setTime( 0, 0, 0 );
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function extract_total_range( $query ) {
+		$result = array();
+
+		if ( preg_match( '/\bbetween\s+[\$£\x{20AC}]?([0-9\.,]+)\s+(?:and|to)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+			return $result;
+		}
+
+		if ( preg_match( '/\b(over|above|more than|greater than|at least|minimum|min)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b(under|below|less than|at most|maximum|max)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b>=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		if ( preg_match( '/\b<=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param string $value Amount string.
+	 * @return float|null
+	 */
+	private function parse_amount_string( $value ) {
+		$value = str_replace( array( ',', ' ' ), '', (string) $value );
+		return $this->normalize_amount( $value );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_country( $query ) {
+		$query_lower = strtolower( $query );
+		$map         = $this->get_country_map();
+
+		foreach ( $map as $name => $code ) {
+			$pattern = '/\b' . preg_quote( $name, '/' ) . '\b/i';
+			if ( preg_match( $pattern, $query_lower ) ) {
+				return $code;
+			}
+		}
+
+		if ( preg_match_all( '/\b([A-Z]{2})\b/', strtoupper( $query ), $matches ) ) {
+			foreach ( $matches[1] as $code ) {
+				if ( isset( $map[ strtolower( $code ) ] ) ) {
+					return $map[ strtolower( $code ) ];
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_country_map() {
+		static $map = null;
+		if ( null !== $map ) {
+			return $map;
+		}
+
+		$countries = array();
+		if ( function_exists( 'WC' ) ) {
+			$wc = WC();
+			if ( $wc && isset( $wc->countries ) && method_exists( $wc->countries, 'get_countries' ) ) {
+				$countries = $wc->countries->get_countries();
+			}
+		}
+
+		if ( empty( $countries ) && class_exists( 'WC_Countries' ) ) {
+			$wc_countries = new \WC_Countries();
+			$countries    = $wc_countries->get_countries();
+		}
+
+		$map = array();
+		if ( is_array( $countries ) ) {
+			foreach ( $countries as $code => $name ) {
+				$map[ strtolower( $name ) ] = strtoupper( $code );
+				$map[ strtolower( $code ) ] = strtoupper( $code );
+			}
+		}
+
+		$map['usa'] = 'US';
+		$map['us']  = 'US';
+		$map['uk']  = 'GB';
+
+		return $map;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_order_country( $order ) {
+		$country = method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '';
+		if ( '' !== $country ) {
+			return $country;
+		}
+
+		if ( method_exists( $order, 'get_billing_country' ) ) {
+			$country = $order->get_billing_country();
+		}
+
+		return is_string( $country ) ? $country : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_draft_id( array $args ) {
+		$draft_id = isset( $args['draft_id'] ) ? $args['draft_id'] : '';
+		if ( '' === $draft_id && isset( $args['params']['draft_id'] ) ) {
+			$draft_id = $args['params']['draft_id'];
+		}
+
+		return is_string( $draft_id ) ? trim( $draft_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_progress_id( array $args ) {
+		$progress_id = isset( $args['progress_id'] ) ? $args['progress_id'] : '';
+		if ( '' === $progress_id && isset( $args['params']['progress_id'] ) ) {
+			$progress_id = $args['params']['progress_id'];
+		}
+
+		return is_string( $progress_id ) ? trim( $progress_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_rollback_id( array $args ) {
+		$rollback_id = isset( $args['rollback_id'] ) ? $args['rollback_id'] : '';
+		if ( '' === $rollback_id && isset( $args['params']['rollback_id'] ) ) {
+			$rollback_id = $args['params']['rollback_id'];
+		}
+
+		return is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+	}
+
+	/**
+	 * @return bool
+	 */
+	private function action_scheduler_available() {
+		return function_exists( 'as_enqueue_async_action' ) || function_exists( 'as_schedule_single_action' );
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return int
+	 */
+	private function schedule_job( $job_id ) {
+		if ( function_exists( 'as_enqueue_async_action' ) ) {
+			return (int) as_enqueue_async_action( self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		if ( function_exists( 'as_schedule_single_action' ) ) {
+			return (int) as_schedule_single_action( time(), self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		return 0;
+	}
+}
diff --git a/src/Plugin.php b/src/Plugin.php
index 01ae991acdb6f0546a735ab888160091c456700a..4751cc435f813540794ea9968e6b5b99ec25ac66
--- a/src/Plugin.php
+++ b/src/Plugin.php
@@ -99,6 +99,10 @@
 			Search\Index::init();
 		}
 
+		if ( class_exists( 'AgentWP\\Handlers\\BulkHandler' ) ) {
+			Handlers\BulkHandler::register_hooks();
+		}
+
 		if ( class_exists( 'AgentWP\\Demo\\Manager' ) ) {
 			Demo\Manager::init();
 		}


thinking
**Reviewing BulkHandler and criteria normalization**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/BulkHandler.php
@@ -1404,3 +1404,11 @@
 
-		$amount   = is_numeric( $amount ) ? (float) $amount : 0.0;
+		if ( is_string( $amount ) ) {
+			$amount = preg_replace( '/[^0-9\.\-]/', '', $amount );
+		}
+
+		if ( '' === $amount || ! is_numeric( $amount ) ) {
+			return null;
+		}
+
+		$amount   = (float) $amount;
 		$decimals = $this->get_price_decimals();
apply_patch(auto_approved=true) exited 0 in 38ms:
Success. Updated the following files:
M src/Handlers/BulkHandler.php
file update:
diff --git a/src/Handlers/BulkHandler.php b/src/Handlers/BulkHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..f071e1fb69c964afa98618d7baaf75fcceab1807
--- /dev/null
+++ b/src/Handlers/BulkHandler.php
@@ -0,0 +1,2231 @@
+<?php
+/**
+ * Handle bulk order operations.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class BulkHandler {
+	const ACTION_HOOK      = 'agentwp_bulk_process';
+	const ASYNC_THRESHOLD  = 20;
+	const DRAFT_TYPE       = 'bulk_action';
+	const JOB_TTL_SECONDS  = 86400;
+	const MAX_BULK         = 1000;
+	const PROGRESS_TTL     = 86400;
+	const ROLLBACK_TTL     = 86400;
+	const POLL_INTERVAL    = 2;
+
+	/**
+	 * Register background processing hooks.
+	 *
+	 * @return void
+	 */
+	public static function register_hooks() {
+		add_action( self::ACTION_HOOK, array( __CLASS__, 'handle_scheduled_action' ), 10, 1 );
+	}
+
+	/**
+	 * Execute scheduled bulk jobs.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	public static function handle_scheduled_action( $job_id ) {
+		$handler = new self();
+		$handler->process_scheduled_job( $job_id );
+	}
+
+	/**
+	 * Handle bulk actions and selections.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['criteria'] ) ) {
+			return $this->select_orders( $args );
+		}
+
+		$progress_id = $this->extract_progress_id( $args );
+		if ( '' !== $progress_id ) {
+			return $this->get_progress_response( $progress_id );
+		}
+
+		$rollback_id = $this->extract_rollback_id( $args );
+		if ( '' !== $rollback_id ) {
+			return $this->rollback_bulk_action( $rollback_id );
+		}
+
+		$draft_id = $this->extract_draft_id( $args );
+		if ( '' !== $draft_id ) {
+			return $this->confirm_bulk_update( $draft_id );
+		}
+
+		return $this->prepare_bulk_update( $args );
+	}
+
+	/**
+	 * Select orders based on criteria.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function select_orders( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to select orders.', 400 );
+		}
+
+		$criteria  = $this->normalize_criteria( isset( $args['criteria'] ) ? $args['criteria'] : array() );
+		$order_ids = $this->query_order_ids( $criteria );
+		$sample    = $this->build_sample_orders( $order_ids );
+
+		return Response::success(
+			array(
+				'order_ids'  => $order_ids,
+				'count'      => count( $order_ids ),
+				'criteria'   => $criteria,
+				'sample'     => $sample,
+				'truncated'  => count( $order_ids ) >= self::MAX_BULK,
+				'max_limit'  => self::MAX_BULK,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a bulk update draft.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	private function prepare_bulk_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $args['action'] ) ? $args['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Missing or invalid bulk action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $args['params'] ) ? $args['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$missing_orders = $this->find_missing_orders( $order_ids );
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		$sample = $this->build_sample_orders( $order_ids );
+		$preview = array(
+			'order_count'    => count( $order_ids ),
+			'sample'         => $sample,
+			'action'         => $action,
+			'action_preview' => $this->build_action_preview( $action, $params ),
+		);
+
+		$draft_payload = array(
+			'order_ids' => $order_ids,
+			'action'    => $action,
+			'params'    => $params,
+			'preview'   => $preview,
+		);
+
+		$draft_id   = $this->generate_uuid();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a bulk update draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	private function confirm_bulk_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to process bulk updates.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing bulk update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Bulk update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for bulk update confirmation.', 400 );
+		}
+
+		$payload  = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $payload['action'] ) ? $payload['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Bulk update draft is missing an action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $payload['params'] ) ? $payload['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$job_id      = $this->generate_uuid();
+		$progress_id = $this->generate_uuid();
+		$rollback_id = $this->generate_uuid();
+
+		$rollback_expires = gmdate( 'c', time() + self::ROLLBACK_TTL );
+		$this->store_rollback(
+			$rollback_id,
+			array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => $rollback_expires,
+				'orders'     => array(),
+			),
+			self::ROLLBACK_TTL
+		);
+
+		$progress = array(
+			'id'                  => $progress_id,
+			'status'              => 'queued',
+			'action'              => $action,
+			'order_count'         => count( $order_ids ),
+			'processed'           => 0,
+			'updated'             => 0,
+			'failed'              => 0,
+			'errors'              => array(),
+			'created_at'          => gmdate( 'c' ),
+			'started_at'          => '',
+			'last_updated'        => gmdate( 'c' ),
+			'completed_at'        => '',
+			'draft_id'            => $draft_id,
+			'rollback_id'         => $rollback_id,
+			'undo_available_until'=> $rollback_expires,
+		);
+		$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+
+		$job = array(
+			'id'          => $job_id,
+			'order_ids'   => $order_ids,
+			'action'      => $action,
+			'params'      => $params,
+			'progress_id' => $progress_id,
+			'rollback_id' => $rollback_id,
+			'draft_id'    => $draft_id,
+		);
+		$this->store_job( $job_id, $job, self::JOB_TTL_SECONDS );
+
+		$async = count( $order_ids ) > self::ASYNC_THRESHOLD && $this->action_scheduler_available();
+		if ( $async ) {
+			$action_id = $this->schedule_job( $job_id );
+			if ( ! $action_id ) {
+				return Response::error( 'Unable to schedule bulk update.', 500 );
+			}
+
+			$this->delete_draft( $draft_id );
+
+			return Response::success(
+				array(
+					'status'     => 'scheduled',
+					'draft_id'   => $draft_id,
+					'job_id'     => $job_id,
+					'progress'   => $progress,
+					'polling'    => array(
+						'progress_id'      => $progress_id,
+						'interval_seconds' => self::POLL_INTERVAL,
+					),
+					'rollback_id' => $rollback_id,
+					'undo_available_until' => $rollback_expires,
+				)
+			);
+		}
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'     => 'running',
+				'started_at' => gmdate( 'c' ),
+			),
+			true
+		);
+
+		$result = $this->run_bulk_job( $job );
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'       => 'completed',
+				'completed_at' => gmdate( 'c' ),
+				'result'       => $result,
+			),
+			true
+		);
+
+		$this->delete_job( $job_id );
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'status'      => 'completed',
+				'draft_id'    => $draft_id,
+				'result'      => $result,
+				'progress'    => $progress,
+				'polling'     => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+				'rollback_id' => $rollback_id,
+				'undo_available_until' => $rollback_expires,
+			)
+		);
+	}
+
+	/**
+	 * Process a scheduled bulk job.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	private function process_scheduled_job( $job_id ) {
+		$job_id = is_string( $job_id ) ? trim( $job_id ) : '';
+		if ( '' === $job_id ) {
+			return;
+		}
+
+		$job = $this->load_job( $job_id );
+		if ( ! is_array( $job ) ) {
+			return;
+		}
+
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'     => 'running',
+					'started_at' => gmdate( 'c' ),
+				),
+				true
+			);
+		}
+
+		$result = $this->run_bulk_job( $job );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'       => 'completed',
+					'completed_at' => gmdate( 'c' ),
+					'result'       => $result,
+				),
+				true
+			);
+		}
+
+		$draft_id = isset( $job['draft_id'] ) ? (string) $job['draft_id'] : '';
+		if ( '' !== $draft_id ) {
+			$this->delete_draft( $draft_id );
+		}
+
+		$this->delete_job( $job_id );
+	}
+
+	/**
+	 * Execute a bulk job.
+	 *
+	 * @param array $job Job payload.
+	 * @return array
+	 */
+	private function run_bulk_job( array $job ) {
+		$order_ids   = isset( $job['order_ids'] ) ? $this->normalize_order_ids( $job['order_ids'] ) : array();
+		$action      = isset( $job['action'] ) ? $this->normalize_action( $job['action'] ) : '';
+		$params      = isset( $job['params'] ) && is_array( $job['params'] ) ? $job['params'] : array();
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		$rollback_id = isset( $job['rollback_id'] ) ? (string) $job['rollback_id'] : '';
+
+		$result = array(
+			'action'    => $action,
+			'order_ids' => $order_ids,
+			'updated'   => array(),
+			'failed'    => array(),
+			'errors'    => array(),
+		);
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			$rollback = array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => gmdate( 'c', time() + self::ROLLBACK_TTL ),
+				'orders'     => array(),
+			);
+		}
+
+		$processed = 0;
+		$updated   = 0;
+		$failed    = 0;
+		$errors    = array();
+		$rows      = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$processed++;
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed++;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found.',
+				);
+				$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$current_status = $this->normalize_status( $order->get_status() );
+					$new_status     = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+					if ( '' === $new_status ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing target status.',
+						);
+						break;
+					}
+
+					$rollback['orders'][ $order_id ] = array(
+						'status' => $current_status,
+					);
+
+					$note            = isset( $params['note'] ) ? (string) $params['note'] : '';
+					$notify_customer = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+					$updated_flag    = $this->apply_status_update( $order, $new_status, $note, $notify_customer );
+
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to update status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+					$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+					$tags = $this->normalize_tags( $tags, $tag );
+					if ( empty( $tags ) ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing tags to add.',
+						);
+						break;
+					}
+
+					$before_tags = $this->get_order_tags( $order_id );
+					$rollback['orders'][ $order_id ] = array(
+						'tags' => $before_tags,
+					);
+
+					$updated_flag = $this->apply_tags_update( $order, $tags );
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+					if ( '' === $note ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing note content.',
+						);
+						break;
+					}
+
+					$is_customer_note = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+					$note_id          = $this->apply_order_note( $order, $note, $is_customer_note );
+					if ( $note_id > 0 ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+						$rollback['orders'][ $order_id ] = array(
+							'notes' => array( $note_id ),
+						);
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add note.',
+						);
+					}
+					break;
+				case 'export_csv':
+					$rows[] = $this->format_export_row( $order );
+					$updated++;
+					$result['updated'][] = $order_id;
+					break;
+				default:
+					$failed++;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Unsupported bulk action.',
+					);
+			}
+
+			$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+		}
+
+		$result['errors'] = $errors;
+		$result['failed'] = array_unique( array_merge( $result['failed'], wp_list_pluck( $errors, 'order_id' ) ) );
+
+		if ( 'export_csv' === $action ) {
+			$export = $this->export_csv( $rows, isset( $params['fields'] ) ? $params['fields'] : array() );
+			if ( isset( $export['error'] ) ) {
+				$errors[]         = array( 'order_id' => 0, 'message' => $export['error'] );
+				$result['errors'] = $errors;
+			} else {
+				$result['export'] = $export;
+			}
+		}
+
+		$this->store_rollback( $rollback_id, $rollback, self::ROLLBACK_TTL );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'processed' => $processed,
+					'updated'   => $updated,
+					'failed'    => $failed,
+					'errors'    => $errors,
+				),
+				true
+			);
+		}
+
+		return $result;
+	}
+
+	/**
+	 * Provide progress updates to polling clients.
+	 *
+	 * @param string $progress_id Progress identifier.
+	 * @return Response
+	 */
+	private function get_progress_response( $progress_id ): Response {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			return Response::error( 'Bulk progress not found or expired.', 404 );
+		}
+
+		return Response::success(
+			array(
+				'progress' => $progress,
+				'polling'  => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Roll back a bulk action.
+	 *
+	 * @param string $rollback_id Rollback identifier.
+	 * @return Response
+	 */
+	private function rollback_bulk_action( $rollback_id ): Response {
+		$rollback_id = is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+		if ( '' === $rollback_id ) {
+			return Response::error( 'Missing rollback ID.', 400 );
+		}
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			return Response::error( 'Rollback data not found or expired.', 404 );
+		}
+
+		$action  = isset( $rollback['action'] ) ? $this->normalize_action( $rollback['action'] ) : '';
+		$orders  = isset( $rollback['orders'] ) && is_array( $rollback['orders'] ) ? $rollback['orders'] : array();
+		$undone  = array();
+		$failed  = array();
+		$errors  = array();
+
+		foreach ( $orders as $order_id => $data ) {
+			$order_id = absint( $order_id );
+			$order    = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed[] = $order_id;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found for rollback.',
+				);
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$previous_status = isset( $data['status'] ) ? $this->normalize_status( $data['status'] ) : '';
+					if ( '' === $previous_status ) {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing previous status.',
+						);
+						break;
+					}
+
+					$updated = $this->apply_status_update( $order, $previous_status, 'Rollback to previous status.', false );
+					if ( $updated ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore previous status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $data['tags'] ) ? $data['tags'] : array();
+					$restored = $this->restore_order_tags( $order_id, $tags );
+					if ( $restored ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$notes = isset( $data['notes'] ) ? (array) $data['notes'] : array();
+					$deleted = $this->delete_order_notes( $notes );
+					if ( $deleted ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to remove notes.',
+						);
+					}
+					break;
+				default:
+					$failed[] = $order_id;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Rollback not supported for this action.',
+					);
+			}
+		}
+
+		return Response::success(
+			array(
+				'rollback_id' => $rollback_id,
+				'action'      => $action,
+				'undone'      => $undone,
+				'failed'      => $failed,
+				'errors'      => $errors,
+			)
+		);
+	}
+
+	/**
+	 * @param array $criteria Criteria input.
+	 * @return array
+	 */
+	private function normalize_criteria( $criteria ) {
+		$parsed = array(
+			'status'         => '',
+			'date_range'     => null,
+			'customer_email' => '',
+			'total_min'      => null,
+			'total_max'      => null,
+			'country'        => '',
+		);
+		$query  = '';
+
+		if ( is_string( $criteria ) ) {
+			$query = sanitize_text_field( $criteria );
+		} elseif ( is_array( $criteria ) ) {
+			$query = isset( $criteria['query'] ) ? sanitize_text_field( $criteria['query'] ) : '';
+			$parsed['status'] = isset( $criteria['status'] ) ? $this->normalize_status( $criteria['status'] ) : '';
+			$parsed['date_range'] = $this->normalize_date_range_input( isset( $criteria['date_range'] ) ? $criteria['date_range'] : null );
+			$parsed['customer_email'] = isset( $criteria['customer_email'] ) ? sanitize_email( $criteria['customer_email'] ) : '';
+			$parsed['total_min'] = isset( $criteria['total_min'] ) ? $this->normalize_amount( $criteria['total_min'] ) : null;
+			$parsed['total_max'] = isset( $criteria['total_max'] ) ? $this->normalize_amount( $criteria['total_max'] ) : null;
+			$parsed['country'] = isset( $criteria['country'] ) ? $this->normalize_country( $criteria['country'] ) : '';
+		}
+
+		if ( '' !== $query ) {
+			$text_parsed = $this->parse_criteria_text( $query );
+			foreach ( $text_parsed as $key => $value ) {
+				if ( ! isset( $parsed[ $key ] ) || '' === $parsed[ $key ] || null === $parsed[ $key ] ) {
+					$parsed[ $key ] = $value;
+				}
+			}
+		}
+
+		if ( '' === $parsed['status'] ) {
+			unset( $parsed['status'] );
+		}
+		if ( '' === $parsed['customer_email'] ) {
+			unset( $parsed['customer_email'] );
+		}
+		if ( '' === $parsed['country'] ) {
+			unset( $parsed['country'] );
+		}
+		if ( null === $parsed['total_min'] ) {
+			unset( $parsed['total_min'] );
+		}
+		if ( null === $parsed['total_max'] ) {
+			unset( $parsed['total_max'] );
+		}
+		if ( null === $parsed['date_range'] ) {
+			unset( $parsed['date_range'] );
+		}
+
+		return $parsed;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function parse_criteria_text( $query ) {
+		$query  = trim( (string) $query );
+		$lower  = strtolower( $query );
+		$result = array();
+
+		$status = $this->detect_status( $lower );
+		if ( '' !== $status ) {
+			$result['status'] = $status;
+		}
+
+		$date_range = $this->parse_date_range_from_query( $lower );
+		if ( null !== $date_range ) {
+			$result['date_range'] = $date_range;
+		}
+
+		$email = $this->extract_email( $query );
+		if ( '' !== $email ) {
+			$result['customer_email'] = $email;
+		}
+
+		$totals = $this->extract_total_range( $lower );
+		if ( isset( $totals['min'] ) ) {
+			$result['total_min'] = $totals['min'];
+		}
+		if ( isset( $totals['max'] ) ) {
+			$result['total_max'] = $totals['max'];
+		}
+
+		$country = $this->extract_country( $query );
+		if ( '' !== $country ) {
+			$result['country'] = $country;
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param array $criteria Query criteria.
+	 * @return array
+	 */
+	private function query_order_ids( array $criteria ) {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		$args = array(
+			'limit'   => self::MAX_BULK,
+			'return'  => 'ids',
+			'orderby' => 'date',
+			'order'   => 'DESC',
+		);
+
+		if ( isset( $criteria['status'] ) && '' !== $criteria['status'] ) {
+			$args['status'] = $criteria['status'];
+		}
+
+		if ( isset( $criteria['date_range'] ) && is_array( $criteria['date_range'] ) ) {
+			$args['date_created'] = $criteria['date_range']['start'] . '...' . $criteria['date_range']['end'];
+		}
+
+		$meta_query = array( 'relation' => 'AND' );
+
+		if ( isset( $criteria['customer_email'] ) && '' !== $criteria['customer_email'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['country'] ) && '' !== $criteria['country'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['total_min'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_min'],
+				'compare' => '>=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( isset( $criteria['total_max'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_max'],
+				'compare' => '<=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( count( $meta_query ) > 1 ) {
+			$args['meta_query'] = $meta_query;
+		}
+
+		$order_ids = wc_get_orders( $args );
+		if ( ! is_array( $order_ids ) ) {
+			return array();
+		}
+
+		$order_ids = array_map( 'absint', $order_ids );
+		$order_ids = array_filter( $order_ids );
+		$order_ids = array_values( array_unique( $order_ids ) );
+
+		return $order_ids;
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function build_sample_orders( array $order_ids ) {
+		$sample = array();
+		$order_ids = array_slice( $order_ids, 0, 5 );
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( $order ) {
+				$sample[] = $this->format_order_summary( $order );
+			}
+		}
+
+		return $sample;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_order_summary( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'       => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'currency'       => method_exists( $order, 'get_currency' ) ? sanitize_text_field( $order->get_currency() ) : '',
+			'customer_name'  => sanitize_text_field( $this->get_customer_name( $order ) ),
+			'customer_email' => sanitize_email( $this->get_customer_email( $order ) ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'country'        => sanitize_text_field( $this->get_order_country( $order ) ),
+		);
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @param mixed $action Raw action.
+	 * @return string
+	 */
+	private function normalize_action( $action ) {
+		$action = is_string( $action ) ? strtolower( trim( $action ) ) : '';
+		$allowed = array( 'update_status', 'add_tag', 'add_note', 'export_csv' );
+
+		return in_array( $action, $allowed, true ) ? $action : '';
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param mixed  $params Raw params.
+	 * @return array
+	 */
+	private function normalize_params( $action, $params ) {
+		$params = is_array( $params ) ? $params : array();
+		$normalized = array();
+
+		switch ( $action ) {
+			case 'update_status':
+				$new_status = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+				if ( '' === $new_status ) {
+					return array( 'error' => 'Missing new status for bulk update.' );
+				}
+
+				$valid_statuses = $this->get_valid_statuses();
+				if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+					return array( 'error' => 'Invalid status for bulk update.' );
+				}
+
+				$normalized['new_status'] = $new_status;
+				$normalized['note'] = isset( $params['note'] ) ? sanitize_text_field( wp_unslash( $params['note'] ) ) : '';
+				$normalized['notify_customer'] = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+				break;
+			case 'add_tag':
+				$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+				$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+				$normalized['tags'] = $this->normalize_tags( $tags, $tag );
+				if ( empty( $normalized['tags'] ) ) {
+					return array( 'error' => 'Missing tags for bulk update.' );
+				}
+				break;
+			case 'add_note':
+				$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+				if ( '' === $note ) {
+					return array( 'error' => 'Missing note for bulk update.' );
+				}
+				$normalized['note'] = sanitize_text_field( wp_unslash( $note ) );
+				$normalized['is_customer_note'] = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+				break;
+			case 'export_csv':
+				$fields = isset( $params['fields'] ) ? $params['fields'] : array();
+				$normalized['fields'] = $this->normalize_fields( $fields );
+				break;
+			default:
+				return array( 'error' => 'Unsupported bulk action.' );
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param array  $params Params.
+	 * @return array
+	 */
+	private function build_action_preview( $action, array $params ) {
+		switch ( $action ) {
+			case 'update_status':
+				return array(
+					'new_status'      => isset( $params['new_status'] ) ? $params['new_status'] : '',
+					'notify_customer' => ! empty( $params['notify_customer'] ),
+					'note'            => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'add_tag':
+				return array(
+					'tags' => isset( $params['tags'] ) ? $params['tags'] : array(),
+				);
+			case 'add_note':
+				return array(
+					'note' => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'export_csv':
+				return array(
+					'fields' => isset( $params['fields'] ) ? $params['fields'] : $this->normalize_fields( array() ),
+				);
+			default:
+				return array();
+		}
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function find_missing_orders( array $order_ids ) {
+		$missing = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$missing[] = $order_id;
+			}
+		}
+
+		return $missing;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @param int    $processed Processed count.
+	 * @param int    $updated Updated count.
+	 * @param int    $failed Failed count.
+	 * @param array  $errors Error list.
+	 * @return void
+	 */
+	private function maybe_update_progress( $progress_id, $processed, $updated, $failed, array $errors ) {
+		if ( '' === $progress_id ) {
+			return;
+		}
+
+		$this->update_progress(
+			$progress_id,
+			array(
+				'processed' => $processed,
+				'updated'   => $updated,
+				'failed'    => $failed,
+				'errors'    => $errors,
+			),
+			false
+		);
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $updates Updates.
+	 * @param bool   $force Force update.
+	 * @return array
+	 */
+	private function update_progress( $progress_id, array $updates, $force ) {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			$progress = array(
+				'id'           => $progress_id,
+				'status'       => 'queued',
+				'processed'    => 0,
+				'updated'      => 0,
+				'failed'       => 0,
+				'errors'       => array(),
+				'created_at'   => gmdate( 'c' ),
+				'last_updated' => gmdate( 'c' ),
+			);
+		}
+
+		$last_updated = isset( $progress['last_updated'] ) ? strtotime( $progress['last_updated'] ) : 0;
+		$should_update = $force || ( time() - $last_updated >= self::POLL_INTERVAL );
+
+		foreach ( $updates as $key => $value ) {
+			$progress[ $key ] = $value;
+		}
+
+		if ( $should_update ) {
+			$progress['last_updated'] = gmdate( 'c' );
+			$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @return array|null
+	 */
+	private function load_progress( $progress_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$progress = get_transient( $this->build_progress_key( $progress_id ) );
+		if ( false === $progress || ! is_array( $progress ) ) {
+			return null;
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $progress Progress payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_progress( $progress_id, array $progress, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_progress_key( $progress_id ), $progress, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return array|null
+	 */
+	private function load_job( $job_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$job = get_transient( $this->build_job_key( $job_id ) );
+		if ( false === $job || ! is_array( $job ) ) {
+			return null;
+		}
+
+		return $job;
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @param array  $job Job payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_job( $job_id, array $job, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_job_key( $job_id ), $job, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return void
+	 */
+	private function delete_job( $job_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_job_key( $job_id ) );
+		}
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @return array|null
+	 */
+	private function load_rollback( $rollback_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$rollback = get_transient( $this->build_rollback_key( $rollback_id ) );
+		if ( false === $rollback || ! is_array( $rollback ) ) {
+			return null;
+		}
+
+		return $rollback;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @param array  $rollback Rollback data.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_rollback( $rollback_id, array $rollback, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_rollback_key( $rollback_id ), $rollback, $ttl );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_uuid() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'bulk_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_draft_' . $draft_id;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @return string
+	 */
+	private function build_progress_key( $progress_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_progress_' . $progress_id;
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return string
+	 */
+	private function build_job_key( $job_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_job_' . $job_id;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback identifier.
+	 * @return string
+	 */
+	private function build_rollback_key( $rollback_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_rollback_' . $rollback_id;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param mixed $status Raw status.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float|null
+	 */
+	private function normalize_amount( $amount ) {
+		if ( null === $amount || '' === $amount ) {
+			return null;
+		}
+
+		if ( is_string( $amount ) ) {
+			$amount = preg_replace( '/[^0-9\.\-]/', '', $amount );
+		}
+
+		if ( '' === $amount || ! is_numeric( $amount ) ) {
+			return null;
+		}
+
+		$amount   = (float) $amount;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $country Country input.
+	 * @return string
+	 */
+	private function normalize_country( $country ) {
+		$country = is_string( $country ) ? strtoupper( trim( $country ) ) : '';
+		if ( '' === $country ) {
+			return '';
+		}
+
+		if ( strlen( $country ) === 2 ) {
+			return $country;
+		}
+
+		$map = $this->get_country_map();
+		$key = strtolower( $country );
+
+		return isset( $map[ $key ] ) ? $map[ $key ] : '';
+	}
+
+	/**
+	 * @param mixed $tags Tags list.
+	 * @param mixed $tag Single tag.
+	 * @return array
+	 */
+	private function normalize_tags( $tags, $tag ) {
+		$list = array();
+
+		if ( is_string( $tags ) ) {
+			$tags = preg_split( '/[\s,]+/', $tags );
+		}
+
+		if ( is_array( $tags ) ) {
+			foreach ( $tags as $item ) {
+				$item = sanitize_text_field( (string) $item );
+				if ( '' !== $item ) {
+					$list[] = $item;
+				}
+			}
+		}
+
+		if ( is_string( $tag ) ) {
+			$tag = sanitize_text_field( $tag );
+			if ( '' !== $tag ) {
+				$list[] = $tag;
+			}
+		}
+
+		$list = array_values( array_unique( $list ) );
+
+		return $list;
+	}
+
+	/**
+	 * @param mixed $fields Fields input.
+	 * @return array
+	 */
+	private function normalize_fields( $fields ) {
+		$default = array( 'order_id', 'status', 'total', 'currency', 'customer_name', 'customer_email', 'date_created', 'billing_country', 'shipping_country' );
+		if ( empty( $fields ) ) {
+			return $default;
+		}
+
+		if ( is_string( $fields ) ) {
+			$fields = preg_split( '/[\s,]+/', $fields );
+		}
+
+		if ( ! is_array( $fields ) ) {
+			return $default;
+		}
+
+		$sanitized = array();
+		foreach ( $fields as $field ) {
+			$field = sanitize_key( $field );
+			if ( '' !== $field ) {
+				$sanitized[] = $field;
+			}
+		}
+
+		return array_values( array_unique( $sanitized ) );
+	}
+
+	/**
+	 * @param array $order Order object.
+	 * @param string $new_status New status.
+	 * @param string $note Note for audit.
+	 * @param bool $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $current_status === $new_status ) {
+			return false;
+		}
+
+		$note = trim( (string) $note );
+		$audit_note = sprintf( '[AgentWP] Bulk status update: %s -> %s.', $current_status, $new_status );
+		if ( '' !== $note ) {
+			$audit_note .= ' Note: ' . $note . '.';
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $audit_note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param array  $tags Tags to add.
+	 * @return bool
+	 */
+	private function apply_tags_update( $order, array $tags ) {
+		$order_id = method_exists( $order, 'get_id' ) ? $order->get_id() : 0;
+		if ( $order_id <= 0 ) {
+			return false;
+		}
+
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				$existing = array();
+			}
+			$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+			wp_set_object_terms( $order_id, $merged, $taxonomy, false );
+			return true;
+		}
+
+		if ( ! method_exists( $order, 'get_meta' ) || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			$existing = array();
+		}
+
+		$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+		$order->update_meta_data( '_agentwp_order_tags', $merged );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param string $note Note text.
+	 * @param bool   $is_customer_note Customer visibility.
+	 * @return int
+	 */
+	private function apply_order_note( $order, $note, $is_customer_note ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return 0;
+		}
+
+		$note = trim( (string) $note );
+		if ( '' === $note ) {
+			return 0;
+		}
+
+		$note_id = $order->add_order_note( $note, $is_customer_note );
+
+		return absint( $note_id );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_export_row( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'        => intval( $order->get_id() ),
+			'status'          => sanitize_text_field( $order->get_status() ),
+			'total'           => $order->get_total(),
+			'currency'        => method_exists( $order, 'get_currency' ) ? $order->get_currency() : '',
+			'customer_name'   => $this->get_customer_name( $order ),
+			'customer_email'  => $this->get_customer_email( $order ),
+			'date_created'    => $date_created ? $date_created->date( 'c' ) : '',
+			'billing_country' => method_exists( $order, 'get_billing_country' ) ? $order->get_billing_country() : '',
+			'shipping_country'=> method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '',
+		);
+	}
+
+	/**
+	 * @param array $rows Data rows.
+	 * @param array $fields Fields list.
+	 * @return array
+	 */
+	private function export_csv( array $rows, array $fields ) {
+		if ( ! function_exists( 'wp_upload_dir' ) ) {
+			return array( 'error' => 'Unable to export CSV in this environment.' );
+		}
+
+		$fields = $this->normalize_fields( $fields );
+		$upload = wp_upload_dir();
+		$base   = isset( $upload['basedir'] ) ? $upload['basedir'] : '';
+		$url    = isset( $upload['baseurl'] ) ? $upload['baseurl'] : '';
+
+		if ( '' === $base || '' === $url ) {
+			return array( 'error' => 'Unable to resolve upload directory.' );
+		}
+
+		$dir = trailingslashit( $base ) . 'agentwp-exports';
+		if ( function_exists( 'wp_mkdir_p' ) ) {
+			wp_mkdir_p( $dir );
+		}
+
+		$filename = 'agentwp-bulk-export-' . gmdate( 'Ymd-His' ) . '-' . wp_generate_password( 6, false ) . '.csv';
+		$path     = trailingslashit( $dir ) . $filename;
+		$file     = @fopen( $path, 'w' );
+		if ( ! $file ) {
+			return array( 'error' => 'Unable to create CSV export file.' );
+		}
+
+		fputcsv( $file, $fields );
+		foreach ( $rows as $row ) {
+			$line = array();
+			foreach ( $fields as $field ) {
+				$line[] = isset( $row[ $field ] ) ? $row[ $field ] : '';
+			}
+			fputcsv( $file, $line );
+		}
+
+		fclose( $file );
+
+		return array(
+			'file_path' => $path,
+			'file_url'  => trailingslashit( $url ) . 'agentwp-exports/' . $filename,
+			'rows'      => count( $rows ),
+		);
+	}
+
+	/**
+	 * @param int $order_id Order ID.
+	 * @return array
+	 */
+	private function get_order_tags( $order_id ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				return array();
+			}
+			return $existing;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'get_meta' ) ) {
+			return array();
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			return array();
+		}
+
+		return $existing;
+	}
+
+	/**
+	 * @param int   $order_id Order ID.
+	 * @param array $tags Tags.
+	 * @return bool
+	 */
+	private function restore_order_tags( $order_id, $tags ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			wp_set_object_terms( $order_id, (array) $tags, $taxonomy, false );
+			return true;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$order->update_meta_data( '_agentwp_order_tags', (array) $tags );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param array $note_ids Note IDs.
+	 * @return bool
+	 */
+	private function delete_order_notes( array $note_ids ) {
+		if ( ! function_exists( 'wp_delete_comment' ) ) {
+			return false;
+		}
+
+		$deleted_any = false;
+		foreach ( $note_ids as $note_id ) {
+			$note_id = absint( $note_id );
+			if ( $note_id > 0 ) {
+				wp_delete_comment( $note_id, true );
+				$deleted_any = true;
+			}
+		}
+
+		return $deleted_any;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function get_order_tag_taxonomy() {
+		$taxonomy = apply_filters( 'agentwp_order_tag_taxonomy', 'shop_order_tag' );
+		$taxonomy = is_string( $taxonomy ) ? trim( $taxonomy ) : '';
+
+		if ( '' !== $taxonomy && function_exists( 'taxonomy_exists' ) && taxonomy_exists( $taxonomy ) ) {
+			return $taxonomy;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param array|null $date_range Date range input.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query text.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date.
+	 * @param string $end End date.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Date string.
+	 * @param bool   $end_of_day End of day flag.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		$date = $end_of_day ? $date->setTime( 23, 59, 59 ) : $date->setTime( 0, 0, 0 );
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function extract_total_range( $query ) {
+		$result = array();
+
+		if ( preg_match( '/\bbetween\s+[\$£\x{20AC}]?([0-9\.,]+)\s+(?:and|to)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+			return $result;
+		}
+
+		if ( preg_match( '/\b(over|above|more than|greater than|at least|minimum|min)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b(under|below|less than|at most|maximum|max)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b>=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		if ( preg_match( '/\b<=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param string $value Amount string.
+	 * @return float|null
+	 */
+	private function parse_amount_string( $value ) {
+		$value = str_replace( array( ',', ' ' ), '', (string) $value );
+		return $this->normalize_amount( $value );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_country( $query ) {
+		$query_lower = strtolower( $query );
+		$map         = $this->get_country_map();
+
+		foreach ( $map as $name => $code ) {
+			$pattern = '/\b' . preg_quote( $name, '/' ) . '\b/i';
+			if ( preg_match( $pattern, $query_lower ) ) {
+				return $code;
+			}
+		}
+
+		if ( preg_match_all( '/\b([A-Z]{2})\b/', strtoupper( $query ), $matches ) ) {
+			foreach ( $matches[1] as $code ) {
+				if ( isset( $map[ strtolower( $code ) ] ) ) {
+					return $map[ strtolower( $code ) ];
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_country_map() {
+		static $map = null;
+		if ( null !== $map ) {
+			return $map;
+		}
+
+		$countries = array();
+		if ( function_exists( 'WC' ) ) {
+			$wc = WC();
+			if ( $wc && isset( $wc->countries ) && method_exists( $wc->countries, 'get_countries' ) ) {
+				$countries = $wc->countries->get_countries();
+			}
+		}
+
+		if ( empty( $countries ) && class_exists( 'WC_Countries' ) ) {
+			$wc_countries = new \WC_Countries();
+			$countries    = $wc_countries->get_countries();
+		}
+
+		$map = array();
+		if ( is_array( $countries ) ) {
+			foreach ( $countries as $code => $name ) {
+				$map[ strtolower( $name ) ] = strtoupper( $code );
+				$map[ strtolower( $code ) ] = strtoupper( $code );
+			}
+		}
+
+		$map['usa'] = 'US';
+		$map['us']  = 'US';
+		$map['uk']  = 'GB';
+
+		return $map;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_order_country( $order ) {
+		$country = method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '';
+		if ( '' !== $country ) {
+			return $country;
+		}
+
+		if ( method_exists( $order, 'get_billing_country' ) ) {
+			$country = $order->get_billing_country();
+		}
+
+		return is_string( $country ) ? $country : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_draft_id( array $args ) {
+		$draft_id = isset( $args['draft_id'] ) ? $args['draft_id'] : '';
+		if ( '' === $draft_id && isset( $args['params']['draft_id'] ) ) {
+			$draft_id = $args['params']['draft_id'];
+		}
+
+		return is_string( $draft_id ) ? trim( $draft_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_progress_id( array $args ) {
+		$progress_id = isset( $args['progress_id'] ) ? $args['progress_id'] : '';
+		if ( '' === $progress_id && isset( $args['params']['progress_id'] ) ) {
+			$progress_id = $args['params']['progress_id'];
+		}
+
+		return is_string( $progress_id ) ? trim( $progress_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_rollback_id( array $args ) {
+		$rollback_id = isset( $args['rollback_id'] ) ? $args['rollback_id'] : '';
+		if ( '' === $rollback_id && isset( $args['params']['rollback_id'] ) ) {
+			$rollback_id = $args['params']['rollback_id'];
+		}
+
+		return is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+	}
+
+	/**
+	 * @return bool
+	 */
+	private function action_scheduler_available() {
+		return function_exists( 'as_enqueue_async_action' ) || function_exists( 'as_schedule_single_action' );
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return int
+	 */
+	private function schedule_job( $job_id ) {
+		if ( function_exists( 'as_enqueue_async_action' ) ) {
+			return (int) as_enqueue_async_action( self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		if ( function_exists( 'as_schedule_single_action' ) ) {
+			return (int) as_schedule_single_action( time(), self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		return 0;
+	}
+}
diff --git a/src/Plugin.php b/src/Plugin.php
index 01ae991acdb6f0546a735ab888160091c456700a..4751cc435f813540794ea9968e6b5b99ec25ac66
--- a/src/Plugin.php
+++ b/src/Plugin.php
@@ -99,6 +99,10 @@
 			Search\Index::init();
 		}
 
+		if ( class_exists( 'AgentWP\\Handlers\\BulkHandler' ) ) {
+			Handlers\BulkHandler::register_hooks();
+		}
+
 		if ( class_exists( 'AgentWP\\Demo\\Manager' ) ) {
 			Demo\Manager::init();
 		}

file update:
diff --git a/src/Handlers/BulkHandler.php b/src/Handlers/BulkHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..f071e1fb69c964afa98618d7baaf75fcceab1807
--- /dev/null
+++ b/src/Handlers/BulkHandler.php
@@ -0,0 +1,2231 @@
+<?php
+/**
+ * Handle bulk order operations.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class BulkHandler {
+	const ACTION_HOOK      = 'agentwp_bulk_process';
+	const ASYNC_THRESHOLD  = 20;
+	const DRAFT_TYPE       = 'bulk_action';
+	const JOB_TTL_SECONDS  = 86400;
+	const MAX_BULK         = 1000;
+	const PROGRESS_TTL     = 86400;
+	const ROLLBACK_TTL     = 86400;
+	const POLL_INTERVAL    = 2;
+
+	/**
+	 * Register background processing hooks.
+	 *
+	 * @return void
+	 */
+	public static function register_hooks() {
+		add_action( self::ACTION_HOOK, array( __CLASS__, 'handle_scheduled_action' ), 10, 1 );
+	}
+
+	/**
+	 * Execute scheduled bulk jobs.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	public static function handle_scheduled_action( $job_id ) {
+		$handler = new self();
+		$handler->process_scheduled_job( $job_id );
+	}
+
+	/**
+	 * Handle bulk actions and selections.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['criteria'] ) ) {
+			return $this->select_orders( $args );
+		}
+
+		$progress_id = $this->extract_progress_id( $args );
+		if ( '' !== $progress_id ) {
+			return $this->get_progress_response( $progress_id );
+		}
+
+		$rollback_id = $this->extract_rollback_id( $args );
+		if ( '' !== $rollback_id ) {
+			return $this->rollback_bulk_action( $rollback_id );
+		}
+
+		$draft_id = $this->extract_draft_id( $args );
+		if ( '' !== $draft_id ) {
+			return $this->confirm_bulk_update( $draft_id );
+		}
+
+		return $this->prepare_bulk_update( $args );
+	}
+
+	/**
+	 * Select orders based on criteria.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function select_orders( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to select orders.', 400 );
+		}
+
+		$criteria  = $this->normalize_criteria( isset( $args['criteria'] ) ? $args['criteria'] : array() );
+		$order_ids = $this->query_order_ids( $criteria );
+		$sample    = $this->build_sample_orders( $order_ids );
+
+		return Response::success(
+			array(
+				'order_ids'  => $order_ids,
+				'count'      => count( $order_ids ),
+				'criteria'   => $criteria,
+				'sample'     => $sample,
+				'truncated'  => count( $order_ids ) >= self::MAX_BULK,
+				'max_limit'  => self::MAX_BULK,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a bulk update draft.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	private function prepare_bulk_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $args['action'] ) ? $args['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Missing or invalid bulk action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $args['params'] ) ? $args['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$missing_orders = $this->find_missing_orders( $order_ids );
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		$sample = $this->build_sample_orders( $order_ids );
+		$preview = array(
+			'order_count'    => count( $order_ids ),
+			'sample'         => $sample,
+			'action'         => $action,
+			'action_preview' => $this->build_action_preview( $action, $params ),
+		);
+
+		$draft_payload = array(
+			'order_ids' => $order_ids,
+			'action'    => $action,
+			'params'    => $params,
+			'preview'   => $preview,
+		);
+
+		$draft_id   = $this->generate_uuid();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a bulk update draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	private function confirm_bulk_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to process bulk updates.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing bulk update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Bulk update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for bulk update confirmation.', 400 );
+		}
+
+		$payload  = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $payload['action'] ) ? $payload['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Bulk update draft is missing an action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $payload['params'] ) ? $payload['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$job_id      = $this->generate_uuid();
+		$progress_id = $this->generate_uuid();
+		$rollback_id = $this->generate_uuid();
+
+		$rollback_expires = gmdate( 'c', time() + self::ROLLBACK_TTL );
+		$this->store_rollback(
+			$rollback_id,
+			array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => $rollback_expires,
+				'orders'     => array(),
+			),
+			self::ROLLBACK_TTL
+		);
+
+		$progress = array(
+			'id'                  => $progress_id,
+			'status'              => 'queued',
+			'action'              => $action,
+			'order_count'         => count( $order_ids ),
+			'processed'           => 0,
+			'updated'             => 0,
+			'failed'              => 0,
+			'errors'              => array(),
+			'created_at'          => gmdate( 'c' ),
+			'started_at'          => '',
+			'last_updated'        => gmdate( 'c' ),
+			'completed_at'        => '',
+			'draft_id'            => $draft_id,
+			'rollback_id'         => $rollback_id,
+			'undo_available_until'=> $rollback_expires,
+		);
+		$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+
+		$job = array(
+			'id'          => $job_id,
+			'order_ids'   => $order_ids,
+			'action'      => $action,
+			'params'      => $params,
+			'progress_id' => $progress_id,
+			'rollback_id' => $rollback_id,
+			'draft_id'    => $draft_id,
+		);
+		$this->store_job( $job_id, $job, self::JOB_TTL_SECONDS );
+
+		$async = count( $order_ids ) > self::ASYNC_THRESHOLD && $this->action_scheduler_available();
+		if ( $async ) {
+			$action_id = $this->schedule_job( $job_id );
+			if ( ! $action_id ) {
+				return Response::error( 'Unable to schedule bulk update.', 500 );
+			}
+
+			$this->delete_draft( $draft_id );
+
+			return Response::success(
+				array(
+					'status'     => 'scheduled',
+					'draft_id'   => $draft_id,
+					'job_id'     => $job_id,
+					'progress'   => $progress,
+					'polling'    => array(
+						'progress_id'      => $progress_id,
+						'interval_seconds' => self::POLL_INTERVAL,
+					),
+					'rollback_id' => $rollback_id,
+					'undo_available_until' => $rollback_expires,
+				)
+			);
+		}
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'     => 'running',
+				'started_at' => gmdate( 'c' ),
+			),
+			true
+		);
+
+		$result = $this->run_bulk_job( $job );
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'       => 'completed',
+				'completed_at' => gmdate( 'c' ),
+				'result'       => $result,
+			),
+			true
+		);
+
+		$this->delete_job( $job_id );
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'status'      => 'completed',
+				'draft_id'    => $draft_id,
+				'result'      => $result,
+				'progress'    => $progress,
+				'polling'     => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+				'rollback_id' => $rollback_id,
+				'undo_available_until' => $rollback_expires,
+			)
+		);
+	}
+
+	/**
+	 * Process a scheduled bulk job.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	private function process_scheduled_job( $job_id ) {
+		$job_id = is_string( $job_id ) ? trim( $job_id ) : '';
+		if ( '' === $job_id ) {
+			return;
+		}
+
+		$job = $this->load_job( $job_id );
+		if ( ! is_array( $job ) ) {
+			return;
+		}
+
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'     => 'running',
+					'started_at' => gmdate( 'c' ),
+				),
+				true
+			);
+		}
+
+		$result = $this->run_bulk_job( $job );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'       => 'completed',
+					'completed_at' => gmdate( 'c' ),
+					'result'       => $result,
+				),
+				true
+			);
+		}
+
+		$draft_id = isset( $job['draft_id'] ) ? (string) $job['draft_id'] : '';
+		if ( '' !== $draft_id ) {
+			$this->delete_draft( $draft_id );
+		}
+
+		$this->delete_job( $job_id );
+	}
+
+	/**
+	 * Execute a bulk job.
+	 *
+	 * @param array $job Job payload.
+	 * @return array
+	 */
+	private function run_bulk_job( array $job ) {
+		$order_ids   = isset( $job['order_ids'] ) ? $this->normalize_order_ids( $job['order_ids'] ) : array();
+		$action      = isset( $job['action'] ) ? $this->normalize_action( $job['action'] ) : '';
+		$params      = isset( $job['params'] ) && is_array( $job['params'] ) ? $job['params'] : array();
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		$rollback_id = isset( $job['rollback_id'] ) ? (string) $job['rollback_id'] : '';
+
+		$result = array(
+			'action'    => $action,
+			'order_ids' => $order_ids,
+			'updated'   => array(),
+			'failed'    => array(),
+			'errors'    => array(),
+		);
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			$rollback = array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => gmdate( 'c', time() + self::ROLLBACK_TTL ),
+				'orders'     => array(),
+			);
+		}
+
+		$processed = 0;
+		$updated   = 0;
+		$failed    = 0;
+		$errors    = array();
+		$rows      = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$processed++;
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed++;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found.',
+				);
+				$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$current_status = $this->normalize_status( $order->get_status() );
+					$new_status     = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+					if ( '' === $new_status ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing target status.',
+						);
+						break;
+					}
+
+					$rollback['orders'][ $order_id ] = array(
+						'status' => $current_status,
+					);
+
+					$note            = isset( $params['note'] ) ? (string) $params['note'] : '';
+					$notify_customer = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+					$updated_flag    = $this->apply_status_update( $order, $new_status, $note, $notify_customer );
+
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to update status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+					$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+					$tags = $this->normalize_tags( $tags, $tag );
+					if ( empty( $tags ) ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing tags to add.',
+						);
+						break;
+					}
+
+					$before_tags = $this->get_order_tags( $order_id );
+					$rollback['orders'][ $order_id ] = array(
+						'tags' => $before_tags,
+					);
+
+					$updated_flag = $this->apply_tags_update( $order, $tags );
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+					if ( '' === $note ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing note content.',
+						);
+						break;
+					}
+
+					$is_customer_note = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+					$note_id          = $this->apply_order_note( $order, $note, $is_customer_note );
+					if ( $note_id > 0 ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+						$rollback['orders'][ $order_id ] = array(
+							'notes' => array( $note_id ),
+						);
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add note.',
+						);
+					}
+					break;
+				case 'export_csv':
+					$rows[] = $this->format_export_row( $order );
+					$updated++;
+					$result['updated'][] = $order_id;
+					break;
+				default:
+					$failed++;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Unsupported bulk action.',
+					);
+			}
+
+			$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+		}
+
+		$result['errors'] = $errors;
+		$result['failed'] = array_unique( array_merge( $result['failed'], wp_list_pluck( $errors, 'order_id' ) ) );
+
+		if ( 'export_csv' === $action ) {
+			$export = $this->export_csv( $rows, isset( $params['fields'] ) ? $params['fields'] : array() );
+			if ( isset( $export['error'] ) ) {
+				$errors[]         = array( 'order_id' => 0, 'message' => $export['error'] );
+				$result['errors'] = $errors;
+			} else {
+				$result['export'] = $export;
+			}
+		}
+
+		$this->store_rollback( $rollback_id, $rollback, self::ROLLBACK_TTL );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'processed' => $processed,
+					'updated'   => $updated,
+					'failed'    => $failed,
+					'errors'    => $errors,
+				),
+				true
+			);
+		}
+
+		return $result;
+	}
+
+	/**
+	 * Provide progress updates to polling clients.
+	 *
+	 * @param string $progress_id Progress identifier.
+	 * @return Response
+	 */
+	private function get_progress_response( $progress_id ): Response {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			return Response::error( 'Bulk progress not found or expired.', 404 );
+		}
+
+		return Response::success(
+			array(
+				'progress' => $progress,
+				'polling'  => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Roll back a bulk action.
+	 *
+	 * @param string $rollback_id Rollback identifier.
+	 * @return Response
+	 */
+	private function rollback_bulk_action( $rollback_id ): Response {
+		$rollback_id = is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+		if ( '' === $rollback_id ) {
+			return Response::error( 'Missing rollback ID.', 400 );
+		}
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			return Response::error( 'Rollback data not found or expired.', 404 );
+		}
+
+		$action  = isset( $rollback['action'] ) ? $this->normalize_action( $rollback['action'] ) : '';
+		$orders  = isset( $rollback['orders'] ) && is_array( $rollback['orders'] ) ? $rollback['orders'] : array();
+		$undone  = array();
+		$failed  = array();
+		$errors  = array();
+
+		foreach ( $orders as $order_id => $data ) {
+			$order_id = absint( $order_id );
+			$order    = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed[] = $order_id;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found for rollback.',
+				);
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$previous_status = isset( $data['status'] ) ? $this->normalize_status( $data['status'] ) : '';
+					if ( '' === $previous_status ) {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing previous status.',
+						);
+						break;
+					}
+
+					$updated = $this->apply_status_update( $order, $previous_status, 'Rollback to previous status.', false );
+					if ( $updated ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore previous status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $data['tags'] ) ? $data['tags'] : array();
+					$restored = $this->restore_order_tags( $order_id, $tags );
+					if ( $restored ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$notes = isset( $data['notes'] ) ? (array) $data['notes'] : array();
+					$deleted = $this->delete_order_notes( $notes );
+					if ( $deleted ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to remove notes.',
+						);
+					}
+					break;
+				default:
+					$failed[] = $order_id;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Rollback not supported for this action.',
+					);
+			}
+		}
+
+		return Response::success(
+			array(
+				'rollback_id' => $rollback_id,
+				'action'      => $action,
+				'undone'      => $undone,
+				'failed'      => $failed,
+				'errors'      => $errors,
+			)
+		);
+	}
+
+	/**
+	 * @param array $criteria Criteria input.
+	 * @return array
+	 */
+	private function normalize_criteria( $criteria ) {
+		$parsed = array(
+			'status'         => '',
+			'date_range'     => null,
+			'customer_email' => '',
+			'total_min'      => null,
+			'total_max'      => null,
+			'country'        => '',
+		);
+		$query  = '';
+
+		if ( is_string( $criteria ) ) {
+			$query = sanitize_text_field( $criteria );
+		} elseif ( is_array( $criteria ) ) {
+			$query = isset( $criteria['query'] ) ? sanitize_text_field( $criteria['query'] ) : '';
+			$parsed['status'] = isset( $criteria['status'] ) ? $this->normalize_status( $criteria['status'] ) : '';
+			$parsed['date_range'] = $this->normalize_date_range_input( isset( $criteria['date_range'] ) ? $criteria['date_range'] : null );
+			$parsed['customer_email'] = isset( $criteria['customer_email'] ) ? sanitize_email( $criteria['customer_email'] ) : '';
+			$parsed['total_min'] = isset( $criteria['total_min'] ) ? $this->normalize_amount( $criteria['total_min'] ) : null;
+			$parsed['total_max'] = isset( $criteria['total_max'] ) ? $this->normalize_amount( $criteria['total_max'] ) : null;
+			$parsed['country'] = isset( $criteria['country'] ) ? $this->normalize_country( $criteria['country'] ) : '';
+		}
+
+		if ( '' !== $query ) {
+			$text_parsed = $this->parse_criteria_text( $query );
+			foreach ( $text_parsed as $key => $value ) {
+				if ( ! isset( $parsed[ $key ] ) || '' === $parsed[ $key ] || null === $parsed[ $key ] ) {
+					$parsed[ $key ] = $value;
+				}
+			}
+		}
+
+		if ( '' === $parsed['status'] ) {
+			unset( $parsed['status'] );
+		}
+		if ( '' === $parsed['customer_email'] ) {
+			unset( $parsed['customer_email'] );
+		}
+		if ( '' === $parsed['country'] ) {
+			unset( $parsed['country'] );
+		}
+		if ( null === $parsed['total_min'] ) {
+			unset( $parsed['total_min'] );
+		}
+		if ( null === $parsed['total_max'] ) {
+			unset( $parsed['total_max'] );
+		}
+		if ( null === $parsed['date_range'] ) {
+			unset( $parsed['date_range'] );
+		}
+
+		return $parsed;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function parse_criteria_text( $query ) {
+		$query  = trim( (string) $query );
+		$lower  = strtolower( $query );
+		$result = array();
+
+		$status = $this->detect_status( $lower );
+		if ( '' !== $status ) {
+			$result['status'] = $status;
+		}
+
+		$date_range = $this->parse_date_range_from_query( $lower );
+		if ( null !== $date_range ) {
+			$result['date_range'] = $date_range;
+		}
+
+		$email = $this->extract_email( $query );
+		if ( '' !== $email ) {
+			$result['customer_email'] = $email;
+		}
+
+		$totals = $this->extract_total_range( $lower );
+		if ( isset( $totals['min'] ) ) {
+			$result['total_min'] = $totals['min'];
+		}
+		if ( isset( $totals['max'] ) ) {
+			$result['total_max'] = $totals['max'];
+		}
+
+		$country = $this->extract_country( $query );
+		if ( '' !== $country ) {
+			$result['country'] = $country;
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param array $criteria Query criteria.
+	 * @return array
+	 */
+	private function query_order_ids( array $criteria ) {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		$args = array(
+			'limit'   => self::MAX_BULK,
+			'return'  => 'ids',
+			'orderby' => 'date',
+			'order'   => 'DESC',
+		);
+
+		if ( isset( $criteria['status'] ) && '' !== $criteria['status'] ) {
+			$args['status'] = $criteria['status'];
+		}
+
+		if ( isset( $criteria['date_range'] ) && is_array( $criteria['date_range'] ) ) {
+			$args['date_created'] = $criteria['date_range']['start'] . '...' . $criteria['date_range']['end'];
+		}
+
+		$meta_query = array( 'relation' => 'AND' );
+
+		if ( isset( $criteria['customer_email'] ) && '' !== $criteria['customer_email'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['country'] ) && '' !== $criteria['country'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['total_min'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_min'],
+				'compare' => '>=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( isset( $criteria['total_max'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_max'],
+				'compare' => '<=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( count( $meta_query ) > 1 ) {
+			$args['meta_query'] = $meta_query;
+		}
+
+		$order_ids = wc_get_orders( $args );
+		if ( ! is_array( $order_ids ) ) {
+			return array();
+		}
+
+		$order_ids = array_map( 'absint', $order_ids );
+		$order_ids = array_filter( $order_ids );
+		$order_ids = array_values( array_unique( $order_ids ) );
+
+		return $order_ids;
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function build_sample_orders( array $order_ids ) {
+		$sample = array();
+		$order_ids = array_slice( $order_ids, 0, 5 );
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( $order ) {
+				$sample[] = $this->format_order_summary( $order );
+			}
+		}
+
+		return $sample;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_order_summary( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'       => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'currency'       => method_exists( $order, 'get_currency' ) ? sanitize_text_field( $order->get_currency() ) : '',
+			'customer_name'  => sanitize_text_field( $this->get_customer_name( $order ) ),
+			'customer_email' => sanitize_email( $this->get_customer_email( $order ) ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'country'        => sanitize_text_field( $this->get_order_country( $order ) ),
+		);
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @param mixed $action Raw action.
+	 * @return string
+	 */
+	private function normalize_action( $action ) {
+		$action = is_string( $action ) ? strtolower( trim( $action ) ) : '';
+		$allowed = array( 'update_status', 'add_tag', 'add_note', 'export_csv' );
+
+		return in_array( $action, $allowed, true ) ? $action : '';
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param mixed  $params Raw params.
+	 * @return array
+	 */
+	private function normalize_params( $action, $params ) {
+		$params = is_array( $params ) ? $params : array();
+		$normalized = array();
+
+		switch ( $action ) {
+			case 'update_status':
+				$new_status = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+				if ( '' === $new_status ) {
+					return array( 'error' => 'Missing new status for bulk update.' );
+				}
+
+				$valid_statuses = $this->get_valid_statuses();
+				if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+					return array( 'error' => 'Invalid status for bulk update.' );
+				}
+
+				$normalized['new_status'] = $new_status;
+				$normalized['note'] = isset( $params['note'] ) ? sanitize_text_field( wp_unslash( $params['note'] ) ) : '';
+				$normalized['notify_customer'] = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+				break;
+			case 'add_tag':
+				$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+				$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+				$normalized['tags'] = $this->normalize_tags( $tags, $tag );
+				if ( empty( $normalized['tags'] ) ) {
+					return array( 'error' => 'Missing tags for bulk update.' );
+				}
+				break;
+			case 'add_note':
+				$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+				if ( '' === $note ) {
+					return array( 'error' => 'Missing note for bulk update.' );
+				}
+				$normalized['note'] = sanitize_text_field( wp_unslash( $note ) );
+				$normalized['is_customer_note'] = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+				break;
+			case 'export_csv':
+				$fields = isset( $params['fields'] ) ? $params['fields'] : array();
+				$normalized['fields'] = $this->normalize_fields( $fields );
+				break;
+			default:
+				return array( 'error' => 'Unsupported bulk action.' );
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param array  $params Params.
+	 * @return array
+	 */
+	private function build_action_preview( $action, array $params ) {
+		switch ( $action ) {
+			case 'update_status':
+				return array(
+					'new_status'      => isset( $params['new_status'] ) ? $params['new_status'] : '',
+					'notify_customer' => ! empty( $params['notify_customer'] ),
+					'note'            => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'add_tag':
+				return array(
+					'tags' => isset( $params['tags'] ) ? $params['tags'] : array(),
+				);
+			case 'add_note':
+				return array(
+					'note' => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'export_csv':
+				return array(
+					'fields' => isset( $params['fields'] ) ? $params['fields'] : $this->normalize_fields( array() ),
+				);
+			default:
+				return array();
+		}
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function find_missing_orders( array $order_ids ) {
+		$missing = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$missing[] = $order_id;
+			}
+		}
+
+		return $missing;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @param int    $processed Processed count.
+	 * @param int    $updated Updated count.
+	 * @param int    $failed Failed count.
+	 * @param array  $errors Error list.
+	 * @return void
+	 */
+	private function maybe_update_progress( $progress_id, $processed, $updated, $failed, array $errors ) {
+		if ( '' === $progress_id ) {
+			return;
+		}
+
+		$this->update_progress(
+			$progress_id,
+			array(
+				'processed' => $processed,
+				'updated'   => $updated,
+				'failed'    => $failed,
+				'errors'    => $errors,
+			),
+			false
+		);
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $updates Updates.
+	 * @param bool   $force Force update.
+	 * @return array
+	 */
+	private function update_progress( $progress_id, array $updates, $force ) {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			$progress = array(
+				'id'           => $progress_id,
+				'status'       => 'queued',
+				'processed'    => 0,
+				'updated'      => 0,
+				'failed'       => 0,
+				'errors'       => array(),
+				'created_at'   => gmdate( 'c' ),
+				'last_updated' => gmdate( 'c' ),
+			);
+		}
+
+		$last_updated = isset( $progress['last_updated'] ) ? strtotime( $progress['last_updated'] ) : 0;
+		$should_update = $force || ( time() - $last_updated >= self::POLL_INTERVAL );
+
+		foreach ( $updates as $key => $value ) {
+			$progress[ $key ] = $value;
+		}
+
+		if ( $should_update ) {
+			$progress['last_updated'] = gmdate( 'c' );
+			$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @return array|null
+	 */
+	private function load_progress( $progress_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$progress = get_transient( $this->build_progress_key( $progress_id ) );
+		if ( false === $progress || ! is_array( $progress ) ) {
+			return null;
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $progress Progress payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_progress( $progress_id, array $progress, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_progress_key( $progress_id ), $progress, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return array|null
+	 */
+	private function load_job( $job_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$job = get_transient( $this->build_job_key( $job_id ) );
+		if ( false === $job || ! is_array( $job ) ) {
+			return null;
+		}
+
+		return $job;
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @param array  $job Job payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_job( $job_id, array $job, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_job_key( $job_id ), $job, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return void
+	 */
+	private function delete_job( $job_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_job_key( $job_id ) );
+		}
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @return array|null
+	 */
+	private function load_rollback( $rollback_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$rollback = get_transient( $this->build_rollback_key( $rollback_id ) );
+		if ( false === $rollback || ! is_array( $rollback ) ) {
+			return null;
+		}
+
+		return $rollback;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @param array  $rollback Rollback data.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_rollback( $rollback_id, array $rollback, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_rollback_key( $rollback_id ), $rollback, $ttl );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_uuid() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'bulk_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_draft_' . $draft_id;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @return string
+	 */
+	private function build_progress_key( $progress_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_progress_' . $progress_id;
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return string
+	 */
+	private function build_job_key( $job_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_job_' . $job_id;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback identifier.
+	 * @return string
+	 */
+	private function build_rollback_key( $rollback_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_rollback_' . $rollback_id;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param mixed $status Raw status.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float|null
+	 */
+	private function normalize_amount( $amount ) {
+		if ( null === $amount || '' === $amount ) {
+			return null;
+		}
+
+		if ( is_string( $amount ) ) {
+			$amount = preg_replace( '/[^0-9\.\-]/', '', $amount );
+		}
+
+		if ( '' === $amount || ! is_numeric( $amount ) ) {
+			return null;
+		}
+
+		$amount   = (float) $amount;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $country Country input.
+	 * @return string
+	 */
+	private function normalize_country( $country ) {
+		$country = is_string( $country ) ? strtoupper( trim( $country ) ) : '';
+		if ( '' === $country ) {
+			return '';
+		}
+
+		if ( strlen( $country ) === 2 ) {
+			return $country;
+		}
+
+		$map = $this->get_country_map();
+		$key = strtolower( $country );
+
+		return isset( $map[ $key ] ) ? $map[ $key ] : '';
+	}
+
+	/**
+	 * @param mixed $tags Tags list.
+	 * @param mixed $tag Single tag.
+	 * @return array
+	 */
+	private function normalize_tags( $tags, $tag ) {
+		$list = array();
+
+		if ( is_string( $tags ) ) {
+			$tags = preg_split( '/[\s,]+/', $tags );
+		}
+
+		if ( is_array( $tags ) ) {
+			foreach ( $tags as $item ) {
+				$item = sanitize_text_field( (string) $item );
+				if ( '' !== $item ) {
+					$list[] = $item;
+				}
+			}
+		}
+
+		if ( is_string( $tag ) ) {
+			$tag = sanitize_text_field( $tag );
+			if ( '' !== $tag ) {
+				$list[] = $tag;
+			}
+		}
+
+		$list = array_values( array_unique( $list ) );
+
+		return $list;
+	}
+
+	/**
+	 * @param mixed $fields Fields input.
+	 * @return array
+	 */
+	private function normalize_fields( $fields ) {
+		$default = array( 'order_id', 'status', 'total', 'currency', 'customer_name', 'customer_email', 'date_created', 'billing_country', 'shipping_country' );
+		if ( empty( $fields ) ) {
+			return $default;
+		}
+
+		if ( is_string( $fields ) ) {
+			$fields = preg_split( '/[\s,]+/', $fields );
+		}
+
+		if ( ! is_array( $fields ) ) {
+			return $default;
+		}
+
+		$sanitized = array();
+		foreach ( $fields as $field ) {
+			$field = sanitize_key( $field );
+			if ( '' !== $field ) {
+				$sanitized[] = $field;
+			}
+		}
+
+		return array_values( array_unique( $sanitized ) );
+	}
+
+	/**
+	 * @param array $order Order object.
+	 * @param string $new_status New status.
+	 * @param string $note Note for audit.
+	 * @param bool $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $current_status === $new_status ) {
+			return false;
+		}
+
+		$note = trim( (string) $note );
+		$audit_note = sprintf( '[AgentWP] Bulk status update: %s -> %s.', $current_status, $new_status );
+		if ( '' !== $note ) {
+			$audit_note .= ' Note: ' . $note . '.';
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $audit_note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param array  $tags Tags to add.
+	 * @return bool
+	 */
+	private function apply_tags_update( $order, array $tags ) {
+		$order_id = method_exists( $order, 'get_id' ) ? $order->get_id() : 0;
+		if ( $order_id <= 0 ) {
+			return false;
+		}
+
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				$existing = array();
+			}
+			$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+			wp_set_object_terms( $order_id, $merged, $taxonomy, false );
+			return true;
+		}
+
+		if ( ! method_exists( $order, 'get_meta' ) || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			$existing = array();
+		}
+
+		$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+		$order->update_meta_data( '_agentwp_order_tags', $merged );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param string $note Note text.
+	 * @param bool   $is_customer_note Customer visibility.
+	 * @return int
+	 */
+	private function apply_order_note( $order, $note, $is_customer_note ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return 0;
+		}
+
+		$note = trim( (string) $note );
+		if ( '' === $note ) {
+			return 0;
+		}
+
+		$note_id = $order->add_order_note( $note, $is_customer_note );
+
+		return absint( $note_id );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_export_row( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'        => intval( $order->get_id() ),
+			'status'          => sanitize_text_field( $order->get_status() ),
+			'total'           => $order->get_total(),
+			'currency'        => method_exists( $order, 'get_currency' ) ? $order->get_currency() : '',
+			'customer_name'   => $this->get_customer_name( $order ),
+			'customer_email'  => $this->get_customer_email( $order ),
+			'date_created'    => $date_created ? $date_created->date( 'c' ) : '',
+			'billing_country' => method_exists( $order, 'get_billing_country' ) ? $order->get_billing_country() : '',
+			'shipping_country'=> method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '',
+		);
+	}
+
+	/**
+	 * @param array $rows Data rows.
+	 * @param array $fields Fields list.
+	 * @return array
+	 */
+	private function export_csv( array $rows, array $fields ) {
+		if ( ! function_exists( 'wp_upload_dir' ) ) {
+			return array( 'error' => 'Unable to export CSV in this environment.' );
+		}
+
+		$fields = $this->normalize_fields( $fields );
+		$upload = wp_upload_dir();
+		$base   = isset( $upload['basedir'] ) ? $upload['basedir'] : '';
+		$url    = isset( $upload['baseurl'] ) ? $upload['baseurl'] : '';
+
+		if ( '' === $base || '' === $url ) {
+			return array( 'error' => 'Unable to resolve upload directory.' );
+		}
+
+		$dir = trailingslashit( $base ) . 'agentwp-exports';
+		if ( function_exists( 'wp_mkdir_p' ) ) {
+			wp_mkdir_p( $dir );
+		}
+
+		$filename = 'agentwp-bulk-export-' . gmdate( 'Ymd-His' ) . '-' . wp_generate_password( 6, false ) . '.csv';
+		$path     = trailingslashit( $dir ) . $filename;
+		$file     = @fopen( $path, 'w' );
+		if ( ! $file ) {
+			return array( 'error' => 'Unable to create CSV export file.' );
+		}
+
+		fputcsv( $file, $fields );
+		foreach ( $rows as $row ) {
+			$line = array();
+			foreach ( $fields as $field ) {
+				$line[] = isset( $row[ $field ] ) ? $row[ $field ] : '';
+			}
+			fputcsv( $file, $line );
+		}
+
+		fclose( $file );
+
+		return array(
+			'file_path' => $path,
+			'file_url'  => trailingslashit( $url ) . 'agentwp-exports/' . $filename,
+			'rows'      => count( $rows ),
+		);
+	}
+
+	/**
+	 * @param int $order_id Order ID.
+	 * @return array
+	 */
+	private function get_order_tags( $order_id ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				return array();
+			}
+			return $existing;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'get_meta' ) ) {
+			return array();
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			return array();
+		}
+
+		return $existing;
+	}
+
+	/**
+	 * @param int   $order_id Order ID.
+	 * @param array $tags Tags.
+	 * @return bool
+	 */
+	private function restore_order_tags( $order_id, $tags ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			wp_set_object_terms( $order_id, (array) $tags, $taxonomy, false );
+			return true;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$order->update_meta_data( '_agentwp_order_tags', (array) $tags );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param array $note_ids Note IDs.
+	 * @return bool
+	 */
+	private function delete_order_notes( array $note_ids ) {
+		if ( ! function_exists( 'wp_delete_comment' ) ) {
+			return false;
+		}
+
+		$deleted_any = false;
+		foreach ( $note_ids as $note_id ) {
+			$note_id = absint( $note_id );
+			if ( $note_id > 0 ) {
+				wp_delete_comment( $note_id, true );
+				$deleted_any = true;
+			}
+		}
+
+		return $deleted_any;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function get_order_tag_taxonomy() {
+		$taxonomy = apply_filters( 'agentwp_order_tag_taxonomy', 'shop_order_tag' );
+		$taxonomy = is_string( $taxonomy ) ? trim( $taxonomy ) : '';
+
+		if ( '' !== $taxonomy && function_exists( 'taxonomy_exists' ) && taxonomy_exists( $taxonomy ) ) {
+			return $taxonomy;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param array|null $date_range Date range input.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query text.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date.
+	 * @param string $end End date.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Date string.
+	 * @param bool   $end_of_day End of day flag.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		$date = $end_of_day ? $date->setTime( 23, 59, 59 ) : $date->setTime( 0, 0, 0 );
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function extract_total_range( $query ) {
+		$result = array();
+
+		if ( preg_match( '/\bbetween\s+[\$£\x{20AC}]?([0-9\.,]+)\s+(?:and|to)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+			return $result;
+		}
+
+		if ( preg_match( '/\b(over|above|more than|greater than|at least|minimum|min)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b(under|below|less than|at most|maximum|max)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b>=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		if ( preg_match( '/\b<=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param string $value Amount string.
+	 * @return float|null
+	 */
+	private function parse_amount_string( $value ) {
+		$value = str_replace( array( ',', ' ' ), '', (string) $value );
+		return $this->normalize_amount( $value );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_country( $query ) {
+		$query_lower = strtolower( $query );
+		$map         = $this->get_country_map();
+
+		foreach ( $map as $name => $code ) {
+			$pattern = '/\b' . preg_quote( $name, '/' ) . '\b/i';
+			if ( preg_match( $pattern, $query_lower ) ) {
+				return $code;
+			}
+		}
+
+		if ( preg_match_all( '/\b([A-Z]{2})\b/', strtoupper( $query ), $matches ) ) {
+			foreach ( $matches[1] as $code ) {
+				if ( isset( $map[ strtolower( $code ) ] ) ) {
+					return $map[ strtolower( $code ) ];
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_country_map() {
+		static $map = null;
+		if ( null !== $map ) {
+			return $map;
+		}
+
+		$countries = array();
+		if ( function_exists( 'WC' ) ) {
+			$wc = WC();
+			if ( $wc && isset( $wc->countries ) && method_exists( $wc->countries, 'get_countries' ) ) {
+				$countries = $wc->countries->get_countries();
+			}
+		}
+
+		if ( empty( $countries ) && class_exists( 'WC_Countries' ) ) {
+			$wc_countries = new \WC_Countries();
+			$countries    = $wc_countries->get_countries();
+		}
+
+		$map = array();
+		if ( is_array( $countries ) ) {
+			foreach ( $countries as $code => $name ) {
+				$map[ strtolower( $name ) ] = strtoupper( $code );
+				$map[ strtolower( $code ) ] = strtoupper( $code );
+			}
+		}
+
+		$map['usa'] = 'US';
+		$map['us']  = 'US';
+		$map['uk']  = 'GB';
+
+		return $map;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_order_country( $order ) {
+		$country = method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '';
+		if ( '' !== $country ) {
+			return $country;
+		}
+
+		if ( method_exists( $order, 'get_billing_country' ) ) {
+			$country = $order->get_billing_country();
+		}
+
+		return is_string( $country ) ? $country : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_draft_id( array $args ) {
+		$draft_id = isset( $args['draft_id'] ) ? $args['draft_id'] : '';
+		if ( '' === $draft_id && isset( $args['params']['draft_id'] ) ) {
+			$draft_id = $args['params']['draft_id'];
+		}
+
+		return is_string( $draft_id ) ? trim( $draft_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_progress_id( array $args ) {
+		$progress_id = isset( $args['progress_id'] ) ? $args['progress_id'] : '';
+		if ( '' === $progress_id && isset( $args['params']['progress_id'] ) ) {
+			$progress_id = $args['params']['progress_id'];
+		}
+
+		return is_string( $progress_id ) ? trim( $progress_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_rollback_id( array $args ) {
+		$rollback_id = isset( $args['rollback_id'] ) ? $args['rollback_id'] : '';
+		if ( '' === $rollback_id && isset( $args['params']['rollback_id'] ) ) {
+			$rollback_id = $args['params']['rollback_id'];
+		}
+
+		return is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+	}
+
+	/**
+	 * @return bool
+	 */
+	private function action_scheduler_available() {
+		return function_exists( 'as_enqueue_async_action' ) || function_exists( 'as_schedule_single_action' );
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return int
+	 */
+	private function schedule_job( $job_id ) {
+		if ( function_exists( 'as_enqueue_async_action' ) ) {
+			return (int) as_enqueue_async_action( self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		if ( function_exists( 'as_schedule_single_action' ) ) {
+			return (int) as_schedule_single_action( time(), self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		return 0;
+	}
+}
diff --git a/src/Plugin.php b/src/Plugin.php
index 01ae991acdb6f0546a735ab888160091c456700a..4751cc435f813540794ea9968e6b5b99ec25ac66
--- a/src/Plugin.php
+++ b/src/Plugin.php
@@ -99,6 +99,10 @@
 			Search\Index::init();
 		}
 
+		if ( class_exists( 'AgentWP\\Handlers\\BulkHandler' ) ) {
+			Handlers\BulkHandler::register_hooks();
+		}
+
 		if ( class_exists( 'AgentWP\\Demo\\Manager' ) ) {
 			Demo\Manager::init();
 		}


thinking
**Summarizing final implementation and verification**

I’m putting together a concise summary of the bulk operations handler implementation, covering all main features like draft/confirm flows, async job scheduling, progress tracking, rollback, and CSV export, along with plugin hook registration. I’ll include status, key file paths, verification notes, and potential risks or follow-ups for clarity.
codex
Implemented bulk action workflow and background processing with draft/confirm previews, criteria parsing, progress polling, rollback storage, and CSV export in `src/Handlers/BulkHandler.php`, and registered the Action Scheduler hook in `src/Plugin.php` to run queued jobs.

Status: DONE

Summary of changes
- Added bulk operations handler with selection, draft/confirm, async processing, polling progress, rollback, and CSV export in `src/Handlers/BulkHandler.php`.
- Registered the bulk job Action Scheduler hook in `src/Plugin.php`.

How to verify
- No verification commands provided.

Risks / follow-ups
- Async processing depends on Action Scheduler availability; if missing, large batches run synchronously.
- Order tags use `shop_order_tag` when available and fall back to `_agentwp_order_tags` meta; adjust via `agentwp_order_tag_taxonomy` if needed.
- Consider adding a dedicated REST endpoint for progress/rollback polling if clients need a stable API surface.
file update:
diff --git a/src/Handlers/BulkHandler.php b/src/Handlers/BulkHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..f071e1fb69c964afa98618d7baaf75fcceab1807
--- /dev/null
+++ b/src/Handlers/BulkHandler.php
@@ -0,0 +1,2231 @@
+<?php
+/**
+ * Handle bulk order operations.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class BulkHandler {
+	const ACTION_HOOK      = 'agentwp_bulk_process';
+	const ASYNC_THRESHOLD  = 20;
+	const DRAFT_TYPE       = 'bulk_action';
+	const JOB_TTL_SECONDS  = 86400;
+	const MAX_BULK         = 1000;
+	const PROGRESS_TTL     = 86400;
+	const ROLLBACK_TTL     = 86400;
+	const POLL_INTERVAL    = 2;
+
+	/**
+	 * Register background processing hooks.
+	 *
+	 * @return void
+	 */
+	public static function register_hooks() {
+		add_action( self::ACTION_HOOK, array( __CLASS__, 'handle_scheduled_action' ), 10, 1 );
+	}
+
+	/**
+	 * Execute scheduled bulk jobs.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	public static function handle_scheduled_action( $job_id ) {
+		$handler = new self();
+		$handler->process_scheduled_job( $job_id );
+	}
+
+	/**
+	 * Handle bulk actions and selections.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['criteria'] ) ) {
+			return $this->select_orders( $args );
+		}
+
+		$progress_id = $this->extract_progress_id( $args );
+		if ( '' !== $progress_id ) {
+			return $this->get_progress_response( $progress_id );
+		}
+
+		$rollback_id = $this->extract_rollback_id( $args );
+		if ( '' !== $rollback_id ) {
+			return $this->rollback_bulk_action( $rollback_id );
+		}
+
+		$draft_id = $this->extract_draft_id( $args );
+		if ( '' !== $draft_id ) {
+			return $this->confirm_bulk_update( $draft_id );
+		}
+
+		return $this->prepare_bulk_update( $args );
+	}
+
+	/**
+	 * Select orders based on criteria.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function select_orders( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to select orders.', 400 );
+		}
+
+		$criteria  = $this->normalize_criteria( isset( $args['criteria'] ) ? $args['criteria'] : array() );
+		$order_ids = $this->query_order_ids( $criteria );
+		$sample    = $this->build_sample_orders( $order_ids );
+
+		return Response::success(
+			array(
+				'order_ids'  => $order_ids,
+				'count'      => count( $order_ids ),
+				'criteria'   => $criteria,
+				'sample'     => $sample,
+				'truncated'  => count( $order_ids ) >= self::MAX_BULK,
+				'max_limit'  => self::MAX_BULK,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a bulk update draft.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	private function prepare_bulk_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $args['action'] ) ? $args['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Missing or invalid bulk action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $args['params'] ) ? $args['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$missing_orders = $this->find_missing_orders( $order_ids );
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		$sample = $this->build_sample_orders( $order_ids );
+		$preview = array(
+			'order_count'    => count( $order_ids ),
+			'sample'         => $sample,
+			'action'         => $action,
+			'action_preview' => $this->build_action_preview( $action, $params ),
+		);
+
+		$draft_payload = array(
+			'order_ids' => $order_ids,
+			'action'    => $action,
+			'params'    => $params,
+			'preview'   => $preview,
+		);
+
+		$draft_id   = $this->generate_uuid();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and execute a bulk update draft.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	private function confirm_bulk_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) ) {
+			return Response::error( 'WooCommerce is required to process bulk updates.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing bulk update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Bulk update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for bulk update confirmation.', 400 );
+		}
+
+		$payload  = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk updates support up to 1000 orders at a time.', 400 );
+		}
+
+		$action = $this->normalize_action( isset( $payload['action'] ) ? $payload['action'] : '' );
+		if ( '' === $action ) {
+			return Response::error( 'Bulk update draft is missing an action.', 400 );
+		}
+
+		$params = $this->normalize_params( $action, isset( $payload['params'] ) ? $payload['params'] : array() );
+		if ( isset( $params['error'] ) ) {
+			return Response::error( $params['error'], 400 );
+		}
+
+		$job_id      = $this->generate_uuid();
+		$progress_id = $this->generate_uuid();
+		$rollback_id = $this->generate_uuid();
+
+		$rollback_expires = gmdate( 'c', time() + self::ROLLBACK_TTL );
+		$this->store_rollback(
+			$rollback_id,
+			array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => $rollback_expires,
+				'orders'     => array(),
+			),
+			self::ROLLBACK_TTL
+		);
+
+		$progress = array(
+			'id'                  => $progress_id,
+			'status'              => 'queued',
+			'action'              => $action,
+			'order_count'         => count( $order_ids ),
+			'processed'           => 0,
+			'updated'             => 0,
+			'failed'              => 0,
+			'errors'              => array(),
+			'created_at'          => gmdate( 'c' ),
+			'started_at'          => '',
+			'last_updated'        => gmdate( 'c' ),
+			'completed_at'        => '',
+			'draft_id'            => $draft_id,
+			'rollback_id'         => $rollback_id,
+			'undo_available_until'=> $rollback_expires,
+		);
+		$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+
+		$job = array(
+			'id'          => $job_id,
+			'order_ids'   => $order_ids,
+			'action'      => $action,
+			'params'      => $params,
+			'progress_id' => $progress_id,
+			'rollback_id' => $rollback_id,
+			'draft_id'    => $draft_id,
+		);
+		$this->store_job( $job_id, $job, self::JOB_TTL_SECONDS );
+
+		$async = count( $order_ids ) > self::ASYNC_THRESHOLD && $this->action_scheduler_available();
+		if ( $async ) {
+			$action_id = $this->schedule_job( $job_id );
+			if ( ! $action_id ) {
+				return Response::error( 'Unable to schedule bulk update.', 500 );
+			}
+
+			$this->delete_draft( $draft_id );
+
+			return Response::success(
+				array(
+					'status'     => 'scheduled',
+					'draft_id'   => $draft_id,
+					'job_id'     => $job_id,
+					'progress'   => $progress,
+					'polling'    => array(
+						'progress_id'      => $progress_id,
+						'interval_seconds' => self::POLL_INTERVAL,
+					),
+					'rollback_id' => $rollback_id,
+					'undo_available_until' => $rollback_expires,
+				)
+			);
+		}
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'     => 'running',
+				'started_at' => gmdate( 'c' ),
+			),
+			true
+		);
+
+		$result = $this->run_bulk_job( $job );
+
+		$progress = $this->update_progress(
+			$progress_id,
+			array(
+				'status'       => 'completed',
+				'completed_at' => gmdate( 'c' ),
+				'result'       => $result,
+			),
+			true
+		);
+
+		$this->delete_job( $job_id );
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'status'      => 'completed',
+				'draft_id'    => $draft_id,
+				'result'      => $result,
+				'progress'    => $progress,
+				'polling'     => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+				'rollback_id' => $rollback_id,
+				'undo_available_until' => $rollback_expires,
+			)
+		);
+	}
+
+	/**
+	 * Process a scheduled bulk job.
+	 *
+	 * @param string $job_id Job identifier.
+	 * @return void
+	 */
+	private function process_scheduled_job( $job_id ) {
+		$job_id = is_string( $job_id ) ? trim( $job_id ) : '';
+		if ( '' === $job_id ) {
+			return;
+		}
+
+		$job = $this->load_job( $job_id );
+		if ( ! is_array( $job ) ) {
+			return;
+		}
+
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'     => 'running',
+					'started_at' => gmdate( 'c' ),
+				),
+				true
+			);
+		}
+
+		$result = $this->run_bulk_job( $job );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'status'       => 'completed',
+					'completed_at' => gmdate( 'c' ),
+					'result'       => $result,
+				),
+				true
+			);
+		}
+
+		$draft_id = isset( $job['draft_id'] ) ? (string) $job['draft_id'] : '';
+		if ( '' !== $draft_id ) {
+			$this->delete_draft( $draft_id );
+		}
+
+		$this->delete_job( $job_id );
+	}
+
+	/**
+	 * Execute a bulk job.
+	 *
+	 * @param array $job Job payload.
+	 * @return array
+	 */
+	private function run_bulk_job( array $job ) {
+		$order_ids   = isset( $job['order_ids'] ) ? $this->normalize_order_ids( $job['order_ids'] ) : array();
+		$action      = isset( $job['action'] ) ? $this->normalize_action( $job['action'] ) : '';
+		$params      = isset( $job['params'] ) && is_array( $job['params'] ) ? $job['params'] : array();
+		$progress_id = isset( $job['progress_id'] ) ? (string) $job['progress_id'] : '';
+		$rollback_id = isset( $job['rollback_id'] ) ? (string) $job['rollback_id'] : '';
+
+		$result = array(
+			'action'    => $action,
+			'order_ids' => $order_ids,
+			'updated'   => array(),
+			'failed'    => array(),
+			'errors'    => array(),
+		);
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			$rollback = array(
+				'id'         => $rollback_id,
+				'action'     => $action,
+				'created_at' => gmdate( 'c' ),
+				'expires_at' => gmdate( 'c', time() + self::ROLLBACK_TTL ),
+				'orders'     => array(),
+			);
+		}
+
+		$processed = 0;
+		$updated   = 0;
+		$failed    = 0;
+		$errors    = array();
+		$rows      = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$processed++;
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed++;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found.',
+				);
+				$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$current_status = $this->normalize_status( $order->get_status() );
+					$new_status     = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+					if ( '' === $new_status ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing target status.',
+						);
+						break;
+					}
+
+					$rollback['orders'][ $order_id ] = array(
+						'status' => $current_status,
+					);
+
+					$note            = isset( $params['note'] ) ? (string) $params['note'] : '';
+					$notify_customer = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+					$updated_flag    = $this->apply_status_update( $order, $new_status, $note, $notify_customer );
+
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to update status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+					$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+					$tags = $this->normalize_tags( $tags, $tag );
+					if ( empty( $tags ) ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing tags to add.',
+						);
+						break;
+					}
+
+					$before_tags = $this->get_order_tags( $order_id );
+					$rollback['orders'][ $order_id ] = array(
+						'tags' => $before_tags,
+					);
+
+					$updated_flag = $this->apply_tags_update( $order, $tags );
+					if ( $updated_flag ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+					if ( '' === $note ) {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing note content.',
+						);
+						break;
+					}
+
+					$is_customer_note = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+					$note_id          = $this->apply_order_note( $order, $note, $is_customer_note );
+					if ( $note_id > 0 ) {
+						$updated++;
+						$result['updated'][] = $order_id;
+						$rollback['orders'][ $order_id ] = array(
+							'notes' => array( $note_id ),
+						);
+					} else {
+						$failed++;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to add note.',
+						);
+					}
+					break;
+				case 'export_csv':
+					$rows[] = $this->format_export_row( $order );
+					$updated++;
+					$result['updated'][] = $order_id;
+					break;
+				default:
+					$failed++;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Unsupported bulk action.',
+					);
+			}
+
+			$this->maybe_update_progress( $progress_id, $processed, $updated, $failed, $errors );
+		}
+
+		$result['errors'] = $errors;
+		$result['failed'] = array_unique( array_merge( $result['failed'], wp_list_pluck( $errors, 'order_id' ) ) );
+
+		if ( 'export_csv' === $action ) {
+			$export = $this->export_csv( $rows, isset( $params['fields'] ) ? $params['fields'] : array() );
+			if ( isset( $export['error'] ) ) {
+				$errors[]         = array( 'order_id' => 0, 'message' => $export['error'] );
+				$result['errors'] = $errors;
+			} else {
+				$result['export'] = $export;
+			}
+		}
+
+		$this->store_rollback( $rollback_id, $rollback, self::ROLLBACK_TTL );
+
+		if ( '' !== $progress_id ) {
+			$this->update_progress(
+				$progress_id,
+				array(
+					'processed' => $processed,
+					'updated'   => $updated,
+					'failed'    => $failed,
+					'errors'    => $errors,
+				),
+				true
+			);
+		}
+
+		return $result;
+	}
+
+	/**
+	 * Provide progress updates to polling clients.
+	 *
+	 * @param string $progress_id Progress identifier.
+	 * @return Response
+	 */
+	private function get_progress_response( $progress_id ): Response {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			return Response::error( 'Bulk progress not found or expired.', 404 );
+		}
+
+		return Response::success(
+			array(
+				'progress' => $progress,
+				'polling'  => array(
+					'progress_id'      => $progress_id,
+					'interval_seconds' => self::POLL_INTERVAL,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Roll back a bulk action.
+	 *
+	 * @param string $rollback_id Rollback identifier.
+	 * @return Response
+	 */
+	private function rollback_bulk_action( $rollback_id ): Response {
+		$rollback_id = is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+		if ( '' === $rollback_id ) {
+			return Response::error( 'Missing rollback ID.', 400 );
+		}
+
+		$rollback = $this->load_rollback( $rollback_id );
+		if ( ! is_array( $rollback ) ) {
+			return Response::error( 'Rollback data not found or expired.', 404 );
+		}
+
+		$action  = isset( $rollback['action'] ) ? $this->normalize_action( $rollback['action'] ) : '';
+		$orders  = isset( $rollback['orders'] ) && is_array( $rollback['orders'] ) ? $rollback['orders'] : array();
+		$undone  = array();
+		$failed  = array();
+		$errors  = array();
+
+		foreach ( $orders as $order_id => $data ) {
+			$order_id = absint( $order_id );
+			$order    = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$failed[] = $order_id;
+				$errors[] = array(
+					'order_id' => $order_id,
+					'message'  => 'Order not found for rollback.',
+				);
+				continue;
+			}
+
+			switch ( $action ) {
+				case 'update_status':
+					$previous_status = isset( $data['status'] ) ? $this->normalize_status( $data['status'] ) : '';
+					if ( '' === $previous_status ) {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Missing previous status.',
+						);
+						break;
+					}
+
+					$updated = $this->apply_status_update( $order, $previous_status, 'Rollback to previous status.', false );
+					if ( $updated ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore previous status.',
+						);
+					}
+					break;
+				case 'add_tag':
+					$tags = isset( $data['tags'] ) ? $data['tags'] : array();
+					$restored = $this->restore_order_tags( $order_id, $tags );
+					if ( $restored ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to restore tags.',
+						);
+					}
+					break;
+				case 'add_note':
+					$notes = isset( $data['notes'] ) ? (array) $data['notes'] : array();
+					$deleted = $this->delete_order_notes( $notes );
+					if ( $deleted ) {
+						$undone[] = $order_id;
+					} else {
+						$failed[] = $order_id;
+						$errors[] = array(
+							'order_id' => $order_id,
+							'message'  => 'Unable to remove notes.',
+						);
+					}
+					break;
+				default:
+					$failed[] = $order_id;
+					$errors[] = array(
+						'order_id' => $order_id,
+						'message'  => 'Rollback not supported for this action.',
+					);
+			}
+		}
+
+		return Response::success(
+			array(
+				'rollback_id' => $rollback_id,
+				'action'      => $action,
+				'undone'      => $undone,
+				'failed'      => $failed,
+				'errors'      => $errors,
+			)
+		);
+	}
+
+	/**
+	 * @param array $criteria Criteria input.
+	 * @return array
+	 */
+	private function normalize_criteria( $criteria ) {
+		$parsed = array(
+			'status'         => '',
+			'date_range'     => null,
+			'customer_email' => '',
+			'total_min'      => null,
+			'total_max'      => null,
+			'country'        => '',
+		);
+		$query  = '';
+
+		if ( is_string( $criteria ) ) {
+			$query = sanitize_text_field( $criteria );
+		} elseif ( is_array( $criteria ) ) {
+			$query = isset( $criteria['query'] ) ? sanitize_text_field( $criteria['query'] ) : '';
+			$parsed['status'] = isset( $criteria['status'] ) ? $this->normalize_status( $criteria['status'] ) : '';
+			$parsed['date_range'] = $this->normalize_date_range_input( isset( $criteria['date_range'] ) ? $criteria['date_range'] : null );
+			$parsed['customer_email'] = isset( $criteria['customer_email'] ) ? sanitize_email( $criteria['customer_email'] ) : '';
+			$parsed['total_min'] = isset( $criteria['total_min'] ) ? $this->normalize_amount( $criteria['total_min'] ) : null;
+			$parsed['total_max'] = isset( $criteria['total_max'] ) ? $this->normalize_amount( $criteria['total_max'] ) : null;
+			$parsed['country'] = isset( $criteria['country'] ) ? $this->normalize_country( $criteria['country'] ) : '';
+		}
+
+		if ( '' !== $query ) {
+			$text_parsed = $this->parse_criteria_text( $query );
+			foreach ( $text_parsed as $key => $value ) {
+				if ( ! isset( $parsed[ $key ] ) || '' === $parsed[ $key ] || null === $parsed[ $key ] ) {
+					$parsed[ $key ] = $value;
+				}
+			}
+		}
+
+		if ( '' === $parsed['status'] ) {
+			unset( $parsed['status'] );
+		}
+		if ( '' === $parsed['customer_email'] ) {
+			unset( $parsed['customer_email'] );
+		}
+		if ( '' === $parsed['country'] ) {
+			unset( $parsed['country'] );
+		}
+		if ( null === $parsed['total_min'] ) {
+			unset( $parsed['total_min'] );
+		}
+		if ( null === $parsed['total_max'] ) {
+			unset( $parsed['total_max'] );
+		}
+		if ( null === $parsed['date_range'] ) {
+			unset( $parsed['date_range'] );
+		}
+
+		return $parsed;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function parse_criteria_text( $query ) {
+		$query  = trim( (string) $query );
+		$lower  = strtolower( $query );
+		$result = array();
+
+		$status = $this->detect_status( $lower );
+		if ( '' !== $status ) {
+			$result['status'] = $status;
+		}
+
+		$date_range = $this->parse_date_range_from_query( $lower );
+		if ( null !== $date_range ) {
+			$result['date_range'] = $date_range;
+		}
+
+		$email = $this->extract_email( $query );
+		if ( '' !== $email ) {
+			$result['customer_email'] = $email;
+		}
+
+		$totals = $this->extract_total_range( $lower );
+		if ( isset( $totals['min'] ) ) {
+			$result['total_min'] = $totals['min'];
+		}
+		if ( isset( $totals['max'] ) ) {
+			$result['total_max'] = $totals['max'];
+		}
+
+		$country = $this->extract_country( $query );
+		if ( '' !== $country ) {
+			$result['country'] = $country;
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param array $criteria Query criteria.
+	 * @return array
+	 */
+	private function query_order_ids( array $criteria ) {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		$args = array(
+			'limit'   => self::MAX_BULK,
+			'return'  => 'ids',
+			'orderby' => 'date',
+			'order'   => 'DESC',
+		);
+
+		if ( isset( $criteria['status'] ) && '' !== $criteria['status'] ) {
+			$args['status'] = $criteria['status'];
+		}
+
+		if ( isset( $criteria['date_range'] ) && is_array( $criteria['date_range'] ) ) {
+			$args['date_created'] = $criteria['date_range']['start'] . '...' . $criteria['date_range']['end'];
+		}
+
+		$meta_query = array( 'relation' => 'AND' );
+
+		if ( isset( $criteria['customer_email'] ) && '' !== $criteria['customer_email'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $criteria['customer_email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['country'] ) && '' !== $criteria['country'] ) {
+			$meta_query[] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_country',
+					'value'   => $criteria['country'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		if ( isset( $criteria['total_min'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_min'],
+				'compare' => '>=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( isset( $criteria['total_max'] ) ) {
+			$meta_query[] = array(
+				'key'     => '_order_total',
+				'value'   => $criteria['total_max'],
+				'compare' => '<=',
+				'type'    => 'NUMERIC',
+			);
+		}
+
+		if ( count( $meta_query ) > 1 ) {
+			$args['meta_query'] = $meta_query;
+		}
+
+		$order_ids = wc_get_orders( $args );
+		if ( ! is_array( $order_ids ) ) {
+			return array();
+		}
+
+		$order_ids = array_map( 'absint', $order_ids );
+		$order_ids = array_filter( $order_ids );
+		$order_ids = array_values( array_unique( $order_ids ) );
+
+		return $order_ids;
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function build_sample_orders( array $order_ids ) {
+		$sample = array();
+		$order_ids = array_slice( $order_ids, 0, 5 );
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( $order ) {
+				$sample[] = $this->format_order_summary( $order );
+			}
+		}
+
+		return $sample;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_order_summary( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'       => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'currency'       => method_exists( $order, 'get_currency' ) ? sanitize_text_field( $order->get_currency() ) : '',
+			'customer_name'  => sanitize_text_field( $this->get_customer_name( $order ) ),
+			'customer_email' => sanitize_email( $this->get_customer_email( $order ) ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'country'        => sanitize_text_field( $this->get_order_country( $order ) ),
+		);
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @param mixed $action Raw action.
+	 * @return string
+	 */
+	private function normalize_action( $action ) {
+		$action = is_string( $action ) ? strtolower( trim( $action ) ) : '';
+		$allowed = array( 'update_status', 'add_tag', 'add_note', 'export_csv' );
+
+		return in_array( $action, $allowed, true ) ? $action : '';
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param mixed  $params Raw params.
+	 * @return array
+	 */
+	private function normalize_params( $action, $params ) {
+		$params = is_array( $params ) ? $params : array();
+		$normalized = array();
+
+		switch ( $action ) {
+			case 'update_status':
+				$new_status = isset( $params['new_status'] ) ? $this->normalize_status( $params['new_status'] ) : '';
+				if ( '' === $new_status ) {
+					return array( 'error' => 'Missing new status for bulk update.' );
+				}
+
+				$valid_statuses = $this->get_valid_statuses();
+				if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+					return array( 'error' => 'Invalid status for bulk update.' );
+				}
+
+				$normalized['new_status'] = $new_status;
+				$normalized['note'] = isset( $params['note'] ) ? sanitize_text_field( wp_unslash( $params['note'] ) ) : '';
+				$normalized['notify_customer'] = $this->normalize_bool( isset( $params['notify_customer'] ) ? $params['notify_customer'] : false );
+				break;
+			case 'add_tag':
+				$tag  = isset( $params['tag'] ) ? $params['tag'] : '';
+				$tags = isset( $params['tags'] ) ? $params['tags'] : array();
+				$normalized['tags'] = $this->normalize_tags( $tags, $tag );
+				if ( empty( $normalized['tags'] ) ) {
+					return array( 'error' => 'Missing tags for bulk update.' );
+				}
+				break;
+			case 'add_note':
+				$note = isset( $params['note'] ) ? trim( (string) $params['note'] ) : '';
+				if ( '' === $note ) {
+					return array( 'error' => 'Missing note for bulk update.' );
+				}
+				$normalized['note'] = sanitize_text_field( wp_unslash( $note ) );
+				$normalized['is_customer_note'] = $this->normalize_bool( isset( $params['is_customer_note'] ) ? $params['is_customer_note'] : false );
+				break;
+			case 'export_csv':
+				$fields = isset( $params['fields'] ) ? $params['fields'] : array();
+				$normalized['fields'] = $this->normalize_fields( $fields );
+				break;
+			default:
+				return array( 'error' => 'Unsupported bulk action.' );
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param string $action Action name.
+	 * @param array  $params Params.
+	 * @return array
+	 */
+	private function build_action_preview( $action, array $params ) {
+		switch ( $action ) {
+			case 'update_status':
+				return array(
+					'new_status'      => isset( $params['new_status'] ) ? $params['new_status'] : '',
+					'notify_customer' => ! empty( $params['notify_customer'] ),
+					'note'            => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'add_tag':
+				return array(
+					'tags' => isset( $params['tags'] ) ? $params['tags'] : array(),
+				);
+			case 'add_note':
+				return array(
+					'note' => isset( $params['note'] ) ? $params['note'] : '',
+				);
+			case 'export_csv':
+				return array(
+					'fields' => isset( $params['fields'] ) ? $params['fields'] : $this->normalize_fields( array() ),
+				);
+			default:
+				return array();
+		}
+	}
+
+	/**
+	 * @param array $order_ids Order IDs.
+	 * @return array
+	 */
+	private function find_missing_orders( array $order_ids ) {
+		$missing = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+			if ( ! $order ) {
+				$missing[] = $order_id;
+			}
+		}
+
+		return $missing;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @param int    $processed Processed count.
+	 * @param int    $updated Updated count.
+	 * @param int    $failed Failed count.
+	 * @param array  $errors Error list.
+	 * @return void
+	 */
+	private function maybe_update_progress( $progress_id, $processed, $updated, $failed, array $errors ) {
+		if ( '' === $progress_id ) {
+			return;
+		}
+
+		$this->update_progress(
+			$progress_id,
+			array(
+				'processed' => $processed,
+				'updated'   => $updated,
+				'failed'    => $failed,
+				'errors'    => $errors,
+			),
+			false
+		);
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $updates Updates.
+	 * @param bool   $force Force update.
+	 * @return array
+	 */
+	private function update_progress( $progress_id, array $updates, $force ) {
+		$progress = $this->load_progress( $progress_id );
+		if ( null === $progress ) {
+			$progress = array(
+				'id'           => $progress_id,
+				'status'       => 'queued',
+				'processed'    => 0,
+				'updated'      => 0,
+				'failed'       => 0,
+				'errors'       => array(),
+				'created_at'   => gmdate( 'c' ),
+				'last_updated' => gmdate( 'c' ),
+			);
+		}
+
+		$last_updated = isset( $progress['last_updated'] ) ? strtotime( $progress['last_updated'] ) : 0;
+		$should_update = $force || ( time() - $last_updated >= self::POLL_INTERVAL );
+
+		foreach ( $updates as $key => $value ) {
+			$progress[ $key ] = $value;
+		}
+
+		if ( $should_update ) {
+			$progress['last_updated'] = gmdate( 'c' );
+			$this->store_progress( $progress_id, $progress, self::PROGRESS_TTL );
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @return array|null
+	 */
+	private function load_progress( $progress_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$progress = get_transient( $this->build_progress_key( $progress_id ) );
+		if ( false === $progress || ! is_array( $progress ) ) {
+			return null;
+		}
+
+		return $progress;
+	}
+
+	/**
+	 * @param string $progress_id Progress ID.
+	 * @param array  $progress Progress payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_progress( $progress_id, array $progress, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_progress_key( $progress_id ), $progress, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return array|null
+	 */
+	private function load_job( $job_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$job = get_transient( $this->build_job_key( $job_id ) );
+		if ( false === $job || ! is_array( $job ) ) {
+			return null;
+		}
+
+		return $job;
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @param array  $job Job payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_job( $job_id, array $job, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_job_key( $job_id ), $job, $ttl );
+	}
+
+	/**
+	 * @param string $job_id Job ID.
+	 * @return void
+	 */
+	private function delete_job( $job_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_job_key( $job_id ) );
+		}
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @return array|null
+	 */
+	private function load_rollback( $rollback_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$rollback = get_transient( $this->build_rollback_key( $rollback_id ) );
+		if ( false === $rollback || ! is_array( $rollback ) ) {
+			return null;
+		}
+
+		return $rollback;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback ID.
+	 * @param array  $rollback Rollback data.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_rollback( $rollback_id, array $rollback, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_rollback_key( $rollback_id ), $rollback, $ttl );
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_uuid() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'bulk_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_draft_' . $draft_id;
+	}
+
+	/**
+	 * @param string $progress_id Progress identifier.
+	 * @return string
+	 */
+	private function build_progress_key( $progress_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_progress_' . $progress_id;
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return string
+	 */
+	private function build_job_key( $job_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_job_' . $job_id;
+	}
+
+	/**
+	 * @param string $rollback_id Rollback identifier.
+	 * @return string
+	 */
+	private function build_rollback_key( $rollback_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'bulk_rollback_' . $rollback_id;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl TTL seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param mixed $status Raw status.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param mixed $value Input.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $amount Amount input.
+	 * @return float|null
+	 */
+	private function normalize_amount( $amount ) {
+		if ( null === $amount || '' === $amount ) {
+			return null;
+		}
+
+		if ( is_string( $amount ) ) {
+			$amount = preg_replace( '/[^0-9\.\-]/', '', $amount );
+		}
+
+		if ( '' === $amount || ! is_numeric( $amount ) ) {
+			return null;
+		}
+
+		$amount   = (float) $amount;
+		$decimals = $this->get_price_decimals();
+
+		if ( function_exists( 'wc_format_decimal' ) ) {
+			return (float) wc_format_decimal( $amount, $decimals );
+		}
+
+		return round( $amount, $decimals );
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_price_decimals() {
+		if ( function_exists( 'wc_get_price_decimals' ) ) {
+			return wc_get_price_decimals();
+		}
+
+		return 2;
+	}
+
+	/**
+	 * @param mixed $country Country input.
+	 * @return string
+	 */
+	private function normalize_country( $country ) {
+		$country = is_string( $country ) ? strtoupper( trim( $country ) ) : '';
+		if ( '' === $country ) {
+			return '';
+		}
+
+		if ( strlen( $country ) === 2 ) {
+			return $country;
+		}
+
+		$map = $this->get_country_map();
+		$key = strtolower( $country );
+
+		return isset( $map[ $key ] ) ? $map[ $key ] : '';
+	}
+
+	/**
+	 * @param mixed $tags Tags list.
+	 * @param mixed $tag Single tag.
+	 * @return array
+	 */
+	private function normalize_tags( $tags, $tag ) {
+		$list = array();
+
+		if ( is_string( $tags ) ) {
+			$tags = preg_split( '/[\s,]+/', $tags );
+		}
+
+		if ( is_array( $tags ) ) {
+			foreach ( $tags as $item ) {
+				$item = sanitize_text_field( (string) $item );
+				if ( '' !== $item ) {
+					$list[] = $item;
+				}
+			}
+		}
+
+		if ( is_string( $tag ) ) {
+			$tag = sanitize_text_field( $tag );
+			if ( '' !== $tag ) {
+				$list[] = $tag;
+			}
+		}
+
+		$list = array_values( array_unique( $list ) );
+
+		return $list;
+	}
+
+	/**
+	 * @param mixed $fields Fields input.
+	 * @return array
+	 */
+	private function normalize_fields( $fields ) {
+		$default = array( 'order_id', 'status', 'total', 'currency', 'customer_name', 'customer_email', 'date_created', 'billing_country', 'shipping_country' );
+		if ( empty( $fields ) ) {
+			return $default;
+		}
+
+		if ( is_string( $fields ) ) {
+			$fields = preg_split( '/[\s,]+/', $fields );
+		}
+
+		if ( ! is_array( $fields ) ) {
+			return $default;
+		}
+
+		$sanitized = array();
+		foreach ( $fields as $field ) {
+			$field = sanitize_key( $field );
+			if ( '' !== $field ) {
+				$sanitized[] = $field;
+			}
+		}
+
+		return array_values( array_unique( $sanitized ) );
+	}
+
+	/**
+	 * @param array $order Order object.
+	 * @param string $new_status New status.
+	 * @param string $note Note for audit.
+	 * @param bool $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $current_status === $new_status ) {
+			return false;
+		}
+
+		$note = trim( (string) $note );
+		$audit_note = sprintf( '[AgentWP] Bulk status update: %s -> %s.', $current_status, $new_status );
+		if ( '' !== $note ) {
+			$audit_note .= ' Note: ' . $note . '.';
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $audit_note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param array  $tags Tags to add.
+	 * @return bool
+	 */
+	private function apply_tags_update( $order, array $tags ) {
+		$order_id = method_exists( $order, 'get_id' ) ? $order->get_id() : 0;
+		if ( $order_id <= 0 ) {
+			return false;
+		}
+
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				$existing = array();
+			}
+			$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+			wp_set_object_terms( $order_id, $merged, $taxonomy, false );
+			return true;
+		}
+
+		if ( ! method_exists( $order, 'get_meta' ) || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			$existing = array();
+		}
+
+		$merged = array_values( array_unique( array_merge( $existing, $tags ) ) );
+		$order->update_meta_data( '_agentwp_order_tags', $merged );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @param string $note Note text.
+	 * @param bool   $is_customer_note Customer visibility.
+	 * @return int
+	 */
+	private function apply_order_note( $order, $note, $is_customer_note ) {
+		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
+			return 0;
+		}
+
+		$note = trim( (string) $note );
+		if ( '' === $note ) {
+			return 0;
+		}
+
+		$note_id = $order->add_order_note( $note, $is_customer_note );
+
+		return absint( $note_id );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return array
+	 */
+	private function format_export_row( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+
+		return array(
+			'order_id'        => intval( $order->get_id() ),
+			'status'          => sanitize_text_field( $order->get_status() ),
+			'total'           => $order->get_total(),
+			'currency'        => method_exists( $order, 'get_currency' ) ? $order->get_currency() : '',
+			'customer_name'   => $this->get_customer_name( $order ),
+			'customer_email'  => $this->get_customer_email( $order ),
+			'date_created'    => $date_created ? $date_created->date( 'c' ) : '',
+			'billing_country' => method_exists( $order, 'get_billing_country' ) ? $order->get_billing_country() : '',
+			'shipping_country'=> method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '',
+		);
+	}
+
+	/**
+	 * @param array $rows Data rows.
+	 * @param array $fields Fields list.
+	 * @return array
+	 */
+	private function export_csv( array $rows, array $fields ) {
+		if ( ! function_exists( 'wp_upload_dir' ) ) {
+			return array( 'error' => 'Unable to export CSV in this environment.' );
+		}
+
+		$fields = $this->normalize_fields( $fields );
+		$upload = wp_upload_dir();
+		$base   = isset( $upload['basedir'] ) ? $upload['basedir'] : '';
+		$url    = isset( $upload['baseurl'] ) ? $upload['baseurl'] : '';
+
+		if ( '' === $base || '' === $url ) {
+			return array( 'error' => 'Unable to resolve upload directory.' );
+		}
+
+		$dir = trailingslashit( $base ) . 'agentwp-exports';
+		if ( function_exists( 'wp_mkdir_p' ) ) {
+			wp_mkdir_p( $dir );
+		}
+
+		$filename = 'agentwp-bulk-export-' . gmdate( 'Ymd-His' ) . '-' . wp_generate_password( 6, false ) . '.csv';
+		$path     = trailingslashit( $dir ) . $filename;
+		$file     = @fopen( $path, 'w' );
+		if ( ! $file ) {
+			return array( 'error' => 'Unable to create CSV export file.' );
+		}
+
+		fputcsv( $file, $fields );
+		foreach ( $rows as $row ) {
+			$line = array();
+			foreach ( $fields as $field ) {
+				$line[] = isset( $row[ $field ] ) ? $row[ $field ] : '';
+			}
+			fputcsv( $file, $line );
+		}
+
+		fclose( $file );
+
+		return array(
+			'file_path' => $path,
+			'file_url'  => trailingslashit( $url ) . 'agentwp-exports/' . $filename,
+			'rows'      => count( $rows ),
+		);
+	}
+
+	/**
+	 * @param int $order_id Order ID.
+	 * @return array
+	 */
+	private function get_order_tags( $order_id ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			$existing = wp_get_object_terms( $order_id, $taxonomy, array( 'fields' => 'names' ) );
+			if ( is_wp_error( $existing ) ) {
+				return array();
+			}
+			return $existing;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'get_meta' ) ) {
+			return array();
+		}
+
+		$existing = $order->get_meta( '_agentwp_order_tags', true );
+		if ( ! is_array( $existing ) ) {
+			return array();
+		}
+
+		return $existing;
+	}
+
+	/**
+	 * @param int   $order_id Order ID.
+	 * @param array $tags Tags.
+	 * @return bool
+	 */
+	private function restore_order_tags( $order_id, $tags ) {
+		$taxonomy = $this->get_order_tag_taxonomy();
+		if ( '' !== $taxonomy ) {
+			wp_set_object_terms( $order_id, (array) $tags, $taxonomy, false );
+			return true;
+		}
+
+		$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
+		if ( ! $order || ! method_exists( $order, 'update_meta_data' ) ) {
+			return false;
+		}
+
+		$order->update_meta_data( '_agentwp_order_tags', (array) $tags );
+		if ( method_exists( $order, 'save' ) ) {
+			$order->save();
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param array $note_ids Note IDs.
+	 * @return bool
+	 */
+	private function delete_order_notes( array $note_ids ) {
+		if ( ! function_exists( 'wp_delete_comment' ) ) {
+			return false;
+		}
+
+		$deleted_any = false;
+		foreach ( $note_ids as $note_id ) {
+			$note_id = absint( $note_id );
+			if ( $note_id > 0 ) {
+				wp_delete_comment( $note_id, true );
+				$deleted_any = true;
+			}
+		}
+
+		return $deleted_any;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function get_order_tag_taxonomy() {
+		$taxonomy = apply_filters( 'agentwp_order_tag_taxonomy', 'shop_order_tag' );
+		$taxonomy = is_string( $taxonomy ) ? trim( $taxonomy ) : '';
+
+		if ( '' !== $taxonomy && function_exists( 'taxonomy_exists' ) && taxonomy_exists( $taxonomy ) ) {
+			return $taxonomy;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param array|null $date_range Date range input.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query text.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date.
+	 * @param string $end End date.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Date string.
+	 * @param bool   $end_of_day End of day flag.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		$date = $end_of_day ? $date->setTime( 23, 59, 59 ) : $date->setTime( 0, 0, 0 );
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array
+	 */
+	private function extract_total_range( $query ) {
+		$result = array();
+
+		if ( preg_match( '/\bbetween\s+[\$£\x{20AC}]?([0-9\.,]+)\s+(?:and|to)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+			return $result;
+		}
+
+		if ( preg_match( '/\b(over|above|more than|greater than|at least|minimum|min)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b(under|below|less than|at most|maximum|max)\s+[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[2] );
+		}
+
+		if ( preg_match( '/\b>=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['min'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		if ( preg_match( '/\b<=\s*[\$£\x{20AC}]?([0-9\.,]+)/ui', $query, $matches ) ) {
+			$result['max'] = $this->parse_amount_string( $matches[1] );
+		}
+
+		return $result;
+	}
+
+	/**
+	 * @param string $value Amount string.
+	 * @return float|null
+	 */
+	private function parse_amount_string( $value ) {
+		$value = str_replace( array( ',', ' ' ), '', (string) $value );
+		return $this->normalize_amount( $value );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_country( $query ) {
+		$query_lower = strtolower( $query );
+		$map         = $this->get_country_map();
+
+		foreach ( $map as $name => $code ) {
+			$pattern = '/\b' . preg_quote( $name, '/' ) . '\b/i';
+			if ( preg_match( $pattern, $query_lower ) ) {
+				return $code;
+			}
+		}
+
+		if ( preg_match_all( '/\b([A-Z]{2})\b/', strtoupper( $query ), $matches ) ) {
+			foreach ( $matches[1] as $code ) {
+				if ( isset( $map[ strtolower( $code ) ] ) ) {
+					return $map[ strtolower( $code ) ];
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_country_map() {
+		static $map = null;
+		if ( null !== $map ) {
+			return $map;
+		}
+
+		$countries = array();
+		if ( function_exists( 'WC' ) ) {
+			$wc = WC();
+			if ( $wc && isset( $wc->countries ) && method_exists( $wc->countries, 'get_countries' ) ) {
+				$countries = $wc->countries->get_countries();
+			}
+		}
+
+		if ( empty( $countries ) && class_exists( 'WC_Countries' ) ) {
+			$wc_countries = new \WC_Countries();
+			$countries    = $wc_countries->get_countries();
+		}
+
+		$map = array();
+		if ( is_array( $countries ) ) {
+			foreach ( $countries as $code => $name ) {
+				$map[ strtolower( $name ) ] = strtoupper( $code );
+				$map[ strtolower( $code ) ] = strtoupper( $code );
+			}
+		}
+
+		$map['usa'] = 'US';
+		$map['us']  = 'US';
+		$map['uk']  = 'GB';
+
+		return $map;
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order object.
+	 * @return string
+	 */
+	private function get_order_country( $order ) {
+		$country = method_exists( $order, 'get_shipping_country' ) ? $order->get_shipping_country() : '';
+		if ( '' !== $country ) {
+			return $country;
+		}
+
+		if ( method_exists( $order, 'get_billing_country' ) ) {
+			$country = $order->get_billing_country();
+		}
+
+		return is_string( $country ) ? $country : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_draft_id( array $args ) {
+		$draft_id = isset( $args['draft_id'] ) ? $args['draft_id'] : '';
+		if ( '' === $draft_id && isset( $args['params']['draft_id'] ) ) {
+			$draft_id = $args['params']['draft_id'];
+		}
+
+		return is_string( $draft_id ) ? trim( $draft_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_progress_id( array $args ) {
+		$progress_id = isset( $args['progress_id'] ) ? $args['progress_id'] : '';
+		if ( '' === $progress_id && isset( $args['params']['progress_id'] ) ) {
+			$progress_id = $args['params']['progress_id'];
+		}
+
+		return is_string( $progress_id ) ? trim( $progress_id ) : '';
+	}
+
+	/**
+	 * @param array $args Request args.
+	 * @return string
+	 */
+	private function extract_rollback_id( array $args ) {
+		$rollback_id = isset( $args['rollback_id'] ) ? $args['rollback_id'] : '';
+		if ( '' === $rollback_id && isset( $args['params']['rollback_id'] ) ) {
+			$rollback_id = $args['params']['rollback_id'];
+		}
+
+		return is_string( $rollback_id ) ? trim( $rollback_id ) : '';
+	}
+
+	/**
+	 * @return bool
+	 */
+	private function action_scheduler_available() {
+		return function_exists( 'as_enqueue_async_action' ) || function_exists( 'as_schedule_single_action' );
+	}
+
+	/**
+	 * @param string $job_id Job identifier.
+	 * @return int
+	 */
+	private function schedule_job( $job_id ) {
+		if ( function_exists( 'as_enqueue_async_action' ) ) {
+			return (int) as_enqueue_async_action( self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		if ( function_exists( 'as_schedule_single_action' ) ) {
+			return (int) as_schedule_single_action( time(), self::ACTION_HOOK, array( 'job_id' => $job_id ) );
+		}
+
+		return 0;
+	}
+}
diff --git a/src/Plugin.php b/src/Plugin.php
index 01ae991acdb6f0546a735ab888160091c456700a..4751cc435f813540794ea9968e6b5b99ec25ac66
--- a/src/Plugin.php
+++ b/src/Plugin.php
@@ -99,6 +99,10 @@
 			Search\Index::init();
 		}
 
+		if ( class_exists( 'AgentWP\\Handlers\\BulkHandler' ) ) {
+			Handlers\BulkHandler::register_hooks();
+		}
+
 		if ( class_exists( 'AgentWP\\Demo\\Manager' ) ) {
 			Demo\Manager::init();
 		}

tokens used
166,420
