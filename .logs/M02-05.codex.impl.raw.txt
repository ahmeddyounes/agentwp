Implemented stock search plus draft/confirm stock updates via a new stock handler, and wired product stock intents to surface live results.

Status: DONE
Summary of changes
- Added SKU/ID/name product search with variation payloads and stock update draft/confirm flow in `src/Handlers/StockHandler.php`.
- Updated product stock intent to call the stock handler and return matching products with counts in `src/Intent/Handlers/ProductStockHandler.php`.

How to verify
- No verification commands specified.

Risks / follow-ups
- Tests not run (no commands provided).

OpenAI Codex v0.77.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/agentwp
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019b94fa-7ef1-73c0-a693-3ff0fb399c01
--------
user
You are implementing task M02-05 in this git repository.

1) Read the spec: .plans/M02-05.md
2) Read handoff/context: .t2/handoff/M02-05.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: 
- test: 

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers

thinking
**Preparing to review skills and instructions**
exec
/bin/zsh -lc ls in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 45ms:
agentwp.php
assets
composer.json
docker
docker-compose.yml
docs
includes
languages
react
README.md
scripts
setup.sh
src
tasks.csv
uninstall.php

thinking
**Reading plan and handoff files**
exec
/bin/zsh -lc 'cat .plans/M02-05.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 46ms:
# M02-05 — Product Stock Management

Implement inventory management functionality: 1) Create AgentWP\Handlers\StockHandler class. 2) OpenAI function schemas: search_product(query: string, sku?: string), prepare_stock_update(product_id: int, quantity: int, operation: 'set'|'increase'|'decrease'). 3) Product search by name (fuzzy match), SKU (exact), or ID. 4) Return product info: id, name, sku, current_stock, stock_status, manage_stock, backorders_allowed. 5) Draft-Confirm for stock changes showing: product name, SKU, current_stock → new_stock. 6) Handle variable products: show variations, allow updating specific variation. 7) Validate: can't decrease below 0 unless backorders allowed, warn if setting stock when manage_stock is disabled. Acceptance Criteria: SKU search returns exact match, name search handles partial matches, stock updates trigger woocommerce_product_set_stock hook, variations displayed and updatable independently.
exec
/bin/zsh -lc 'cat .t2/handoff/M02-05.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
# Handoff: M02-05

Created: 2026-01-06T20:23:23.080804Z

Spec: .plans/M02-05.md

thinking
**Exploring WordPress plugin integration**
exec
/bin/zsh -lc 'rg -n "StockHandler|stock" includes src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/Handlers/RefundHandler.php:54:		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );
src/Handlers/RefundHandler.php:79:		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();
src/Handlers/RefundHandler.php:90:			'items_to_restock'       => $items_to_restock,
src/Handlers/RefundHandler.php:179:		$items_to_restock = isset( $payload['items_to_restock'] ) && is_array( $payload['items_to_restock'] )
src/Handlers/RefundHandler.php:180:			? $payload['items_to_restock']
src/Handlers/RefundHandler.php:182:		$should_restock = $this->is_full_refund( $refund_amount, $remaining ) && ! empty( $items_to_restock );
src/Handlers/RefundHandler.php:190:				'restock_items'  => false,
src/Handlers/RefundHandler.php:199:		$restocked = $should_restock ? $this->restock_items( $order, $items_to_restock ) : array();
src/Handlers/RefundHandler.php:202:		$this->add_audit_note( $order, $draft_id, $refund_amount, $reason, ! empty( $restocked ) );
src/Handlers/RefundHandler.php:212:				'restocked_items'        => $restocked,
src/Handlers/RefundHandler.php:277:	private function build_items_to_restock( $order ) {
src/Handlers/RefundHandler.php:464:	 * @param array $items_to_restock Items to restock.
src/Handlers/RefundHandler.php:467:	private function restock_items( $order, array $items_to_restock ) {
src/Handlers/RefundHandler.php:468:		$restocked = array();
src/Handlers/RefundHandler.php:470:		if ( ! $order || ! function_exists( 'wc_update_product_stock' ) ) {
src/Handlers/RefundHandler.php:471:			return $restocked;
src/Handlers/RefundHandler.php:474:		foreach ( $items_to_restock as $item_data ) {
src/Handlers/RefundHandler.php:487:			if ( ! $product || ! $product->managing_stock() ) {
src/Handlers/RefundHandler.php:491:			wc_update_product_stock( $product, $quantity, 'increase' );
src/Handlers/RefundHandler.php:492:			$restocked[] = array(

thinking
**Checking existing PrepareStockUpdate schema**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/PrepareStockUpdate.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
<?php
/**
 * Function schema for stock updates.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class PrepareStockUpdate extends AbstractFunction {
	public function get_name() {
		return 'prepare_stock_update';
	}

	public function get_description() {
		return 'Prepare a draft stock update for a product.';
	}

	public function get_parameters() {
		return array(

thinking
**Searching for product function**
exec
/bin/zsh -lc 'rg -n "search_product" -S src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
src/AI/Functions/SearchProduct.php:12:		return 'search_product';
src/Intent/Engine.php:179:			Intent::PRODUCT_STOCK   => array( 'prepare_stock_update', 'search_product' ),
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/SearchProduct.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Function schema for product search.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class SearchProduct extends AbstractFunction {
	public function get_name() {
		return 'search_product';
	}

	public function get_description() {
		return 'Search for products by name, SKU, or ID.';
	}

	public function get_parameters() {
		return array(

thinking
**Checking for existing stock handlers**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/ProductStockHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 46ms:
<?php
/**
 * Handle product stock intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Intent;

class ProductStockHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::PRODUCT_STOCK );
	}

	/**
	 * @param array $context Context data.
	 * @return Response

thinking
**Checking existing handlers**
exec
/bin/zsh -lc 'ls src/Handlers' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
OrderSearchHandler.php
OrderStatusHandler.php
RefundHandler.php

thinking
**Creating StockHandler class**
exec
/bin/zsh -lc "sed -n '1,240p' src/Handlers/OrderStatusHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Handle order status draft preparation and confirmation.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;

class OrderStatusHandler {
	const DRAFT_TYPE = 'status_update';
	const MAX_BULK   = 50;

	/**
	 * Handle order status requests.
	 *
	 * @param array $args Request args.

thinking
**Inspecting draft storage implementation**
exec
/bin/zsh -lc "sed -n '240,520p' src/Handlers/OrderStatusHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 46ms:
	}

	/**
	 * Confirm and apply a draft status update.
	 *
	 * @param string $draft_id Draft identifier.
	 * @return Response
	 */
	public function confirm_status_update( $draft_id ): Response {
		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
			return Response::error( 'WooCommerce is required to update order statuses.', 400 );
		}

		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
		if ( '' === $draft_id ) {
			return Response::error( 'Missing status update draft ID.', 400 );
		}

		$draft = $this->load_draft( $draft_id );
		if ( null === $draft ) {
exec
/bin/zsh -lc "sed -n '520,1040p' src/Handlers/OrderStatusHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
					if ( '' !== $normalized_status ) {
						$normalized[] = $normalized_status;
					}
				}
			}
		}

		if ( ! empty( $normalized ) ) {
			$allowed = array_values( array_intersect( $allowed, $normalized ) );
		}

		sort( $allowed );

		return $allowed;
	}

	/**
	 * @param string $status Target status.
	 * @return string
	 */

thinking
**Comparing handlers for insights**
exec
/bin/zsh -lc "sed -n '1,200p' src/Handlers/RefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 46ms:
<?php
/**
 * Handle refund draft preparation and confirmation.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;

class RefundHandler {
	const DRAFT_TYPE = 'refund';

	/**
	 * Handle refund-related requests.
	 *
	 * @param array $args Request args.
	 * @return Response

thinking
**Identifying handler needs for stock drafts**
exec
/bin/zsh -lc "rg -n \"Handlers\\\\\" src" in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 44ms:
rg: regex parse error:
    (?:Handlers\)
    ^
error: unclosed group

thinking
**Simplifying regex usage**
exec
/bin/zsh -lc 'rg -n "Handlers" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
src/Handlers/RefundHandler.php:8:namespace AgentWP\Handlers;
src/Handlers/OrderSearchHandler.php:8:namespace AgentWP\Handlers;
src/Handlers/OrderStatusHandler.php:8:namespace AgentWP\Handlers;
src/Intent/Handlers/FallbackHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/CustomerLookupHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderRefundHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/ProductStockHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/BaseHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderSearchHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderSearchHandler.php:11:use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
src/Intent/Handlers/EmailDraftHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderStatusHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/AnalyticsQueryHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Engine.php:11:use AgentWP\Intent\Handlers\AnalyticsQueryHandler;
src/Intent/Engine.php:12:use AgentWP\Intent\Handlers\CustomerLookupHandler;
src/Intent/Engine.php:13:use AgentWP\Intent\Handlers\EmailDraftHandler;
src/Intent/Engine.php:14:use AgentWP\Intent\Handlers\FallbackHandler;
src/Intent/Engine.php:15:use AgentWP\Intent\Handlers\OrderRefundHandler;
src/Intent/Engine.php:16:use AgentWP\Intent\Handlers\OrderSearchHandler;
src/Intent/Engine.php:17:use AgentWP\Intent\Handlers\OrderStatusHandler;

thinking
**Checking API endpoints and handlers**
exec
/bin/zsh -lc 'rg -n "prepare_" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
src/Handlers/RefundHandler.php:27:		return $this->prepare_refund( $args );
src/Handlers/RefundHandler.php:36:	public function prepare_refund( array $args ): Response {
src/Handlers/OrderStatusHandler.php:29:			return $this->prepare_bulk_status_update( $args );
src/Handlers/OrderStatusHandler.php:32:		return $this->prepare_status_update( $args );
src/Handlers/OrderStatusHandler.php:41:	public function prepare_status_update( array $args ): Response {
src/Handlers/OrderStatusHandler.php:128:	public function prepare_bulk_status_update( array $args ): Response {
src/AI/Functions/PrepareBulkStatusUpdate.php:12:		return 'prepare_bulk_status_update';
src/AI/Functions/PrepareStockUpdate.php:12:		return 'prepare_stock_update';
src/AI/Functions/PrepareRefund.php:12:		return 'prepare_refund';
src/AI/Functions/PrepareStatusUpdate.php:12:		return 'prepare_status_update';
src/Intent/Engine.php:177:			Intent::ORDER_REFUND    => array( 'prepare_refund', 'confirm_refund' ),
src/Intent/Engine.php:178:			Intent::ORDER_STATUS    => array( 'prepare_status_update', 'prepare_bulk_status_update', 'bulk_update' ),
src/Intent/Engine.php:179:			Intent::PRODUCT_STOCK   => array( 'prepare_stock_update', 'search_product' ),

thinking
**Searching for OpenAI function handlers**
exec
/bin/zsh -lc 'rg -n "prepare_stock_update|confirm_refund|prepare_refund|prepare_status_update|search_product" src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/Handlers/RefundHandler.php:24:			return $this->confirm_refund( $args['draft_id'] );
src/Handlers/RefundHandler.php:27:		return $this->prepare_refund( $args );
src/Handlers/RefundHandler.php:36:	public function prepare_refund( array $args ): Response {
src/Handlers/RefundHandler.php:129:	public function confirm_refund( $draft_id ): Response {
src/Handlers/OrderStatusHandler.php:32:		return $this->prepare_status_update( $args );
src/Handlers/OrderStatusHandler.php:41:	public function prepare_status_update( array $args ): Response {
src/Intent/Engine.php:177:			Intent::ORDER_REFUND    => array( 'prepare_refund', 'confirm_refund' ),
src/Intent/Engine.php:178:			Intent::ORDER_STATUS    => array( 'prepare_status_update', 'prepare_bulk_status_update', 'bulk_update' ),
src/Intent/Engine.php:179:			Intent::PRODUCT_STOCK   => array( 'prepare_stock_update', 'search_product' ),
src/AI/Functions/ConfirmRefund.php:12:		return 'confirm_refund';
src/AI/Functions/PrepareStatusUpdate.php:12:		return 'prepare_status_update';
src/AI/Functions/SearchProduct.php:12:		return 'search_product';
src/AI/Functions/PrepareStockUpdate.php:12:		return 'prepare_stock_update';
src/AI/Functions/PrepareRefund.php:12:		return 'prepare_refund';

thinking
**Searching for function dispatch registry**
exec
/bin/zsh -lc 'rg -n "function" src/AI src/Handlers src/REST src/Routes includes' in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 55ms:
rg: src/Routes: No such file or directory (os error 2)
src/AI/Model.php:19:	public static function all() {
src/AI/Model.php:32:	public static function normalize( $model ) {
src/Handlers/RefundHandler.php:22:	public function handle( array $args ): Response {
src/Handlers/RefundHandler.php:36:	public function prepare_refund( array $args ): Response {
src/Handlers/RefundHandler.php:37:		if ( ! function_exists( 'wc_get_order' ) ) {
src/Handlers/RefundHandler.php:129:	public function confirm_refund( $draft_id ): Response {
src/Handlers/RefundHandler.php:130:		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_create_refund' ) ) {
src/Handlers/RefundHandler.php:222:	private function normalize_bool( $value ) {
src/Handlers/RefundHandler.php:223:		if ( function_exists( 'rest_sanitize_boolean' ) ) {
src/Handlers/RefundHandler.php:234:	private function normalize_amount( $amount ) {
src/Handlers/RefundHandler.php:238:		if ( function_exists( 'wc_format_decimal' ) ) {
src/Handlers/RefundHandler.php:248:	private function get_price_decimals() {
src/Handlers/RefundHandler.php:249:		if ( function_exists( 'wc_get_price_decimals' ) ) {
src/Handlers/RefundHandler.php:259:	private function amount_epsilon() {
src/Handlers/RefundHandler.php:269:	private function is_full_refund( $refund_amount, $remaining ) {
src/Handlers/RefundHandler.php:277:	private function build_items_to_restock( $order ) {
src/Handlers/RefundHandler.php:310:	private function get_customer_email( $order ) {
src/Handlers/RefundHandler.php:322:	private function get_payment_method_label( $order ) {
src/Handlers/RefundHandler.php:341:	private function get_payment_gateway( $order ) {

thinking
**Searching for Intent Controller**
exec
/bin/zsh -lc "sed -n '1,220p' src/REST/IntentController.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Intent REST controller.
 *
 * @package AgentWP
 */

namespace AgentWP\Rest;

use AgentWP\API\RestController;
use AgentWP\Intent\Engine;
use WP_REST_Server;

class IntentController extends RestController {
	/**
	 * Register REST routes.
	 *
	 * @return void
	 */
	public function register_routes() {

thinking
**Inspecting Engine for tool handling**
exec
/bin/zsh -lc "sed -n '1,260p' src/Intent/Engine.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
<?php
/**
 * Intent engine for routing requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

use AgentWP\AI\Response;
use AgentWP\Intent\Handlers\AnalyticsQueryHandler;
use AgentWP\Intent\Handlers\CustomerLookupHandler;
use AgentWP\Intent\Handlers\EmailDraftHandler;
use AgentWP\Intent\Handlers\FallbackHandler;
use AgentWP\Intent\Handlers\OrderRefundHandler;
use AgentWP\Intent\Handlers\OrderSearchHandler;
use AgentWP\Intent\Handlers\OrderStatusHandler;
use AgentWP\Intent\Handlers\ProductStockHandler;

class Engine {

thinking
**Investigating FunctionRegistry usage**
exec
/bin/zsh -lc "sed -n '1,240p' src/Intent/FunctionRegistry.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 45ms:
<?php
/**
 * OpenAI function registry for intent handlers.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

class FunctionRegistry {
	/**
	 * @var array<string, Handler>
	 */
	private $map = array();

	/**
	 * @param string  $function_name OpenAI function name.
	 * @param Handler $handler Handler instance.
	 * @return void
	 */

thinking
**Inspecting OrderRefundHandler**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/OrderRefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Handle order refund intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Intent;

class OrderRefundHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_REFUND );
	}

	/**
	 * @param array $context Context data.
	 * @return Response

thinking
**Searching for function call handlers**
exec
/bin/zsh -lc 'rg -n "tool_call|function_call|tool" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 62ms:
src/AI/Functions/FunctionSchema.php:29:	public function to_tool_definition();
src/AI/Functions/AbstractFunction.php:3: * Base class for tool definitions.
src/AI/Functions/AbstractFunction.php:14:	public function to_tool_definition() {
src/AI/TokenCounter.php:20:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:24:	public function count_request_tokens( array $messages, array $tools, $model ) {
src/AI/TokenCounter.php:28:			+ $this->count_tool_tokens( $tools, $model );
src/AI/TokenCounter.php:67:	 * Count tokens for tool definitions.
src/AI/TokenCounter.php:69:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:73:	public function count_tool_tokens( array $tools, $model ) {
src/AI/TokenCounter.php:74:		if ( empty( $tools ) ) {
src/AI/TokenCounter.php:78:		$payload = wp_json_encode( $tools );
src/AI/OpenAIClient.php:99:		$tools = $this->normalize_tools( $functions );
src/AI/OpenAIClient.php:106:		if ( ! empty( $tools ) ) {
src/AI/OpenAIClient.php:107:			$payload['tools']       = $tools;
src/AI/OpenAIClient.php:108:			$payload['tool_choice'] = 'auto';
src/AI/OpenAIClient.php:116:		$input_tokens = $this->token_counter->count_request_tokens( $messages, $tools, $this->model );
src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:296:	private function normalize_tools( array $functions ) {
src/AI/OpenAIClient.php:297:		$tools = array();
src/AI/OpenAIClient.php:301:				$tools[] = $function->to_tool_definition();

thinking
**Searching for tool call processing**
exec
/bin/zsh -lc 'rg -n "tool_calls|function_registry|FunctionRegistry" -S src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
src/Intent/FunctionRegistry.php:10:class FunctionRegistry {
src/Intent/Engine.php:37:	 * @var FunctionRegistry
src/Intent/Engine.php:39:	private $function_registry;
src/Intent/Engine.php:53:	 * @param FunctionRegistry|null $function_registry Optional registry.
src/Intent/Engine.php:60:		FunctionRegistry $function_registry = null,
src/Intent/Engine.php:68:		$this->function_registry = $function_registry ? $function_registry : new FunctionRegistry();
src/Intent/Engine.php:94:		$enriched['function_suggestions'] = $this->function_registry->get_functions_for_intent( $enriched['intent'] );
src/Intent/Engine.php:112:	 * @return FunctionRegistry
src/Intent/Engine.php:114:	public function get_function_registry() {
src/Intent/Engine.php:115:		return $this->function_registry;
src/Intent/Engine.php:192:				$this->function_registry->register( $function_name, $handler );
src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:389:				'tool_calls' => array(),
src/AI/OpenAIClient.php:400:		$tool_calls = isset( $message['tool_calls'] ) && is_array( $message['tool_calls'] ) ? $message['tool_calls'] : array();
src/AI/OpenAIClient.php:402:		if ( empty( $tool_calls ) && isset( $message['function_call'] ) && is_array( $message['function_call'] ) ) {
src/AI/OpenAIClient.php:403:			$tool_calls = array(
src/AI/OpenAIClient.php:416:			'tool_calls' => $tool_calls,
src/AI/OpenAIClient.php:430:		$tool_calls = array();
src/AI/OpenAIClient.php:476:			if ( isset( $delta['tool_calls'] ) && is_array( $delta['tool_calls'] ) ) {
src/AI/OpenAIClient.php:477:				$tool_calls = $this->merge_tool_call_deltas( $tool_calls, $delta['tool_calls'] );

thinking
**Searching for function call handling**
exec
/bin/zsh -lc 'ls src/AI' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 35ms:
Functions
Model.php
OpenAIClient.php
Response.php
TokenCounter.php

thinking
**Searching for function call handlers**
exec
/bin/zsh -lc 'rg -n "tool_calls|function_call|function" react src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
src/Rest/HealthController.php:19:	public function register_routes() {
src/Rest/HealthController.php:37:	public function get_health( $request ) {
src/Intent/IntentClassifier.php:16:	public function classify( $input, array $context = array() ) {
src/Intent/IntentClassifier.php:56:	private function score_refund( $text ) {
src/Intent/IntentClassifier.php:73:	private function score_status( $text ) {
src/Intent/IntentClassifier.php:93:	private function score_stock( $text ) {
src/Intent/IntentClassifier.php:111:	private function score_email( $text ) {
src/Intent/IntentClassifier.php:134:	private function score_analytics( $text ) {
src/Intent/IntentClassifier.php:154:	private function score_customer( $text ) {
src/Intent/IntentClassifier.php:171:	private function score_search( $text ) {
src/Intent/IntentClassifier.php:191:	private function match_score( $text, array $phrases ) {
src/Intent/IntentClassifier.php:207:	private function contains_phrase( $text, $phrase ) {
react/src/App.jsx:64:  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
react/src/App.jsx:79:export default function App() {
react/src/App.jsx:151:    if (lastActive && typeof lastActive.focus === 'function') {
src/Rest/SettingsController.php:23:	public function register_routes() {
src/Rest/SettingsController.php:68:	public function get_settings( $request ) {
src/Rest/SettingsController.php:91:	public function update_settings( $request ) {
src/Rest/SettingsController.php:118:	public function update_api_key( $request ) {
src/Rest/SettingsController.php:173:	public function get_usage( $request ) {

thinking
**Searching for tool usage**
exec
/bin/zsh -lc 'rg -n "tool_calls|function_registry|prepare_stock_update|search_product" -S .' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
./src/AI/Functions/SearchProduct.php:12:		return 'search_product';
./src/AI/Functions/PrepareStockUpdate.php:12:		return 'prepare_stock_update';
./src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
./src/AI/OpenAIClient.php:389:				'tool_calls' => array(),
./src/AI/OpenAIClient.php:400:		$tool_calls = isset( $message['tool_calls'] ) && is_array( $message['tool_calls'] ) ? $message['tool_calls'] : array();
./src/AI/OpenAIClient.php:402:		if ( empty( $tool_calls ) && isset( $message['function_call'] ) && is_array( $message['function_call'] ) ) {
./src/AI/OpenAIClient.php:403:			$tool_calls = array(
./src/AI/OpenAIClient.php:416:			'tool_calls' => $tool_calls,
./src/AI/OpenAIClient.php:430:		$tool_calls = array();
./src/AI/OpenAIClient.php:476:			if ( isset( $delta['tool_calls'] ) && is_array( $delta['tool_calls'] ) ) {
./src/AI/OpenAIClient.php:477:				$tool_calls = $this->merge_tool_call_deltas( $tool_calls, $delta['tool_calls'] );
./src/AI/OpenAIClient.php:481:				$tool_calls = $this->merge_tool_call_deltas(
./src/AI/OpenAIClient.php:482:					$tool_calls,
./src/AI/OpenAIClient.php:498:			'tool_calls' => array_values( $tool_calls ),
./src/AI/OpenAIClient.php:506:	 * @param array $tool_calls Existing tool calls.
./src/AI/OpenAIClient.php:510:	private function merge_tool_call_deltas( array $tool_calls, array $deltas ) {
./src/AI/OpenAIClient.php:514:			if ( ! isset( $tool_calls[ $index ] ) ) {
./src/AI/OpenAIClient.php:515:				$tool_calls[ $index ] = array(
./src/AI/OpenAIClient.php:526:				$tool_calls[ $index ]['id'] = $delta['id'];
./src/AI/OpenAIClient.php:530:				$tool_calls[ $index ]['type'] = $delta['type'];

thinking
**Searching for tool handler implementations**
exec
/bin/zsh -lc 'rg -n "tool" includes src | head -n 50' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
src/AI/Functions/FunctionSchema.php:29:	public function to_tool_definition();
src/AI/TokenCounter.php:20:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:24:	public function count_request_tokens( array $messages, array $tools, $model ) {
src/AI/TokenCounter.php:28:			+ $this->count_tool_tokens( $tools, $model );
src/AI/TokenCounter.php:67:	 * Count tokens for tool definitions.
src/AI/TokenCounter.php:69:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:73:	public function count_tool_tokens( array $tools, $model ) {
src/AI/TokenCounter.php:74:		if ( empty( $tools ) ) {
src/AI/TokenCounter.php:78:		$payload = wp_json_encode( $tools );
src/AI/OpenAIClient.php:99:		$tools = $this->normalize_tools( $functions );
src/AI/OpenAIClient.php:106:		if ( ! empty( $tools ) ) {
src/AI/OpenAIClient.php:107:			$payload['tools']       = $tools;
src/AI/OpenAIClient.php:108:			$payload['tool_choice'] = 'auto';
src/AI/OpenAIClient.php:116:		$input_tokens = $this->token_counter->count_request_tokens( $messages, $tools, $this->model );
src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:296:	private function normalize_tools( array $functions ) {
src/AI/OpenAIClient.php:297:		$tools = array();
src/AI/OpenAIClient.php:301:				$tools[] = $function->to_tool_definition();
src/AI/OpenAIClient.php:305:			if ( is_object( $function ) && method_exists( $function, 'to_tool_definition' ) ) {
src/AI/OpenAIClient.php:306:				$tools[] = $function->to_tool_definition();

thinking
**Checking for external function execution APIs**
exec
/bin/zsh -lc 'rg -n "FunctionRegistry|function_suggestions|draft" includes src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
src/Rest/SettingsController.php:236:		if ( isset( $payload['draft_ttl_minutes'] ) ) {
src/Rest/SettingsController.php:237:			$draft_ttl = intval( $payload['draft_ttl_minutes'] );
src/Rest/SettingsController.php:238:			if ( $draft_ttl >= 0 ) {
src/Rest/SettingsController.php:239:				$settings['draft_ttl_minutes'] = $draft_ttl;
src/Rest/SettingsController.php:351:				'draft_ttl_minutes' => array(
src/Intent/IntentClassifier.php:114:			|| $this->contains_phrase( $text, 'draft' )
src/Handlers/RefundHandler.php:3: * Handle refund draft preparation and confirmation.
src/Handlers/RefundHandler.php:23:		if ( isset( $args['draft_id'] ) ) {
src/Handlers/RefundHandler.php:24:			return $this->confirm_refund( $args['draft_id'] );
src/Handlers/RefundHandler.php:31:	 * Prepare a refund draft without executing it.
src/Handlers/RefundHandler.php:85:		$draft_payload = array(
src/Handlers/RefundHandler.php:96:		$draft_id   = $this->generate_draft_id();
src/Handlers/RefundHandler.php:97:		$ttl        = $this->get_draft_ttl_seconds();
src/Handlers/RefundHandler.php:99:		$stored     = $this->store_draft(
src/Handlers/RefundHandler.php:100:			$draft_id,
src/Handlers/RefundHandler.php:102:				'id'         => $draft_id,
src/Handlers/RefundHandler.php:104:				'payload'    => $draft_payload,
src/Handlers/RefundHandler.php:111:			return Response::error( 'Unable to store refund draft.', 500 );
src/Handlers/RefundHandler.php:116:				'draft_id'   => $draft_id,
src/Handlers/RefundHandler.php:117:				'draft'      => $draft_payload,

thinking
**Exploring includes directory for handlers**
exec
/bin/zsh -lc 'ls includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 60ms:
index.php

thinking
**Checking plugin main file**
exec
/bin/zsh -lc "sed -n '1,240p' agentwp.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
<?php
/**
 * Plugin Name: AgentWP
 * Plugin URI: https://agentwp.example
 * Description: React-powered admin UI for WooCommerce automation.
 * Version: 0.1.0
 * Requires at least: 6.4
 * Requires PHP: 7.4
 * WC requires at least: 8.0
 * Author: AgentWP
 * Text Domain: agentwp
 * Domain Path: /languages
 */

if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

define( 'AGENTWP_VERSION', '0.1.0' );
define( 'AGENTWP_PLUGIN_FILE', __FILE__ );

thinking
**Searching for function call APIs**
exec
/bin/zsh -lc "sed -n '1,260p' src/Plugin.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * Core plugin bootstrap.
 *
 * @package AgentWP
 */

namespace AgentWP;

class Plugin {
	const OPTION_SETTINGS     = 'agentwp_settings';
	const OPTION_API_KEY      = 'agentwp_api_key';
	const OPTION_API_KEY_LAST4 = 'agentwp_api_key_last4';
	const OPTION_BUDGET_LIMIT = 'agentwp_budget_limit';
	const OPTION_DRAFT_TTL    = 'agentwp_draft_ttl_minutes';
	const OPTION_USAGE_STATS  = 'agentwp_usage_stats';
	const TRANSIENT_PREFIX    = 'agentwp_';

	/**
	 * @var Plugin|null

thinking
**Searching for function calls in React source**
exec
/bin/zsh -lc 'rg -n "intent|tool|function|draft" react/src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
react/src/App.jsx:10:const REST_PATH = '/agentwp/v1/intent';
react/src/App.jsx:64:  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
react/src/App.jsx:79:export default function App() {
react/src/App.jsx:151:    if (lastActive && typeof lastActive.focus === 'function') {
react/src/App.jsx:343:              &ldquo;Summarize today&apos;s pending orders and draft a response for the two longest
exec
/bin/zsh -lc "sed -n '1,220p' react/src/App.jsx" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
import { useCallback, useEffect, useRef, useState } from 'react';
import ReactMarkdown from 'react-markdown';

const OPEN_STATE_KEY = 'agentwp-command-deck-open';
const ADMIN_TRIGGER_SELECTORS = [
  '#wp-admin-bar-agentwp',
  '[data-agentwp-command-deck]',
  '#agentwp-command-deck',
];
const REST_PATH = '/agentwp/v1/intent';
const FOCUSABLE_SELECTORS = [
  'a[href]',
  'button:not([disabled])',
  'textarea:not([disabled])',
  'input:not([disabled])',
  'select:not([disabled])',
  '[tabindex]:not([tabindex="-1"])',
];

const getInitialOpenState = () => {

thinking
**Analyzing handler usage and function calls**
exec
/bin/zsh -lc 'rg -n "Stock|stock" docs src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
docs/agentwp-prd.md:145:**Automated refund processing:** Multiple successful implementations exist (Smart Refunder, YITH Advanced Refund, WP Swings RMA). Research shows **40% reduction in processing costs** with automation and significantly improved customer satisfaction. Recommended capabilities include rule-based automatic approval, fraud pattern detection, automatic inventory restocking, and payment gateway integration for instant refunds.
src/Handlers/RefundHandler.php:54:		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );
src/Handlers/RefundHandler.php:79:		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();
src/Handlers/RefundHandler.php:90:			'items_to_restock'       => $items_to_restock,
src/Handlers/RefundHandler.php:179:		$items_to_restock = isset( $payload['items_to_restock'] ) && is_array( $payload['items_to_restock'] )
src/Handlers/RefundHandler.php:180:			? $payload['items_to_restock']
src/Handlers/RefundHandler.php:182:		$should_restock = $this->is_full_refund( $refund_amount, $remaining ) && ! empty( $items_to_restock );
src/Handlers/RefundHandler.php:190:				'restock_items'  => false,
src/Handlers/RefundHandler.php:199:		$restocked = $should_restock ? $this->restock_items( $order, $items_to_restock ) : array();
src/Handlers/RefundHandler.php:202:		$this->add_audit_note( $order, $draft_id, $refund_amount, $reason, ! empty( $restocked ) );
src/Handlers/RefundHandler.php:212:				'restocked_items'        => $restocked,
src/Handlers/RefundHandler.php:277:	private function build_items_to_restock( $order ) {
src/Handlers/RefundHandler.php:464:	 * @param array $items_to_restock Items to restock.
src/Handlers/RefundHandler.php:467:	private function restock_items( $order, array $items_to_restock ) {
src/Handlers/RefundHandler.php:468:		$restocked = array();
src/Handlers/RefundHandler.php:470:		if ( ! $order || ! function_exists( 'wc_update_product_stock' ) ) {
src/Handlers/RefundHandler.php:471:			return $restocked;
src/Handlers/RefundHandler.php:474:		foreach ( $items_to_restock as $item_data ) {
src/Handlers/RefundHandler.php:487:			if ( ! $product || ! $product->managing_stock() ) {
src/Handlers/RefundHandler.php:491:			wc_update_product_stock( $product, $quantity, 'increase' );

thinking
**Reviewing architecture docs for functions**
exec
/bin/zsh -lc "sed -n '140,220p' docs/ARCHITECTURE.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
    "message": "string"
  }
}
```

### POST /intent
Primary AI entry point. Converts user input into actions and/or drafts.

Request schema:
```json
{
  "input": "string",
  "context": {
    "ui_source": "command_deck|api",
    "session_id": "string",
    "draft_id": "string"
  }
}
```


thinking
**Searching for stock update in documentation**
exec
/bin/zsh -lc 'rg -n "stock_update|stock" docs/ARCHITECTURE.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
168:      "type": "refund|status_update|stock_update|bulk_action",
300:    "type": "refund|status_update|stock_update|bulk_action",
308:Confirms a draft action (refund, status update, stock update, bulk action).
426:    "restock_items": true
exec
/bin/zsh -lc "sed -n '260,360p' docs/ARCHITECTURE.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 33ms:
```json
{
  "success": true,
  "data": {
    "status": "ok|degraded|down",
    "openai_reachable": true,
    "rate_limit_remaining": 0
  }
}
```

### GET /search
Typeahead search across products, orders, customers.

Request schema (query string):
```
?q=string&types=products,orders,customers
```

Response schema:

thinking
**Planning StockHandler implementation**
exec
/bin/zsh -lc "sed -n '1,220p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
<?php
/**
 * Handle order search requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;
use DateTimeImmutable;
use DateTimeZone;
use Exception;

class OrderSearchHandler {
	const DEFAULT_LIMIT = 10;
	const CACHE_TTL     = 3600;

	/**

thinking
**Reviewing formatting style**
exec
/bin/zsh -lc "sed -n '220,520p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 44ms:
			return array();
		}

		$query_args = array(
			'limit'   => $normalized['limit'],
			'orderby' => $normalized['orderby'],
			'order'   => $normalized['order'],
		);

		if ( '' !== $normalized['status'] ) {
			$query_args['status'] = $normalized['status'];
		}

		if ( is_array( $normalized['date_range'] ) ) {
			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
		}

		if ( '' !== $normalized['email'] ) {
			$query_args['meta_query'] = array(
				'relation' => 'OR',

thinking
**Planning StockHandler implementation**
exec
/bin/zsh -lc 'rg -n "function" docs/ARCHITECTURE.md docs/agentwp-prd.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 61ms:
docs/agentwp-prd.md:31:CodeCanyon's WooCommerce category presents a mature but opportunity-rich environment. The **top-selling plugins** cluster around essential e-commerce functions: Filter Everything ($49, 121 weekly sales), CURCY multi-currency ($34), and Extra Product Options ($69, 1,300+ reviews). These establish the proven price ceiling.
docs/agentwp-prd.md:39:The data shows **98.2% of plugins price under $40**, but top performers consistently price at **$42–69**. AI plugins like MagicAI and Davinci AI successfully command $49–69, validating premium pricing for AI-powered functionality. The "race to bottom" strategy fails—the average plugin price of $18.91 correlates with minimal success, while category leaders demonstrate that merchants pay for genuine value.
docs/agentwp-prd.md:46:- Live demo site showcasing real functionality (essential, not optional)
docs/agentwp-prd.md:62:- Design functions that pass the "intern test"—if the function name and description alone don't make usage obvious, refine them
docs/agentwp-prd.md:63:- Combine functions that are always called sequentially into single operations
docs/agentwp-prd.md:98:- **78–88%** of companies use AI in at least one business function
docs/agentwp-prd.md:196:**Compliance:** Execute OpenAI DPA immediately, build GDPR consent mechanisms into initial release, and implement CCPA opt-out functionality. These cannot be afterthoughts.

thinking
**Examining handler roles and function mappings**
exec
/bin/zsh -lc "rg -n \"Handlers\\\\OrderSearchHandler\" -S src" in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 56ms:
rg: regex parse error:
    (?:Handlers\OrderSearchHandler)
               ^^
error: unrecognized escape sequence

thinking
**Searching for OrderSearchHandler**
exec
/bin/zsh -lc 'rg -n "OrderSearchHandler" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
src/Handlers/OrderSearchHandler.php:16:class OrderSearchHandler {
src/Intent/Handlers/OrderSearchHandler.php:11:use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
src/Intent/Handlers/OrderSearchHandler.php:14:class OrderSearchHandler extends BaseHandler {
src/Intent/Engine.php:16:use AgentWP\Intent\Handlers\OrderSearchHandler;
src/Intent/Engine.php:130:			new OrderSearchHandler(),

thinking
**Checking OrderSearchHandler usage**
exec
/bin/zsh -lc "sed -n '1,120p' src/Intent/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Handle order search intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
use AgentWP\Intent\Intent;

class OrderSearchHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_SEARCH );
	}

	/**
	 * @param array $context Context data.

thinking
**Analyzing Intent Handler Integration**
exec
/bin/zsh -lc "sed -n '1,120p' src/Intent/Handlers/OrderStatusHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
<?php
/**
 * Handle order status intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Intent;

class OrderStatusHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_STATUS );
	}

	/**
	 * @param array $context Context data.
	 * @return Response

thinking
**Analyzing function-to-handler mapping**
exec
/bin/zsh -lc 'rg -n "stock update|stock_update" docs' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
docs/ARCHITECTURE.md:168:      "type": "refund|status_update|stock_update|bulk_action",
docs/ARCHITECTURE.md:300:    "type": "refund|status_update|stock_update|bulk_action",
docs/ARCHITECTURE.md:308:Confirms a draft action (refund, status update, stock update, bulk action).

thinking
**Outlining StockHandler design and integration**

I'm sketching the StockHandler's required features around product search, stock update flows with validation, and variation handling. I want to confirm using WooCommerce's standard functions like `wc_update_product_stock` to trigger hooks properly and figure out how to include variations in search results or the draft update. I'll also check how Response classes manage outputs to finalize data structures.
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Response.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 35ms:
<?php
/**
 * OpenAI response wrapper.
 *
 * @package AgentWP
 */

namespace AgentWP\AI;

class Response {
	/**
	 * @var bool
	 */
	private $success;

	/**
	 * @var int
	 */
	private $status;


thinking
**Designing stock and product handlers**

I’m sorting out how to handle stock updates with a draft-confirm pattern like refunds and order statuses. I want to ensure the SearchProduct function supports fuzzy name, exact SKU, or ID queries and returns detailed product info, including variations. I’m also reviewing if the existing function schemas need tweaks to fully align with the spec, especially around confirming stock updates and bulk update functions. There is a lot here to piece together carefully!
exec
/bin/zsh -lc "sed -n '1,160p' src/AI/Functions/BulkUpdate.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Function schema for executing bulk order actions.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class BulkUpdate extends AbstractFunction {
	public function get_name() {
		return 'bulk_update';
	}

	public function get_description() {
		return 'Apply a bulk action to a list of order IDs.';
	}

	public function get_parameters() {
		return array(

thinking
**Analyzing order status confirmation methods**
exec
/bin/zsh -lc "sed -n '1,160p' src/AI/Functions/PrepareStatusUpdate.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 33ms:
<?php
/**
 * Function schema for order status updates.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class PrepareStatusUpdate extends AbstractFunction {
	public function get_name() {
		return 'prepare_status_update';
	}

	public function get_description() {
		return 'Prepare a draft order status update without applying it.';
	}

	public function get_parameters() {
		return array(

thinking
**Analyzing StockHandler responsibilities and confirm method**

I'm reasoning through how StockHandler should handle both search and stock update actions, considering whether to implement a confirm method like other handlers do for draft confirmations, and how to dispatch calls based on arguments within the same handler class. I’m also planning to check related intent handler usage for function dispatch patterns next.
exec
/bin/zsh -lc "sed -n '1,160p' src/Intent/Handlers/BaseHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
<?php
/**
 * Base handler for intent responses.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Handler;
use AgentWP\Intent\Intent;

abstract class BaseHandler implements Handler {
	/**
	 * @var string
	 */
	protected $intent;

	/**

thinking
**Designing StockHandler and search functionality**

I’m mapping out how to implement the StockHandler class with methods for searching products, preparing stock updates, and confirming updates according to spec. I’m thinking through how to handle variable products, warnings for stock management flags, and argument dispatching in handle(). The search_product function needs to support searching by fuzzy name, exact SKU, or ID using WooCommerce helpers thoughtfully.
exec
/bin/zsh -lc 'rg -n "wc_get_products" -S src' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 59ms:




thinking
**Designing product search and stock update logic**

I'm mapping out how to implement product search handling SKU, ID, and name queries, carefully including variable products with variation details. For stock updates, I'm considering validations, managing warnings when stock management is disabled, and defining clear flows for set, increase, and decrease operations while ensuring hooks trigger correctly.
thinking
**Planning stock update confirmation and integration**

I'm outlining detailed logic to confirm stock updates safely, handle warnings, enforce quantity rules, create and manage drafts, and integrate product stock searching into the intent handler for live query responses. This includes managing variable products, validating inputs, and ensuring hooks trigger properly during stock changes.
thinking
**Finalizing integration and setup**
exec
/bin/zsh -lc 'cat composer.json' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
{
  "name": "agentwp/agentwp",
  "description": "AgentWP WordPress plugin.",
  "type": "wordpress-plugin",
  "license": "GPL-2.0-or-later",
  "autoload": {
    "psr-4": {
      "AgentWP\\": "src/"
    }
  },
  "require": {
    "php": ">=7.4",
    "yethee/tiktoken": "^0.1.2"
  }
}


thinking
**Detailing StockHandler implementation**
thinking
**Finalizing StockHandler design and implementation**

I’m wrapping up the detailed design for StockHandler, clarifying how to handle search queries, variations, validations, stock calculations, and draft storage while ensuring WooCommerce dependencies and error handling are in place. I’m also planning method signatures and data formatting to keep responses consistent and performant.
file update
A /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/StockHandler.php
<?php
/**
 * Handle product stock searches and updates.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;

class StockHandler {
	const DRAFT_TYPE    = 'stock_update';
	const DEFAULT_LIMIT = 10;

	/**
	 * Handle stock-related requests.
	 *
	 * @param array $args Request args.
	 * @return Response
	 */
	public function handle( array $args ): Response {
		if ( isset( $args['query'] ) || isset( $args['sku'] ) ) {
			return $this->search_products( $args );
		}

		if ( isset( $args['draft_id'] ) ) {
			return $this->confirm_stock_update( $args['draft_id'] );
		}

		return $this->prepare_stock_update( $args );
	}

	/**
	 * Search for products by name, SKU, or ID.
	 *
	 * @param array $args Search parameters.
	 * @return Response
	 */
	public function search_products( array $args ): Response {
		if ( ! function_exists( 'wc_get_product' ) ) {
			return Response::error( 'WooCommerce is required to search products.', 400 );
		}

		$query = isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '';
		$sku   = isset( $args['sku'] ) ? sanitize_text_field( $args['sku'] ) : '';

		if ( '' === $query && '' === $sku ) {
			return Response::error( 'Missing product search query.', 400 );
		}

		$products = $this->find_products( $query, $sku );

		return Response::success(
			array(
				'products' => $products,
				'count'    => count( $products ),
				'query'    => array(
					'query' => $query,
					'sku'   => $sku,
				),
			)
		);
	}

	/**
	 * Prepare a draft stock update without applying it.
	 *
	 * @param array $args Request args.
	 * @return Response
	 */
	public function prepare_stock_update( array $args ): Response {
		if ( ! function_exists( 'wc_get_product' ) ) {
			return Response::error( 'WooCommerce is required to prepare stock updates.', 400 );
		}

		$product_id = isset( $args['product_id'] ) ? absint( $args['product_id'] ) : 0;
		if ( 0 === $product_id ) {
			return Response::error( 'Missing product ID for stock update.', 400 );
		}

		$operation = isset( $args['operation'] ) ? $this->normalize_operation( $args['operation'] ) : '';
		if ( '' === $operation ) {
			return Response::error( 'Missing or invalid stock operation.', 400 );
		}

		$quantity = $this->normalize_quantity( isset( $args['quantity'] ) ? $args['quantity'] : null );
		if ( null === $quantity ) {
			return Response::error( 'Stock quantity must be a non-negative integer.', 400 );
		}

		$product = wc_get_product( $product_id );
		if ( ! $product ) {
			return Response::error( 'Product not found for stock update.', 404 );
		}

		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
		$current_stock     = $this->normalize_stock_quantity(
			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
		);
		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );

		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
		}

		$warnings = array();
		if ( ! $manage_stock ) {
			$warnings[] = 'Stock management is disabled for this product; quantity changes may not affect availability.';
		}

		$product_payload = $this->format_product( $product, true );

		$draft_payload = array(
			'product_id'         => $product_id,
			'quantity'           => $quantity,
			'operation'          => $operation,
			'current_stock'      => $current_stock,
			'new_stock'          => $new_stock,
			'manage_stock'       => (bool) $manage_stock,
			'backorders_allowed' => (bool) $backorders_allowed,
			'product'            => $product_payload,
			'warnings'           => $warnings,
			'preview'            => array(
				'name'          => isset( $product_payload['name'] ) ? $product_payload['name'] : '',
				'sku'           => isset( $product_payload['sku'] ) ? $product_payload['sku'] : '',
				'current_stock' => $current_stock,
				'new_stock'     => $new_stock,
			),
		);

		$draft_id   = $this->generate_draft_id();
		$ttl        = $this->get_draft_ttl_seconds();
		$expires_at = gmdate( 'c', time() + $ttl );
		$stored     = $this->store_draft(
			$draft_id,
			array(
				'id'         => $draft_id,
				'type'       => self::DRAFT_TYPE,
				'payload'    => $draft_payload,
				'expires_at' => $expires_at,
			),
			$ttl
		);

		if ( ! $stored ) {
			return Response::error( 'Unable to store stock update draft.', 500 );
		}

		return Response::success(
			array(
				'draft_id'   => $draft_id,
				'draft'      => $draft_payload,
				'expires_at' => $expires_at,
			)
		);
	}

	/**
	 * Confirm and apply a draft stock update.
	 *
	 * @param string $draft_id Draft identifier.
	 * @return Response
	 */
	public function confirm_stock_update( $draft_id ): Response {
		if ( ! function_exists( 'wc_get_product' ) || ! function_exists( 'wc_update_product_stock' ) ) {
			return Response::error( 'WooCommerce is required to update product stock.', 400 );
		}

		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
		if ( '' === $draft_id ) {
			return Response::error( 'Missing stock update draft ID.', 400 );
		}

		$draft = $this->load_draft( $draft_id );
		if ( null === $draft ) {
			return Response::error( 'Stock update draft not found or expired.', 404 );
		}

		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
			return Response::error( 'Draft type mismatch for stock update confirmation.', 400 );
		}

		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;

		$product_id = isset( $payload['product_id'] ) ? absint( $payload['product_id'] ) : 0;
		if ( 0 === $product_id ) {
			return Response::error( 'Stock update draft is missing the product ID.', 400 );
		}

		$operation = isset( $payload['operation'] ) ? $this->normalize_operation( $payload['operation'] ) : '';
		if ( '' === $operation ) {
			return Response::error( 'Stock update draft has an invalid operation.', 400 );
		}

		$quantity = $this->normalize_quantity( isset( $payload['quantity'] ) ? $payload['quantity'] : null );
		if ( null === $quantity ) {
			return Response::error( 'Stock update draft has an invalid quantity.', 400 );
		}

		$product = wc_get_product( $product_id );
		if ( ! $product ) {
			return Response::error( 'Product not found for stock update confirmation.', 404 );
		}

		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
		$current_stock     = $this->normalize_stock_quantity(
			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
		);
		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );

		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
		}

		$updated_stock = wc_update_product_stock( $product, $quantity, $operation );
		if ( is_wp_error( $updated_stock ) ) {
			return Response::error( $updated_stock->get_error_message(), 400 );
		}

		$this->delete_draft( $draft_id );

		$refreshed = wc_get_product( $product_id );
		$product_payload = $refreshed ? $this->format_product( $refreshed, true ) : array();

		return Response::success(
			array(
				'draft_id'       => $draft_id,
				'product_id'     => $product_id,
				'previous_stock' => $current_stock,
				'new_stock'      => is_numeric( $updated_stock ) ? intval( $updated_stock ) : $new_stock,
				'manage_stock'   => (bool) $manage_stock,
				'product'        => $product_payload,
			)
		);
	}

	/**
	 * @param string $query Search string.
	 * @param string $sku SKU search.
	 * @return array
	 */
	private function find_products( $query, $sku ) {
		$products = array();

		$sku = trim( (string) $sku );
		if ( '' !== $sku && function_exists( 'wc_get_product_id_by_sku' ) ) {
			$product_id = absint( wc_get_product_id_by_sku( $sku ) );
			if ( $product_id > 0 ) {
				$product = wc_get_product( $product_id );
				if ( $product ) {
					$products[] = $this->format_product( $product, true );
				}
			}

			return $products;
		}

		$query = trim( (string) $query );
		if ( '' === $query ) {
			return $products;
		}

		$maybe_id = absint( $query );
		if ( $maybe_id > 0 ) {
			$product = wc_get_product( $maybe_id );
			if ( $product ) {
				$products[] = $this->format_product( $product, true );
				return $products;
			}
		}

		if ( function_exists( 'wc_get_product_id_by_sku' ) ) {
			$product_id = absint( wc_get_product_id_by_sku( $query ) );
			if ( $product_id > 0 ) {
				$product = wc_get_product( $product_id );
				if ( $product ) {
					$products[] = $this->format_product( $product, true );
					return $products;
				}
			}
		}

		if ( ! function_exists( 'get_posts' ) ) {
			return $products;
		}

		$matches = get_posts(
			array(
				'post_type'      => array( 'product' ),
				'post_status'    => array( 'publish', 'private' ),
				's'              => $query,
				'posts_per_page' => self::DEFAULT_LIMIT,
				'fields'         => 'ids',
			)
		);

		if ( ! is_array( $matches ) ) {
			return $products;
		}

		foreach ( $matches as $product_id ) {
			$product_id = absint( $product_id );
			if ( 0 === $product_id ) {
				continue;
			}

			$product = wc_get_product( $product_id );
			if ( ! $product ) {
				continue;
			}

			$products[] = $this->format_product( $product, true );
		}

		return $products;
	}

	/**
	 * @param mixed $product Product instance.
	 * @param bool  $include_variations Whether to include variations.
	 * @return array
	 */
	private function format_product( $product, $include_variations = false ) {
		if ( ! $product || ! method_exists( $product, 'get_id' ) ) {
			return array();
		}

		$stock_quantity = method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null;
		$sku            = method_exists( $product, 'get_sku' ) ? $product->get_sku() : '';
		$stock_status   = method_exists( $product, 'get_stock_status' ) ? $product->get_stock_status() : '';

		$payload = array(
			'id'                 => intval( $product->get_id() ),
			'name'               => sanitize_text_field( $this->get_product_name( $product ) ),
			'sku'                => sanitize_text_field( (string) $sku ),
			'current_stock'      => $this->normalize_stock_quantity( $stock_quantity ),
			'stock_status'       => sanitize_text_field( (string) $stock_status ),
			'manage_stock'       => method_exists( $product, 'managing_stock' ) ? (bool) $product->managing_stock() : false,
			'backorders_allowed' => method_exists( $product, 'backorders_allowed' ) ? (bool) $product->backorders_allowed() : false,
		);

		if ( method_exists( $product, 'is_type' ) && $product->is_type( 'variation' ) && method_exists( $product, 'get_parent_id' ) ) {
			$payload['parent_id'] = intval( $product->get_parent_id() );
		}

		if ( $include_variations && method_exists( $product, 'is_type' ) && $product->is_type( 'variable' ) ) {
			$payload['variations'] = $this->format_variations( $product );
		}

		return $payload;
	}

	/**
	 * @param mixed $product Variable product.
	 * @return array
	 */
	private function format_variations( $product ) {
		if ( ! $product || ! method_exists( $product, 'get_children' ) ) {
			return array();
		}

		$variations = array();
		$children   = $product->get_children();

		if ( ! is_array( $children ) ) {
			return $variations;
		}

		foreach ( $children as $variation_id ) {
			$variation_id = absint( $variation_id );
			if ( 0 === $variation_id ) {
				continue;
			}

			$variation = wc_get_product( $variation_id );
			if ( ! $variation ) {
				continue;
			}

			$variations[] = $this->format_product( $variation, false );
		}

		return $variations;
	}

	/**
	 * @param mixed $product Product instance.
	 * @return string
	 */
	private function get_product_name( $product ) {
		if ( method_exists( $product, 'get_formatted_name' ) ) {
			return (string) $product->get_formatted_name();
		}

		if ( method_exists( $product, 'get_name' ) ) {
			return (string) $product->get_name();
		}

		return '';
	}

	/**
	 * @param mixed $quantity Raw quantity.
	 * @return int
	 */
	private function normalize_stock_quantity( $quantity ) {
		if ( is_numeric( $quantity ) ) {
			return intval( $quantity );
		}

		return 0;
	}

	/**
	 * @param mixed $operation Raw operation.
	 * @return string
	 */
	private function normalize_operation( $operation ) {
		$operation = is_string( $operation ) ? strtolower( trim( $operation ) ) : '';
		$allowed   = array( 'set', 'increase', 'decrease' );

		if ( in_array( $operation, $allowed, true ) ) {
			return $operation;
		}

		return '';
	}

	/**
	 * @param mixed $quantity Raw quantity.
	 * @return int|null
	 */
	private function normalize_quantity( $quantity ) {
		if ( null === $quantity || '' === $quantity ) {
			return null;
		}

		if ( is_int( $quantity ) ) {
			return $quantity >= 0 ? $quantity : null;
		}

		$validated = filter_var(
			$quantity,
			FILTER_VALIDATE_INT,
			array(
				'options' => array(
					'min_range' => 0,
				),
			)
		);

		if ( false === $validated ) {
			return null;
		}

		return intval( $validated );
	}

	/**
	 * @param int    $current_stock Current stock.
	 * @param int    $quantity Quantity.
	 * @param string $operation Operation.
	 * @return int
	 */
	private function calculate_new_stock( $current_stock, $quantity, $operation ) {
		switch ( $operation ) {
			case 'increase':
				return $current_stock + $quantity;
			case 'decrease':
				return $current_stock - $quantity;
			case 'set':
			default:
				return $quantity;
		}
	}

	/**
	 * @return string
	 */
	private function generate_draft_id() {
		if ( function_exists( 'wp_generate_uuid4' ) ) {
			return wp_generate_uuid4();
		}

		return uniqid( 'draft_', true );
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return string
	 */
	private function build_draft_key( $draft_id ) {
		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
	}

	/**
	 * @return int
	 */
	private function get_draft_ttl_seconds() {
		$ttl_minutes = null;

		if ( function_exists( 'get_option' ) ) {
			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
			if ( null !== $option_ttl && '' !== $option_ttl ) {
				$ttl_minutes = intval( $option_ttl );
			}
		}

		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
			}
		}

		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
			$ttl_minutes = 10;
		}

		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;

		return $ttl_minutes * $minute_seconds;
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @param array  $draft Draft payload.
	 * @param int    $ttl_seconds Expiration seconds.
	 * @return bool
	 */
	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
		if ( ! function_exists( 'set_transient' ) ) {
			return false;
		}

		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return array|null
	 */
	private function load_draft( $draft_id ) {
		if ( ! function_exists( 'get_transient' ) ) {
			return null;
		}

		$draft = get_transient( $this->build_draft_key( $draft_id ) );
		if ( false === $draft || ! is_array( $draft ) ) {
			return null;
		}

		return $draft;
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return void
	 */
	private function delete_draft( $draft_id ) {
		if ( function_exists( 'delete_transient' ) ) {
			delete_transient( $this->build_draft_key( $draft_id ) );
		}
	}
}
apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
A src/Handlers/StockHandler.php
file update:
diff --git a/src/Handlers/StockHandler.php b/src/Handlers/StockHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..a2502132d5df57368949b328d7decf34b10e1233
--- /dev/null
+++ b/src/Handlers/StockHandler.php
@@ -0,0 +1,569 @@
+<?php
+/**
+ * Handle product stock searches and updates.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class StockHandler {
+	const DRAFT_TYPE    = 'stock_update';
+	const DEFAULT_LIMIT = 10;
+
+	/**
+	 * Handle stock-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['query'] ) || isset( $args['sku'] ) ) {
+			return $this->search_products( $args );
+		}
+
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_stock_update( $args['draft_id'] );
+		}
+
+		return $this->prepare_stock_update( $args );
+	}
+
+	/**
+	 * Search for products by name, SKU, or ID.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function search_products( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to search products.', 400 );
+		}
+
+		$query = isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '';
+		$sku   = isset( $args['sku'] ) ? sanitize_text_field( $args['sku'] ) : '';
+
+		if ( '' === $query && '' === $sku ) {
+			return Response::error( 'Missing product search query.', 400 );
+		}
+
+		$products = $this->find_products( $query, $sku );
+
+		return Response::success(
+			array(
+				'products' => $products,
+				'count'    => count( $products ),
+				'query'    => array(
+					'query' => $query,
+					'sku'   => $sku,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft stock update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_stock_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to prepare stock updates.', 400 );
+		}
+
+		$product_id = isset( $args['product_id'] ) ? absint( $args['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Missing product ID for stock update.', 400 );
+		}
+
+		$operation = isset( $args['operation'] ) ? $this->normalize_operation( $args['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Missing or invalid stock operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $args['quantity'] ) ? $args['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock quantity must be a non-negative integer.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$warnings = array();
+		if ( ! $manage_stock ) {
+			$warnings[] = 'Stock management is disabled for this product; quantity changes may not affect availability.';
+		}
+
+		$product_payload = $this->format_product( $product, true );
+
+		$draft_payload = array(
+			'product_id'         => $product_id,
+			'quantity'           => $quantity,
+			'operation'          => $operation,
+			'current_stock'      => $current_stock,
+			'new_stock'          => $new_stock,
+			'manage_stock'       => (bool) $manage_stock,
+			'backorders_allowed' => (bool) $backorders_allowed,
+			'product'            => $product_payload,
+			'warnings'           => $warnings,
+			'preview'            => array(
+				'name'          => isset( $product_payload['name'] ) ? $product_payload['name'] : '',
+				'sku'           => isset( $product_payload['sku'] ) ? $product_payload['sku'] : '',
+				'current_stock' => $current_stock,
+				'new_stock'     => $new_stock,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store stock update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft stock update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_stock_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_product' ) || ! function_exists( 'wc_update_product_stock' ) ) {
+			return Response::error( 'WooCommerce is required to update product stock.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing stock update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Stock update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for stock update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+
+		$product_id = isset( $payload['product_id'] ) ? absint( $payload['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Stock update draft is missing the product ID.', 400 );
+		}
+
+		$operation = isset( $payload['operation'] ) ? $this->normalize_operation( $payload['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Stock update draft has an invalid operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $payload['quantity'] ) ? $payload['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock update draft has an invalid quantity.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update confirmation.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$updated_stock = wc_update_product_stock( $product, $quantity, $operation );
+		if ( is_wp_error( $updated_stock ) ) {
+			return Response::error( $updated_stock->get_error_message(), 400 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		$refreshed = wc_get_product( $product_id );
+		$product_payload = $refreshed ? $this->format_product( $refreshed, true ) : array();
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'product_id'     => $product_id,
+				'previous_stock' => $current_stock,
+				'new_stock'      => is_numeric( $updated_stock ) ? intval( $updated_stock ) : $new_stock,
+				'manage_stock'   => (bool) $manage_stock,
+				'product'        => $product_payload,
+			)
+		);
+	}
+
+	/**
+	 * @param string $query Search string.
+	 * @param string $sku SKU search.
+	 * @return array
+	 */
+	private function find_products( $query, $sku ) {
+		$products = array();
+
+		$sku = trim( (string) $sku );
+		if ( '' !== $sku && function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $sku ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+				}
+			}
+
+			return $products;
+		}
+
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $products;
+		}
+
+		$maybe_id = absint( $query );
+		if ( $maybe_id > 0 ) {
+			$product = wc_get_product( $maybe_id );
+			if ( $product ) {
+				$products[] = $this->format_product( $product, true );
+				return $products;
+			}
+		}
+
+		if ( function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $query ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+					return $products;
+				}
+			}
+		}
+
+		if ( ! function_exists( 'get_posts' ) ) {
+			return $products;
+		}
+
+		$matches = get_posts(
+			array(
+				'post_type'      => array( 'product' ),
+				'post_status'    => array( 'publish', 'private' ),
+				's'              => $query,
+				'posts_per_page' => self::DEFAULT_LIMIT,
+				'fields'         => 'ids',
+			)
+		);
+
+		if ( ! is_array( $matches ) ) {
+			return $products;
+		}
+
+		foreach ( $matches as $product_id ) {
+			$product_id = absint( $product_id );
+			if ( 0 === $product_id ) {
+				continue;
+			}
+
+			$product = wc_get_product( $product_id );
+			if ( ! $product ) {
+				continue;
+			}
+
+			$products[] = $this->format_product( $product, true );
+		}
+
+		return $products;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @param bool  $include_variations Whether to include variations.
+	 * @return array
+	 */
+	private function format_product( $product, $include_variations = false ) {
+		if ( ! $product || ! method_exists( $product, 'get_id' ) ) {
+			return array();
+		}
+
+		$stock_quantity = method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null;
+		$sku            = method_exists( $product, 'get_sku' ) ? $product->get_sku() : '';
+		$stock_status   = method_exists( $product, 'get_stock_status' ) ? $product->get_stock_status() : '';
+
+		$payload = array(
+			'id'                 => intval( $product->get_id() ),
+			'name'               => sanitize_text_field( $this->get_product_name( $product ) ),
+			'sku'                => sanitize_text_field( (string) $sku ),
+			'current_stock'      => $this->normalize_stock_quantity( $stock_quantity ),
+			'stock_status'       => sanitize_text_field( (string) $stock_status ),
+			'manage_stock'       => method_exists( $product, 'managing_stock' ) ? (bool) $product->managing_stock() : false,
+			'backorders_allowed' => method_exists( $product, 'backorders_allowed' ) ? (bool) $product->backorders_allowed() : false,
+		);
+
+		if ( method_exists( $product, 'is_type' ) && $product->is_type( 'variation' ) && method_exists( $product, 'get_parent_id' ) ) {
+			$payload['parent_id'] = intval( $product->get_parent_id() );
+		}
+
+		if ( $include_variations && method_exists( $product, 'is_type' ) && $product->is_type( 'variable' ) ) {
+			$payload['variations'] = $this->format_variations( $product );
+		}
+
+		return $payload;
+	}
+
+	/**
+	 * @param mixed $product Variable product.
+	 * @return array
+	 */
+	private function format_variations( $product ) {
+		if ( ! $product || ! method_exists( $product, 'get_children' ) ) {
+			return array();
+		}
+
+		$variations = array();
+		$children   = $product->get_children();
+
+		if ( ! is_array( $children ) ) {
+			return $variations;
+		}
+
+		foreach ( $children as $variation_id ) {
+			$variation_id = absint( $variation_id );
+			if ( 0 === $variation_id ) {
+				continue;
+			}
+
+			$variation = wc_get_product( $variation_id );
+			if ( ! $variation ) {
+				continue;
+			}
+
+			$variations[] = $this->format_product( $variation, false );
+		}
+
+		return $variations;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @return string
+	 */
+	private function get_product_name( $product ) {
+		if ( method_exists( $product, 'get_formatted_name' ) ) {
+			return (string) $product->get_formatted_name();
+		}
+
+		if ( method_exists( $product, 'get_name' ) ) {
+			return (string) $product->get_name();
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int
+	 */
+	private function normalize_stock_quantity( $quantity ) {
+		if ( is_numeric( $quantity ) ) {
+			return intval( $quantity );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param mixed $operation Raw operation.
+	 * @return string
+	 */
+	private function normalize_operation( $operation ) {
+		$operation = is_string( $operation ) ? strtolower( trim( $operation ) ) : '';
+		$allowed   = array( 'set', 'increase', 'decrease' );
+
+		if ( in_array( $operation, $allowed, true ) ) {
+			return $operation;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int|null
+	 */
+	private function normalize_quantity( $quantity ) {
+		if ( null === $quantity || '' === $quantity ) {
+			return null;
+		}
+
+		if ( is_int( $quantity ) ) {
+			return $quantity >= 0 ? $quantity : null;
+		}
+
+		$validated = filter_var(
+			$quantity,
+			FILTER_VALIDATE_INT,
+			array(
+				'options' => array(
+					'min_range' => 0,
+				),
+			)
+		);
+
+		if ( false === $validated ) {
+			return null;
+		}
+
+		return intval( $validated );
+	}
+
+	/**
+	 * @param int    $current_stock Current stock.
+	 * @param int    $quantity Quantity.
+	 * @param string $operation Operation.
+	 * @return int
+	 */
+	private function calculate_new_stock( $current_stock, $quantity, $operation ) {
+		switch ( $operation ) {
+			case 'increase':
+				return $current_stock + $quantity;
+			case 'decrease':
+				return $current_stock - $quantity;
+			case 'set':
+			default:
+				return $quantity;
+		}
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}

file update:
diff --git a/src/Handlers/StockHandler.php b/src/Handlers/StockHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..a2502132d5df57368949b328d7decf34b10e1233
--- /dev/null
+++ b/src/Handlers/StockHandler.php
@@ -0,0 +1,569 @@
+<?php
+/**
+ * Handle product stock searches and updates.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class StockHandler {
+	const DRAFT_TYPE    = 'stock_update';
+	const DEFAULT_LIMIT = 10;
+
+	/**
+	 * Handle stock-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['query'] ) || isset( $args['sku'] ) ) {
+			return $this->search_products( $args );
+		}
+
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_stock_update( $args['draft_id'] );
+		}
+
+		return $this->prepare_stock_update( $args );
+	}
+
+	/**
+	 * Search for products by name, SKU, or ID.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function search_products( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to search products.', 400 );
+		}
+
+		$query = isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '';
+		$sku   = isset( $args['sku'] ) ? sanitize_text_field( $args['sku'] ) : '';
+
+		if ( '' === $query && '' === $sku ) {
+			return Response::error( 'Missing product search query.', 400 );
+		}
+
+		$products = $this->find_products( $query, $sku );
+
+		return Response::success(
+			array(
+				'products' => $products,
+				'count'    => count( $products ),
+				'query'    => array(
+					'query' => $query,
+					'sku'   => $sku,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft stock update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_stock_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to prepare stock updates.', 400 );
+		}
+
+		$product_id = isset( $args['product_id'] ) ? absint( $args['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Missing product ID for stock update.', 400 );
+		}
+
+		$operation = isset( $args['operation'] ) ? $this->normalize_operation( $args['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Missing or invalid stock operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $args['quantity'] ) ? $args['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock quantity must be a non-negative integer.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$warnings = array();
+		if ( ! $manage_stock ) {
+			$warnings[] = 'Stock management is disabled for this product; quantity changes may not affect availability.';
+		}
+
+		$product_payload = $this->format_product( $product, true );
+
+		$draft_payload = array(
+			'product_id'         => $product_id,
+			'quantity'           => $quantity,
+			'operation'          => $operation,
+			'current_stock'      => $current_stock,
+			'new_stock'          => $new_stock,
+			'manage_stock'       => (bool) $manage_stock,
+			'backorders_allowed' => (bool) $backorders_allowed,
+			'product'            => $product_payload,
+			'warnings'           => $warnings,
+			'preview'            => array(
+				'name'          => isset( $product_payload['name'] ) ? $product_payload['name'] : '',
+				'sku'           => isset( $product_payload['sku'] ) ? $product_payload['sku'] : '',
+				'current_stock' => $current_stock,
+				'new_stock'     => $new_stock,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store stock update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft stock update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_stock_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_product' ) || ! function_exists( 'wc_update_product_stock' ) ) {
+			return Response::error( 'WooCommerce is required to update product stock.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing stock update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Stock update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for stock update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+
+		$product_id = isset( $payload['product_id'] ) ? absint( $payload['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Stock update draft is missing the product ID.', 400 );
+		}
+
+		$operation = isset( $payload['operation'] ) ? $this->normalize_operation( $payload['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Stock update draft has an invalid operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $payload['quantity'] ) ? $payload['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock update draft has an invalid quantity.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update confirmation.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$updated_stock = wc_update_product_stock( $product, $quantity, $operation );
+		if ( is_wp_error( $updated_stock ) ) {
+			return Response::error( $updated_stock->get_error_message(), 400 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		$refreshed = wc_get_product( $product_id );
+		$product_payload = $refreshed ? $this->format_product( $refreshed, true ) : array();
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'product_id'     => $product_id,
+				'previous_stock' => $current_stock,
+				'new_stock'      => is_numeric( $updated_stock ) ? intval( $updated_stock ) : $new_stock,
+				'manage_stock'   => (bool) $manage_stock,
+				'product'        => $product_payload,
+			)
+		);
+	}
+
+	/**
+	 * @param string $query Search string.
+	 * @param string $sku SKU search.
+	 * @return array
+	 */
+	private function find_products( $query, $sku ) {
+		$products = array();
+
+		$sku = trim( (string) $sku );
+		if ( '' !== $sku && function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $sku ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+				}
+			}
+
+			return $products;
+		}
+
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $products;
+		}
+
+		$maybe_id = absint( $query );
+		if ( $maybe_id > 0 ) {
+			$product = wc_get_product( $maybe_id );
+			if ( $product ) {
+				$products[] = $this->format_product( $product, true );
+				return $products;
+			}
+		}
+
+		if ( function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $query ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+					return $products;
+				}
+			}
+		}
+
+		if ( ! function_exists( 'get_posts' ) ) {
+			return $products;
+		}
+
+		$matches = get_posts(
+			array(
+				'post_type'      => array( 'product' ),
+				'post_status'    => array( 'publish', 'private' ),
+				's'              => $query,
+				'posts_per_page' => self::DEFAULT_LIMIT,
+				'fields'         => 'ids',
+			)
+		);
+
+		if ( ! is_array( $matches ) ) {
+			return $products;
+		}
+
+		foreach ( $matches as $product_id ) {
+			$product_id = absint( $product_id );
+			if ( 0 === $product_id ) {
+				continue;
+			}
+
+			$product = wc_get_product( $product_id );
+			if ( ! $product ) {
+				continue;
+			}
+
+			$products[] = $this->format_product( $product, true );
+		}
+
+		return $products;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @param bool  $include_variations Whether to include variations.
+	 * @return array
+	 */
+	private function format_product( $product, $include_variations = false ) {
+		if ( ! $product || ! method_exists( $product, 'get_id' ) ) {
+			return array();
+		}
+
+		$stock_quantity = method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null;
+		$sku            = method_exists( $product, 'get_sku' ) ? $product->get_sku() : '';
+		$stock_status   = method_exists( $product, 'get_stock_status' ) ? $product->get_stock_status() : '';
+
+		$payload = array(
+			'id'                 => intval( $product->get_id() ),
+			'name'               => sanitize_text_field( $this->get_product_name( $product ) ),
+			'sku'                => sanitize_text_field( (string) $sku ),
+			'current_stock'      => $this->normalize_stock_quantity( $stock_quantity ),
+			'stock_status'       => sanitize_text_field( (string) $stock_status ),
+			'manage_stock'       => method_exists( $product, 'managing_stock' ) ? (bool) $product->managing_stock() : false,
+			'backorders_allowed' => method_exists( $product, 'backorders_allowed' ) ? (bool) $product->backorders_allowed() : false,
+		);
+
+		if ( method_exists( $product, 'is_type' ) && $product->is_type( 'variation' ) && method_exists( $product, 'get_parent_id' ) ) {
+			$payload['parent_id'] = intval( $product->get_parent_id() );
+		}
+
+		if ( $include_variations && method_exists( $product, 'is_type' ) && $product->is_type( 'variable' ) ) {
+			$payload['variations'] = $this->format_variations( $product );
+		}
+
+		return $payload;
+	}
+
+	/**
+	 * @param mixed $product Variable product.
+	 * @return array
+	 */
+	private function format_variations( $product ) {
+		if ( ! $product || ! method_exists( $product, 'get_children' ) ) {
+			return array();
+		}
+
+		$variations = array();
+		$children   = $product->get_children();
+
+		if ( ! is_array( $children ) ) {
+			return $variations;
+		}
+
+		foreach ( $children as $variation_id ) {
+			$variation_id = absint( $variation_id );
+			if ( 0 === $variation_id ) {
+				continue;
+			}
+
+			$variation = wc_get_product( $variation_id );
+			if ( ! $variation ) {
+				continue;
+			}
+
+			$variations[] = $this->format_product( $variation, false );
+		}
+
+		return $variations;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @return string
+	 */
+	private function get_product_name( $product ) {
+		if ( method_exists( $product, 'get_formatted_name' ) ) {
+			return (string) $product->get_formatted_name();
+		}
+
+		if ( method_exists( $product, 'get_name' ) ) {
+			return (string) $product->get_name();
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int
+	 */
+	private function normalize_stock_quantity( $quantity ) {
+		if ( is_numeric( $quantity ) ) {
+			return intval( $quantity );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param mixed $operation Raw operation.
+	 * @return string
+	 */
+	private function normalize_operation( $operation ) {
+		$operation = is_string( $operation ) ? strtolower( trim( $operation ) ) : '';
+		$allowed   = array( 'set', 'increase', 'decrease' );
+
+		if ( in_array( $operation, $allowed, true ) ) {
+			return $operation;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int|null
+	 */
+	private function normalize_quantity( $quantity ) {
+		if ( null === $quantity || '' === $quantity ) {
+			return null;
+		}
+
+		if ( is_int( $quantity ) ) {
+			return $quantity >= 0 ? $quantity : null;
+		}
+
+		$validated = filter_var(
+			$quantity,
+			FILTER_VALIDATE_INT,
+			array(
+				'options' => array(
+					'min_range' => 0,
+				),
+			)
+		);
+
+		if ( false === $validated ) {
+			return null;
+		}
+
+		return intval( $validated );
+	}
+
+	/**
+	 * @param int    $current_stock Current stock.
+	 * @param int    $quantity Quantity.
+	 * @param string $operation Operation.
+	 * @return int
+	 */
+	private function calculate_new_stock( $current_stock, $quantity, $operation ) {
+		switch ( $operation ) {
+			case 'increase':
+				return $current_stock + $quantity;
+			case 'decrease':
+				return $current_stock - $quantity;
+			case 'set':
+			default:
+				return $quantity;
+		}
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}


thinking
**Updating ProductStockHandler with StockHandler**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Intent/Handlers/ProductStockHandler.php
@@ -10,2 +10,3 @@
 use AgentWP\AI\Response;
+use AgentWP\Handlers\StockHandler;
 use AgentWP\Intent\Intent;
@@ -22,4 +23,28 @@
 	public function handle( array $context ): Response {
-		$message = 'I can check product stock. Share a product name or SKU.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		if ( '' === $query ) {
+			$message = 'I can check product stock. Share a product name or SKU.';
+			return $this->build_response( $context, $message );
+		}
+
+		$search = new StockHandler();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any products that match.'
+			: sprintf( 'Found %d product%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M src/Intent/Handlers/ProductStockHandler.php
file update:
diff --git a/src/Handlers/StockHandler.php b/src/Handlers/StockHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..a2502132d5df57368949b328d7decf34b10e1233
--- /dev/null
+++ b/src/Handlers/StockHandler.php
@@ -0,0 +1,569 @@
+<?php
+/**
+ * Handle product stock searches and updates.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class StockHandler {
+	const DRAFT_TYPE    = 'stock_update';
+	const DEFAULT_LIMIT = 10;
+
+	/**
+	 * Handle stock-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['query'] ) || isset( $args['sku'] ) ) {
+			return $this->search_products( $args );
+		}
+
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_stock_update( $args['draft_id'] );
+		}
+
+		return $this->prepare_stock_update( $args );
+	}
+
+	/**
+	 * Search for products by name, SKU, or ID.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function search_products( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to search products.', 400 );
+		}
+
+		$query = isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '';
+		$sku   = isset( $args['sku'] ) ? sanitize_text_field( $args['sku'] ) : '';
+
+		if ( '' === $query && '' === $sku ) {
+			return Response::error( 'Missing product search query.', 400 );
+		}
+
+		$products = $this->find_products( $query, $sku );
+
+		return Response::success(
+			array(
+				'products' => $products,
+				'count'    => count( $products ),
+				'query'    => array(
+					'query' => $query,
+					'sku'   => $sku,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft stock update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_stock_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to prepare stock updates.', 400 );
+		}
+
+		$product_id = isset( $args['product_id'] ) ? absint( $args['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Missing product ID for stock update.', 400 );
+		}
+
+		$operation = isset( $args['operation'] ) ? $this->normalize_operation( $args['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Missing or invalid stock operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $args['quantity'] ) ? $args['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock quantity must be a non-negative integer.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$warnings = array();
+		if ( ! $manage_stock ) {
+			$warnings[] = 'Stock management is disabled for this product; quantity changes may not affect availability.';
+		}
+
+		$product_payload = $this->format_product( $product, true );
+
+		$draft_payload = array(
+			'product_id'         => $product_id,
+			'quantity'           => $quantity,
+			'operation'          => $operation,
+			'current_stock'      => $current_stock,
+			'new_stock'          => $new_stock,
+			'manage_stock'       => (bool) $manage_stock,
+			'backorders_allowed' => (bool) $backorders_allowed,
+			'product'            => $product_payload,
+			'warnings'           => $warnings,
+			'preview'            => array(
+				'name'          => isset( $product_payload['name'] ) ? $product_payload['name'] : '',
+				'sku'           => isset( $product_payload['sku'] ) ? $product_payload['sku'] : '',
+				'current_stock' => $current_stock,
+				'new_stock'     => $new_stock,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store stock update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft stock update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_stock_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_product' ) || ! function_exists( 'wc_update_product_stock' ) ) {
+			return Response::error( 'WooCommerce is required to update product stock.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing stock update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Stock update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for stock update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+
+		$product_id = isset( $payload['product_id'] ) ? absint( $payload['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Stock update draft is missing the product ID.', 400 );
+		}
+
+		$operation = isset( $payload['operation'] ) ? $this->normalize_operation( $payload['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Stock update draft has an invalid operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $payload['quantity'] ) ? $payload['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock update draft has an invalid quantity.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update confirmation.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$updated_stock = wc_update_product_stock( $product, $quantity, $operation );
+		if ( is_wp_error( $updated_stock ) ) {
+			return Response::error( $updated_stock->get_error_message(), 400 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		$refreshed = wc_get_product( $product_id );
+		$product_payload = $refreshed ? $this->format_product( $refreshed, true ) : array();
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'product_id'     => $product_id,
+				'previous_stock' => $current_stock,
+				'new_stock'      => is_numeric( $updated_stock ) ? intval( $updated_stock ) : $new_stock,
+				'manage_stock'   => (bool) $manage_stock,
+				'product'        => $product_payload,
+			)
+		);
+	}
+
+	/**
+	 * @param string $query Search string.
+	 * @param string $sku SKU search.
+	 * @return array
+	 */
+	private function find_products( $query, $sku ) {
+		$products = array();
+
+		$sku = trim( (string) $sku );
+		if ( '' !== $sku && function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $sku ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+				}
+			}
+
+			return $products;
+		}
+
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $products;
+		}
+
+		$maybe_id = absint( $query );
+		if ( $maybe_id > 0 ) {
+			$product = wc_get_product( $maybe_id );
+			if ( $product ) {
+				$products[] = $this->format_product( $product, true );
+				return $products;
+			}
+		}
+
+		if ( function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $query ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+					return $products;
+				}
+			}
+		}
+
+		if ( ! function_exists( 'get_posts' ) ) {
+			return $products;
+		}
+
+		$matches = get_posts(
+			array(
+				'post_type'      => array( 'product' ),
+				'post_status'    => array( 'publish', 'private' ),
+				's'              => $query,
+				'posts_per_page' => self::DEFAULT_LIMIT,
+				'fields'         => 'ids',
+			)
+		);
+
+		if ( ! is_array( $matches ) ) {
+			return $products;
+		}
+
+		foreach ( $matches as $product_id ) {
+			$product_id = absint( $product_id );
+			if ( 0 === $product_id ) {
+				continue;
+			}
+
+			$product = wc_get_product( $product_id );
+			if ( ! $product ) {
+				continue;
+			}
+
+			$products[] = $this->format_product( $product, true );
+		}
+
+		return $products;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @param bool  $include_variations Whether to include variations.
+	 * @return array
+	 */
+	private function format_product( $product, $include_variations = false ) {
+		if ( ! $product || ! method_exists( $product, 'get_id' ) ) {
+			return array();
+		}
+
+		$stock_quantity = method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null;
+		$sku            = method_exists( $product, 'get_sku' ) ? $product->get_sku() : '';
+		$stock_status   = method_exists( $product, 'get_stock_status' ) ? $product->get_stock_status() : '';
+
+		$payload = array(
+			'id'                 => intval( $product->get_id() ),
+			'name'               => sanitize_text_field( $this->get_product_name( $product ) ),
+			'sku'                => sanitize_text_field( (string) $sku ),
+			'current_stock'      => $this->normalize_stock_quantity( $stock_quantity ),
+			'stock_status'       => sanitize_text_field( (string) $stock_status ),
+			'manage_stock'       => method_exists( $product, 'managing_stock' ) ? (bool) $product->managing_stock() : false,
+			'backorders_allowed' => method_exists( $product, 'backorders_allowed' ) ? (bool) $product->backorders_allowed() : false,
+		);
+
+		if ( method_exists( $product, 'is_type' ) && $product->is_type( 'variation' ) && method_exists( $product, 'get_parent_id' ) ) {
+			$payload['parent_id'] = intval( $product->get_parent_id() );
+		}
+
+		if ( $include_variations && method_exists( $product, 'is_type' ) && $product->is_type( 'variable' ) ) {
+			$payload['variations'] = $this->format_variations( $product );
+		}
+
+		return $payload;
+	}
+
+	/**
+	 * @param mixed $product Variable product.
+	 * @return array
+	 */
+	private function format_variations( $product ) {
+		if ( ! $product || ! method_exists( $product, 'get_children' ) ) {
+			return array();
+		}
+
+		$variations = array();
+		$children   = $product->get_children();
+
+		if ( ! is_array( $children ) ) {
+			return $variations;
+		}
+
+		foreach ( $children as $variation_id ) {
+			$variation_id = absint( $variation_id );
+			if ( 0 === $variation_id ) {
+				continue;
+			}
+
+			$variation = wc_get_product( $variation_id );
+			if ( ! $variation ) {
+				continue;
+			}
+
+			$variations[] = $this->format_product( $variation, false );
+		}
+
+		return $variations;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @return string
+	 */
+	private function get_product_name( $product ) {
+		if ( method_exists( $product, 'get_formatted_name' ) ) {
+			return (string) $product->get_formatted_name();
+		}
+
+		if ( method_exists( $product, 'get_name' ) ) {
+			return (string) $product->get_name();
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int
+	 */
+	private function normalize_stock_quantity( $quantity ) {
+		if ( is_numeric( $quantity ) ) {
+			return intval( $quantity );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param mixed $operation Raw operation.
+	 * @return string
+	 */
+	private function normalize_operation( $operation ) {
+		$operation = is_string( $operation ) ? strtolower( trim( $operation ) ) : '';
+		$allowed   = array( 'set', 'increase', 'decrease' );
+
+		if ( in_array( $operation, $allowed, true ) ) {
+			return $operation;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int|null
+	 */
+	private function normalize_quantity( $quantity ) {
+		if ( null === $quantity || '' === $quantity ) {
+			return null;
+		}
+
+		if ( is_int( $quantity ) ) {
+			return $quantity >= 0 ? $quantity : null;
+		}
+
+		$validated = filter_var(
+			$quantity,
+			FILTER_VALIDATE_INT,
+			array(
+				'options' => array(
+					'min_range' => 0,
+				),
+			)
+		);
+
+		if ( false === $validated ) {
+			return null;
+		}
+
+		return intval( $validated );
+	}
+
+	/**
+	 * @param int    $current_stock Current stock.
+	 * @param int    $quantity Quantity.
+	 * @param string $operation Operation.
+	 * @return int
+	 */
+	private function calculate_new_stock( $current_stock, $quantity, $operation ) {
+		switch ( $operation ) {
+			case 'increase':
+				return $current_stock + $quantity;
+			case 'decrease':
+				return $current_stock - $quantity;
+			case 'set':
+			default:
+				return $quantity;
+		}
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}
diff --git a/src/Intent/Handlers/ProductStockHandler.php b/src/Intent/Handlers/ProductStockHandler.php
index f9fa36278962b3b0fcaf7863daa9f10077e5b33c..f4df63499e7b56d618f2a8c7037785de242fba6a
--- a/src/Intent/Handlers/ProductStockHandler.php
+++ b/src/Intent/Handlers/ProductStockHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\StockHandler;
 use AgentWP\Intent\Intent;
 
 class ProductStockHandler extends BaseHandler {
@@ -20,7 +21,31 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can check product stock. Share a product name or SKU.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		if ( '' === $query ) {
+			$message = 'I can check product stock. Share a product name or SKU.';
+			return $this->build_response( $context, $message );
+		}
+
+		$search = new StockHandler();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any products that match.'
+			: sprintf( 'Found %d product%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }

file update:
diff --git a/src/Handlers/StockHandler.php b/src/Handlers/StockHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..a2502132d5df57368949b328d7decf34b10e1233
--- /dev/null
+++ b/src/Handlers/StockHandler.php
@@ -0,0 +1,569 @@
+<?php
+/**
+ * Handle product stock searches and updates.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class StockHandler {
+	const DRAFT_TYPE    = 'stock_update';
+	const DEFAULT_LIMIT = 10;
+
+	/**
+	 * Handle stock-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['query'] ) || isset( $args['sku'] ) ) {
+			return $this->search_products( $args );
+		}
+
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_stock_update( $args['draft_id'] );
+		}
+
+		return $this->prepare_stock_update( $args );
+	}
+
+	/**
+	 * Search for products by name, SKU, or ID.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function search_products( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to search products.', 400 );
+		}
+
+		$query = isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '';
+		$sku   = isset( $args['sku'] ) ? sanitize_text_field( $args['sku'] ) : '';
+
+		if ( '' === $query && '' === $sku ) {
+			return Response::error( 'Missing product search query.', 400 );
+		}
+
+		$products = $this->find_products( $query, $sku );
+
+		return Response::success(
+			array(
+				'products' => $products,
+				'count'    => count( $products ),
+				'query'    => array(
+					'query' => $query,
+					'sku'   => $sku,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft stock update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_stock_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to prepare stock updates.', 400 );
+		}
+
+		$product_id = isset( $args['product_id'] ) ? absint( $args['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Missing product ID for stock update.', 400 );
+		}
+
+		$operation = isset( $args['operation'] ) ? $this->normalize_operation( $args['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Missing or invalid stock operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $args['quantity'] ) ? $args['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock quantity must be a non-negative integer.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$warnings = array();
+		if ( ! $manage_stock ) {
+			$warnings[] = 'Stock management is disabled for this product; quantity changes may not affect availability.';
+		}
+
+		$product_payload = $this->format_product( $product, true );
+
+		$draft_payload = array(
+			'product_id'         => $product_id,
+			'quantity'           => $quantity,
+			'operation'          => $operation,
+			'current_stock'      => $current_stock,
+			'new_stock'          => $new_stock,
+			'manage_stock'       => (bool) $manage_stock,
+			'backorders_allowed' => (bool) $backorders_allowed,
+			'product'            => $product_payload,
+			'warnings'           => $warnings,
+			'preview'            => array(
+				'name'          => isset( $product_payload['name'] ) ? $product_payload['name'] : '',
+				'sku'           => isset( $product_payload['sku'] ) ? $product_payload['sku'] : '',
+				'current_stock' => $current_stock,
+				'new_stock'     => $new_stock,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store stock update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft stock update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_stock_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_product' ) || ! function_exists( 'wc_update_product_stock' ) ) {
+			return Response::error( 'WooCommerce is required to update product stock.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing stock update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Stock update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for stock update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+
+		$product_id = isset( $payload['product_id'] ) ? absint( $payload['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Stock update draft is missing the product ID.', 400 );
+		}
+
+		$operation = isset( $payload['operation'] ) ? $this->normalize_operation( $payload['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Stock update draft has an invalid operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $payload['quantity'] ) ? $payload['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock update draft has an invalid quantity.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update confirmation.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$updated_stock = wc_update_product_stock( $product, $quantity, $operation );
+		if ( is_wp_error( $updated_stock ) ) {
+			return Response::error( $updated_stock->get_error_message(), 400 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		$refreshed = wc_get_product( $product_id );
+		$product_payload = $refreshed ? $this->format_product( $refreshed, true ) : array();
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'product_id'     => $product_id,
+				'previous_stock' => $current_stock,
+				'new_stock'      => is_numeric( $updated_stock ) ? intval( $updated_stock ) : $new_stock,
+				'manage_stock'   => (bool) $manage_stock,
+				'product'        => $product_payload,
+			)
+		);
+	}
+
+	/**
+	 * @param string $query Search string.
+	 * @param string $sku SKU search.
+	 * @return array
+	 */
+	private function find_products( $query, $sku ) {
+		$products = array();
+
+		$sku = trim( (string) $sku );
+		if ( '' !== $sku && function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $sku ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+				}
+			}
+
+			return $products;
+		}
+
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $products;
+		}
+
+		$maybe_id = absint( $query );
+		if ( $maybe_id > 0 ) {
+			$product = wc_get_product( $maybe_id );
+			if ( $product ) {
+				$products[] = $this->format_product( $product, true );
+				return $products;
+			}
+		}
+
+		if ( function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $query ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+					return $products;
+				}
+			}
+		}
+
+		if ( ! function_exists( 'get_posts' ) ) {
+			return $products;
+		}
+
+		$matches = get_posts(
+			array(
+				'post_type'      => array( 'product' ),
+				'post_status'    => array( 'publish', 'private' ),
+				's'              => $query,
+				'posts_per_page' => self::DEFAULT_LIMIT,
+				'fields'         => 'ids',
+			)
+		);
+
+		if ( ! is_array( $matches ) ) {
+			return $products;
+		}
+
+		foreach ( $matches as $product_id ) {
+			$product_id = absint( $product_id );
+			if ( 0 === $product_id ) {
+				continue;
+			}
+
+			$product = wc_get_product( $product_id );
+			if ( ! $product ) {
+				continue;
+			}
+
+			$products[] = $this->format_product( $product, true );
+		}
+
+		return $products;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @param bool  $include_variations Whether to include variations.
+	 * @return array
+	 */
+	private function format_product( $product, $include_variations = false ) {
+		if ( ! $product || ! method_exists( $product, 'get_id' ) ) {
+			return array();
+		}
+
+		$stock_quantity = method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null;
+		$sku            = method_exists( $product, 'get_sku' ) ? $product->get_sku() : '';
+		$stock_status   = method_exists( $product, 'get_stock_status' ) ? $product->get_stock_status() : '';
+
+		$payload = array(
+			'id'                 => intval( $product->get_id() ),
+			'name'               => sanitize_text_field( $this->get_product_name( $product ) ),
+			'sku'                => sanitize_text_field( (string) $sku ),
+			'current_stock'      => $this->normalize_stock_quantity( $stock_quantity ),
+			'stock_status'       => sanitize_text_field( (string) $stock_status ),
+			'manage_stock'       => method_exists( $product, 'managing_stock' ) ? (bool) $product->managing_stock() : false,
+			'backorders_allowed' => method_exists( $product, 'backorders_allowed' ) ? (bool) $product->backorders_allowed() : false,
+		);
+
+		if ( method_exists( $product, 'is_type' ) && $product->is_type( 'variation' ) && method_exists( $product, 'get_parent_id' ) ) {
+			$payload['parent_id'] = intval( $product->get_parent_id() );
+		}
+
+		if ( $include_variations && method_exists( $product, 'is_type' ) && $product->is_type( 'variable' ) ) {
+			$payload['variations'] = $this->format_variations( $product );
+		}
+
+		return $payload;
+	}
+
+	/**
+	 * @param mixed $product Variable product.
+	 * @return array
+	 */
+	private function format_variations( $product ) {
+		if ( ! $product || ! method_exists( $product, 'get_children' ) ) {
+			return array();
+		}
+
+		$variations = array();
+		$children   = $product->get_children();
+
+		if ( ! is_array( $children ) ) {
+			return $variations;
+		}
+
+		foreach ( $children as $variation_id ) {
+			$variation_id = absint( $variation_id );
+			if ( 0 === $variation_id ) {
+				continue;
+			}
+
+			$variation = wc_get_product( $variation_id );
+			if ( ! $variation ) {
+				continue;
+			}
+
+			$variations[] = $this->format_product( $variation, false );
+		}
+
+		return $variations;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @return string
+	 */
+	private function get_product_name( $product ) {
+		if ( method_exists( $product, 'get_formatted_name' ) ) {
+			return (string) $product->get_formatted_name();
+		}
+
+		if ( method_exists( $product, 'get_name' ) ) {
+			return (string) $product->get_name();
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int
+	 */
+	private function normalize_stock_quantity( $quantity ) {
+		if ( is_numeric( $quantity ) ) {
+			return intval( $quantity );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param mixed $operation Raw operation.
+	 * @return string
+	 */
+	private function normalize_operation( $operation ) {
+		$operation = is_string( $operation ) ? strtolower( trim( $operation ) ) : '';
+		$allowed   = array( 'set', 'increase', 'decrease' );
+
+		if ( in_array( $operation, $allowed, true ) ) {
+			return $operation;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int|null
+	 */
+	private function normalize_quantity( $quantity ) {
+		if ( null === $quantity || '' === $quantity ) {
+			return null;
+		}
+
+		if ( is_int( $quantity ) ) {
+			return $quantity >= 0 ? $quantity : null;
+		}
+
+		$validated = filter_var(
+			$quantity,
+			FILTER_VALIDATE_INT,
+			array(
+				'options' => array(
+					'min_range' => 0,
+				),
+			)
+		);
+
+		if ( false === $validated ) {
+			return null;
+		}
+
+		return intval( $validated );
+	}
+
+	/**
+	 * @param int    $current_stock Current stock.
+	 * @param int    $quantity Quantity.
+	 * @param string $operation Operation.
+	 * @return int
+	 */
+	private function calculate_new_stock( $current_stock, $quantity, $operation ) {
+		switch ( $operation ) {
+			case 'increase':
+				return $current_stock + $quantity;
+			case 'decrease':
+				return $current_stock - $quantity;
+			case 'set':
+			default:
+				return $quantity;
+		}
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}
diff --git a/src/Intent/Handlers/ProductStockHandler.php b/src/Intent/Handlers/ProductStockHandler.php
index f9fa36278962b3b0fcaf7863daa9f10077e5b33c..f4df63499e7b56d618f2a8c7037785de242fba6a
--- a/src/Intent/Handlers/ProductStockHandler.php
+++ b/src/Intent/Handlers/ProductStockHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\StockHandler;
 use AgentWP\Intent\Intent;
 
 class ProductStockHandler extends BaseHandler {
@@ -20,7 +21,31 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can check product stock. Share a product name or SKU.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		if ( '' === $query ) {
+			$message = 'I can check product stock. Share a product name or SKU.';
+			return $this->build_response( $context, $message );
+		}
+
+		$search = new StockHandler();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any products that match.'
+			: sprintf( 'Found %d product%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Reviewing and refining stock update logic**

I'm checking schema descriptions and behavior for SearchProduct and PrepareStockUpdate and focusing on warnings related to stock management settings. I want to align the warnings with the spec—specifically warning only when the 'set' operation occurs and manage_stock is false—and ensure proper error handling on stock updates, adding checks for false returns from `wc_update_product_stock`. Also, I’ll verify that input sanitization fits use cases like SKU strings and prepare the code adjustments accordingly.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/StockHandler.php
@@ -109,3 +109,3 @@
 		$warnings = array();
-		if ( ! $manage_stock ) {
+		if ( ! $manage_stock && 'set' === $operation ) {
 			$warnings[] = 'Stock management is disabled for this product; quantity changes may not affect availability.';
@@ -222,2 +222,5 @@
 		}
+		if ( false === $updated_stock ) {
+			return Response::error( 'Unable to update product stock.', 500 );
+		}
 
apply_patch(auto_approved=true) exited 0 in 34ms:
Success. Updated the following files:
M src/Handlers/StockHandler.php
file update:
diff --git a/src/Handlers/StockHandler.php b/src/Handlers/StockHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..51c5b66eee70395d5b68066c14cae9ed90553d0a
--- /dev/null
+++ b/src/Handlers/StockHandler.php
@@ -0,0 +1,572 @@
+<?php
+/**
+ * Handle product stock searches and updates.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class StockHandler {
+	const DRAFT_TYPE    = 'stock_update';
+	const DEFAULT_LIMIT = 10;
+
+	/**
+	 * Handle stock-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['query'] ) || isset( $args['sku'] ) ) {
+			return $this->search_products( $args );
+		}
+
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_stock_update( $args['draft_id'] );
+		}
+
+		return $this->prepare_stock_update( $args );
+	}
+
+	/**
+	 * Search for products by name, SKU, or ID.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function search_products( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to search products.', 400 );
+		}
+
+		$query = isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '';
+		$sku   = isset( $args['sku'] ) ? sanitize_text_field( $args['sku'] ) : '';
+
+		if ( '' === $query && '' === $sku ) {
+			return Response::error( 'Missing product search query.', 400 );
+		}
+
+		$products = $this->find_products( $query, $sku );
+
+		return Response::success(
+			array(
+				'products' => $products,
+				'count'    => count( $products ),
+				'query'    => array(
+					'query' => $query,
+					'sku'   => $sku,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft stock update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_stock_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to prepare stock updates.', 400 );
+		}
+
+		$product_id = isset( $args['product_id'] ) ? absint( $args['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Missing product ID for stock update.', 400 );
+		}
+
+		$operation = isset( $args['operation'] ) ? $this->normalize_operation( $args['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Missing or invalid stock operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $args['quantity'] ) ? $args['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock quantity must be a non-negative integer.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$warnings = array();
+		if ( ! $manage_stock && 'set' === $operation ) {
+			$warnings[] = 'Stock management is disabled for this product; quantity changes may not affect availability.';
+		}
+
+		$product_payload = $this->format_product( $product, true );
+
+		$draft_payload = array(
+			'product_id'         => $product_id,
+			'quantity'           => $quantity,
+			'operation'          => $operation,
+			'current_stock'      => $current_stock,
+			'new_stock'          => $new_stock,
+			'manage_stock'       => (bool) $manage_stock,
+			'backorders_allowed' => (bool) $backorders_allowed,
+			'product'            => $product_payload,
+			'warnings'           => $warnings,
+			'preview'            => array(
+				'name'          => isset( $product_payload['name'] ) ? $product_payload['name'] : '',
+				'sku'           => isset( $product_payload['sku'] ) ? $product_payload['sku'] : '',
+				'current_stock' => $current_stock,
+				'new_stock'     => $new_stock,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store stock update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft stock update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_stock_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_product' ) || ! function_exists( 'wc_update_product_stock' ) ) {
+			return Response::error( 'WooCommerce is required to update product stock.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing stock update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Stock update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for stock update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+
+		$product_id = isset( $payload['product_id'] ) ? absint( $payload['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Stock update draft is missing the product ID.', 400 );
+		}
+
+		$operation = isset( $payload['operation'] ) ? $this->normalize_operation( $payload['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Stock update draft has an invalid operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $payload['quantity'] ) ? $payload['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock update draft has an invalid quantity.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update confirmation.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$updated_stock = wc_update_product_stock( $product, $quantity, $operation );
+		if ( is_wp_error( $updated_stock ) ) {
+			return Response::error( $updated_stock->get_error_message(), 400 );
+		}
+		if ( false === $updated_stock ) {
+			return Response::error( 'Unable to update product stock.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		$refreshed = wc_get_product( $product_id );
+		$product_payload = $refreshed ? $this->format_product( $refreshed, true ) : array();
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'product_id'     => $product_id,
+				'previous_stock' => $current_stock,
+				'new_stock'      => is_numeric( $updated_stock ) ? intval( $updated_stock ) : $new_stock,
+				'manage_stock'   => (bool) $manage_stock,
+				'product'        => $product_payload,
+			)
+		);
+	}
+
+	/**
+	 * @param string $query Search string.
+	 * @param string $sku SKU search.
+	 * @return array
+	 */
+	private function find_products( $query, $sku ) {
+		$products = array();
+
+		$sku = trim( (string) $sku );
+		if ( '' !== $sku && function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $sku ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+				}
+			}
+
+			return $products;
+		}
+
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $products;
+		}
+
+		$maybe_id = absint( $query );
+		if ( $maybe_id > 0 ) {
+			$product = wc_get_product( $maybe_id );
+			if ( $product ) {
+				$products[] = $this->format_product( $product, true );
+				return $products;
+			}
+		}
+
+		if ( function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $query ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+					return $products;
+				}
+			}
+		}
+
+		if ( ! function_exists( 'get_posts' ) ) {
+			return $products;
+		}
+
+		$matches = get_posts(
+			array(
+				'post_type'      => array( 'product' ),
+				'post_status'    => array( 'publish', 'private' ),
+				's'              => $query,
+				'posts_per_page' => self::DEFAULT_LIMIT,
+				'fields'         => 'ids',
+			)
+		);
+
+		if ( ! is_array( $matches ) ) {
+			return $products;
+		}
+
+		foreach ( $matches as $product_id ) {
+			$product_id = absint( $product_id );
+			if ( 0 === $product_id ) {
+				continue;
+			}
+
+			$product = wc_get_product( $product_id );
+			if ( ! $product ) {
+				continue;
+			}
+
+			$products[] = $this->format_product( $product, true );
+		}
+
+		return $products;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @param bool  $include_variations Whether to include variations.
+	 * @return array
+	 */
+	private function format_product( $product, $include_variations = false ) {
+		if ( ! $product || ! method_exists( $product, 'get_id' ) ) {
+			return array();
+		}
+
+		$stock_quantity = method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null;
+		$sku            = method_exists( $product, 'get_sku' ) ? $product->get_sku() : '';
+		$stock_status   = method_exists( $product, 'get_stock_status' ) ? $product->get_stock_status() : '';
+
+		$payload = array(
+			'id'                 => intval( $product->get_id() ),
+			'name'               => sanitize_text_field( $this->get_product_name( $product ) ),
+			'sku'                => sanitize_text_field( (string) $sku ),
+			'current_stock'      => $this->normalize_stock_quantity( $stock_quantity ),
+			'stock_status'       => sanitize_text_field( (string) $stock_status ),
+			'manage_stock'       => method_exists( $product, 'managing_stock' ) ? (bool) $product->managing_stock() : false,
+			'backorders_allowed' => method_exists( $product, 'backorders_allowed' ) ? (bool) $product->backorders_allowed() : false,
+		);
+
+		if ( method_exists( $product, 'is_type' ) && $product->is_type( 'variation' ) && method_exists( $product, 'get_parent_id' ) ) {
+			$payload['parent_id'] = intval( $product->get_parent_id() );
+		}
+
+		if ( $include_variations && method_exists( $product, 'is_type' ) && $product->is_type( 'variable' ) ) {
+			$payload['variations'] = $this->format_variations( $product );
+		}
+
+		return $payload;
+	}
+
+	/**
+	 * @param mixed $product Variable product.
+	 * @return array
+	 */
+	private function format_variations( $product ) {
+		if ( ! $product || ! method_exists( $product, 'get_children' ) ) {
+			return array();
+		}
+
+		$variations = array();
+		$children   = $product->get_children();
+
+		if ( ! is_array( $children ) ) {
+			return $variations;
+		}
+
+		foreach ( $children as $variation_id ) {
+			$variation_id = absint( $variation_id );
+			if ( 0 === $variation_id ) {
+				continue;
+			}
+
+			$variation = wc_get_product( $variation_id );
+			if ( ! $variation ) {
+				continue;
+			}
+
+			$variations[] = $this->format_product( $variation, false );
+		}
+
+		return $variations;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @return string
+	 */
+	private function get_product_name( $product ) {
+		if ( method_exists( $product, 'get_formatted_name' ) ) {
+			return (string) $product->get_formatted_name();
+		}
+
+		if ( method_exists( $product, 'get_name' ) ) {
+			return (string) $product->get_name();
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int
+	 */
+	private function normalize_stock_quantity( $quantity ) {
+		if ( is_numeric( $quantity ) ) {
+			return intval( $quantity );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param mixed $operation Raw operation.
+	 * @return string
+	 */
+	private function normalize_operation( $operation ) {
+		$operation = is_string( $operation ) ? strtolower( trim( $operation ) ) : '';
+		$allowed   = array( 'set', 'increase', 'decrease' );
+
+		if ( in_array( $operation, $allowed, true ) ) {
+			return $operation;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int|null
+	 */
+	private function normalize_quantity( $quantity ) {
+		if ( null === $quantity || '' === $quantity ) {
+			return null;
+		}
+
+		if ( is_int( $quantity ) ) {
+			return $quantity >= 0 ? $quantity : null;
+		}
+
+		$validated = filter_var(
+			$quantity,
+			FILTER_VALIDATE_INT,
+			array(
+				'options' => array(
+					'min_range' => 0,
+				),
+			)
+		);
+
+		if ( false === $validated ) {
+			return null;
+		}
+
+		return intval( $validated );
+	}
+
+	/**
+	 * @param int    $current_stock Current stock.
+	 * @param int    $quantity Quantity.
+	 * @param string $operation Operation.
+	 * @return int
+	 */
+	private function calculate_new_stock( $current_stock, $quantity, $operation ) {
+		switch ( $operation ) {
+			case 'increase':
+				return $current_stock + $quantity;
+			case 'decrease':
+				return $current_stock - $quantity;
+			case 'set':
+			default:
+				return $quantity;
+		}
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}
diff --git a/src/Intent/Handlers/ProductStockHandler.php b/src/Intent/Handlers/ProductStockHandler.php
index f9fa36278962b3b0fcaf7863daa9f10077e5b33c..f4df63499e7b56d618f2a8c7037785de242fba6a
--- a/src/Intent/Handlers/ProductStockHandler.php
+++ b/src/Intent/Handlers/ProductStockHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\StockHandler;
 use AgentWP\Intent\Intent;
 
 class ProductStockHandler extends BaseHandler {
@@ -20,7 +21,31 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can check product stock. Share a product name or SKU.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		if ( '' === $query ) {
+			$message = 'I can check product stock. Share a product name or SKU.';
+			return $this->build_response( $context, $message );
+		}
+
+		$search = new StockHandler();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any products that match.'
+			: sprintf( 'Found %d product%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }

file update:
diff --git a/src/Handlers/StockHandler.php b/src/Handlers/StockHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..51c5b66eee70395d5b68066c14cae9ed90553d0a
--- /dev/null
+++ b/src/Handlers/StockHandler.php
@@ -0,0 +1,572 @@
+<?php
+/**
+ * Handle product stock searches and updates.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class StockHandler {
+	const DRAFT_TYPE    = 'stock_update';
+	const DEFAULT_LIMIT = 10;
+
+	/**
+	 * Handle stock-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['query'] ) || isset( $args['sku'] ) ) {
+			return $this->search_products( $args );
+		}
+
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_stock_update( $args['draft_id'] );
+		}
+
+		return $this->prepare_stock_update( $args );
+	}
+
+	/**
+	 * Search for products by name, SKU, or ID.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function search_products( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to search products.', 400 );
+		}
+
+		$query = isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '';
+		$sku   = isset( $args['sku'] ) ? sanitize_text_field( $args['sku'] ) : '';
+
+		if ( '' === $query && '' === $sku ) {
+			return Response::error( 'Missing product search query.', 400 );
+		}
+
+		$products = $this->find_products( $query, $sku );
+
+		return Response::success(
+			array(
+				'products' => $products,
+				'count'    => count( $products ),
+				'query'    => array(
+					'query' => $query,
+					'sku'   => $sku,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft stock update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_stock_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to prepare stock updates.', 400 );
+		}
+
+		$product_id = isset( $args['product_id'] ) ? absint( $args['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Missing product ID for stock update.', 400 );
+		}
+
+		$operation = isset( $args['operation'] ) ? $this->normalize_operation( $args['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Missing or invalid stock operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $args['quantity'] ) ? $args['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock quantity must be a non-negative integer.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$warnings = array();
+		if ( ! $manage_stock && 'set' === $operation ) {
+			$warnings[] = 'Stock management is disabled for this product; quantity changes may not affect availability.';
+		}
+
+		$product_payload = $this->format_product( $product, true );
+
+		$draft_payload = array(
+			'product_id'         => $product_id,
+			'quantity'           => $quantity,
+			'operation'          => $operation,
+			'current_stock'      => $current_stock,
+			'new_stock'          => $new_stock,
+			'manage_stock'       => (bool) $manage_stock,
+			'backorders_allowed' => (bool) $backorders_allowed,
+			'product'            => $product_payload,
+			'warnings'           => $warnings,
+			'preview'            => array(
+				'name'          => isset( $product_payload['name'] ) ? $product_payload['name'] : '',
+				'sku'           => isset( $product_payload['sku'] ) ? $product_payload['sku'] : '',
+				'current_stock' => $current_stock,
+				'new_stock'     => $new_stock,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store stock update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft stock update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_stock_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_product' ) || ! function_exists( 'wc_update_product_stock' ) ) {
+			return Response::error( 'WooCommerce is required to update product stock.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing stock update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Stock update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for stock update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+
+		$product_id = isset( $payload['product_id'] ) ? absint( $payload['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Stock update draft is missing the product ID.', 400 );
+		}
+
+		$operation = isset( $payload['operation'] ) ? $this->normalize_operation( $payload['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Stock update draft has an invalid operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $payload['quantity'] ) ? $payload['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock update draft has an invalid quantity.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update confirmation.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$updated_stock = wc_update_product_stock( $product, $quantity, $operation );
+		if ( is_wp_error( $updated_stock ) ) {
+			return Response::error( $updated_stock->get_error_message(), 400 );
+		}
+		if ( false === $updated_stock ) {
+			return Response::error( 'Unable to update product stock.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		$refreshed = wc_get_product( $product_id );
+		$product_payload = $refreshed ? $this->format_product( $refreshed, true ) : array();
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'product_id'     => $product_id,
+				'previous_stock' => $current_stock,
+				'new_stock'      => is_numeric( $updated_stock ) ? intval( $updated_stock ) : $new_stock,
+				'manage_stock'   => (bool) $manage_stock,
+				'product'        => $product_payload,
+			)
+		);
+	}
+
+	/**
+	 * @param string $query Search string.
+	 * @param string $sku SKU search.
+	 * @return array
+	 */
+	private function find_products( $query, $sku ) {
+		$products = array();
+
+		$sku = trim( (string) $sku );
+		if ( '' !== $sku && function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $sku ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+				}
+			}
+
+			return $products;
+		}
+
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $products;
+		}
+
+		$maybe_id = absint( $query );
+		if ( $maybe_id > 0 ) {
+			$product = wc_get_product( $maybe_id );
+			if ( $product ) {
+				$products[] = $this->format_product( $product, true );
+				return $products;
+			}
+		}
+
+		if ( function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $query ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+					return $products;
+				}
+			}
+		}
+
+		if ( ! function_exists( 'get_posts' ) ) {
+			return $products;
+		}
+
+		$matches = get_posts(
+			array(
+				'post_type'      => array( 'product' ),
+				'post_status'    => array( 'publish', 'private' ),
+				's'              => $query,
+				'posts_per_page' => self::DEFAULT_LIMIT,
+				'fields'         => 'ids',
+			)
+		);
+
+		if ( ! is_array( $matches ) ) {
+			return $products;
+		}
+
+		foreach ( $matches as $product_id ) {
+			$product_id = absint( $product_id );
+			if ( 0 === $product_id ) {
+				continue;
+			}
+
+			$product = wc_get_product( $product_id );
+			if ( ! $product ) {
+				continue;
+			}
+
+			$products[] = $this->format_product( $product, true );
+		}
+
+		return $products;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @param bool  $include_variations Whether to include variations.
+	 * @return array
+	 */
+	private function format_product( $product, $include_variations = false ) {
+		if ( ! $product || ! method_exists( $product, 'get_id' ) ) {
+			return array();
+		}
+
+		$stock_quantity = method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null;
+		$sku            = method_exists( $product, 'get_sku' ) ? $product->get_sku() : '';
+		$stock_status   = method_exists( $product, 'get_stock_status' ) ? $product->get_stock_status() : '';
+
+		$payload = array(
+			'id'                 => intval( $product->get_id() ),
+			'name'               => sanitize_text_field( $this->get_product_name( $product ) ),
+			'sku'                => sanitize_text_field( (string) $sku ),
+			'current_stock'      => $this->normalize_stock_quantity( $stock_quantity ),
+			'stock_status'       => sanitize_text_field( (string) $stock_status ),
+			'manage_stock'       => method_exists( $product, 'managing_stock' ) ? (bool) $product->managing_stock() : false,
+			'backorders_allowed' => method_exists( $product, 'backorders_allowed' ) ? (bool) $product->backorders_allowed() : false,
+		);
+
+		if ( method_exists( $product, 'is_type' ) && $product->is_type( 'variation' ) && method_exists( $product, 'get_parent_id' ) ) {
+			$payload['parent_id'] = intval( $product->get_parent_id() );
+		}
+
+		if ( $include_variations && method_exists( $product, 'is_type' ) && $product->is_type( 'variable' ) ) {
+			$payload['variations'] = $this->format_variations( $product );
+		}
+
+		return $payload;
+	}
+
+	/**
+	 * @param mixed $product Variable product.
+	 * @return array
+	 */
+	private function format_variations( $product ) {
+		if ( ! $product || ! method_exists( $product, 'get_children' ) ) {
+			return array();
+		}
+
+		$variations = array();
+		$children   = $product->get_children();
+
+		if ( ! is_array( $children ) ) {
+			return $variations;
+		}
+
+		foreach ( $children as $variation_id ) {
+			$variation_id = absint( $variation_id );
+			if ( 0 === $variation_id ) {
+				continue;
+			}
+
+			$variation = wc_get_product( $variation_id );
+			if ( ! $variation ) {
+				continue;
+			}
+
+			$variations[] = $this->format_product( $variation, false );
+		}
+
+		return $variations;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @return string
+	 */
+	private function get_product_name( $product ) {
+		if ( method_exists( $product, 'get_formatted_name' ) ) {
+			return (string) $product->get_formatted_name();
+		}
+
+		if ( method_exists( $product, 'get_name' ) ) {
+			return (string) $product->get_name();
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int
+	 */
+	private function normalize_stock_quantity( $quantity ) {
+		if ( is_numeric( $quantity ) ) {
+			return intval( $quantity );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param mixed $operation Raw operation.
+	 * @return string
+	 */
+	private function normalize_operation( $operation ) {
+		$operation = is_string( $operation ) ? strtolower( trim( $operation ) ) : '';
+		$allowed   = array( 'set', 'increase', 'decrease' );
+
+		if ( in_array( $operation, $allowed, true ) ) {
+			return $operation;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int|null
+	 */
+	private function normalize_quantity( $quantity ) {
+		if ( null === $quantity || '' === $quantity ) {
+			return null;
+		}
+
+		if ( is_int( $quantity ) ) {
+			return $quantity >= 0 ? $quantity : null;
+		}
+
+		$validated = filter_var(
+			$quantity,
+			FILTER_VALIDATE_INT,
+			array(
+				'options' => array(
+					'min_range' => 0,
+				),
+			)
+		);
+
+		if ( false === $validated ) {
+			return null;
+		}
+
+		return intval( $validated );
+	}
+
+	/**
+	 * @param int    $current_stock Current stock.
+	 * @param int    $quantity Quantity.
+	 * @param string $operation Operation.
+	 * @return int
+	 */
+	private function calculate_new_stock( $current_stock, $quantity, $operation ) {
+		switch ( $operation ) {
+			case 'increase':
+				return $current_stock + $quantity;
+			case 'decrease':
+				return $current_stock - $quantity;
+			case 'set':
+			default:
+				return $quantity;
+		}
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}
diff --git a/src/Intent/Handlers/ProductStockHandler.php b/src/Intent/Handlers/ProductStockHandler.php
index f9fa36278962b3b0fcaf7863daa9f10077e5b33c..f4df63499e7b56d618f2a8c7037785de242fba6a
--- a/src/Intent/Handlers/ProductStockHandler.php
+++ b/src/Intent/Handlers/ProductStockHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\StockHandler;
 use AgentWP\Intent\Intent;
 
 class ProductStockHandler extends BaseHandler {
@@ -20,7 +21,31 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can check product stock. Share a product name or SKU.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		if ( '' === $query ) {
+			$message = 'I can check product stock. Share a product name or SKU.';
+			return $this->build_response( $context, $message );
+		}
+
+		$search = new StockHandler();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any products that match.'
+			: sprintf( 'Found %d product%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Analyzing stock operation validations**
exec
/bin/zsh -lc "sed -n '1,260p' src/Handlers/StockHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Handle product stock searches and updates.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;

class StockHandler {
	const DRAFT_TYPE    = 'stock_update';
	const DEFAULT_LIMIT = 10;

	/**
	 * Handle stock-related requests.
	 *
	 * @param array $args Request args.
file update:
diff --git a/src/Handlers/StockHandler.php b/src/Handlers/StockHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..51c5b66eee70395d5b68066c14cae9ed90553d0a
--- /dev/null
+++ b/src/Handlers/StockHandler.php
@@ -0,0 +1,572 @@
+<?php
+/**
+ * Handle product stock searches and updates.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class StockHandler {
+	const DRAFT_TYPE    = 'stock_update';
+	const DEFAULT_LIMIT = 10;
+
+	/**
+	 * Handle stock-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['query'] ) || isset( $args['sku'] ) ) {
+			return $this->search_products( $args );
+		}
+
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_stock_update( $args['draft_id'] );
+		}
+
+		return $this->prepare_stock_update( $args );
+	}
+
+	/**
+	 * Search for products by name, SKU, or ID.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function search_products( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to search products.', 400 );
+		}
+
+		$query = isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '';
+		$sku   = isset( $args['sku'] ) ? sanitize_text_field( $args['sku'] ) : '';
+
+		if ( '' === $query && '' === $sku ) {
+			return Response::error( 'Missing product search query.', 400 );
+		}
+
+		$products = $this->find_products( $query, $sku );
+
+		return Response::success(
+			array(
+				'products' => $products,
+				'count'    => count( $products ),
+				'query'    => array(
+					'query' => $query,
+					'sku'   => $sku,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft stock update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_stock_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to prepare stock updates.', 400 );
+		}
+
+		$product_id = isset( $args['product_id'] ) ? absint( $args['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Missing product ID for stock update.', 400 );
+		}
+
+		$operation = isset( $args['operation'] ) ? $this->normalize_operation( $args['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Missing or invalid stock operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $args['quantity'] ) ? $args['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock quantity must be a non-negative integer.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$warnings = array();
+		if ( ! $manage_stock && 'set' === $operation ) {
+			$warnings[] = 'Stock management is disabled for this product; quantity changes may not affect availability.';
+		}
+
+		$product_payload = $this->format_product( $product, true );
+
+		$draft_payload = array(
+			'product_id'         => $product_id,
+			'quantity'           => $quantity,
+			'operation'          => $operation,
+			'current_stock'      => $current_stock,
+			'new_stock'          => $new_stock,
+			'manage_stock'       => (bool) $manage_stock,
+			'backorders_allowed' => (bool) $backorders_allowed,
+			'product'            => $product_payload,
+			'warnings'           => $warnings,
+			'preview'            => array(
+				'name'          => isset( $product_payload['name'] ) ? $product_payload['name'] : '',
+				'sku'           => isset( $product_payload['sku'] ) ? $product_payload['sku'] : '',
+				'current_stock' => $current_stock,
+				'new_stock'     => $new_stock,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store stock update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft stock update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_stock_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_product' ) || ! function_exists( 'wc_update_product_stock' ) ) {
+			return Response::error( 'WooCommerce is required to update product stock.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing stock update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Stock update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for stock update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+
+		$product_id = isset( $payload['product_id'] ) ? absint( $payload['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Stock update draft is missing the product ID.', 400 );
+		}
+
+		$operation = isset( $payload['operation'] ) ? $this->normalize_operation( $payload['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Stock update draft has an invalid operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $payload['quantity'] ) ? $payload['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock update draft has an invalid quantity.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update confirmation.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$updated_stock = wc_update_product_stock( $product, $quantity, $operation );
+		if ( is_wp_error( $updated_stock ) ) {
+			return Response::error( $updated_stock->get_error_message(), 400 );
+		}
+		if ( false === $updated_stock ) {
+			return Response::error( 'Unable to update product stock.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		$refreshed = wc_get_product( $product_id );
+		$product_payload = $refreshed ? $this->format_product( $refreshed, true ) : array();
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'product_id'     => $product_id,
+				'previous_stock' => $current_stock,
+				'new_stock'      => is_numeric( $updated_stock ) ? intval( $updated_stock ) : $new_stock,
+				'manage_stock'   => (bool) $manage_stock,
+				'product'        => $product_payload,
+			)
+		);
+	}
+
+	/**
+	 * @param string $query Search string.
+	 * @param string $sku SKU search.
+	 * @return array
+	 */
+	private function find_products( $query, $sku ) {
+		$products = array();
+
+		$sku = trim( (string) $sku );
+		if ( '' !== $sku && function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $sku ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+				}
+			}
+
+			return $products;
+		}
+
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $products;
+		}
+
+		$maybe_id = absint( $query );
+		if ( $maybe_id > 0 ) {
+			$product = wc_get_product( $maybe_id );
+			if ( $product ) {
+				$products[] = $this->format_product( $product, true );
+				return $products;
+			}
+		}
+
+		if ( function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $query ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+					return $products;
+				}
+			}
+		}
+
+		if ( ! function_exists( 'get_posts' ) ) {
+			return $products;
+		}
+
+		$matches = get_posts(
+			array(
+				'post_type'      => array( 'product' ),
+				'post_status'    => array( 'publish', 'private' ),
+				's'              => $query,
+				'posts_per_page' => self::DEFAULT_LIMIT,
+				'fields'         => 'ids',
+			)
+		);
+
+		if ( ! is_array( $matches ) ) {
+			return $products;
+		}
+
+		foreach ( $matches as $product_id ) {
+			$product_id = absint( $product_id );
+			if ( 0 === $product_id ) {
+				continue;
+			}
+
+			$product = wc_get_product( $product_id );
+			if ( ! $product ) {
+				continue;
+			}
+
+			$products[] = $this->format_product( $product, true );
+		}
+
+		return $products;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @param bool  $include_variations Whether to include variations.
+	 * @return array
+	 */
+	private function format_product( $product, $include_variations = false ) {
+		if ( ! $product || ! method_exists( $product, 'get_id' ) ) {
+			return array();
+		}
+
+		$stock_quantity = method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null;
+		$sku            = method_exists( $product, 'get_sku' ) ? $product->get_sku() : '';
+		$stock_status   = method_exists( $product, 'get_stock_status' ) ? $product->get_stock_status() : '';
+
+		$payload = array(
+			'id'                 => intval( $product->get_id() ),
+			'name'               => sanitize_text_field( $this->get_product_name( $product ) ),
+			'sku'                => sanitize_text_field( (string) $sku ),
+			'current_stock'      => $this->normalize_stock_quantity( $stock_quantity ),
+			'stock_status'       => sanitize_text_field( (string) $stock_status ),
+			'manage_stock'       => method_exists( $product, 'managing_stock' ) ? (bool) $product->managing_stock() : false,
+			'backorders_allowed' => method_exists( $product, 'backorders_allowed' ) ? (bool) $product->backorders_allowed() : false,
+		);
+
+		if ( method_exists( $product, 'is_type' ) && $product->is_type( 'variation' ) && method_exists( $product, 'get_parent_id' ) ) {
+			$payload['parent_id'] = intval( $product->get_parent_id() );
+		}
+
+		if ( $include_variations && method_exists( $product, 'is_type' ) && $product->is_type( 'variable' ) ) {
+			$payload['variations'] = $this->format_variations( $product );
+		}
+
+		return $payload;
+	}
+
+	/**
+	 * @param mixed $product Variable product.
+	 * @return array
+	 */
+	private function format_variations( $product ) {
+		if ( ! $product || ! method_exists( $product, 'get_children' ) ) {
+			return array();
+		}
+
+		$variations = array();
+		$children   = $product->get_children();
+
+		if ( ! is_array( $children ) ) {
+			return $variations;
+		}
+
+		foreach ( $children as $variation_id ) {
+			$variation_id = absint( $variation_id );
+			if ( 0 === $variation_id ) {
+				continue;
+			}
+
+			$variation = wc_get_product( $variation_id );
+			if ( ! $variation ) {
+				continue;
+			}
+
+			$variations[] = $this->format_product( $variation, false );
+		}
+
+		return $variations;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @return string
+	 */
+	private function get_product_name( $product ) {
+		if ( method_exists( $product, 'get_formatted_name' ) ) {
+			return (string) $product->get_formatted_name();
+		}
+
+		if ( method_exists( $product, 'get_name' ) ) {
+			return (string) $product->get_name();
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int
+	 */
+	private function normalize_stock_quantity( $quantity ) {
+		if ( is_numeric( $quantity ) ) {
+			return intval( $quantity );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param mixed $operation Raw operation.
+	 * @return string
+	 */
+	private function normalize_operation( $operation ) {
+		$operation = is_string( $operation ) ? strtolower( trim( $operation ) ) : '';
+		$allowed   = array( 'set', 'increase', 'decrease' );
+
+		if ( in_array( $operation, $allowed, true ) ) {
+			return $operation;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int|null
+	 */
+	private function normalize_quantity( $quantity ) {
+		if ( null === $quantity || '' === $quantity ) {
+			return null;
+		}
+
+		if ( is_int( $quantity ) ) {
+			return $quantity >= 0 ? $quantity : null;
+		}
+
+		$validated = filter_var(
+			$quantity,
+			FILTER_VALIDATE_INT,
+			array(
+				'options' => array(
+					'min_range' => 0,
+				),
+			)
+		);
+
+		if ( false === $validated ) {
+			return null;
+		}
+
+		return intval( $validated );
+	}
+
+	/**
+	 * @param int    $current_stock Current stock.
+	 * @param int    $quantity Quantity.
+	 * @param string $operation Operation.
+	 * @return int
+	 */
+	private function calculate_new_stock( $current_stock, $quantity, $operation ) {
+		switch ( $operation ) {
+			case 'increase':
+				return $current_stock + $quantity;
+			case 'decrease':
+				return $current_stock - $quantity;
+			case 'set':
+			default:
+				return $quantity;
+		}
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}
diff --git a/src/Intent/Handlers/ProductStockHandler.php b/src/Intent/Handlers/ProductStockHandler.php
index f9fa36278962b3b0fcaf7863daa9f10077e5b33c..f4df63499e7b56d618f2a8c7037785de242fba6a
--- a/src/Intent/Handlers/ProductStockHandler.php
+++ b/src/Intent/Handlers/ProductStockHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\StockHandler;
 use AgentWP\Intent\Intent;
 
 class ProductStockHandler extends BaseHandler {
@@ -20,7 +21,31 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can check product stock. Share a product name or SKU.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		if ( '' === $query ) {
+			$message = 'I can check product stock. Share a product name or SKU.';
+			return $this->build_response( $context, $message );
+		}
+
+		$search = new StockHandler();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any products that match.'
+			: sprintf( 'Found %d product%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Reviewing code details and decisions**
exec
/bin/zsh -lc "sed -n '1,160p' src/Intent/Handlers/ProductStockHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Handle product stock intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Handlers\StockHandler;
use AgentWP\Intent\Intent;

class ProductStockHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::PRODUCT_STOCK );
	}

	/**
	 * @param array $context Context data.
file update:
diff --git a/src/Handlers/StockHandler.php b/src/Handlers/StockHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..51c5b66eee70395d5b68066c14cae9ed90553d0a
--- /dev/null
+++ b/src/Handlers/StockHandler.php
@@ -0,0 +1,572 @@
+<?php
+/**
+ * Handle product stock searches and updates.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class StockHandler {
+	const DRAFT_TYPE    = 'stock_update';
+	const DEFAULT_LIMIT = 10;
+
+	/**
+	 * Handle stock-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['query'] ) || isset( $args['sku'] ) ) {
+			return $this->search_products( $args );
+		}
+
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_stock_update( $args['draft_id'] );
+		}
+
+		return $this->prepare_stock_update( $args );
+	}
+
+	/**
+	 * Search for products by name, SKU, or ID.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function search_products( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to search products.', 400 );
+		}
+
+		$query = isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '';
+		$sku   = isset( $args['sku'] ) ? sanitize_text_field( $args['sku'] ) : '';
+
+		if ( '' === $query && '' === $sku ) {
+			return Response::error( 'Missing product search query.', 400 );
+		}
+
+		$products = $this->find_products( $query, $sku );
+
+		return Response::success(
+			array(
+				'products' => $products,
+				'count'    => count( $products ),
+				'query'    => array(
+					'query' => $query,
+					'sku'   => $sku,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft stock update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_stock_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to prepare stock updates.', 400 );
+		}
+
+		$product_id = isset( $args['product_id'] ) ? absint( $args['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Missing product ID for stock update.', 400 );
+		}
+
+		$operation = isset( $args['operation'] ) ? $this->normalize_operation( $args['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Missing or invalid stock operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $args['quantity'] ) ? $args['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock quantity must be a non-negative integer.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$warnings = array();
+		if ( ! $manage_stock && 'set' === $operation ) {
+			$warnings[] = 'Stock management is disabled for this product; quantity changes may not affect availability.';
+		}
+
+		$product_payload = $this->format_product( $product, true );
+
+		$draft_payload = array(
+			'product_id'         => $product_id,
+			'quantity'           => $quantity,
+			'operation'          => $operation,
+			'current_stock'      => $current_stock,
+			'new_stock'          => $new_stock,
+			'manage_stock'       => (bool) $manage_stock,
+			'backorders_allowed' => (bool) $backorders_allowed,
+			'product'            => $product_payload,
+			'warnings'           => $warnings,
+			'preview'            => array(
+				'name'          => isset( $product_payload['name'] ) ? $product_payload['name'] : '',
+				'sku'           => isset( $product_payload['sku'] ) ? $product_payload['sku'] : '',
+				'current_stock' => $current_stock,
+				'new_stock'     => $new_stock,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store stock update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft stock update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_stock_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_product' ) || ! function_exists( 'wc_update_product_stock' ) ) {
+			return Response::error( 'WooCommerce is required to update product stock.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing stock update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Stock update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for stock update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+
+		$product_id = isset( $payload['product_id'] ) ? absint( $payload['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Stock update draft is missing the product ID.', 400 );
+		}
+
+		$operation = isset( $payload['operation'] ) ? $this->normalize_operation( $payload['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Stock update draft has an invalid operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $payload['quantity'] ) ? $payload['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock update draft has an invalid quantity.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update confirmation.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$updated_stock = wc_update_product_stock( $product, $quantity, $operation );
+		if ( is_wp_error( $updated_stock ) ) {
+			return Response::error( $updated_stock->get_error_message(), 400 );
+		}
+		if ( false === $updated_stock ) {
+			return Response::error( 'Unable to update product stock.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		$refreshed = wc_get_product( $product_id );
+		$product_payload = $refreshed ? $this->format_product( $refreshed, true ) : array();
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'product_id'     => $product_id,
+				'previous_stock' => $current_stock,
+				'new_stock'      => is_numeric( $updated_stock ) ? intval( $updated_stock ) : $new_stock,
+				'manage_stock'   => (bool) $manage_stock,
+				'product'        => $product_payload,
+			)
+		);
+	}
+
+	/**
+	 * @param string $query Search string.
+	 * @param string $sku SKU search.
+	 * @return array
+	 */
+	private function find_products( $query, $sku ) {
+		$products = array();
+
+		$sku = trim( (string) $sku );
+		if ( '' !== $sku && function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $sku ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+				}
+			}
+
+			return $products;
+		}
+
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $products;
+		}
+
+		$maybe_id = absint( $query );
+		if ( $maybe_id > 0 ) {
+			$product = wc_get_product( $maybe_id );
+			if ( $product ) {
+				$products[] = $this->format_product( $product, true );
+				return $products;
+			}
+		}
+
+		if ( function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $query ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+					return $products;
+				}
+			}
+		}
+
+		if ( ! function_exists( 'get_posts' ) ) {
+			return $products;
+		}
+
+		$matches = get_posts(
+			array(
+				'post_type'      => array( 'product' ),
+				'post_status'    => array( 'publish', 'private' ),
+				's'              => $query,
+				'posts_per_page' => self::DEFAULT_LIMIT,
+				'fields'         => 'ids',
+			)
+		);
+
+		if ( ! is_array( $matches ) ) {
+			return $products;
+		}
+
+		foreach ( $matches as $product_id ) {
+			$product_id = absint( $product_id );
+			if ( 0 === $product_id ) {
+				continue;
+			}
+
+			$product = wc_get_product( $product_id );
+			if ( ! $product ) {
+				continue;
+			}
+
+			$products[] = $this->format_product( $product, true );
+		}
+
+		return $products;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @param bool  $include_variations Whether to include variations.
+	 * @return array
+	 */
+	private function format_product( $product, $include_variations = false ) {
+		if ( ! $product || ! method_exists( $product, 'get_id' ) ) {
+			return array();
+		}
+
+		$stock_quantity = method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null;
+		$sku            = method_exists( $product, 'get_sku' ) ? $product->get_sku() : '';
+		$stock_status   = method_exists( $product, 'get_stock_status' ) ? $product->get_stock_status() : '';
+
+		$payload = array(
+			'id'                 => intval( $product->get_id() ),
+			'name'               => sanitize_text_field( $this->get_product_name( $product ) ),
+			'sku'                => sanitize_text_field( (string) $sku ),
+			'current_stock'      => $this->normalize_stock_quantity( $stock_quantity ),
+			'stock_status'       => sanitize_text_field( (string) $stock_status ),
+			'manage_stock'       => method_exists( $product, 'managing_stock' ) ? (bool) $product->managing_stock() : false,
+			'backorders_allowed' => method_exists( $product, 'backorders_allowed' ) ? (bool) $product->backorders_allowed() : false,
+		);
+
+		if ( method_exists( $product, 'is_type' ) && $product->is_type( 'variation' ) && method_exists( $product, 'get_parent_id' ) ) {
+			$payload['parent_id'] = intval( $product->get_parent_id() );
+		}
+
+		if ( $include_variations && method_exists( $product, 'is_type' ) && $product->is_type( 'variable' ) ) {
+			$payload['variations'] = $this->format_variations( $product );
+		}
+
+		return $payload;
+	}
+
+	/**
+	 * @param mixed $product Variable product.
+	 * @return array
+	 */
+	private function format_variations( $product ) {
+		if ( ! $product || ! method_exists( $product, 'get_children' ) ) {
+			return array();
+		}
+
+		$variations = array();
+		$children   = $product->get_children();
+
+		if ( ! is_array( $children ) ) {
+			return $variations;
+		}
+
+		foreach ( $children as $variation_id ) {
+			$variation_id = absint( $variation_id );
+			if ( 0 === $variation_id ) {
+				continue;
+			}
+
+			$variation = wc_get_product( $variation_id );
+			if ( ! $variation ) {
+				continue;
+			}
+
+			$variations[] = $this->format_product( $variation, false );
+		}
+
+		return $variations;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @return string
+	 */
+	private function get_product_name( $product ) {
+		if ( method_exists( $product, 'get_formatted_name' ) ) {
+			return (string) $product->get_formatted_name();
+		}
+
+		if ( method_exists( $product, 'get_name' ) ) {
+			return (string) $product->get_name();
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int
+	 */
+	private function normalize_stock_quantity( $quantity ) {
+		if ( is_numeric( $quantity ) ) {
+			return intval( $quantity );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param mixed $operation Raw operation.
+	 * @return string
+	 */
+	private function normalize_operation( $operation ) {
+		$operation = is_string( $operation ) ? strtolower( trim( $operation ) ) : '';
+		$allowed   = array( 'set', 'increase', 'decrease' );
+
+		if ( in_array( $operation, $allowed, true ) ) {
+			return $operation;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int|null
+	 */
+	private function normalize_quantity( $quantity ) {
+		if ( null === $quantity || '' === $quantity ) {
+			return null;
+		}
+
+		if ( is_int( $quantity ) ) {
+			return $quantity >= 0 ? $quantity : null;
+		}
+
+		$validated = filter_var(
+			$quantity,
+			FILTER_VALIDATE_INT,
+			array(
+				'options' => array(
+					'min_range' => 0,
+				),
+			)
+		);
+
+		if ( false === $validated ) {
+			return null;
+		}
+
+		return intval( $validated );
+	}
+
+	/**
+	 * @param int    $current_stock Current stock.
+	 * @param int    $quantity Quantity.
+	 * @param string $operation Operation.
+	 * @return int
+	 */
+	private function calculate_new_stock( $current_stock, $quantity, $operation ) {
+		switch ( $operation ) {
+			case 'increase':
+				return $current_stock + $quantity;
+			case 'decrease':
+				return $current_stock - $quantity;
+			case 'set':
+			default:
+				return $quantity;
+		}
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}
diff --git a/src/Intent/Handlers/ProductStockHandler.php b/src/Intent/Handlers/ProductStockHandler.php
index f9fa36278962b3b0fcaf7863daa9f10077e5b33c..f4df63499e7b56d618f2a8c7037785de242fba6a
--- a/src/Intent/Handlers/ProductStockHandler.php
+++ b/src/Intent/Handlers/ProductStockHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\StockHandler;
 use AgentWP\Intent\Intent;
 
 class ProductStockHandler extends BaseHandler {
@@ -20,7 +21,31 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can check product stock. Share a product name or SKU.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		if ( '' === $query ) {
+			$message = 'I can check product stock. Share a product name or SKU.';
+			return $this->build_response( $context, $message );
+		}
+
+		$search = new StockHandler();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any products that match.'
+			: sprintf( 'Found %d product%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Confirming implementation details**
codex
Implemented stock search plus draft/confirm stock updates via a new stock handler, and wired product stock intents to surface live results.

Status: DONE
Summary of changes
- Added SKU/ID/name product search with variation payloads and stock update draft/confirm flow in `src/Handlers/StockHandler.php`.
- Updated product stock intent to call the stock handler and return matching products with counts in `src/Intent/Handlers/ProductStockHandler.php`.

How to verify
- No verification commands specified.

Risks / follow-ups
- Tests not run (no commands provided).
file update:
diff --git a/src/Handlers/StockHandler.php b/src/Handlers/StockHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..51c5b66eee70395d5b68066c14cae9ed90553d0a
--- /dev/null
+++ b/src/Handlers/StockHandler.php
@@ -0,0 +1,572 @@
+<?php
+/**
+ * Handle product stock searches and updates.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class StockHandler {
+	const DRAFT_TYPE    = 'stock_update';
+	const DEFAULT_LIMIT = 10;
+
+	/**
+	 * Handle stock-related requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['query'] ) || isset( $args['sku'] ) ) {
+			return $this->search_products( $args );
+		}
+
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_stock_update( $args['draft_id'] );
+		}
+
+		return $this->prepare_stock_update( $args );
+	}
+
+	/**
+	 * Search for products by name, SKU, or ID.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function search_products( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to search products.', 400 );
+		}
+
+		$query = isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '';
+		$sku   = isset( $args['sku'] ) ? sanitize_text_field( $args['sku'] ) : '';
+
+		if ( '' === $query && '' === $sku ) {
+			return Response::error( 'Missing product search query.', 400 );
+		}
+
+		$products = $this->find_products( $query, $sku );
+
+		return Response::success(
+			array(
+				'products' => $products,
+				'count'    => count( $products ),
+				'query'    => array(
+					'query' => $query,
+					'sku'   => $sku,
+				),
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft stock update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_stock_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_product' ) ) {
+			return Response::error( 'WooCommerce is required to prepare stock updates.', 400 );
+		}
+
+		$product_id = isset( $args['product_id'] ) ? absint( $args['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Missing product ID for stock update.', 400 );
+		}
+
+		$operation = isset( $args['operation'] ) ? $this->normalize_operation( $args['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Missing or invalid stock operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $args['quantity'] ) ? $args['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock quantity must be a non-negative integer.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$warnings = array();
+		if ( ! $manage_stock && 'set' === $operation ) {
+			$warnings[] = 'Stock management is disabled for this product; quantity changes may not affect availability.';
+		}
+
+		$product_payload = $this->format_product( $product, true );
+
+		$draft_payload = array(
+			'product_id'         => $product_id,
+			'quantity'           => $quantity,
+			'operation'          => $operation,
+			'current_stock'      => $current_stock,
+			'new_stock'          => $new_stock,
+			'manage_stock'       => (bool) $manage_stock,
+			'backorders_allowed' => (bool) $backorders_allowed,
+			'product'            => $product_payload,
+			'warnings'           => $warnings,
+			'preview'            => array(
+				'name'          => isset( $product_payload['name'] ) ? $product_payload['name'] : '',
+				'sku'           => isset( $product_payload['sku'] ) ? $product_payload['sku'] : '',
+				'current_stock' => $current_stock,
+				'new_stock'     => $new_stock,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store stock update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft stock update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_stock_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_product' ) || ! function_exists( 'wc_update_product_stock' ) ) {
+			return Response::error( 'WooCommerce is required to update product stock.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing stock update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Stock update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for stock update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+
+		$product_id = isset( $payload['product_id'] ) ? absint( $payload['product_id'] ) : 0;
+		if ( 0 === $product_id ) {
+			return Response::error( 'Stock update draft is missing the product ID.', 400 );
+		}
+
+		$operation = isset( $payload['operation'] ) ? $this->normalize_operation( $payload['operation'] ) : '';
+		if ( '' === $operation ) {
+			return Response::error( 'Stock update draft has an invalid operation.', 400 );
+		}
+
+		$quantity = $this->normalize_quantity( isset( $payload['quantity'] ) ? $payload['quantity'] : null );
+		if ( null === $quantity ) {
+			return Response::error( 'Stock update draft has an invalid quantity.', 400 );
+		}
+
+		$product = wc_get_product( $product_id );
+		if ( ! $product ) {
+			return Response::error( 'Product not found for stock update confirmation.', 404 );
+		}
+
+		$manage_stock      = method_exists( $product, 'managing_stock' ) ? $product->managing_stock() : false;
+		$backorders_allowed = method_exists( $product, 'backorders_allowed' ) ? $product->backorders_allowed() : false;
+		$current_stock     = $this->normalize_stock_quantity(
+			method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null
+		);
+		$new_stock = $this->calculate_new_stock( $current_stock, $quantity, $operation );
+
+		if ( 'decrease' === $operation && $new_stock < 0 && ! $backorders_allowed ) {
+			return Response::error( 'Cannot decrease stock below zero unless backorders are allowed.', 400 );
+		}
+
+		$updated_stock = wc_update_product_stock( $product, $quantity, $operation );
+		if ( is_wp_error( $updated_stock ) ) {
+			return Response::error( $updated_stock->get_error_message(), 400 );
+		}
+		if ( false === $updated_stock ) {
+			return Response::error( 'Unable to update product stock.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		$refreshed = wc_get_product( $product_id );
+		$product_payload = $refreshed ? $this->format_product( $refreshed, true ) : array();
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'product_id'     => $product_id,
+				'previous_stock' => $current_stock,
+				'new_stock'      => is_numeric( $updated_stock ) ? intval( $updated_stock ) : $new_stock,
+				'manage_stock'   => (bool) $manage_stock,
+				'product'        => $product_payload,
+			)
+		);
+	}
+
+	/**
+	 * @param string $query Search string.
+	 * @param string $sku SKU search.
+	 * @return array
+	 */
+	private function find_products( $query, $sku ) {
+		$products = array();
+
+		$sku = trim( (string) $sku );
+		if ( '' !== $sku && function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $sku ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+				}
+			}
+
+			return $products;
+		}
+
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $products;
+		}
+
+		$maybe_id = absint( $query );
+		if ( $maybe_id > 0 ) {
+			$product = wc_get_product( $maybe_id );
+			if ( $product ) {
+				$products[] = $this->format_product( $product, true );
+				return $products;
+			}
+		}
+
+		if ( function_exists( 'wc_get_product_id_by_sku' ) ) {
+			$product_id = absint( wc_get_product_id_by_sku( $query ) );
+			if ( $product_id > 0 ) {
+				$product = wc_get_product( $product_id );
+				if ( $product ) {
+					$products[] = $this->format_product( $product, true );
+					return $products;
+				}
+			}
+		}
+
+		if ( ! function_exists( 'get_posts' ) ) {
+			return $products;
+		}
+
+		$matches = get_posts(
+			array(
+				'post_type'      => array( 'product' ),
+				'post_status'    => array( 'publish', 'private' ),
+				's'              => $query,
+				'posts_per_page' => self::DEFAULT_LIMIT,
+				'fields'         => 'ids',
+			)
+		);
+
+		if ( ! is_array( $matches ) ) {
+			return $products;
+		}
+
+		foreach ( $matches as $product_id ) {
+			$product_id = absint( $product_id );
+			if ( 0 === $product_id ) {
+				continue;
+			}
+
+			$product = wc_get_product( $product_id );
+			if ( ! $product ) {
+				continue;
+			}
+
+			$products[] = $this->format_product( $product, true );
+		}
+
+		return $products;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @param bool  $include_variations Whether to include variations.
+	 * @return array
+	 */
+	private function format_product( $product, $include_variations = false ) {
+		if ( ! $product || ! method_exists( $product, 'get_id' ) ) {
+			return array();
+		}
+
+		$stock_quantity = method_exists( $product, 'get_stock_quantity' ) ? $product->get_stock_quantity() : null;
+		$sku            = method_exists( $product, 'get_sku' ) ? $product->get_sku() : '';
+		$stock_status   = method_exists( $product, 'get_stock_status' ) ? $product->get_stock_status() : '';
+
+		$payload = array(
+			'id'                 => intval( $product->get_id() ),
+			'name'               => sanitize_text_field( $this->get_product_name( $product ) ),
+			'sku'                => sanitize_text_field( (string) $sku ),
+			'current_stock'      => $this->normalize_stock_quantity( $stock_quantity ),
+			'stock_status'       => sanitize_text_field( (string) $stock_status ),
+			'manage_stock'       => method_exists( $product, 'managing_stock' ) ? (bool) $product->managing_stock() : false,
+			'backorders_allowed' => method_exists( $product, 'backorders_allowed' ) ? (bool) $product->backorders_allowed() : false,
+		);
+
+		if ( method_exists( $product, 'is_type' ) && $product->is_type( 'variation' ) && method_exists( $product, 'get_parent_id' ) ) {
+			$payload['parent_id'] = intval( $product->get_parent_id() );
+		}
+
+		if ( $include_variations && method_exists( $product, 'is_type' ) && $product->is_type( 'variable' ) ) {
+			$payload['variations'] = $this->format_variations( $product );
+		}
+
+		return $payload;
+	}
+
+	/**
+	 * @param mixed $product Variable product.
+	 * @return array
+	 */
+	private function format_variations( $product ) {
+		if ( ! $product || ! method_exists( $product, 'get_children' ) ) {
+			return array();
+		}
+
+		$variations = array();
+		$children   = $product->get_children();
+
+		if ( ! is_array( $children ) ) {
+			return $variations;
+		}
+
+		foreach ( $children as $variation_id ) {
+			$variation_id = absint( $variation_id );
+			if ( 0 === $variation_id ) {
+				continue;
+			}
+
+			$variation = wc_get_product( $variation_id );
+			if ( ! $variation ) {
+				continue;
+			}
+
+			$variations[] = $this->format_product( $variation, false );
+		}
+
+		return $variations;
+	}
+
+	/**
+	 * @param mixed $product Product instance.
+	 * @return string
+	 */
+	private function get_product_name( $product ) {
+		if ( method_exists( $product, 'get_formatted_name' ) ) {
+			return (string) $product->get_formatted_name();
+		}
+
+		if ( method_exists( $product, 'get_name' ) ) {
+			return (string) $product->get_name();
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int
+	 */
+	private function normalize_stock_quantity( $quantity ) {
+		if ( is_numeric( $quantity ) ) {
+			return intval( $quantity );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param mixed $operation Raw operation.
+	 * @return string
+	 */
+	private function normalize_operation( $operation ) {
+		$operation = is_string( $operation ) ? strtolower( trim( $operation ) ) : '';
+		$allowed   = array( 'set', 'increase', 'decrease' );
+
+		if ( in_array( $operation, $allowed, true ) ) {
+			return $operation;
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $quantity Raw quantity.
+	 * @return int|null
+	 */
+	private function normalize_quantity( $quantity ) {
+		if ( null === $quantity || '' === $quantity ) {
+			return null;
+		}
+
+		if ( is_int( $quantity ) ) {
+			return $quantity >= 0 ? $quantity : null;
+		}
+
+		$validated = filter_var(
+			$quantity,
+			FILTER_VALIDATE_INT,
+			array(
+				'options' => array(
+					'min_range' => 0,
+				),
+			)
+		);
+
+		if ( false === $validated ) {
+			return null;
+		}
+
+		return intval( $validated );
+	}
+
+	/**
+	 * @param int    $current_stock Current stock.
+	 * @param int    $quantity Quantity.
+	 * @param string $operation Operation.
+	 * @return int
+	 */
+	private function calculate_new_stock( $current_stock, $quantity, $operation ) {
+		switch ( $operation ) {
+			case 'increase':
+				return $current_stock + $quantity;
+			case 'decrease':
+				return $current_stock - $quantity;
+			case 'set':
+			default:
+				return $quantity;
+		}
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}
diff --git a/src/Intent/Handlers/ProductStockHandler.php b/src/Intent/Handlers/ProductStockHandler.php
index f9fa36278962b3b0fcaf7863daa9f10077e5b33c..f4df63499e7b56d618f2a8c7037785de242fba6a
--- a/src/Intent/Handlers/ProductStockHandler.php
+++ b/src/Intent/Handlers/ProductStockHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\StockHandler;
 use AgentWP\Intent\Intent;
 
 class ProductStockHandler extends BaseHandler {
@@ -20,7 +21,31 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can check product stock. Share a product name or SKU.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		if ( '' === $query ) {
+			$message = 'I can check product stock. Share a product name or SKU.';
+			return $this->build_response( $context, $message );
+		}
+
+		$search = new StockHandler();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any products that match.'
+			: sprintf( 'Found %d product%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }

tokens used
122,719
