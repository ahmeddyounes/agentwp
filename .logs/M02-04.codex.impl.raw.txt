Implemented a full order status draft/confirm handler so updates are validated, previewed, and only applied after explicit confirmation.

Summary of changes:
- Added `src/Handlers/OrderStatusHandler.php` to prepare single and bulk status update drafts with previews, irreversible-change warnings, and a 50-order cap.
- Confirm flow applies WooCommerce status updates, writes `[AgentWP]` audit notes, and suppresses emails when `notify_customer` is false.
- Drafts are stored in transients with the configured TTL and reject invalid statuses or no-op transitions.

Status: DONE

How to verify:
- (no commands provided)

Risks / follow-ups:
- Confirmation still requires a caller (tool/REST wiring) to invoke `confirm_status_update` with a `draft_id` if that plumbing isn’t already in place.

OpenAI Codex v0.77.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/agentwp
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019b94ec-c611-7dc1-bd86-8173d7135473
--------
user
You are implementing task M02-04 in this git repository.

1) Read the spec: .plans/M02-04.md
2) Read handoff/context: .t2/handoff/M02-04.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: 
- test: 

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers

thinking
**Considering how to read files**
exec
/bin/zsh -lc ls in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 183ms:
agentwp.php
assets
composer.json
docker
docker-compose.yml
docs
includes
languages
react
README.md
scripts
setup.sh
src
tasks.csv
uninstall.php

thinking
**Checking for instructions files**
exec
/bin/zsh -lc 'cat .plans/M02-04.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
# M02-04 — Order Status Updates

Implement order status change functionality: 1) Create AgentWP\Handlers\OrderStatusHandler class. 2) OpenAI function schema: prepare_status_update(order_id: int, new_status: string, note?: string, notify_customer?: bool). 3) Valid statuses from wc_get_order_statuses(): pending, processing, on-hold, completed, cancelled, refunded, failed. 4) Draft-Confirm protocol: return preview showing current_status → new_status with warning for irreversible changes (cancelled, refunded). 5) Support bulk updates: prepare_bulk_status_update(order_ids: int[], new_status: string). 6) Add order note with '[AgentWP]' prefix for audit trail. 7) Trigger WooCommerce status change hooks for email notifications. Acceptance Criteria: Status only changes after confirmation, customer notification respects notify_customer flag, bulk updates handle up to 50 orders, invalid status transitions rejected with explanation.

thinking
**Reviewing handoff**
exec
/bin/zsh -lc 'cat .t2/handoff/M02-04.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
# Handoff: M02-04

Created: 2026-01-06T20:08:23.784400Z

Spec: .plans/M02-04.md

thinking
**Searching for existing handlers**
exec
/bin/zsh -lc "rg --files -g '*Handler*.php' -g '*handler*.php'" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 46ms:
src/Handlers/RefundHandler.php
src/Handlers/OrderSearchHandler.php
src/Intent/Handlers/FallbackHandler.php
src/Intent/Handlers/CustomerLookupHandler.php
src/Intent/Handlers/OrderRefundHandler.php
src/Intent/Handlers/ProductStockHandler.php
src/Intent/Handlers/BaseHandler.php
src/Intent/Handlers/OrderSearchHandler.php
src/Intent/Handlers/EmailDraftHandler.php
src/Intent/Handlers/OrderStatusHandler.php
src/Intent/Handlers/AnalyticsQueryHandler.php
src/Intent/Handler.php

thinking
**Inspecting existing OrderStatusHandler**
exec
/bin/zsh -lc "sed -n '1,200p' src/Handlers/RefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 39ms:
<?php
/**
 * Handle refund draft preparation and confirmation.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;

class RefundHandler {
	const DRAFT_TYPE = 'refund';

	/**
	 * Handle refund-related requests.
	 *
	 * @param array $args Request args.
	 * @return Response

thinking
**Checking for order status handler**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/OrderStatusHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
<?php
/**
 * Handle order status intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Intent;

class OrderStatusHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_STATUS );
	}

	/**
	 * @param array $context Context data.
	 * @return Response

thinking
**Inspecting handler patterns**
exec
/bin/zsh -lc 'ls src/Handlers' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 32ms:
OrderSearchHandler.php
RefundHandler.php

thinking
**Opening OrderSearchHandler**
exec
/bin/zsh -lc "sed -n '1,240p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 45ms:
<?php
/**
 * Handle order search requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;
use DateTimeImmutable;
use DateTimeZone;
use Exception;

class OrderSearchHandler {
	const DEFAULT_LIMIT = 10;
	const CACHE_TTL     = 3600;

	/**

thinking
**Searching for function schema definitions**
exec
/bin/zsh -lc 'rg -n "prepare_refund|refund" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/Handlers/RefundHandler.php:3: * Handle refund draft preparation and confirmation.
src/Handlers/RefundHandler.php:14:	const DRAFT_TYPE = 'refund';
src/Handlers/RefundHandler.php:17:	 * Handle refund-related requests.
src/Handlers/RefundHandler.php:24:			return $this->confirm_refund( $args['draft_id'] );
src/Handlers/RefundHandler.php:27:		return $this->prepare_refund( $args );
src/Handlers/RefundHandler.php:31:	 * Prepare a refund draft without executing it.
src/Handlers/RefundHandler.php:36:	public function prepare_refund( array $args ): Response {
src/Handlers/RefundHandler.php:38:			return Response::error( 'WooCommerce is required to prepare refunds.', 400 );
src/Handlers/RefundHandler.php:43:			return Response::error( 'Missing order ID for refund.', 400 );
src/Handlers/RefundHandler.php:48:			return Response::error( 'Order not found for refund.', 404 );
src/Handlers/RefundHandler.php:57:		$total_refunded = $this->normalize_amount( $order->get_total_refunded() );
src/Handlers/RefundHandler.php:58:		$remaining      = max( 0, $this->normalize_amount( $order_total - $total_refunded ) );
src/Handlers/RefundHandler.php:61:			return Response::error( 'Order has no refundable balance.', 400 );
src/Handlers/RefundHandler.php:73:			$refund_amount = $this->is_full_refund( $amount_input, $remaining ) ? $remaining : $amount_input;
src/Handlers/RefundHandler.php:75:			$refund_amount = $remaining;
src/Handlers/RefundHandler.php:78:		$is_full_refund   = $this->is_full_refund( $refund_amount, $remaining );
src/Handlers/RefundHandler.php:79:		$items_to_restock = ( $restock_items && $is_full_refund ) ? $this->build_items_to_restock( $order ) : array();
src/Handlers/RefundHandler.php:83:		$requires_manual_refund = $this->requires_manual_refund( $gateway );
src/Handlers/RefundHandler.php:88:			'refund_amount'          => $refund_amount,
src/Handlers/RefundHandler.php:93:			'requires_manual_refund' => $requires_manual_refund,

thinking
**Checking existing status update function**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/PrepareStatusUpdate.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Function schema for order status updates.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class PrepareStatusUpdate extends AbstractFunction {
	public function get_name() {
		return 'prepare_status_update';
	}

	public function get_description() {
		return 'Prepare a draft order status update without applying it.';
	}

	public function get_parameters() {
		return array(

thinking
**Checking for existing BulkStatusUpdate**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/PrepareBulkStatusUpdate.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Function schema for bulk order status updates.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class PrepareBulkStatusUpdate extends AbstractFunction {
	public function get_name() {
		return 'prepare_bulk_status_update';
	}

	public function get_description() {
		return 'Prepare a draft bulk status update for multiple orders.';
	}

	public function get_parameters() {
		return array(

thinking
**Verifying existing schema and searching handlers**
exec
/bin/zsh -lc 'rg -n "status_update" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/AI/Functions/PrepareBulkStatusUpdate.php:12:		return 'prepare_bulk_status_update';
src/AI/Functions/PrepareStatusUpdate.php:12:		return 'prepare_status_update';
src/Intent/Engine.php:178:			Intent::ORDER_STATUS    => array( 'prepare_status_update', 'prepare_bulk_status_update', 'bulk_update' ),

thinking
**Checking Engine mapping**
exec
/bin/zsh -lc "sed -n '1,260p' src/Intent/Engine.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 32ms:
<?php
/**
 * Intent engine for routing requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

use AgentWP\AI\Response;
use AgentWP\Intent\Handlers\AnalyticsQueryHandler;
use AgentWP\Intent\Handlers\CustomerLookupHandler;
use AgentWP\Intent\Handlers\EmailDraftHandler;
use AgentWP\Intent\Handlers\FallbackHandler;
use AgentWP\Intent\Handlers\OrderRefundHandler;
use AgentWP\Intent\Handlers\OrderSearchHandler;
use AgentWP\Intent\Handlers\OrderStatusHandler;
use AgentWP\Intent\Handlers\ProductStockHandler;

class Engine {

thinking
**Investigating handler interface and function mapping**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Intent handler contract.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

use AgentWP\AI\Response;

interface Handler {
	/**
	 * @param string $intent Intent identifier.
	 * @return bool
	 */
	public function canHandle( string $intent ): bool;

	/**
	 * @param array $context Enriched request context.

thinking
**Locating refund function handlers**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/FunctionRegistry.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
<?php
/**
 * OpenAI function registry for intent handlers.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

class FunctionRegistry {
	/**
	 * @var array<string, Handler>
	 */
	private $map = array();

	/**
	 * @param string  $function_name OpenAI function name.
	 * @param Handler $handler Handler instance.
	 * @return void
	 */

thinking
**Searching for function dispatch**
exec
/bin/zsh -lc 'rg -n "function" src/AI src/Intent src/includes' in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 54ms:
rg: src/includes: No such file or directory (os error 2)
src/Intent/IntentClassifier.php:16:	public function classify( $input, array $context = array() ) {
src/Intent/IntentClassifier.php:56:	private function score_refund( $text ) {
src/Intent/IntentClassifier.php:73:	private function score_status( $text ) {
src/Intent/IntentClassifier.php:93:	private function score_stock( $text ) {
src/Intent/IntentClassifier.php:111:	private function score_email( $text ) {
src/Intent/IntentClassifier.php:134:	private function score_analytics( $text ) {
src/Intent/IntentClassifier.php:154:	private function score_customer( $text ) {
src/Intent/IntentClassifier.php:171:	private function score_search( $text ) {
src/Intent/IntentClassifier.php:191:	private function match_score( $text, array $phrases ) {
src/Intent/IntentClassifier.php:207:	private function contains_phrase( $text, $phrase ) {
src/AI/Functions/GetSalesReport.php:11:	public function get_name() {
src/AI/Functions/GetSalesReport.php:15:	public function get_description() {
src/AI/Functions/GetSalesReport.php:19:	public function get_parameters() {
src/AI/Functions/SearchOrders.php:11:	public function get_name() {
src/AI/Functions/SearchOrders.php:15:	public function get_description() {
src/AI/Functions/SearchOrders.php:19:	public function get_parameters() {
src/Intent/Handlers/FallbackHandler.php:14:	public function __construct() {
src/Intent/Handlers/FallbackHandler.php:22:	public function handle( array $context ): Response {
src/AI/Functions/PrepareBulkStatusUpdate.php:11:	public function get_name() {

thinking
**Checking for status update handler**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/BulkUpdate.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Function schema for executing bulk order actions.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class BulkUpdate extends AbstractFunction {
	public function get_name() {
		return 'bulk_update';
	}

	public function get_description() {
		return 'Apply a bulk action to a list of order IDs.';
	}

	public function get_parameters() {
		return array(

thinking
**Searching for bulk update handlers**
exec
/bin/zsh -lc 'rg -n "bulk_update" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/AI/Functions/BulkUpdate.php:12:		return 'bulk_update';
src/Intent/Engine.php:178:			Intent::ORDER_STATUS    => array( 'prepare_status_update', 'prepare_bulk_status_update', 'bulk_update' ),

thinking
**Identifying missing handler for bulk_update**
exec
/bin/zsh -lc 'rg -n "tool" src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
src/AI/Functions/FunctionSchema.php:29:	public function to_tool_definition();
src/AI/Functions/AbstractFunction.php:3: * Base class for tool definitions.
src/AI/Functions/AbstractFunction.php:14:	public function to_tool_definition() {
src/AI/TokenCounter.php:20:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:24:	public function count_request_tokens( array $messages, array $tools, $model ) {
src/AI/TokenCounter.php:28:			+ $this->count_tool_tokens( $tools, $model );
src/AI/TokenCounter.php:67:	 * Count tokens for tool definitions.
src/AI/TokenCounter.php:69:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:73:	public function count_tool_tokens( array $tools, $model ) {
src/AI/TokenCounter.php:74:		if ( empty( $tools ) ) {
src/AI/TokenCounter.php:78:		$payload = wp_json_encode( $tools );
src/AI/OpenAIClient.php:99:		$tools = $this->normalize_tools( $functions );
src/AI/OpenAIClient.php:106:		if ( ! empty( $tools ) ) {
src/AI/OpenAIClient.php:107:			$payload['tools']       = $tools;
src/AI/OpenAIClient.php:108:			$payload['tool_choice'] = 'auto';
src/AI/OpenAIClient.php:116:		$input_tokens = $this->token_counter->count_request_tokens( $messages, $tools, $this->model );
src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:296:	private function normalize_tools( array $functions ) {
src/AI/OpenAIClient.php:297:		$tools = array();
src/AI/OpenAIClient.php:301:				$tools[] = $function->to_tool_definition();

thinking
**Searching for tool call executions**
exec
/bin/zsh -lc 'rg -n "tool_calls|function_call" src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:389:				'tool_calls' => array(),
src/AI/OpenAIClient.php:400:		$tool_calls = isset( $message['tool_calls'] ) && is_array( $message['tool_calls'] ) ? $message['tool_calls'] : array();
src/AI/OpenAIClient.php:402:		if ( empty( $tool_calls ) && isset( $message['function_call'] ) && is_array( $message['function_call'] ) ) {
src/AI/OpenAIClient.php:403:			$tool_calls = array(
src/AI/OpenAIClient.php:407:					'function' => $message['function_call'],
src/AI/OpenAIClient.php:416:			'tool_calls' => $tool_calls,
src/AI/OpenAIClient.php:430:		$tool_calls = array();
src/AI/OpenAIClient.php:476:			if ( isset( $delta['tool_calls'] ) && is_array( $delta['tool_calls'] ) ) {
src/AI/OpenAIClient.php:477:				$tool_calls = $this->merge_tool_call_deltas( $tool_calls, $delta['tool_calls'] );
src/AI/OpenAIClient.php:480:			if ( isset( $delta['function_call'] ) && is_array( $delta['function_call'] ) ) {
src/AI/OpenAIClient.php:481:				$tool_calls = $this->merge_tool_call_deltas(
src/AI/OpenAIClient.php:482:					$tool_calls,
src/AI/OpenAIClient.php:487:							'function' => $delta['function_call'],
src/AI/OpenAIClient.php:498:			'tool_calls' => array_values( $tool_calls ),
src/AI/OpenAIClient.php:506:	 * @param array $tool_calls Existing tool calls.
src/AI/OpenAIClient.php:510:	private function merge_tool_call_deltas( array $tool_calls, array $deltas ) {
src/AI/OpenAIClient.php:514:			if ( ! isset( $tool_calls[ $index ] ) ) {
src/AI/OpenAIClient.php:515:				$tool_calls[ $index ] = array(
src/AI/OpenAIClient.php:526:				$tool_calls[ $index ]['id'] = $delta['id'];

thinking
**Searching for function call usage**
exec
/bin/zsh -lc 'rg -n "function_registry|tool" src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
src/Intent/Engine.php:39:	private $function_registry;
src/Intent/Engine.php:53:	 * @param FunctionRegistry|null $function_registry Optional registry.
src/Intent/Engine.php:60:		FunctionRegistry $function_registry = null,
src/Intent/Engine.php:68:		$this->function_registry = $function_registry ? $function_registry : new FunctionRegistry();
src/Intent/Engine.php:94:		$enriched['function_suggestions'] = $this->function_registry->get_functions_for_intent( $enriched['intent'] );
src/Intent/Engine.php:114:	public function get_function_registry() {
src/Intent/Engine.php:115:		return $this->function_registry;
src/Intent/Engine.php:192:				$this->function_registry->register( $function_name, $handler );
src/AI/Functions/FunctionSchema.php:29:	public function to_tool_definition();
src/AI/Functions/AbstractFunction.php:3: * Base class for tool definitions.
src/AI/Functions/AbstractFunction.php:14:	public function to_tool_definition() {
src/AI/TokenCounter.php:20:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:24:	public function count_request_tokens( array $messages, array $tools, $model ) {
src/AI/TokenCounter.php:28:			+ $this->count_tool_tokens( $tools, $model );
src/AI/TokenCounter.php:67:	 * Count tokens for tool definitions.
src/AI/TokenCounter.php:69:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:73:	public function count_tool_tokens( array $tools, $model ) {
src/AI/TokenCounter.php:74:		if ( empty( $tools ) ) {
src/AI/TokenCounter.php:78:		$payload = wp_json_encode( $tools );
src/AI/OpenAIClient.php:99:		$tools = $this->normalize_tools( $functions );

thinking
**Searching for tool call handling**
exec
/bin/zsh -lc 'ls includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
index.php

thinking
**Searching for function execution code**
exec
/bin/zsh -lc 'rg -n "function_registry|get_handler|tool_calls" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:389:				'tool_calls' => array(),
src/AI/OpenAIClient.php:400:		$tool_calls = isset( $message['tool_calls'] ) && is_array( $message['tool_calls'] ) ? $message['tool_calls'] : array();
src/AI/OpenAIClient.php:402:		if ( empty( $tool_calls ) && isset( $message['function_call'] ) && is_array( $message['function_call'] ) ) {
src/AI/OpenAIClient.php:403:			$tool_calls = array(
src/AI/OpenAIClient.php:416:			'tool_calls' => $tool_calls,
src/AI/OpenAIClient.php:430:		$tool_calls = array();
src/AI/OpenAIClient.php:476:			if ( isset( $delta['tool_calls'] ) && is_array( $delta['tool_calls'] ) ) {
src/AI/OpenAIClient.php:477:				$tool_calls = $this->merge_tool_call_deltas( $tool_calls, $delta['tool_calls'] );
src/AI/OpenAIClient.php:481:				$tool_calls = $this->merge_tool_call_deltas(
src/AI/OpenAIClient.php:482:					$tool_calls,
src/AI/OpenAIClient.php:498:			'tool_calls' => array_values( $tool_calls ),
src/AI/OpenAIClient.php:506:	 * @param array $tool_calls Existing tool calls.
src/AI/OpenAIClient.php:510:	private function merge_tool_call_deltas( array $tool_calls, array $deltas ) {
src/AI/OpenAIClient.php:514:			if ( ! isset( $tool_calls[ $index ] ) ) {
src/AI/OpenAIClient.php:515:				$tool_calls[ $index ] = array(
src/AI/OpenAIClient.php:526:				$tool_calls[ $index ]['id'] = $delta['id'];
src/AI/OpenAIClient.php:530:				$tool_calls[ $index ]['type'] = $delta['type'];
src/AI/OpenAIClient.php:535:					$tool_calls[ $index ]['function']['name'] = $delta['function']['name'];
src/AI/OpenAIClient.php:539:					$tool_calls[ $index ]['function']['arguments'] .= $delta['function']['arguments'];

thinking
**Inspecting plugin source for tool calls**
exec
/bin/zsh -lc "sed -n '1,220p' src/Plugin.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Core plugin bootstrap.
 *
 * @package AgentWP
 */

namespace AgentWP;

class Plugin {
	const OPTION_SETTINGS     = 'agentwp_settings';
	const OPTION_API_KEY      = 'agentwp_api_key';
	const OPTION_API_KEY_LAST4 = 'agentwp_api_key_last4';
	const OPTION_BUDGET_LIMIT = 'agentwp_budget_limit';
	const OPTION_DRAFT_TTL    = 'agentwp_draft_ttl_minutes';
	const OPTION_USAGE_STATS  = 'agentwp_usage_stats';
	const TRANSIENT_PREFIX    = 'agentwp_';

	/**
	 * @var Plugin|null

thinking
**Searching for REST controller handling tool calls**
exec
/bin/zsh -lc "sed -n '1,260p' src/Rest/IntentController.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Intent REST controller.
 *
 * @package AgentWP
 */

namespace AgentWP\Rest;

use AgentWP\API\RestController;
use AgentWP\Intent\Engine;
use WP_REST_Server;

class IntentController extends RestController {
	/**
	 * Register REST routes.
	 *
	 * @return void
	 */
	public function register_routes() {

thinking
**Searching for function invocation controller**
exec
/bin/zsh -lc 'ls src/Rest' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 44ms:
HealthController.php
IntentController.php
SettingsController.php

thinking
**Searching for API endpoints**
exec
/bin/zsh -lc 'ls src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
AI
API
Handlers
index.php
Intent
Plugin.php
Rest
Security

thinking
**Noticing API directory**
exec
/bin/zsh -lc 'ls src/API' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 32ms:
RestController.php

thinking
**Checking AI directory contents**
exec
/bin/zsh -lc 'ls src/AI' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 45ms:
Functions
Model.php
OpenAIClient.php
Response.php
TokenCounter.php

thinking
**Searching for confirm_refund usage**
exec
/bin/zsh -lc 'rg -n "confirm_refund|prepare_refund|prepare_status_update" -S .' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
./src/Handlers/RefundHandler.php:24:			return $this->confirm_refund( $args['draft_id'] );
./src/Handlers/RefundHandler.php:27:		return $this->prepare_refund( $args );
./src/Handlers/RefundHandler.php:36:	public function prepare_refund( array $args ): Response {
./src/Handlers/RefundHandler.php:129:	public function confirm_refund( $draft_id ): Response {
./src/AI/Functions/ConfirmRefund.php:12:		return 'confirm_refund';
./src/AI/Functions/PrepareRefund.php:12:		return 'prepare_refund';
./src/AI/Functions/PrepareStatusUpdate.php:12:		return 'prepare_status_update';
./src/Intent/Engine.php:177:			Intent::ORDER_REFUND    => array( 'prepare_refund', 'confirm_refund' ),
./src/Intent/Engine.php:178:			Intent::ORDER_STATUS    => array( 'prepare_status_update', 'prepare_bulk_status_update', 'bulk_update' ),
./tasks.csv:13:M02-03,"Refund Processing - Draft Mode","Implement the refund workflow with Draft-Confirm protocol: 1) Create AgentWP\Handlers\RefundHandler class. 2) OpenAI function schema: prepare_refund(order_id: int, amount?: float, reason?: string, restock_items?: bool). 3) NEVER execute refund on first call - return draft object only. 4) Draft object contains: order_id, order_total, refund_amount, reason, items_to_restock, customer_email, payment_method, requires_manual_refund (bool). 5) Create separate confirm_refund(draft_id: string) function that executes wc_create_refund(). 6) Generate unique draft_id, store in transient with 10-minute expiry. 7) Handle partial refunds, full refunds, and refund+restock scenarios. 8) After confirmation, optionally trigger customer notification email. Acceptance Criteria: No refund ever processed without explicit confirm_refund call, draft expires after 10 minutes, partial refund calculates correctly, payment gateway refund triggered for supported gateways, audit log entry created."
./tasks.csv:14:M02-04,"Order Status Updates","Implement order status change functionality: 1) Create AgentWP\Handlers\OrderStatusHandler class. 2) OpenAI function schema: prepare_status_update(order_id: int, new_status: string, note?: string, notify_customer?: bool). 3) Valid statuses from wc_get_order_statuses(): pending, processing, on-hold, completed, cancelled, refunded, failed. 4) Draft-Confirm protocol: return preview showing current_status → new_status with warning for irreversible changes (cancelled, refunded). 5) Support bulk updates: prepare_bulk_status_update(order_ids: int[], new_status: string). 6) Add order note with '[AgentWP]' prefix for audit trail. 7) Trigger WooCommerce status change hooks for email notifications. Acceptance Criteria: Status only changes after confirmation, customer notification respects notify_customer flag, bulk updates handle up to 50 orders, invalid status transitions rejected with explanation."

thinking
**Searching for handler usage in API or actions**
exec
/bin/zsh -lc "rg -n \"handle\\( array \\"'$args" src/Handlers src/Intent' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 53ms:


thinking
**Investigating refund handler usage**
exec
/bin/zsh -lc 'rg -n "RefundHandler" -S .' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 59ms:
./src/Handlers/RefundHandler.php:13:class RefundHandler {
./src/Intent/Handlers/OrderRefundHandler.php:13:class OrderRefundHandler extends BaseHandler {
./src/Intent/Engine.php:15:use AgentWP\Intent\Handlers\OrderRefundHandler;
./src/Intent/Engine.php:131:			new OrderRefundHandler(),
./tasks.csv:13:M02-03,"Refund Processing - Draft Mode","Implement the refund workflow with Draft-Confirm protocol: 1) Create AgentWP\Handlers\RefundHandler class. 2) OpenAI function schema: prepare_refund(order_id: int, amount?: float, reason?: string, restock_items?: bool). 3) NEVER execute refund on first call - return draft object only. 4) Draft object contains: order_id, order_total, refund_amount, reason, items_to_restock, customer_email, payment_method, requires_manual_refund (bool). 5) Create separate confirm_refund(draft_id: string) function that executes wc_create_refund(). 6) Generate unique draft_id, store in transient with 10-minute expiry. 7) Handle partial refunds, full refunds, and refund+restock scenarios. 8) After confirmation, optionally trigger customer notification email. Acceptance Criteria: No refund ever processed without explicit confirm_refund call, draft expires after 10 minutes, partial refund calculates correctly, payment gateway refund triggered for supported gateways, audit log entry created."

thinking
**Checking RefundHandler usage**
exec
/bin/zsh -lc 'rg -n "prepare_refund|confirm_refund|prepare_status_update" react assets' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 54ms:


thinking
**Analyzing order status update workflow**
exec
/bin/zsh -lc "rg -n \"Handlers\\\\\" src" in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 44ms:
rg: regex parse error:
    (?:Handlers\)
    ^
error: unclosed group

thinking
**Correcting search query syntax**
exec
/bin/zsh -lc "rg -n \"AgentWP\\\\Handlers\" -S src" in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 48ms:
rg: regex parse error:
    (?:AgentWP\Handlers)
              ^^
error: unrecognized escape sequence

thinking
**Preparing regex search with escaped backslash**
exec
/bin/zsh -lc "rg -n -F \"AgentWP\\\\Handlers\" src" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 43ms:
src/Handlers/RefundHandler.php:8:namespace AgentWP\Handlers;
src/Handlers/OrderSearchHandler.php:8:namespace AgentWP\Handlers;
src/Intent/Handlers/OrderSearchHandler.php:11:use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;

thinking
**Examining Intent handler linkage**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 36ms:
<?php
/**
 * Handle order search intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
use AgentWP\Intent\Intent;

class OrderSearchHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_SEARCH );
	}

	/**
	 * @param array $context Context data.

thinking
**Planning new OrderStatusHandler integration**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/OrderRefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * Handle order refund intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Intent;

class OrderRefundHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_REFUND );
	}

	/**
	 * @param array $context Context data.
	 * @return Response

thinking
**Investigating function call implementation**
exec
/bin/zsh -lc 'rg -n "function" react' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
react/src/App.jsx:64:  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
react/src/App.jsx:79:export default function App() {
react/src/App.jsx:151:    if (lastActive && typeof lastActive.focus === 'function') {

thinking
**Analyzing handler implementation patterns**
exec
/bin/zsh -lc "sed -n '1,40p' tasks.csv" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
id,title,spec
M00-01,"Technical Architecture Document","Create a comprehensive technical architecture document in Markdown format covering: 1) System overview diagram showing WordPress plugin structure, React frontend, PHP backend, and OpenAI API integration. 2) Database schema using only standard WooCommerce tables plus wp_options for settings (no custom tables). 3) REST API endpoint specification for /wp-json/agentwp/v1/* routes. 4) Security architecture for BYOK (Bring Your Own Key) with AES-256 encryption. 5) Data flow diagrams for the Draft-Confirm protocol. 6) Component hierarchy for React Command Deck. Save to /docs/ARCHITECTURE.md. Acceptance Criteria: Document covers all major subsystems, includes Mermaid diagrams, specifies all API endpoints with request/response schemas, and passes technical review."
M00-02,"Docker Development Environment","Create Docker-based development environment with docker-compose.yml including: 1) WordPress container with PHP 8.1+ and WooCommerce 8.x pre-installed. 2) MySQL 8.0 container with persistent volume. 3) Node.js container for React build tooling. 4) Mailhog for email testing. 5) Volume mounts for live code reloading. Include .env.example with all configuration variables. Create setup script (setup.sh) that initializes WooCommerce with sample data. Acceptance Criteria: Running 'docker-compose up' creates fully functional dev environment within 5 minutes, hot reloading works for both PHP and React, sample store has 50+ products and 100+ orders."
M00-03,"CI/CD Pipeline Configuration","Create GitHub Actions workflows in .github/workflows/ for: 1) ci.yml - runs on PR: PHP linting (PHPCS with WordPress standards), PHPUnit tests, Jest tests, ESLint, build verification. 2) release.yml - runs on tag: builds production assets, creates CodeCanyon-ready ZIP, generates changelog from commits. 3) security.yml - runs weekly: dependency vulnerability scanning with Composer audit and npm audit. Include branch protection rules documentation. Acceptance Criteria: CI blocks merges on test failures, release workflow produces valid plugin ZIP under 10MB, security scans report to GitHub Security tab."
M01-01,"WordPress Plugin Scaffold","Create the core plugin file structure following WordPress coding standards: 1) Main plugin file (agentwp.php) with proper headers, activation/deactivation hooks, and autoloader. 2) PSR-4 autoloading via Composer for /src directory. 3) Namespace: AgentWP\*. 4) Directory structure: /src (PHP classes), /assets (compiled JS/CSS), /react (source), /includes (legacy compatibility), /languages (i18n). 5) Activation hook creates default options, deactivation cleans transients, uninstall.php removes all data. 6) Admin menu registration under WooCommerce menu. 7) Enqueue scripts only on plugin pages and WooCommerce screens. Acceptance Criteria: Plugin activates without errors on WordPress 6.4+ with WooCommerce 8.0+, passes WordPress Plugin Check, no PHP notices/warnings."
M01-02,"Settings Page - React Interface","Build React-based settings page using @wordpress/scripts and @wordpress/components: 1) Settings sections: API Configuration, Model Selection, Interface Preferences, Usage Statistics. 2) API Key input field with masked display (show last 4 chars only), validation button that tests key against OpenAI API. 3) Model dropdown: gpt-4o (recommended), gpt-4o-mini (budget). 4) Hotkey configuration (default Cmd+K / Ctrl+K). 5) Toggle for dark/light mode default. 6) Usage stats display: total commands this month, estimated cost, last sync time. 7) Export/Import settings as JSON. 8) Save button with optimistic updates via @wordpress/api-fetch. Acceptance Criteria: Settings persist across page reloads, API key validation provides clear success/error feedback within 3 seconds, all settings accessible via REST API."
M01-03,"API Key Encryption System","Implement secure API key storage in PHP: 1) Create AgentWP\Security\Encryption class using AES-256-CTR with WordPress salts (LOGGED_IN_KEY and LOGGED_IN_SALT) as encryption materials. 2) Methods: encrypt(string $plaintext): string, decrypt(string $ciphertext): string, isEncrypted(string $data): bool. 3) Store encrypted key in wp_options table under 'agentwp_api_key'. 4) Create REST endpoint POST /agentwp/v1/settings/api-key that validates key format (sk-*), tests against OpenAI /v1/models endpoint, encrypts and stores on success. 5) Never log or expose plaintext keys. 6) Add key rotation support (re-encrypt with new salts). Acceptance Criteria: Stored key is unreadable without WordPress salts, key validation catches invalid/expired keys, encryption/decryption round-trips correctly, no plaintext keys in logs or database queries."
M01-04,"REST API Framework","Build the REST API infrastructure in PHP: 1) Create AgentWP\API\RestController base class extending WP_REST_Controller with common auth, validation, and response formatting. 2) Register namespace 'agentwp/v1'. 3) Implement permission callbacks using current_user_can('manage_woocommerce'). 4) Create rate limiter using transients: 60 requests/minute per user, return 429 with Retry-After header when exceeded. 5) Endpoints to create: POST /intent (main AI endpoint), GET/POST /settings, GET /usage, GET /health. 6) Request validation with JSON schemas. 7) Standardized response format: {success: bool, data: any, error?: {code: string, message: string}}. 8) Add request logging for debugging (stored in transients, auto-expire 24h). Acceptance Criteria: All endpoints require authentication, rate limiter triggers at 61st request within 60 seconds, invalid requests return descriptive errors with correct HTTP codes, OpenAPI/Swagger spec generated."
M01-05,"OpenAI Integration Layer","Create the OpenAI API client wrapper in PHP: 1) AgentWP\AI\OpenAIClient class with methods: chat(array $messages, array $functions): Response, validateKey(string $key): bool. 2) Implement Function Calling (Tools API) with strict mode enabled. 3) Define function schemas in AgentWP\AI\Functions\* classes (one per function). 4) Retry logic with exponential backoff: initial 1s, max 60s, 10 retries, add random jitter 0-1s. 5) Handle rate limits (429), server errors (5xx), and network timeouts gracefully. 6) Stream response support for long-running queries (SSE). 7) Token counting using tiktoken-php for cost estimation. 8) Model abstraction allowing easy switching between gpt-4o and gpt-4o-mini. Acceptance Criteria: Function calls return properly structured responses, retry logic handles transient failures without user intervention, streaming works for responses >10 seconds, token counts accurate within 5%."
M01-06,"Command Deck Modal - Basic","Build the React modal interface (Command Deck) using React 18 and TailwindCSS: 1) Floating modal overlay with semi-transparent backdrop. 2) Trigger: global hotkey listener (Cmd+K Mac, Ctrl+K Windows), admin bar button click. 3) Visual style: Linear.app aesthetic, dark mode default, 600px max width, centered vertically. 4) Components: Omnibox (text input with placeholder 'Ask AgentWP anything...'), Stage (results area), Status Bar (latency + token cost). 5) Input handling: submit on Enter, close on Escape, focus trap within modal. 6) Loading state with skeleton animation. 7) Basic request/response flow to /agentwp/v1/intent endpoint. 8) Render markdown in responses using react-markdown. 9) Persist modal open state in session. Acceptance Criteria: Modal opens within 100ms of hotkey press, doesn't conflict with browser/OS shortcuts, closes cleanly without memory leaks, works across Chrome/Firefox/Safari/Edge, meets WCAG 2.1 AA accessibility."
M02-01,"Intent Engine Core","Build the intent classification and routing system in PHP: 1) AgentWP\Intent\Engine class that receives natural language input and routes to appropriate handler. 2) Define intent categories: ORDER_SEARCH, ORDER_REFUND, ORDER_STATUS, PRODUCT_STOCK, EMAIL_DRAFT, ANALYTICS_QUERY, CUSTOMER_LOOKUP. 3) Create AgentWP\Intent\Handler interface with methods: canHandle(string $intent): bool, handle(array $context): Response. 4) Context builder that enriches requests with: current user, recent orders (last 5), store timezone, currency. 5) Function registry mapping OpenAI function names to PHP handlers. 6) Implement conversation memory within session (last 5 exchanges). 7) Fallback handler for unrecognized intents with helpful suggestions. Acceptance Criteria: Correct intent identified >95% of test cases, context includes relevant store data, handlers receive properly structured input, unhandled intents suggest alternatives."
M02-02,"Order Search and Retrieval","Implement natural language order search: 1) Create AgentWP\Handlers\OrderSearchHandler class. 2) OpenAI function schema: search_orders(query?: string, order_id?: int, email?: string, status?: string, date_range?: {start: string, end: string}, limit?: int). 3) Translate natural language to WC_Order_Query parameters: 'last order' → limit 1 + orderby date DESC, 'orders from john@...' → customer email filter, 'pending orders' → status filter. 4) Return simplified order objects: id, status, total, customer_name, customer_email, date_created, items_summary, shipping_address. 5) Cache recent queries in transients (1 hour TTL). 6) Support relative dates: 'yesterday', 'last week', 'this month'. Acceptance Criteria: 'Show me the last order' returns most recent order within 500ms, email search finds orders by billing/shipping email, date parsing handles common formats, cache reduces DB queries by 50%+ for repeated searches."
M02-03,"Refund Processing - Draft Mode","Implement the refund workflow with Draft-Confirm protocol: 1) Create AgentWP\Handlers\RefundHandler class. 2) OpenAI function schema: prepare_refund(order_id: int, amount?: float, reason?: string, restock_items?: bool). 3) NEVER execute refund on first call - return draft object only. 4) Draft object contains: order_id, order_total, refund_amount, reason, items_to_restock, customer_email, payment_method, requires_manual_refund (bool). 5) Create separate confirm_refund(draft_id: string) function that executes wc_create_refund(). 6) Generate unique draft_id, store in transient with 10-minute expiry. 7) Handle partial refunds, full refunds, and refund+restock scenarios. 8) After confirmation, optionally trigger customer notification email. Acceptance Criteria: No refund ever processed without explicit confirm_refund call, draft expires after 10 minutes, partial refund calculates correctly, payment gateway refund triggered for supported gateways, audit log entry created."
M02-04,"Order Status Updates","Implement order status change functionality: 1) Create AgentWP\Handlers\OrderStatusHandler class. 2) OpenAI function schema: prepare_status_update(order_id: int, new_status: string, note?: string, notify_customer?: bool). 3) Valid statuses from wc_get_order_statuses(): pending, processing, on-hold, completed, cancelled, refunded, failed. 4) Draft-Confirm protocol: return preview showing current_status → new_status with warning for irreversible changes (cancelled, refunded). 5) Support bulk updates: prepare_bulk_status_update(order_ids: int[], new_status: string). 6) Add order note with '[AgentWP]' prefix for audit trail. 7) Trigger WooCommerce status change hooks for email notifications. Acceptance Criteria: Status only changes after confirmation, customer notification respects notify_customer flag, bulk updates handle up to 50 orders, invalid status transitions rejected with explanation."
M02-05,"Product Stock Management","Implement inventory management functionality: 1) Create AgentWP\Handlers\StockHandler class. 2) OpenAI function schemas: search_product(query: string, sku?: string), prepare_stock_update(product_id: int, quantity: int, operation: 'set'|'increase'|'decrease'). 3) Product search by name (fuzzy match), SKU (exact), or ID. 4) Return product info: id, name, sku, current_stock, stock_status, manage_stock, backorders_allowed. 5) Draft-Confirm for stock changes showing: product name, SKU, current_stock → new_stock. 6) Handle variable products: show variations, allow updating specific variation. 7) Validate: can't decrease below 0 unless backorders allowed, warn if setting stock when manage_stock is disabled. Acceptance Criteria: SKU search returns exact match, name search handles partial matches, stock updates trigger woocommerce_product_set_stock hook, variations displayed and updatable independently."
M02-06,"Action Cards Component Library","Build React component library for displaying AI responses: 1) Create components in /react/components/cards/: BaseCard, DangerousActionCard, SuccessCard, ErrorCard, InfoCard, ChartCard, DataTableCard. 2) DangerousActionCard: red accent border, warning icon, clear headline (e.g., 'Confirm Refund?'), details section, [Execute] (red) and [Cancel] (gray) buttons. 3) SuccessCard: green accent, checkmark icon, action summary, optional 'Undo' link. 4) ErrorCard: red background, error message, retry button, 'Report Issue' link. 5) InfoCard: neutral styling for read-only data display. 6) DataTableCard: sortable columns, pagination for >10 rows. 7) All cards support dark/light mode via CSS variables. 8) Animate card entry with subtle fade+slide. Acceptance Criteria: Cards render correctly in both themes, buttons have proper hover/focus states, animations complete in <200ms, keyboard navigation works (Tab through actions, Enter to confirm)."
M03-01,"Email Context Builder","Build context aggregation for email drafting: 1) Create AgentWP\Context\EmailContextBuilder class. 2) For given order_id, gather: order details (items, totals, dates), customer info (name, email, order history count, total spent), shipping info (method, tracking number if available, estimated delivery), payment info (method, last 4 digits if card), recent order notes (last 5). 3) Integrate with popular tracking plugins: WooCommerce Shipment Tracking, AfterShip, ShipStation (check if active, fetch tracking URL). 4) Detect order issues: payment failed, backordered items, delayed shipping (created >3 days ago, not shipped). 5) Return structured context object for AI prompt construction. Acceptance Criteria: Context loads within 300ms for single order, tracking info retrieved when plugins active, issue detection flags common problems, handles orders with 50+ line items."
M03-02,"AI Email Drafting Engine","Implement AI-powered email draft generation: 1) Create AgentWP\Handlers\EmailDraftHandler class. 2) OpenAI function schema: draft_email(order_id: int, intent: string, tone: 'professional'|'friendly'|'apologetic', custom_instructions?: string). 3) Intent types: shipping_update, refund_confirmation, order_issue, general_inquiry, review_request. 4) Build dynamic prompts incorporating EmailContextBuilder output. 5) Response includes: subject_line, email_body (HTML with simple formatting), plain_text_version. 6) Store drafts in transient with 30-minute expiry, allow retrieval/editing. 7) Support template variables: {{customer_name}}, {{order_id}}, {{tracking_url}}, etc. Acceptance Criteria: Generated emails are contextually relevant (mention specific products, tracking info), tone clearly different between options, drafts valid HTML, no placeholder text like '[TRACKING URL]' when data available."
M03-03,"Copy to Clipboard and Export","Implement clipboard and export functionality in React: 1) ClipboardButton component using navigator.clipboard API with fallback for older browsers. 2) Copy formats: plain text, HTML (for email clients), Markdown. 3) Visual feedback: button text changes to 'Copied!' for 2 seconds, subtle animation. 4) Email client integration: 'Open in Mail' button generates mailto: link with subject and body (URL-encoded). 5) Draft history: store last 10 drafts in localStorage, display in collapsible panel, click to restore. 6) Export analytics charts as PNG using html2canvas. Acceptance Criteria: Copy works across all modern browsers, mailto link opens default email client with content populated, draft history persists across sessions, chart export produces crisp image at 2x resolution."
M03-04,"Sales Analytics Queries","Implement sales analytics functionality: 1) Create AgentWP\Handlers\AnalyticsHandler class. 2) OpenAI function schema: get_sales_report(period: 'today'|'yesterday'|'this_week'|'last_week'|'this_month'|'last_month'|'custom', start_date?: string, end_date?: string, compare_previous?: bool). 3) Metrics to return: total_revenue, order_count, average_order_value, items_sold, refund_total, net_revenue, top_products (top 5), top_categories. 4) Use WooCommerce Analytics tables (wp_wc_order_stats) for performance. 5) Comparison mode: return current_period and previous_period with percentage_change. 6) Cache results in transients: 1 hour for historical data, 5 minutes for 'today'. 7) Format currency according to WooCommerce settings. Acceptance Criteria: 'Sales this month' returns accurate totals matching WooCommerce Analytics, comparison calculations correct, queries execute in <1 second for stores with 100k orders, proper currency formatting."

thinking
**Analyzing service and confirmation functions**
exec
/bin/zsh -lc 'rg -n "Draft-Confirm|draft" docs' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
docs/openapi.json:302:          "draft_ttl_minutes": {
docs/openapi.json:361:          "draft_ttl_minutes": {
docs/agentwp-prd.md:143:All three proposed core features—automated refunds, AI email drafting, and store analytics—have strong market validation.
docs/agentwp-prd.md:147:**AI email drafting:** Customer support automation reduces support tasks by **68–80%** on average. eDesk, Help Scout, and Tidio AI demonstrate successful implementations. Priority templates: shipping updates, refund confirmations, order inquiries, and WISMO (Where Is My Order) responses.
docs/agentwp-prd.md:192:**Launch features:** Prioritize automated refund processing, AI email drafting, and conversational analytics dashboard. These three address the highest-severity pain points with validated market demand.
docs/ARCHITECTURE.md:126:- Drafts are stored in transients (e.g., `agentwp_draft_{id}`) with short TTLs.
docs/ARCHITECTURE.md:146:Primary AI entry point. Converts user input into actions and/or drafts.
docs/ARCHITECTURE.md:155:    "draft_id": "string"
docs/ARCHITECTURE.md:166:    "draft": {
docs/ARCHITECTURE.md:208:    "draft_ttl_minutes": 10
docs/ARCHITECTURE.md:221:  "draft_ttl_minutes": 10
docs/ARCHITECTURE.md:291:### GET /drafts/{draft_id}
docs/ARCHITECTURE.md:292:Fetches a pending draft for confirmation UI.
docs/ARCHITECTURE.md:307:### POST /drafts/{draft_id}/confirm
docs/ARCHITECTURE.md:308:Confirms a draft action (refund, status update, stock update, bulk action).
docs/ARCHITECTURE.md:328:### POST /drafts/{draft_id}/cancel
docs/ARCHITECTURE.md:329:Cancels a pending draft action.
docs/ARCHITECTURE.md:380:## 5) Draft-Confirm Data Flow
docs/ARCHITECTURE.md:382:Draft-Confirm prevents destructive actions without explicit approval. The AI prepares a draft, then the user confirms the action in the UI.
docs/ARCHITECTURE.md:395:  REST->>DraftStore: Save draft (10 min TTL)

thinking
**Examining draft and confirm endpoints in API docs**
exec
/bin/zsh -lc 'rg -n "status_update|confirm_status" docs/ARCHITECTURE.md docs/openapi.json' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
docs/ARCHITECTURE.md:168:      "type": "refund|status_update|stock_update|bulk_action",
docs/ARCHITECTURE.md:300:    "type": "refund|status_update|stock_update|bulk_action",

thinking
**Searching for draft-related code**
exec
/bin/zsh -lc 'rg -n "draft" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 39ms:
src/Rest/SettingsController.php:236:		if ( isset( $payload['draft_ttl_minutes'] ) ) {
src/Rest/SettingsController.php:237:			$draft_ttl = intval( $payload['draft_ttl_minutes'] );
src/Rest/SettingsController.php:238:			if ( $draft_ttl >= 0 ) {
src/Rest/SettingsController.php:239:				$settings['draft_ttl_minutes'] = $draft_ttl;
src/Rest/SettingsController.php:351:				'draft_ttl_minutes' => array(
src/Handlers/RefundHandler.php:3: * Handle refund draft preparation and confirmation.
src/Handlers/RefundHandler.php:23:		if ( isset( $args['draft_id'] ) ) {
src/Handlers/RefundHandler.php:24:			return $this->confirm_refund( $args['draft_id'] );
src/Handlers/RefundHandler.php:31:	 * Prepare a refund draft without executing it.
src/Handlers/RefundHandler.php:85:		$draft_payload = array(
src/Handlers/RefundHandler.php:96:		$draft_id   = $this->generate_draft_id();
src/Handlers/RefundHandler.php:97:		$ttl        = $this->get_draft_ttl_seconds();
src/Handlers/RefundHandler.php:99:		$stored     = $this->store_draft(
src/Handlers/RefundHandler.php:100:			$draft_id,
src/Handlers/RefundHandler.php:102:				'id'         => $draft_id,
src/Handlers/RefundHandler.php:104:				'payload'    => $draft_payload,
src/Handlers/RefundHandler.php:111:			return Response::error( 'Unable to store refund draft.', 500 );
src/Handlers/RefundHandler.php:116:				'draft_id'   => $draft_id,
src/Handlers/RefundHandler.php:117:				'draft'      => $draft_payload,
src/Handlers/RefundHandler.php:124:	 * Confirm and execute a refund from a draft.

thinking
**Designing order status handler and confirmation flow**

I'm working through creating a new order status handler modeled on RefundHandler, focusing on managing drafts and confirmation steps. The challenge is that no specific confirm function schema exists for status updates, so I'm considering whether to adapt the bulk_update function or wait for a separate confirm endpoint; checking architecture docs next may clarify intended workflow and function mappings.
exec
/bin/zsh -lc 'rg -n "prepare_status_update|confirm_status" docs/ARCHITECTURE.md' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 45ms:


thinking
**Analyzing order status update requirements**
exec
/bin/zsh -lc "sed -n '500,620p' src/Handlers/RefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 45ms:

	/**
	 * @param mixed  $order Order instance.
	 * @param string $draft_id Draft ID.
	 * @param float  $amount Refund amount.
	 * @param string $reason Refund reason.
	 * @param bool   $restocked Restock indicator.
	 * @return void
	 */
	private function add_audit_note( $order, $draft_id, $amount, $reason, $restocked ) {
		if ( ! $order || ! method_exists( $order, 'add_order_note' ) ) {
			return;
		}

		$reason_text = '' !== $reason ? $reason : 'no reason provided';
		$amount      = $this->normalize_amount( $amount );
		$note        = sprintf(
			'[AgentWP] Refund confirmed (draft %s). Amount: %s. Reason: %s. Restocked: %s.',
			$draft_id,
			$amount,

thinking
**Designing OrderStatusHandler implementation**

I’m outlining how to create an OrderStatusHandler similar to RefundHandler, respecting the notify_customer flag to control email notifications and supporting drafts with a preview for status changes, including bulk updates limited to 50 orders. I’m also checking integration points, handler patterns, and storage reuse while investigating openapi.json for drafts-related endpoints to align implementation with the spec.
exec
/bin/zsh -lc 'rg -n "drafts" docs/openapi.json' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 35ms:



thinking
**Analyzing confirm and bulk update strategies**

I'm piecing together how order status confirmation fits with existing patterns like RefundHandler, noting the absence of a formal confirm function schema for status updates. It seems confirmation might occur via a generic bulk_update call or a draft_id handled internally. I'll align the handler to support prepare and confirm steps via draft management, handle both single and bulk updates with status validation, notifications control, warnings for irreversible changes, and audit notes—while respecting WooCommerce functions and limiting bulk size. This way, I keep compatibility with the spec’s acceptance criteria without adding unrequested function schemas.
thinking
**Checking autoload configuration**
exec
/bin/zsh -lc 'cat composer.json' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
{
  "name": "agentwp/agentwp",
  "description": "AgentWP WordPress plugin.",
  "type": "wordpress-plugin",
  "license": "GPL-2.0-or-later",
  "autoload": {
    "psr-4": {
      "AgentWP\\": "src/"
    }
  },
  "require": {
    "php": ">=7.4",
    "yethee/tiktoken": "^0.1.2"
  }
}

thinking
**Designing OrderStatusHandler structure**
exec
/bin/zsh -lc 'rg -n "normalize_bool" -n src/Handlers/RefundHandler.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
54:		$restock_items   = $this->normalize_bool( isset( $args['restock_items'] ) ? $args['restock_items'] : false );
222:	private function normalize_bool( $value ) {
exec
/bin/zsh -lc "sed -n '210,260p' src/Handlers/RefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 44ms:
				'refund_id'              => $refund_id,
				'refund_amount'          => $refund_amount,
				'restocked_items'        => $restocked,
				'requires_manual_refund' => $requires_manual_refund,
			)
		);
	}

	/**
	 * @param mixed $value Input.
	 * @return bool
	 */
	private function normalize_bool( $value ) {
		if ( function_exists( 'rest_sanitize_boolean' ) ) {
			return rest_sanitize_boolean( $value );
		}

		return (bool) $value;
	}


thinking
**Designing status update draft and validation**

I'm mapping out how to create a draft payload for status updates that includes current and new statuses, notes, and flags warnings for irreversible states like 'cancelled' or 'refunded.' I’m considering how to handle previews for UI, validate orders and statuses in bulk, check for duplicates, and provide clear error messages when invalid or missing orders appear, aiming for a practical balance between thorough checks and simplicity.
exec
/bin/zsh -lc "sed -n '1,160p' src/AI/Response.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
<?php
/**
 * OpenAI response wrapper.
 *
 * @package AgentWP
 */

namespace AgentWP\AI;

class Response {
	/**
	 * @var bool
	 */
	private $success;

	/**
	 * @var int
	 */
	private $status;



thinking
**Designing comprehensive order status handler**

I’m mapping out a detailed OrderStatusHandler to manage single and bulk order status updates with draft saving, validation, error handling, and audit notes. I’m considering reusing helper patterns from RefundHandler, enforcing limits like max 50 orders for bulk updates, handling notifications with email filters, and carefully deciding how to attach optional notes alongside audit trail entries. This includes schema tweaks, payload normalization, and thoughtful response design to cover all cases.
thinking
**Detailing order status update mechanics**

I’m refining the approach to minimize duplicated notes by embedding user notes into a single audit note passed to update_status, ensuring WooCommerce hooks trigger appropriately. I’m also planning helper methods for status normalization, validation against allowed statuses, irreversible warnings, and draft management, plus thorough error handling and bulk update previews—all wrapped in a well-structured, WordPress-style class modeled after RefundHandler.
exec
/bin/zsh -lc "sed -n '360,520p' src/Handlers/RefundHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:

	/**
	 * @param mixed $gateway Payment gateway.
	 * @return bool
	 */
	private function requires_manual_refund( $gateway ) {
		if ( ! $gateway || ! method_exists( $gateway, 'supports' ) ) {
			return true;
		}

		return ! $gateway->supports( 'refunds' );
	}

	/**
	 * @return string
	 */
	private function generate_draft_id() {
		if ( function_exists( 'wp_generate_uuid4' ) ) {
			return wp_generate_uuid4();
		}

thinking
**Designing order status update methods**

I'm planning out methods for building audit notes with optional inclusion of notes and order IDs, safely applying status updates while optionally suppressing customer emails, and validating bulk updates with limits and uniqueness; I'll implement these in a new file with proper docblocks and ASCII-only comments to keep things clear and maintainable.
file update
A /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/OrderStatusHandler.php
<?php
/**
 * Handle order status draft preparation and confirmation.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;

class OrderStatusHandler {
	const DRAFT_TYPE = 'status_update';
	const MAX_BULK   = 50;

	/**
	 * Handle order status requests.
	 *
	 * @param array $args Request args.
	 * @return Response
	 */
	public function handle( array $args ): Response {
		if ( isset( $args['draft_id'] ) ) {
			return $this->confirm_status_update( $args['draft_id'] );
		}

		if ( isset( $args['order_ids'] ) ) {
			return $this->prepare_bulk_status_update( $args );
		}

		return $this->prepare_status_update( $args );
	}

	/**
	 * Prepare a draft order status update without applying it.
	 *
	 * @param array $args Request args.
	 * @return Response
	 */
	public function prepare_status_update( array $args ): Response {
		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
			return Response::error( 'WooCommerce is required to prepare status updates.', 400 );
		}

		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
		if ( 0 === $order_id ) {
			return Response::error( 'Missing order ID for status update.', 400 );
		}

		$order = wc_get_order( $order_id );
		if ( ! $order ) {
			return Response::error( 'Order not found for status update.', 404 );
		}

		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
		if ( '' === $new_status ) {
			return Response::error( 'Missing new status for update.', 400 );
		}

		$valid_statuses = $this->get_valid_statuses();
		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
			return Response::error(
				sprintf(
					'Invalid status "%s". Valid statuses: %s.',
					$new_status,
					implode( ', ', $valid_statuses )
				),
				400
			);
		}

		$current_status = $this->normalize_status( $order->get_status() );
		if ( $new_status === $current_status ) {
			return Response::error( 'Order already has the requested status.', 400 );
		}

		$note            = isset( $args['note'] ) ? sanitize_text_field( wp_unslash( $args['note'] ) ) : '';
		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
		$warning         = $this->get_irreversible_warning( $new_status );

		$draft_payload = array(
			'order_id'       => $order_id,
			'current_status' => $current_status,
			'new_status'     => $new_status,
			'note'           => $note,
			'notify_customer' => $notify_customer,
			'warning'        => $warning,
			'preview'        => array(
				'transition' => $current_status . ' -> ' . $new_status,
				'warning'    => $warning,
			),
		);

		$draft_id   = $this->generate_draft_id();
		$ttl        = $this->get_draft_ttl_seconds();
		$expires_at = gmdate( 'c', time() + $ttl );
		$stored     = $this->store_draft(
			$draft_id,
			array(
				'id'         => $draft_id,
				'type'       => self::DRAFT_TYPE,
				'payload'    => $draft_payload,
				'expires_at' => $expires_at,
			),
			$ttl
		);

		if ( ! $stored ) {
			return Response::error( 'Unable to store status update draft.', 500 );
		}

		return Response::success(
			array(
				'draft_id'   => $draft_id,
				'draft'      => $draft_payload,
				'expires_at' => $expires_at,
			)
		);
	}

	/**
	 * Prepare a draft bulk status update without applying it.
	 *
	 * @param array $args Request args.
	 * @return Response
	 */
	public function prepare_bulk_status_update( array $args ): Response {
		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
			return Response::error( 'WooCommerce is required to prepare bulk status updates.', 400 );
		}

		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
		if ( empty( $order_ids ) ) {
			return Response::error( 'Missing order IDs for bulk status update.', 400 );
		}

		if ( count( $order_ids ) > self::MAX_BULK ) {
			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
		}

		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
		if ( '' === $new_status ) {
			return Response::error( 'Missing new status for bulk update.', 400 );
		}

		$valid_statuses = $this->get_valid_statuses();
		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
			return Response::error(
				sprintf(
					'Invalid status "%s". Valid statuses: %s.',
					$new_status,
					implode( ', ', $valid_statuses )
				),
				400
			);
		}

		$missing_orders = array();
		$invalid_orders = array();
		$previews       = array();

		foreach ( $order_ids as $order_id ) {
			$order = wc_get_order( $order_id );
			if ( ! $order ) {
				$missing_orders[] = $order_id;
				continue;
			}

			$current_status = $this->normalize_status( $order->get_status() );
			if ( $current_status === $new_status ) {
				$invalid_orders[] = $order_id;
				continue;
			}

			$previews[] = array(
				'order_id'       => $order_id,
				'current_status' => $current_status,
				'new_status'     => $new_status,
				'transition'     => $current_status . ' -> ' . $new_status,
			);
		}

		if ( ! empty( $missing_orders ) ) {
			return Response::error(
				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
				404,
				array( 'missing_orders' => $missing_orders )
			);
		}

		if ( ! empty( $invalid_orders ) ) {
			return Response::error(
				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
				400,
				array( 'invalid_orders' => $invalid_orders )
			);
		}

		$warning = $this->get_irreversible_warning( $new_status );

		$draft_payload = array(
			'order_ids'  => $order_ids,
			'new_status' => $new_status,
			'warning'    => $warning,
			'preview'    => array(
				'order_count' => count( $order_ids ),
				'orders'      => $previews,
				'warning'     => $warning,
			),
		);

		$draft_id   = $this->generate_draft_id();
		$ttl        = $this->get_draft_ttl_seconds();
		$expires_at = gmdate( 'c', time() + $ttl );
		$stored     = $this->store_draft(
			$draft_id,
			array(
				'id'         => $draft_id,
				'type'       => self::DRAFT_TYPE,
				'payload'    => $draft_payload,
				'expires_at' => $expires_at,
			),
			$ttl
		);

		if ( ! $stored ) {
			return Response::error( 'Unable to store bulk status update draft.', 500 );
		}

		return Response::success(
			array(
				'draft_id'   => $draft_id,
				'draft'      => $draft_payload,
				'expires_at' => $expires_at,
			)
		);
	}

	/**
	 * Confirm and apply a draft status update.
	 *
	 * @param string $draft_id Draft identifier.
	 * @return Response
	 */
	public function confirm_status_update( $draft_id ): Response {
		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
			return Response::error( 'WooCommerce is required to update order statuses.', 400 );
		}

		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
		if ( '' === $draft_id ) {
			return Response::error( 'Missing status update draft ID.', 400 );
		}

		$draft = $this->load_draft( $draft_id );
		if ( null === $draft ) {
			return Response::error( 'Status update draft not found or expired.', 404 );
		}

		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
			return Response::error( 'Draft type mismatch for status update confirmation.', 400 );
		}

		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
		if ( isset( $payload['order_ids'] ) ) {
			return $this->confirm_bulk_status_update( $draft_id, $payload );
		}

		return $this->confirm_single_status_update( $draft_id, $payload );
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @param array  $payload Draft payload.
	 * @return Response
	 */
	private function confirm_single_status_update( $draft_id, array $payload ): Response {
		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
		if ( 0 === $order_id ) {
			return Response::error( 'Status update draft is missing the order ID.', 400 );
		}

		$order = wc_get_order( $order_id );
		if ( ! $order ) {
			return Response::error( 'Order not found for status update confirmation.', 404 );
		}

		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
		$valid_statuses = $this->get_valid_statuses();
		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
			return Response::error( 'Draft contains an invalid target status.', 400 );
		}

		$current_status = $this->normalize_status( $order->get_status() );
		if ( $new_status === $current_status ) {
			return Response::error( 'Order already has the requested status.', 400 );
		}

		$note            = isset( $payload['note'] ) ? (string) $payload['note'] : '';
		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
		$audit_note      = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, false );

		$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
		if ( ! $updated ) {
			return Response::error( 'Unable to apply status update.', 500 );
		}

		$this->delete_draft( $draft_id );

		return Response::success(
			array(
				'draft_id'       => $draft_id,
				'order_id'       => $order_id,
				'previous_status' => $current_status,
				'new_status'     => $new_status,
				'notified'       => $notify_customer,
			)
		);
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @param array  $payload Draft payload.
	 * @return Response
	 */
	private function confirm_bulk_status_update( $draft_id, array $payload ): Response {
		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
		if ( empty( $order_ids ) ) {
			return Response::error( 'Bulk status update draft is missing order IDs.', 400 );
		}

		if ( count( $order_ids ) > self::MAX_BULK ) {
			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
		}

		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
		$valid_statuses = $this->get_valid_statuses();
		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
			return Response::error( 'Draft contains an invalid target status.', 400 );
		}

		$missing_orders = array();
		$invalid_orders = array();
		$orders         = array();

		foreach ( $order_ids as $order_id ) {
			$order = wc_get_order( $order_id );
			if ( ! $order ) {
				$missing_orders[] = $order_id;
				continue;
			}

			$current_status = $this->normalize_status( $order->get_status() );
			if ( $current_status === $new_status ) {
				$invalid_orders[] = $order_id;
				continue;
			}

			$orders[ $order_id ] = $order;
		}

		if ( ! empty( $missing_orders ) ) {
			return Response::error(
				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
				404,
				array( 'missing_orders' => $missing_orders )
			);
		}

		if ( ! empty( $invalid_orders ) ) {
			return Response::error(
				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
				400,
				array( 'invalid_orders' => $invalid_orders )
			);
		}

		$updated_orders = array();
		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );

		foreach ( $orders as $order_id => $order ) {
			$current_status = $this->normalize_status( $order->get_status() );
			$audit_note     = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, '', true );

			$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
			if ( $updated ) {
				$updated_orders[] = $order_id;
			}
		}

		$this->delete_draft( $draft_id );

		return Response::success(
			array(
				'draft_id'   => $draft_id,
				'order_ids'  => $order_ids,
				'new_status' => $new_status,
				'updated'    => $updated_orders,
				'notified'   => $notify_customer,
			)
		);
	}

	/**
	 * @param mixed  $order Order instance.
	 * @param string $new_status Target status.
	 * @param string $note Order note.
	 * @param bool   $notify_customer Notify flag.
	 * @return bool
	 */
	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
			return false;
		}

		$notify_customer = $this->normalize_bool( $notify_customer );
		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );

		$filter = null;
		if ( ! $notify_customer ) {
			$filter = function () {
				return false;
			};
			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
		}

		$order->update_status( $new_status, $note );

		if ( $filter ) {
			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
		}

		return true;
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @param int    $order_id Order ID.
	 * @param string $current_status Current status.
	 * @param string $new_status Target status.
	 * @param string $note Optional note.
	 * @param bool   $is_bulk Bulk flag.
	 * @return string
	 */
	private function build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, $is_bulk ) {
		$summary = sprintf(
			'[AgentWP] %s status update confirmed (draft %s) for order #%d. %s -> %s.',
			$is_bulk ? 'Bulk' : 'Order',
			$draft_id,
			$order_id,
			$this->get_status_label( $current_status ),
			$this->get_status_label( $new_status )
		);

		$note = trim( (string) $note );
		if ( '' !== $note ) {
			$summary .= ' Note: ' . $note . '.';
		}

		return $summary;
	}

	/**
	 * @param string $status Status slug.
	 * @return string
	 */
	private function get_status_label( $status ) {
		if ( function_exists( 'wc_get_order_status_name' ) ) {
			return wc_get_order_status_name( $status );
		}

		return $status;
	}

	/**
	 * @param mixed $value Input value.
	 * @return bool
	 */
	private function normalize_bool( $value ) {
		if ( function_exists( 'rest_sanitize_boolean' ) ) {
			return rest_sanitize_boolean( $value );
		}

		return (bool) $value;
	}

	/**
	 * @param mixed $status Raw status input.
	 * @return string
	 */
	private function normalize_status( $status ) {
		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';

		if ( '' === $status ) {
			return '';
		}

		if ( 0 === strpos( $status, 'wc-' ) ) {
			$status = substr( $status, 3 );
		}

		return sanitize_key( $status );
	}

	/**
	 * @return array
	 */
	private function get_valid_statuses() {
		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
		$normalized = array();

		if ( function_exists( 'wc_get_order_statuses' ) ) {
			$statuses = wc_get_order_statuses();
			if ( is_array( $statuses ) ) {
				foreach ( array_keys( $statuses ) as $status ) {
					$normalized_status = $this->normalize_status( $status );
					if ( '' !== $normalized_status ) {
						$normalized[] = $normalized_status;
					}
				}
			}
		}

		if ( ! empty( $normalized ) ) {
			$allowed = array_values( array_intersect( $allowed, $normalized ) );
		}

		sort( $allowed );

		return $allowed;
	}

	/**
	 * @param string $status Target status.
	 * @return string
	 */
	private function get_irreversible_warning( $status ) {
		if ( in_array( $status, array( 'cancelled', 'refunded' ), true ) ) {
			return 'This change is irreversible.';
		}

		return '';
	}

	/**
	 * @param mixed $order_ids Order ID input.
	 * @return array
	 */
	private function normalize_order_ids( $order_ids ) {
		$ids = array();

		if ( is_string( $order_ids ) ) {
			$order_ids = preg_split( '/[\s,]+/', $order_ids );
		}

		if ( ! is_array( $order_ids ) ) {
			return $ids;
		}

		foreach ( $order_ids as $order_id ) {
			$normalized = absint( $order_id );
			if ( $normalized > 0 ) {
				$ids[] = $normalized;
			}
		}

		$ids = array_values( array_unique( $ids ) );

		return $ids;
	}

	/**
	 * @return string
	 */
	private function generate_draft_id() {
		if ( function_exists( 'wp_generate_uuid4' ) ) {
			return wp_generate_uuid4();
		}

		return uniqid( 'draft_', true );
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return string
	 */
	private function build_draft_key( $draft_id ) {
		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
	}

	/**
	 * @return int
	 */
	private function get_draft_ttl_seconds() {
		$ttl_minutes = null;

		if ( function_exists( 'get_option' ) ) {
			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
			if ( null !== $option_ttl && '' !== $option_ttl ) {
				$ttl_minutes = intval( $option_ttl );
			}
		}

		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
			}
		}

		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
			$ttl_minutes = 10;
		}

		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;

		return $ttl_minutes * $minute_seconds;
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @param array  $draft Draft payload.
	 * @param int    $ttl_seconds Expiration seconds.
	 * @return bool
	 */
	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
		if ( ! function_exists( 'set_transient' ) ) {
			return false;
		}

		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return array|null
	 */
	private function load_draft( $draft_id ) {
		if ( ! function_exists( 'get_transient' ) ) {
			return null;
		}

		$draft = get_transient( $this->build_draft_key( $draft_id ) );
		if ( false === $draft || ! is_array( $draft ) ) {
			return null;
		}

		return $draft;
	}

	/**
	 * @param string $draft_id Draft identifier.
	 * @return void
	 */
	private function delete_draft( $draft_id ) {
		if ( function_exists( 'delete_transient' ) ) {
			delete_transient( $this->build_draft_key( $draft_id ) );
		}
	}
}
apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
A src/Handlers/OrderStatusHandler.php
file update:
diff --git a/src/Handlers/OrderStatusHandler.php b/src/Handlers/OrderStatusHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..2f7b8038b454b4a17cfe0d78df14d2eee1b79f36
--- /dev/null
+++ b/src/Handlers/OrderStatusHandler.php
@@ -0,0 +1,661 @@
+<?php
+/**
+ * Handle order status draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class OrderStatusHandler {
+	const DRAFT_TYPE = 'status_update';
+	const MAX_BULK   = 50;
+
+	/**
+	 * Handle order status requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_status_update( $args['draft_id'] );
+		}
+
+		if ( isset( $args['order_ids'] ) ) {
+			return $this->prepare_bulk_status_update( $args );
+		}
+
+		return $this->prepare_status_update( $args );
+	}
+
+	/**
+	 * Prepare a draft order status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare status updates.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for status update.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update.', 404 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $args['note'] ) ? sanitize_text_field( wp_unslash( $args['note'] ) ) : '';
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+		$warning         = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_id'       => $order_id,
+			'current_status' => $current_status,
+			'new_status'     => $new_status,
+			'note'           => $note,
+			'notify_customer' => $notify_customer,
+			'warning'        => $warning,
+			'preview'        => array(
+				'transition' => $current_status . ' -> ' . $new_status,
+				'warning'    => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft bulk status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_bulk_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk status updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk status update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for bulk update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$previews       = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$previews[] = array(
+				'order_id'       => $order_id,
+				'current_status' => $current_status,
+				'new_status'     => $new_status,
+				'transition'     => $current_status . ' -> ' . $new_status,
+			);
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$warning = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_ids'  => $order_ids,
+			'new_status' => $new_status,
+			'warning'    => $warning,
+			'preview'    => array(
+				'order_count' => count( $order_ids ),
+				'orders'      => $previews,
+				'warning'     => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft status update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_status_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to update order statuses.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing status update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Status update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for status update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		if ( isset( $payload['order_ids'] ) ) {
+			return $this->confirm_bulk_status_update( $draft_id, $payload );
+		}
+
+		return $this->confirm_single_status_update( $draft_id, $payload );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_single_status_update( $draft_id, array $payload ): Response {
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Status update draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update confirmation.', 404 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $payload['note'] ) ? (string) $payload['note'] : '';
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+		$audit_note      = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, false );
+
+		$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+		if ( ! $updated ) {
+			return Response::error( 'Unable to apply status update.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'order_id'       => $order_id,
+				'previous_status' => $current_status,
+				'new_status'     => $new_status,
+				'notified'       => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_bulk_status_update( $draft_id, array $payload ): Response {
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk status update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$orders         = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$orders[ $order_id ] = $order;
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$updated_orders = array();
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+
+		foreach ( $orders as $order_id => $order ) {
+			$current_status = $this->normalize_status( $order->get_status() );
+			$audit_note     = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, '', true );
+
+			$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+			if ( $updated ) {
+				$updated_orders[] = $order_id;
+			}
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'order_ids'  => $order_ids,
+				'new_status' => $new_status,
+				'updated'    => $updated_orders,
+				'notified'   => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $new_status Target status.
+	 * @param string $note Order note.
+	 * @param bool   $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param int    $order_id Order ID.
+	 * @param string $current_status Current status.
+	 * @param string $new_status Target status.
+	 * @param string $note Optional note.
+	 * @param bool   $is_bulk Bulk flag.
+	 * @return string
+	 */
+	private function build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, $is_bulk ) {
+		$summary = sprintf(
+			'[AgentWP] %s status update confirmed (draft %s) for order #%d. %s -> %s.',
+			$is_bulk ? 'Bulk' : 'Order',
+			$draft_id,
+			$order_id,
+			$this->get_status_label( $current_status ),
+			$this->get_status_label( $new_status )
+		);
+
+		$note = trim( (string) $note );
+		if ( '' !== $note ) {
+			$summary .= ' Note: ' . $note . '.';
+		}
+
+		return $summary;
+	}
+
+	/**
+	 * @param string $status Status slug.
+	 * @return string
+	 */
+	private function get_status_label( $status ) {
+		if ( function_exists( 'wc_get_order_status_name' ) ) {
+			return wc_get_order_status_name( $status );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param mixed $value Input value.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $status Raw status input.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param string $status Target status.
+	 * @return string
+	 */
+	private function get_irreversible_warning( $status ) {
+		if ( in_array( $status, array( 'cancelled', 'refunded' ), true ) ) {
+			return 'This change is irreversible.';
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}

file update:
diff --git a/src/Handlers/OrderStatusHandler.php b/src/Handlers/OrderStatusHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..2f7b8038b454b4a17cfe0d78df14d2eee1b79f36
--- /dev/null
+++ b/src/Handlers/OrderStatusHandler.php
@@ -0,0 +1,661 @@
+<?php
+/**
+ * Handle order status draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class OrderStatusHandler {
+	const DRAFT_TYPE = 'status_update';
+	const MAX_BULK   = 50;
+
+	/**
+	 * Handle order status requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_status_update( $args['draft_id'] );
+		}
+
+		if ( isset( $args['order_ids'] ) ) {
+			return $this->prepare_bulk_status_update( $args );
+		}
+
+		return $this->prepare_status_update( $args );
+	}
+
+	/**
+	 * Prepare a draft order status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare status updates.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for status update.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update.', 404 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $args['note'] ) ? sanitize_text_field( wp_unslash( $args['note'] ) ) : '';
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+		$warning         = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_id'       => $order_id,
+			'current_status' => $current_status,
+			'new_status'     => $new_status,
+			'note'           => $note,
+			'notify_customer' => $notify_customer,
+			'warning'        => $warning,
+			'preview'        => array(
+				'transition' => $current_status . ' -> ' . $new_status,
+				'warning'    => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft bulk status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_bulk_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk status updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk status update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for bulk update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$previews       = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$previews[] = array(
+				'order_id'       => $order_id,
+				'current_status' => $current_status,
+				'new_status'     => $new_status,
+				'transition'     => $current_status . ' -> ' . $new_status,
+			);
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$warning = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_ids'  => $order_ids,
+			'new_status' => $new_status,
+			'warning'    => $warning,
+			'preview'    => array(
+				'order_count' => count( $order_ids ),
+				'orders'      => $previews,
+				'warning'     => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft status update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_status_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to update order statuses.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing status update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Status update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for status update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		if ( isset( $payload['order_ids'] ) ) {
+			return $this->confirm_bulk_status_update( $draft_id, $payload );
+		}
+
+		return $this->confirm_single_status_update( $draft_id, $payload );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_single_status_update( $draft_id, array $payload ): Response {
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Status update draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update confirmation.', 404 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $payload['note'] ) ? (string) $payload['note'] : '';
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+		$audit_note      = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, false );
+
+		$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+		if ( ! $updated ) {
+			return Response::error( 'Unable to apply status update.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'order_id'       => $order_id,
+				'previous_status' => $current_status,
+				'new_status'     => $new_status,
+				'notified'       => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_bulk_status_update( $draft_id, array $payload ): Response {
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk status update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$orders         = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$orders[ $order_id ] = $order;
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$updated_orders = array();
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+
+		foreach ( $orders as $order_id => $order ) {
+			$current_status = $this->normalize_status( $order->get_status() );
+			$audit_note     = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, '', true );
+
+			$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+			if ( $updated ) {
+				$updated_orders[] = $order_id;
+			}
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'order_ids'  => $order_ids,
+				'new_status' => $new_status,
+				'updated'    => $updated_orders,
+				'notified'   => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $new_status Target status.
+	 * @param string $note Order note.
+	 * @param bool   $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param int    $order_id Order ID.
+	 * @param string $current_status Current status.
+	 * @param string $new_status Target status.
+	 * @param string $note Optional note.
+	 * @param bool   $is_bulk Bulk flag.
+	 * @return string
+	 */
+	private function build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, $is_bulk ) {
+		$summary = sprintf(
+			'[AgentWP] %s status update confirmed (draft %s) for order #%d. %s -> %s.',
+			$is_bulk ? 'Bulk' : 'Order',
+			$draft_id,
+			$order_id,
+			$this->get_status_label( $current_status ),
+			$this->get_status_label( $new_status )
+		);
+
+		$note = trim( (string) $note );
+		if ( '' !== $note ) {
+			$summary .= ' Note: ' . $note . '.';
+		}
+
+		return $summary;
+	}
+
+	/**
+	 * @param string $status Status slug.
+	 * @return string
+	 */
+	private function get_status_label( $status ) {
+		if ( function_exists( 'wc_get_order_status_name' ) ) {
+			return wc_get_order_status_name( $status );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param mixed $value Input value.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $status Raw status input.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param string $status Target status.
+	 * @return string
+	 */
+	private function get_irreversible_warning( $status ) {
+		if ( in_array( $status, array( 'cancelled', 'refunded' ), true ) ) {
+			return 'This change is irreversible.';
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}


thinking
**Reviewing code style and potential issues**
exec
/bin/zsh -lc "sed -n '150,360p' src/Handlers/OrderStatusHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
				sprintf(
					'Invalid status "%s". Valid statuses: %s.',
					$new_status,
					implode( ', ', $valid_statuses )
				),
				400
			);
		}

		$missing_orders = array();
		$invalid_orders = array();
		$previews       = array();

		foreach ( $order_ids as $order_id ) {
			$order = wc_get_order( $order_id );
			if ( ! $order ) {
				$missing_orders[] = $order_id;
				continue;
			}

file update:
diff --git a/src/Handlers/OrderStatusHandler.php b/src/Handlers/OrderStatusHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..2f7b8038b454b4a17cfe0d78df14d2eee1b79f36
--- /dev/null
+++ b/src/Handlers/OrderStatusHandler.php
@@ -0,0 +1,661 @@
+<?php
+/**
+ * Handle order status draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class OrderStatusHandler {
+	const DRAFT_TYPE = 'status_update';
+	const MAX_BULK   = 50;
+
+	/**
+	 * Handle order status requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_status_update( $args['draft_id'] );
+		}
+
+		if ( isset( $args['order_ids'] ) ) {
+			return $this->prepare_bulk_status_update( $args );
+		}
+
+		return $this->prepare_status_update( $args );
+	}
+
+	/**
+	 * Prepare a draft order status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare status updates.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for status update.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update.', 404 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $args['note'] ) ? sanitize_text_field( wp_unslash( $args['note'] ) ) : '';
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+		$warning         = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_id'       => $order_id,
+			'current_status' => $current_status,
+			'new_status'     => $new_status,
+			'note'           => $note,
+			'notify_customer' => $notify_customer,
+			'warning'        => $warning,
+			'preview'        => array(
+				'transition' => $current_status . ' -> ' . $new_status,
+				'warning'    => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft bulk status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_bulk_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk status updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk status update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for bulk update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$previews       = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$previews[] = array(
+				'order_id'       => $order_id,
+				'current_status' => $current_status,
+				'new_status'     => $new_status,
+				'transition'     => $current_status . ' -> ' . $new_status,
+			);
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$warning = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_ids'  => $order_ids,
+			'new_status' => $new_status,
+			'warning'    => $warning,
+			'preview'    => array(
+				'order_count' => count( $order_ids ),
+				'orders'      => $previews,
+				'warning'     => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft status update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_status_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to update order statuses.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing status update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Status update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for status update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		if ( isset( $payload['order_ids'] ) ) {
+			return $this->confirm_bulk_status_update( $draft_id, $payload );
+		}
+
+		return $this->confirm_single_status_update( $draft_id, $payload );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_single_status_update( $draft_id, array $payload ): Response {
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Status update draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update confirmation.', 404 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $payload['note'] ) ? (string) $payload['note'] : '';
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+		$audit_note      = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, false );
+
+		$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+		if ( ! $updated ) {
+			return Response::error( 'Unable to apply status update.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'order_id'       => $order_id,
+				'previous_status' => $current_status,
+				'new_status'     => $new_status,
+				'notified'       => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_bulk_status_update( $draft_id, array $payload ): Response {
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk status update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$orders         = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$orders[ $order_id ] = $order;
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$updated_orders = array();
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+
+		foreach ( $orders as $order_id => $order ) {
+			$current_status = $this->normalize_status( $order->get_status() );
+			$audit_note     = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, '', true );
+
+			$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+			if ( $updated ) {
+				$updated_orders[] = $order_id;
+			}
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'order_ids'  => $order_ids,
+				'new_status' => $new_status,
+				'updated'    => $updated_orders,
+				'notified'   => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $new_status Target status.
+	 * @param string $note Order note.
+	 * @param bool   $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param int    $order_id Order ID.
+	 * @param string $current_status Current status.
+	 * @param string $new_status Target status.
+	 * @param string $note Optional note.
+	 * @param bool   $is_bulk Bulk flag.
+	 * @return string
+	 */
+	private function build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, $is_bulk ) {
+		$summary = sprintf(
+			'[AgentWP] %s status update confirmed (draft %s) for order #%d. %s -> %s.',
+			$is_bulk ? 'Bulk' : 'Order',
+			$draft_id,
+			$order_id,
+			$this->get_status_label( $current_status ),
+			$this->get_status_label( $new_status )
+		);
+
+		$note = trim( (string) $note );
+		if ( '' !== $note ) {
+			$summary .= ' Note: ' . $note . '.';
+		}
+
+		return $summary;
+	}
+
+	/**
+	 * @param string $status Status slug.
+	 * @return string
+	 */
+	private function get_status_label( $status ) {
+		if ( function_exists( 'wc_get_order_status_name' ) ) {
+			return wc_get_order_status_name( $status );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param mixed $value Input value.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $status Raw status input.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param string $status Target status.
+	 * @return string
+	 */
+	private function get_irreversible_warning( $status ) {
+		if ( in_array( $status, array( 'cancelled', 'refunded' ), true ) ) {
+			return 'This change is irreversible.';
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}


thinking
**Reviewing apply_status_update usage**
exec
/bin/zsh -lc "sed -n '360,560p' src/Handlers/OrderStatusHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
			$orders[ $order_id ] = $order;
		}

		if ( ! empty( $missing_orders ) ) {
			return Response::error(
				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
				404,
				array( 'missing_orders' => $missing_orders )
			);
		}

		if ( ! empty( $invalid_orders ) ) {
			return Response::error(
				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
				400,
				array( 'invalid_orders' => $invalid_orders )
			);
		}

		$updated_orders = array();
file update:
diff --git a/src/Handlers/OrderStatusHandler.php b/src/Handlers/OrderStatusHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..2f7b8038b454b4a17cfe0d78df14d2eee1b79f36
--- /dev/null
+++ b/src/Handlers/OrderStatusHandler.php
@@ -0,0 +1,661 @@
+<?php
+/**
+ * Handle order status draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class OrderStatusHandler {
+	const DRAFT_TYPE = 'status_update';
+	const MAX_BULK   = 50;
+
+	/**
+	 * Handle order status requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_status_update( $args['draft_id'] );
+		}
+
+		if ( isset( $args['order_ids'] ) ) {
+			return $this->prepare_bulk_status_update( $args );
+		}
+
+		return $this->prepare_status_update( $args );
+	}
+
+	/**
+	 * Prepare a draft order status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare status updates.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for status update.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update.', 404 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $args['note'] ) ? sanitize_text_field( wp_unslash( $args['note'] ) ) : '';
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+		$warning         = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_id'       => $order_id,
+			'current_status' => $current_status,
+			'new_status'     => $new_status,
+			'note'           => $note,
+			'notify_customer' => $notify_customer,
+			'warning'        => $warning,
+			'preview'        => array(
+				'transition' => $current_status . ' -> ' . $new_status,
+				'warning'    => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft bulk status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_bulk_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk status updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk status update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for bulk update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$previews       = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$previews[] = array(
+				'order_id'       => $order_id,
+				'current_status' => $current_status,
+				'new_status'     => $new_status,
+				'transition'     => $current_status . ' -> ' . $new_status,
+			);
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$warning = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_ids'  => $order_ids,
+			'new_status' => $new_status,
+			'warning'    => $warning,
+			'preview'    => array(
+				'order_count' => count( $order_ids ),
+				'orders'      => $previews,
+				'warning'     => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft status update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_status_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to update order statuses.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing status update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Status update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for status update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		if ( isset( $payload['order_ids'] ) ) {
+			return $this->confirm_bulk_status_update( $draft_id, $payload );
+		}
+
+		return $this->confirm_single_status_update( $draft_id, $payload );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_single_status_update( $draft_id, array $payload ): Response {
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Status update draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update confirmation.', 404 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $payload['note'] ) ? (string) $payload['note'] : '';
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+		$audit_note      = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, false );
+
+		$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+		if ( ! $updated ) {
+			return Response::error( 'Unable to apply status update.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'order_id'       => $order_id,
+				'previous_status' => $current_status,
+				'new_status'     => $new_status,
+				'notified'       => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_bulk_status_update( $draft_id, array $payload ): Response {
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk status update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$orders         = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$orders[ $order_id ] = $order;
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$updated_orders = array();
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+
+		foreach ( $orders as $order_id => $order ) {
+			$current_status = $this->normalize_status( $order->get_status() );
+			$audit_note     = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, '', true );
+
+			$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+			if ( $updated ) {
+				$updated_orders[] = $order_id;
+			}
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'order_ids'  => $order_ids,
+				'new_status' => $new_status,
+				'updated'    => $updated_orders,
+				'notified'   => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $new_status Target status.
+	 * @param string $note Order note.
+	 * @param bool   $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function () {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param int    $order_id Order ID.
+	 * @param string $current_status Current status.
+	 * @param string $new_status Target status.
+	 * @param string $note Optional note.
+	 * @param bool   $is_bulk Bulk flag.
+	 * @return string
+	 */
+	private function build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, $is_bulk ) {
+		$summary = sprintf(
+			'[AgentWP] %s status update confirmed (draft %s) for order #%d. %s -> %s.',
+			$is_bulk ? 'Bulk' : 'Order',
+			$draft_id,
+			$order_id,
+			$this->get_status_label( $current_status ),
+			$this->get_status_label( $new_status )
+		);
+
+		$note = trim( (string) $note );
+		if ( '' !== $note ) {
+			$summary .= ' Note: ' . $note . '.';
+		}
+
+		return $summary;
+	}
+
+	/**
+	 * @param string $status Status slug.
+	 * @return string
+	 */
+	private function get_status_label( $status ) {
+		if ( function_exists( 'wc_get_order_status_name' ) ) {
+			return wc_get_order_status_name( $status );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param mixed $value Input value.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $status Raw status input.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param string $status Target status.
+	 * @return string
+	 */
+	private function get_irreversible_warning( $status ) {
+		if ( in_array( $status, array( 'cancelled', 'refunded' ), true ) ) {
+			return 'This change is irreversible.';
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}


thinking
**Analyzing filter argument handling and sanitization improvements**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/OrderStatusHandler.php
@@ -421,3 +421,3 @@
 		if ( ! $notify_customer ) {
-			$filter = function () {
+			$filter = function ( $enabled, $email ) {
 				return false;
apply_patch(auto_approved=true) exited 0 in 33ms:
Success. Updated the following files:
M src/Handlers/OrderStatusHandler.php
file update:
diff --git a/src/Handlers/OrderStatusHandler.php b/src/Handlers/OrderStatusHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..a2f5f6d5f5e59324c9d5b7ee4f3f399ac0e00ac8
--- /dev/null
+++ b/src/Handlers/OrderStatusHandler.php
@@ -0,0 +1,661 @@
+<?php
+/**
+ * Handle order status draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class OrderStatusHandler {
+	const DRAFT_TYPE = 'status_update';
+	const MAX_BULK   = 50;
+
+	/**
+	 * Handle order status requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_status_update( $args['draft_id'] );
+		}
+
+		if ( isset( $args['order_ids'] ) ) {
+			return $this->prepare_bulk_status_update( $args );
+		}
+
+		return $this->prepare_status_update( $args );
+	}
+
+	/**
+	 * Prepare a draft order status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare status updates.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for status update.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update.', 404 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $args['note'] ) ? sanitize_text_field( wp_unslash( $args['note'] ) ) : '';
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+		$warning         = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_id'       => $order_id,
+			'current_status' => $current_status,
+			'new_status'     => $new_status,
+			'note'           => $note,
+			'notify_customer' => $notify_customer,
+			'warning'        => $warning,
+			'preview'        => array(
+				'transition' => $current_status . ' -> ' . $new_status,
+				'warning'    => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft bulk status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_bulk_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk status updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk status update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for bulk update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$previews       = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$previews[] = array(
+				'order_id'       => $order_id,
+				'current_status' => $current_status,
+				'new_status'     => $new_status,
+				'transition'     => $current_status . ' -> ' . $new_status,
+			);
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$warning = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_ids'  => $order_ids,
+			'new_status' => $new_status,
+			'warning'    => $warning,
+			'preview'    => array(
+				'order_count' => count( $order_ids ),
+				'orders'      => $previews,
+				'warning'     => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft status update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_status_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to update order statuses.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing status update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Status update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for status update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		if ( isset( $payload['order_ids'] ) ) {
+			return $this->confirm_bulk_status_update( $draft_id, $payload );
+		}
+
+		return $this->confirm_single_status_update( $draft_id, $payload );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_single_status_update( $draft_id, array $payload ): Response {
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Status update draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update confirmation.', 404 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $payload['note'] ) ? (string) $payload['note'] : '';
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+		$audit_note      = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, false );
+
+		$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+		if ( ! $updated ) {
+			return Response::error( 'Unable to apply status update.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'order_id'       => $order_id,
+				'previous_status' => $current_status,
+				'new_status'     => $new_status,
+				'notified'       => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_bulk_status_update( $draft_id, array $payload ): Response {
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk status update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$orders         = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$orders[ $order_id ] = $order;
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$updated_orders = array();
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+
+		foreach ( $orders as $order_id => $order ) {
+			$current_status = $this->normalize_status( $order->get_status() );
+			$audit_note     = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, '', true );
+
+			$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+			if ( $updated ) {
+				$updated_orders[] = $order_id;
+			}
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'order_ids'  => $order_ids,
+				'new_status' => $new_status,
+				'updated'    => $updated_orders,
+				'notified'   => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $new_status Target status.
+	 * @param string $note Order note.
+	 * @param bool   $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function ( $enabled, $email ) {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param int    $order_id Order ID.
+	 * @param string $current_status Current status.
+	 * @param string $new_status Target status.
+	 * @param string $note Optional note.
+	 * @param bool   $is_bulk Bulk flag.
+	 * @return string
+	 */
+	private function build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, $is_bulk ) {
+		$summary = sprintf(
+			'[AgentWP] %s status update confirmed (draft %s) for order #%d. %s -> %s.',
+			$is_bulk ? 'Bulk' : 'Order',
+			$draft_id,
+			$order_id,
+			$this->get_status_label( $current_status ),
+			$this->get_status_label( $new_status )
+		);
+
+		$note = trim( (string) $note );
+		if ( '' !== $note ) {
+			$summary .= ' Note: ' . $note . '.';
+		}
+
+		return $summary;
+	}
+
+	/**
+	 * @param string $status Status slug.
+	 * @return string
+	 */
+	private function get_status_label( $status ) {
+		if ( function_exists( 'wc_get_order_status_name' ) ) {
+			return wc_get_order_status_name( $status );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param mixed $value Input value.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $status Raw status input.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param string $status Target status.
+	 * @return string
+	 */
+	private function get_irreversible_warning( $status ) {
+		if ( in_array( $status, array( 'cancelled', 'refunded' ), true ) ) {
+			return 'This change is irreversible.';
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}

file update:
diff --git a/src/Handlers/OrderStatusHandler.php b/src/Handlers/OrderStatusHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..a2f5f6d5f5e59324c9d5b7ee4f3f399ac0e00ac8
--- /dev/null
+++ b/src/Handlers/OrderStatusHandler.php
@@ -0,0 +1,661 @@
+<?php
+/**
+ * Handle order status draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class OrderStatusHandler {
+	const DRAFT_TYPE = 'status_update';
+	const MAX_BULK   = 50;
+
+	/**
+	 * Handle order status requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_status_update( $args['draft_id'] );
+		}
+
+		if ( isset( $args['order_ids'] ) ) {
+			return $this->prepare_bulk_status_update( $args );
+		}
+
+		return $this->prepare_status_update( $args );
+	}
+
+	/**
+	 * Prepare a draft order status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare status updates.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for status update.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update.', 404 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $args['note'] ) ? sanitize_text_field( wp_unslash( $args['note'] ) ) : '';
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+		$warning         = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_id'       => $order_id,
+			'current_status' => $current_status,
+			'new_status'     => $new_status,
+			'note'           => $note,
+			'notify_customer' => $notify_customer,
+			'warning'        => $warning,
+			'preview'        => array(
+				'transition' => $current_status . ' -> ' . $new_status,
+				'warning'    => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft bulk status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_bulk_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk status updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk status update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for bulk update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$previews       = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$previews[] = array(
+				'order_id'       => $order_id,
+				'current_status' => $current_status,
+				'new_status'     => $new_status,
+				'transition'     => $current_status . ' -> ' . $new_status,
+			);
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$warning = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_ids'  => $order_ids,
+			'new_status' => $new_status,
+			'warning'    => $warning,
+			'preview'    => array(
+				'order_count' => count( $order_ids ),
+				'orders'      => $previews,
+				'warning'     => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft status update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_status_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to update order statuses.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing status update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Status update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for status update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		if ( isset( $payload['order_ids'] ) ) {
+			return $this->confirm_bulk_status_update( $draft_id, $payload );
+		}
+
+		return $this->confirm_single_status_update( $draft_id, $payload );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_single_status_update( $draft_id, array $payload ): Response {
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Status update draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update confirmation.', 404 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $payload['note'] ) ? (string) $payload['note'] : '';
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+		$audit_note      = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, false );
+
+		$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+		if ( ! $updated ) {
+			return Response::error( 'Unable to apply status update.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'order_id'       => $order_id,
+				'previous_status' => $current_status,
+				'new_status'     => $new_status,
+				'notified'       => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_bulk_status_update( $draft_id, array $payload ): Response {
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk status update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$orders         = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$orders[ $order_id ] = $order;
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$updated_orders = array();
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+
+		foreach ( $orders as $order_id => $order ) {
+			$current_status = $this->normalize_status( $order->get_status() );
+			$audit_note     = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, '', true );
+
+			$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+			if ( $updated ) {
+				$updated_orders[] = $order_id;
+			}
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'order_ids'  => $order_ids,
+				'new_status' => $new_status,
+				'updated'    => $updated_orders,
+				'notified'   => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $new_status Target status.
+	 * @param string $note Order note.
+	 * @param bool   $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function ( $enabled, $email ) {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param int    $order_id Order ID.
+	 * @param string $current_status Current status.
+	 * @param string $new_status Target status.
+	 * @param string $note Optional note.
+	 * @param bool   $is_bulk Bulk flag.
+	 * @return string
+	 */
+	private function build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, $is_bulk ) {
+		$summary = sprintf(
+			'[AgentWP] %s status update confirmed (draft %s) for order #%d. %s -> %s.',
+			$is_bulk ? 'Bulk' : 'Order',
+			$draft_id,
+			$order_id,
+			$this->get_status_label( $current_status ),
+			$this->get_status_label( $new_status )
+		);
+
+		$note = trim( (string) $note );
+		if ( '' !== $note ) {
+			$summary .= ' Note: ' . $note . '.';
+		}
+
+		return $summary;
+	}
+
+	/**
+	 * @param string $status Status slug.
+	 * @return string
+	 */
+	private function get_status_label( $status ) {
+		if ( function_exists( 'wc_get_order_status_name' ) ) {
+			return wc_get_order_status_name( $status );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param mixed $value Input value.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $status Raw status input.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param string $status Target status.
+	 * @return string
+	 */
+	private function get_irreversible_warning( $status ) {
+		if ( in_array( $status, array( 'cancelled', 'refunded' ), true ) ) {
+			return 'This change is irreversible.';
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}


thinking
**Analyzing OrderStatusHandler update considerations**
exec
/bin/zsh -lc 'rg -n "dispatch|call_user_func|function_name" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/AI/OpenAIClient.php:458:				call_user_func( $this->on_stream, $chunk );
src/Intent/FunctionRegistry.php:17:	 * @param string  $function_name OpenAI function name.
src/Intent/FunctionRegistry.php:21:	public function register( $function_name, Handler $handler ) {
src/Intent/FunctionRegistry.php:22:		$function_name = is_string( $function_name ) ? trim( $function_name ) : '';
src/Intent/FunctionRegistry.php:23:		if ( '' === $function_name ) {
src/Intent/FunctionRegistry.php:27:		$this->map[ $function_name ] = $handler;
src/Intent/FunctionRegistry.php:31:	 * @param string $function_name OpenAI function name.
src/Intent/FunctionRegistry.php:34:	public function get_handler( $function_name ) {
src/Intent/FunctionRegistry.php:35:		$function_name = is_string( $function_name ) ? trim( $function_name ) : '';
src/Intent/FunctionRegistry.php:36:		if ( '' === $function_name ) {
src/Intent/FunctionRegistry.php:40:		return isset( $this->map[ $function_name ] ) ? $this->map[ $function_name ] : null;
src/Intent/FunctionRegistry.php:51:		foreach ( $this->map as $function_name => $handler ) {
src/Intent/FunctionRegistry.php:53:				$names[] = $function_name;
src/Intent/Engine.php:191:			foreach ( $functions as $function_name ) {
src/Intent/Engine.php:192:				$this->function_registry->register( $function_name, $handler );
src/Plugin.php:76:		add_filter( 'rest_post_dispatch', array( $this, 'format_rest_response' ), 10, 3 );
file update:
diff --git a/src/Handlers/OrderStatusHandler.php b/src/Handlers/OrderStatusHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..a2f5f6d5f5e59324c9d5b7ee4f3f399ac0e00ac8
--- /dev/null
+++ b/src/Handlers/OrderStatusHandler.php
@@ -0,0 +1,661 @@
+<?php
+/**
+ * Handle order status draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class OrderStatusHandler {
+	const DRAFT_TYPE = 'status_update';
+	const MAX_BULK   = 50;
+
+	/**
+	 * Handle order status requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_status_update( $args['draft_id'] );
+		}
+
+		if ( isset( $args['order_ids'] ) ) {
+			return $this->prepare_bulk_status_update( $args );
+		}
+
+		return $this->prepare_status_update( $args );
+	}
+
+	/**
+	 * Prepare a draft order status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare status updates.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for status update.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update.', 404 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $args['note'] ) ? sanitize_text_field( wp_unslash( $args['note'] ) ) : '';
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+		$warning         = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_id'       => $order_id,
+			'current_status' => $current_status,
+			'new_status'     => $new_status,
+			'note'           => $note,
+			'notify_customer' => $notify_customer,
+			'warning'        => $warning,
+			'preview'        => array(
+				'transition' => $current_status . ' -> ' . $new_status,
+				'warning'    => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft bulk status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_bulk_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk status updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk status update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for bulk update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$previews       = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$previews[] = array(
+				'order_id'       => $order_id,
+				'current_status' => $current_status,
+				'new_status'     => $new_status,
+				'transition'     => $current_status . ' -> ' . $new_status,
+			);
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$warning = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_ids'  => $order_ids,
+			'new_status' => $new_status,
+			'warning'    => $warning,
+			'preview'    => array(
+				'order_count' => count( $order_ids ),
+				'orders'      => $previews,
+				'warning'     => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft status update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_status_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to update order statuses.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing status update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Status update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for status update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		if ( isset( $payload['order_ids'] ) ) {
+			return $this->confirm_bulk_status_update( $draft_id, $payload );
+		}
+
+		return $this->confirm_single_status_update( $draft_id, $payload );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_single_status_update( $draft_id, array $payload ): Response {
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Status update draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update confirmation.', 404 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $payload['note'] ) ? (string) $payload['note'] : '';
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+		$audit_note      = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, false );
+
+		$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+		if ( ! $updated ) {
+			return Response::error( 'Unable to apply status update.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'order_id'       => $order_id,
+				'previous_status' => $current_status,
+				'new_status'     => $new_status,
+				'notified'       => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_bulk_status_update( $draft_id, array $payload ): Response {
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk status update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$orders         = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$orders[ $order_id ] = $order;
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$updated_orders = array();
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+
+		foreach ( $orders as $order_id => $order ) {
+			$current_status = $this->normalize_status( $order->get_status() );
+			$audit_note     = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, '', true );
+
+			$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+			if ( $updated ) {
+				$updated_orders[] = $order_id;
+			}
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'order_ids'  => $order_ids,
+				'new_status' => $new_status,
+				'updated'    => $updated_orders,
+				'notified'   => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $new_status Target status.
+	 * @param string $note Order note.
+	 * @param bool   $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function ( $enabled, $email ) {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param int    $order_id Order ID.
+	 * @param string $current_status Current status.
+	 * @param string $new_status Target status.
+	 * @param string $note Optional note.
+	 * @param bool   $is_bulk Bulk flag.
+	 * @return string
+	 */
+	private function build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, $is_bulk ) {
+		$summary = sprintf(
+			'[AgentWP] %s status update confirmed (draft %s) for order #%d. %s -> %s.',
+			$is_bulk ? 'Bulk' : 'Order',
+			$draft_id,
+			$order_id,
+			$this->get_status_label( $current_status ),
+			$this->get_status_label( $new_status )
+		);
+
+		$note = trim( (string) $note );
+		if ( '' !== $note ) {
+			$summary .= ' Note: ' . $note . '.';
+		}
+
+		return $summary;
+	}
+
+	/**
+	 * @param string $status Status slug.
+	 * @return string
+	 */
+	private function get_status_label( $status ) {
+		if ( function_exists( 'wc_get_order_status_name' ) ) {
+			return wc_get_order_status_name( $status );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param mixed $value Input value.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $status Raw status input.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param string $status Target status.
+	 * @return string
+	 */
+	private function get_irreversible_warning( $status ) {
+		if ( in_array( $status, array( 'cancelled', 'refunded' ), true ) ) {
+			return 'This change is irreversible.';
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}


thinking
**Reviewing bulk status update notification logic**

I'm thinking through how to handle the `notify_customer` flag in bulk status updates since the schema lacks it. To stay consistent and avoid unexpected emails, I plan to default it to false but keep the option to override it via args, explicitly adding it to the payload for clarity. This way, confirmation steps can use that flag properly, keeping behavior explicit and safe.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/OrderStatusHandler.php
@@ -199,9 +199,11 @@
 
-		$warning = $this->get_irreversible_warning( $new_status );
+		$warning         = $this->get_irreversible_warning( $new_status );
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
 
 		$draft_payload = array(
-			'order_ids'  => $order_ids,
-			'new_status' => $new_status,
-			'warning'    => $warning,
-			'preview'    => array(
+			'order_ids'       => $order_ids,
+			'new_status'      => $new_status,
+			'notify_customer' => $notify_customer,
+			'warning'         => $warning,
+			'preview'         => array(
 				'order_count' => count( $order_ids ),
apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M src/Handlers/OrderStatusHandler.php
file update:
diff --git a/src/Handlers/OrderStatusHandler.php b/src/Handlers/OrderStatusHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..102d15dfdb616513ac7872f297daa67b66016010
--- /dev/null
+++ b/src/Handlers/OrderStatusHandler.php
@@ -0,0 +1,663 @@
+<?php
+/**
+ * Handle order status draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class OrderStatusHandler {
+	const DRAFT_TYPE = 'status_update';
+	const MAX_BULK   = 50;
+
+	/**
+	 * Handle order status requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_status_update( $args['draft_id'] );
+		}
+
+		if ( isset( $args['order_ids'] ) ) {
+			return $this->prepare_bulk_status_update( $args );
+		}
+
+		return $this->prepare_status_update( $args );
+	}
+
+	/**
+	 * Prepare a draft order status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare status updates.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for status update.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update.', 404 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $args['note'] ) ? sanitize_text_field( wp_unslash( $args['note'] ) ) : '';
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+		$warning         = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_id'       => $order_id,
+			'current_status' => $current_status,
+			'new_status'     => $new_status,
+			'note'           => $note,
+			'notify_customer' => $notify_customer,
+			'warning'        => $warning,
+			'preview'        => array(
+				'transition' => $current_status . ' -> ' . $new_status,
+				'warning'    => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft bulk status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_bulk_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk status updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk status update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for bulk update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$previews       = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$previews[] = array(
+				'order_id'       => $order_id,
+				'current_status' => $current_status,
+				'new_status'     => $new_status,
+				'transition'     => $current_status . ' -> ' . $new_status,
+			);
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$warning         = $this->get_irreversible_warning( $new_status );
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+
+		$draft_payload = array(
+			'order_ids'       => $order_ids,
+			'new_status'      => $new_status,
+			'notify_customer' => $notify_customer,
+			'warning'         => $warning,
+			'preview'         => array(
+				'order_count' => count( $order_ids ),
+				'orders'      => $previews,
+				'warning'     => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft status update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_status_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to update order statuses.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing status update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Status update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for status update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		if ( isset( $payload['order_ids'] ) ) {
+			return $this->confirm_bulk_status_update( $draft_id, $payload );
+		}
+
+		return $this->confirm_single_status_update( $draft_id, $payload );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_single_status_update( $draft_id, array $payload ): Response {
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Status update draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update confirmation.', 404 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $payload['note'] ) ? (string) $payload['note'] : '';
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+		$audit_note      = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, false );
+
+		$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+		if ( ! $updated ) {
+			return Response::error( 'Unable to apply status update.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'order_id'       => $order_id,
+				'previous_status' => $current_status,
+				'new_status'     => $new_status,
+				'notified'       => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_bulk_status_update( $draft_id, array $payload ): Response {
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk status update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$orders         = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$orders[ $order_id ] = $order;
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$updated_orders = array();
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+
+		foreach ( $orders as $order_id => $order ) {
+			$current_status = $this->normalize_status( $order->get_status() );
+			$audit_note     = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, '', true );
+
+			$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+			if ( $updated ) {
+				$updated_orders[] = $order_id;
+			}
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'order_ids'  => $order_ids,
+				'new_status' => $new_status,
+				'updated'    => $updated_orders,
+				'notified'   => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $new_status Target status.
+	 * @param string $note Order note.
+	 * @param bool   $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function ( $enabled, $email ) {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param int    $order_id Order ID.
+	 * @param string $current_status Current status.
+	 * @param string $new_status Target status.
+	 * @param string $note Optional note.
+	 * @param bool   $is_bulk Bulk flag.
+	 * @return string
+	 */
+	private function build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, $is_bulk ) {
+		$summary = sprintf(
+			'[AgentWP] %s status update confirmed (draft %s) for order #%d. %s -> %s.',
+			$is_bulk ? 'Bulk' : 'Order',
+			$draft_id,
+			$order_id,
+			$this->get_status_label( $current_status ),
+			$this->get_status_label( $new_status )
+		);
+
+		$note = trim( (string) $note );
+		if ( '' !== $note ) {
+			$summary .= ' Note: ' . $note . '.';
+		}
+
+		return $summary;
+	}
+
+	/**
+	 * @param string $status Status slug.
+	 * @return string
+	 */
+	private function get_status_label( $status ) {
+		if ( function_exists( 'wc_get_order_status_name' ) ) {
+			return wc_get_order_status_name( $status );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param mixed $value Input value.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $status Raw status input.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param string $status Target status.
+	 * @return string
+	 */
+	private function get_irreversible_warning( $status ) {
+		if ( in_array( $status, array( 'cancelled', 'refunded' ), true ) ) {
+			return 'This change is irreversible.';
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}

file update:
diff --git a/src/Handlers/OrderStatusHandler.php b/src/Handlers/OrderStatusHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..102d15dfdb616513ac7872f297daa67b66016010
--- /dev/null
+++ b/src/Handlers/OrderStatusHandler.php
@@ -0,0 +1,663 @@
+<?php
+/**
+ * Handle order status draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class OrderStatusHandler {
+	const DRAFT_TYPE = 'status_update';
+	const MAX_BULK   = 50;
+
+	/**
+	 * Handle order status requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_status_update( $args['draft_id'] );
+		}
+
+		if ( isset( $args['order_ids'] ) ) {
+			return $this->prepare_bulk_status_update( $args );
+		}
+
+		return $this->prepare_status_update( $args );
+	}
+
+	/**
+	 * Prepare a draft order status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare status updates.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for status update.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update.', 404 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $args['note'] ) ? sanitize_text_field( wp_unslash( $args['note'] ) ) : '';
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+		$warning         = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_id'       => $order_id,
+			'current_status' => $current_status,
+			'new_status'     => $new_status,
+			'note'           => $note,
+			'notify_customer' => $notify_customer,
+			'warning'        => $warning,
+			'preview'        => array(
+				'transition' => $current_status . ' -> ' . $new_status,
+				'warning'    => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft bulk status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_bulk_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk status updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk status update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for bulk update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$previews       = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$previews[] = array(
+				'order_id'       => $order_id,
+				'current_status' => $current_status,
+				'new_status'     => $new_status,
+				'transition'     => $current_status . ' -> ' . $new_status,
+			);
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$warning         = $this->get_irreversible_warning( $new_status );
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+
+		$draft_payload = array(
+			'order_ids'       => $order_ids,
+			'new_status'      => $new_status,
+			'notify_customer' => $notify_customer,
+			'warning'         => $warning,
+			'preview'         => array(
+				'order_count' => count( $order_ids ),
+				'orders'      => $previews,
+				'warning'     => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft status update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_status_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to update order statuses.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing status update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Status update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for status update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		if ( isset( $payload['order_ids'] ) ) {
+			return $this->confirm_bulk_status_update( $draft_id, $payload );
+		}
+
+		return $this->confirm_single_status_update( $draft_id, $payload );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_single_status_update( $draft_id, array $payload ): Response {
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Status update draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update confirmation.', 404 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $payload['note'] ) ? (string) $payload['note'] : '';
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+		$audit_note      = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, false );
+
+		$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+		if ( ! $updated ) {
+			return Response::error( 'Unable to apply status update.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'order_id'       => $order_id,
+				'previous_status' => $current_status,
+				'new_status'     => $new_status,
+				'notified'       => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_bulk_status_update( $draft_id, array $payload ): Response {
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk status update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$orders         = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$orders[ $order_id ] = $order;
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$updated_orders = array();
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+
+		foreach ( $orders as $order_id => $order ) {
+			$current_status = $this->normalize_status( $order->get_status() );
+			$audit_note     = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, '', true );
+
+			$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+			if ( $updated ) {
+				$updated_orders[] = $order_id;
+			}
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'order_ids'  => $order_ids,
+				'new_status' => $new_status,
+				'updated'    => $updated_orders,
+				'notified'   => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $new_status Target status.
+	 * @param string $note Order note.
+	 * @param bool   $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function ( $enabled, $email ) {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param int    $order_id Order ID.
+	 * @param string $current_status Current status.
+	 * @param string $new_status Target status.
+	 * @param string $note Optional note.
+	 * @param bool   $is_bulk Bulk flag.
+	 * @return string
+	 */
+	private function build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, $is_bulk ) {
+		$summary = sprintf(
+			'[AgentWP] %s status update confirmed (draft %s) for order #%d. %s -> %s.',
+			$is_bulk ? 'Bulk' : 'Order',
+			$draft_id,
+			$order_id,
+			$this->get_status_label( $current_status ),
+			$this->get_status_label( $new_status )
+		);
+
+		$note = trim( (string) $note );
+		if ( '' !== $note ) {
+			$summary .= ' Note: ' . $note . '.';
+		}
+
+		return $summary;
+	}
+
+	/**
+	 * @param string $status Status slug.
+	 * @return string
+	 */
+	private function get_status_label( $status ) {
+		if ( function_exists( 'wc_get_order_status_name' ) ) {
+			return wc_get_order_status_name( $status );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param mixed $value Input value.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $status Raw status input.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param string $status Target status.
+	 * @return string
+	 */
+	private function get_irreversible_warning( $status ) {
+		if ( in_array( $status, array( 'cancelled', 'refunded' ), true ) ) {
+			return 'This change is irreversible.';
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}


thinking
**Summarizing implementation details and next steps**

I've reviewed the order status update implementation covering draft preparation, confirmation with validation, audit note handling, notification suppression, and bulk update limits. Now I’m preparing a clear final response explaining these changes, verification approach, and potential follow-ups to complete the task thoroughly.
codex
Implemented a full order status draft/confirm handler so updates are validated, previewed, and only applied after explicit confirmation.

Summary of changes:
- Added `src/Handlers/OrderStatusHandler.php` to prepare single and bulk status update drafts with previews, irreversible-change warnings, and a 50-order cap.
- Confirm flow applies WooCommerce status updates, writes `[AgentWP]` audit notes, and suppresses emails when `notify_customer` is false.
- Drafts are stored in transients with the configured TTL and reject invalid statuses or no-op transitions.

Status: DONE

How to verify:
- (no commands provided)

Risks / follow-ups:
- Confirmation still requires a caller (tool/REST wiring) to invoke `confirm_status_update` with a `draft_id` if that plumbing isn’t already in place.
file update:
diff --git a/src/Handlers/OrderStatusHandler.php b/src/Handlers/OrderStatusHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..102d15dfdb616513ac7872f297daa67b66016010
--- /dev/null
+++ b/src/Handlers/OrderStatusHandler.php
@@ -0,0 +1,663 @@
+<?php
+/**
+ * Handle order status draft preparation and confirmation.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+
+class OrderStatusHandler {
+	const DRAFT_TYPE = 'status_update';
+	const MAX_BULK   = 50;
+
+	/**
+	 * Handle order status requests.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( isset( $args['draft_id'] ) ) {
+			return $this->confirm_status_update( $args['draft_id'] );
+		}
+
+		if ( isset( $args['order_ids'] ) ) {
+			return $this->prepare_bulk_status_update( $args );
+		}
+
+		return $this->prepare_status_update( $args );
+	}
+
+	/**
+	 * Prepare a draft order status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare status updates.', 400 );
+		}
+
+		$order_id = isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Missing order ID for status update.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update.', 404 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $args['note'] ) ? sanitize_text_field( wp_unslash( $args['note'] ) ) : '';
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+		$warning         = $this->get_irreversible_warning( $new_status );
+
+		$draft_payload = array(
+			'order_id'       => $order_id,
+			'current_status' => $current_status,
+			'new_status'     => $new_status,
+			'note'           => $note,
+			'notify_customer' => $notify_customer,
+			'warning'        => $warning,
+			'preview'        => array(
+				'transition' => $current_status . ' -> ' . $new_status,
+				'warning'    => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Prepare a draft bulk status update without applying it.
+	 *
+	 * @param array $args Request args.
+	 * @return Response
+	 */
+	public function prepare_bulk_status_update( array $args ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to prepare bulk status updates.', 400 );
+		}
+
+		$order_ids = $this->normalize_order_ids( isset( $args['order_ids'] ) ? $args['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Missing order IDs for bulk status update.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $args['new_status'] ) ? $this->normalize_status( $args['new_status'] ) : '';
+		if ( '' === $new_status ) {
+			return Response::error( 'Missing new status for bulk update.', 400 );
+		}
+
+		$valid_statuses = $this->get_valid_statuses();
+		if ( ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error(
+				sprintf(
+					'Invalid status "%s". Valid statuses: %s.',
+					$new_status,
+					implode( ', ', $valid_statuses )
+				),
+				400
+			);
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$previews       = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$previews[] = array(
+				'order_id'       => $order_id,
+				'current_status' => $current_status,
+				'new_status'     => $new_status,
+				'transition'     => $current_status . ' -> ' . $new_status,
+			);
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$warning         = $this->get_irreversible_warning( $new_status );
+		$notify_customer = $this->normalize_bool( isset( $args['notify_customer'] ) ? $args['notify_customer'] : false );
+
+		$draft_payload = array(
+			'order_ids'       => $order_ids,
+			'new_status'      => $new_status,
+			'notify_customer' => $notify_customer,
+			'warning'         => $warning,
+			'preview'         => array(
+				'order_count' => count( $order_ids ),
+				'orders'      => $previews,
+				'warning'     => $warning,
+			),
+		);
+
+		$draft_id   = $this->generate_draft_id();
+		$ttl        = $this->get_draft_ttl_seconds();
+		$expires_at = gmdate( 'c', time() + $ttl );
+		$stored     = $this->store_draft(
+			$draft_id,
+			array(
+				'id'         => $draft_id,
+				'type'       => self::DRAFT_TYPE,
+				'payload'    => $draft_payload,
+				'expires_at' => $expires_at,
+			),
+			$ttl
+		);
+
+		if ( ! $stored ) {
+			return Response::error( 'Unable to store bulk status update draft.', 500 );
+		}
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'draft'      => $draft_payload,
+				'expires_at' => $expires_at,
+			)
+		);
+	}
+
+	/**
+	 * Confirm and apply a draft status update.
+	 *
+	 * @param string $draft_id Draft identifier.
+	 * @return Response
+	 */
+	public function confirm_status_update( $draft_id ): Response {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_order_statuses' ) ) {
+			return Response::error( 'WooCommerce is required to update order statuses.', 400 );
+		}
+
+		$draft_id = is_string( $draft_id ) ? trim( $draft_id ) : '';
+		if ( '' === $draft_id ) {
+			return Response::error( 'Missing status update draft ID.', 400 );
+		}
+
+		$draft = $this->load_draft( $draft_id );
+		if ( null === $draft ) {
+			return Response::error( 'Status update draft not found or expired.', 404 );
+		}
+
+		if ( isset( $draft['type'] ) && self::DRAFT_TYPE !== $draft['type'] ) {
+			return Response::error( 'Draft type mismatch for status update confirmation.', 400 );
+		}
+
+		$payload = isset( $draft['payload'] ) && is_array( $draft['payload'] ) ? $draft['payload'] : $draft;
+		if ( isset( $payload['order_ids'] ) ) {
+			return $this->confirm_bulk_status_update( $draft_id, $payload );
+		}
+
+		return $this->confirm_single_status_update( $draft_id, $payload );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_single_status_update( $draft_id, array $payload ): Response {
+		$order_id = isset( $payload['order_id'] ) ? absint( $payload['order_id'] ) : 0;
+		if ( 0 === $order_id ) {
+			return Response::error( 'Status update draft is missing the order ID.', 400 );
+		}
+
+		$order = wc_get_order( $order_id );
+		if ( ! $order ) {
+			return Response::error( 'Order not found for status update confirmation.', 404 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$current_status = $this->normalize_status( $order->get_status() );
+		if ( $new_status === $current_status ) {
+			return Response::error( 'Order already has the requested status.', 400 );
+		}
+
+		$note            = isset( $payload['note'] ) ? (string) $payload['note'] : '';
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+		$audit_note      = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, false );
+
+		$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+		if ( ! $updated ) {
+			return Response::error( 'Unable to apply status update.', 500 );
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'       => $draft_id,
+				'order_id'       => $order_id,
+				'previous_status' => $current_status,
+				'new_status'     => $new_status,
+				'notified'       => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $payload Draft payload.
+	 * @return Response
+	 */
+	private function confirm_bulk_status_update( $draft_id, array $payload ): Response {
+		$order_ids = $this->normalize_order_ids( isset( $payload['order_ids'] ) ? $payload['order_ids'] : array() );
+		if ( empty( $order_ids ) ) {
+			return Response::error( 'Bulk status update draft is missing order IDs.', 400 );
+		}
+
+		if ( count( $order_ids ) > self::MAX_BULK ) {
+			return Response::error( 'Bulk status updates support up to 50 orders at a time.', 400 );
+		}
+
+		$new_status = isset( $payload['new_status'] ) ? $this->normalize_status( $payload['new_status'] ) : '';
+		$valid_statuses = $this->get_valid_statuses();
+		if ( '' === $new_status || ! in_array( $new_status, $valid_statuses, true ) ) {
+			return Response::error( 'Draft contains an invalid target status.', 400 );
+		}
+
+		$missing_orders = array();
+		$invalid_orders = array();
+		$orders         = array();
+
+		foreach ( $order_ids as $order_id ) {
+			$order = wc_get_order( $order_id );
+			if ( ! $order ) {
+				$missing_orders[] = $order_id;
+				continue;
+			}
+
+			$current_status = $this->normalize_status( $order->get_status() );
+			if ( $current_status === $new_status ) {
+				$invalid_orders[] = $order_id;
+				continue;
+			}
+
+			$orders[ $order_id ] = $order;
+		}
+
+		if ( ! empty( $missing_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders not found: %s.', implode( ', ', $missing_orders ) ),
+				404,
+				array( 'missing_orders' => $missing_orders )
+			);
+		}
+
+		if ( ! empty( $invalid_orders ) ) {
+			return Response::error(
+				sprintf( 'Orders already have the requested status: %s.', implode( ', ', $invalid_orders ) ),
+				400,
+				array( 'invalid_orders' => $invalid_orders )
+			);
+		}
+
+		$updated_orders = array();
+		$notify_customer = $this->normalize_bool( isset( $payload['notify_customer'] ) ? $payload['notify_customer'] : false );
+
+		foreach ( $orders as $order_id => $order ) {
+			$current_status = $this->normalize_status( $order->get_status() );
+			$audit_note     = $this->build_audit_note( $draft_id, $order_id, $current_status, $new_status, '', true );
+
+			$updated = $this->apply_status_update( $order, $new_status, $audit_note, $notify_customer );
+			if ( $updated ) {
+				$updated_orders[] = $order_id;
+			}
+		}
+
+		$this->delete_draft( $draft_id );
+
+		return Response::success(
+			array(
+				'draft_id'   => $draft_id,
+				'order_ids'  => $order_ids,
+				'new_status' => $new_status,
+				'updated'    => $updated_orders,
+				'notified'   => $notify_customer,
+			)
+		);
+	}
+
+	/**
+	 * @param mixed  $order Order instance.
+	 * @param string $new_status Target status.
+	 * @param string $note Order note.
+	 * @param bool   $notify_customer Notify flag.
+	 * @return bool
+	 */
+	private function apply_status_update( $order, $new_status, $note, $notify_customer ) {
+		if ( ! $order || ! method_exists( $order, 'update_status' ) ) {
+			return false;
+		}
+
+		$notify_customer = $this->normalize_bool( $notify_customer );
+		$notify_customer = apply_filters( 'agentwp_status_notify_customer', $notify_customer, $order, $new_status );
+
+		$filter = null;
+		if ( ! $notify_customer ) {
+			$filter = function ( $enabled, $email ) {
+				return false;
+			};
+			add_filter( 'woocommerce_email_enabled', $filter, 10, 2 );
+		}
+
+		$order->update_status( $new_status, $note );
+
+		if ( $filter ) {
+			remove_filter( 'woocommerce_email_enabled', $filter, 10 );
+		}
+
+		return true;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param int    $order_id Order ID.
+	 * @param string $current_status Current status.
+	 * @param string $new_status Target status.
+	 * @param string $note Optional note.
+	 * @param bool   $is_bulk Bulk flag.
+	 * @return string
+	 */
+	private function build_audit_note( $draft_id, $order_id, $current_status, $new_status, $note, $is_bulk ) {
+		$summary = sprintf(
+			'[AgentWP] %s status update confirmed (draft %s) for order #%d. %s -> %s.',
+			$is_bulk ? 'Bulk' : 'Order',
+			$draft_id,
+			$order_id,
+			$this->get_status_label( $current_status ),
+			$this->get_status_label( $new_status )
+		);
+
+		$note = trim( (string) $note );
+		if ( '' !== $note ) {
+			$summary .= ' Note: ' . $note . '.';
+		}
+
+		return $summary;
+	}
+
+	/**
+	 * @param string $status Status slug.
+	 * @return string
+	 */
+	private function get_status_label( $status ) {
+		if ( function_exists( 'wc_get_order_status_name' ) ) {
+			return wc_get_order_status_name( $status );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param mixed $value Input value.
+	 * @return bool
+	 */
+	private function normalize_bool( $value ) {
+		if ( function_exists( 'rest_sanitize_boolean' ) ) {
+			return rest_sanitize_boolean( $value );
+		}
+
+		return (bool) $value;
+	}
+
+	/**
+	 * @param mixed $status Raw status input.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = is_string( $status ) ? strtolower( trim( $status ) ) : '';
+
+		if ( '' === $status ) {
+			return '';
+		}
+
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return sanitize_key( $status );
+	}
+
+	/**
+	 * @return array
+	 */
+	private function get_valid_statuses() {
+		$allowed = array( 'pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed' );
+		$normalized = array();
+
+		if ( function_exists( 'wc_get_order_statuses' ) ) {
+			$statuses = wc_get_order_statuses();
+			if ( is_array( $statuses ) ) {
+				foreach ( array_keys( $statuses ) as $status ) {
+					$normalized_status = $this->normalize_status( $status );
+					if ( '' !== $normalized_status ) {
+						$normalized[] = $normalized_status;
+					}
+				}
+			}
+		}
+
+		if ( ! empty( $normalized ) ) {
+			$allowed = array_values( array_intersect( $allowed, $normalized ) );
+		}
+
+		sort( $allowed );
+
+		return $allowed;
+	}
+
+	/**
+	 * @param string $status Target status.
+	 * @return string
+	 */
+	private function get_irreversible_warning( $status ) {
+		if ( in_array( $status, array( 'cancelled', 'refunded' ), true ) ) {
+			return 'This change is irreversible.';
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param mixed $order_ids Order ID input.
+	 * @return array
+	 */
+	private function normalize_order_ids( $order_ids ) {
+		$ids = array();
+
+		if ( is_string( $order_ids ) ) {
+			$order_ids = preg_split( '/[\s,]+/', $order_ids );
+		}
+
+		if ( ! is_array( $order_ids ) ) {
+			return $ids;
+		}
+
+		foreach ( $order_ids as $order_id ) {
+			$normalized = absint( $order_id );
+			if ( $normalized > 0 ) {
+				$ids[] = $normalized;
+			}
+		}
+
+		$ids = array_values( array_unique( $ids ) );
+
+		return $ids;
+	}
+
+	/**
+	 * @return string
+	 */
+	private function generate_draft_id() {
+		if ( function_exists( 'wp_generate_uuid4' ) ) {
+			return wp_generate_uuid4();
+		}
+
+		return uniqid( 'draft_', true );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return string
+	 */
+	private function build_draft_key( $draft_id ) {
+		return Plugin::TRANSIENT_PREFIX . 'draft_' . $draft_id;
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_draft_ttl_seconds() {
+		$ttl_minutes = null;
+
+		if ( function_exists( 'get_option' ) ) {
+			$option_ttl = get_option( Plugin::OPTION_DRAFT_TTL, null );
+			if ( null !== $option_ttl && '' !== $option_ttl ) {
+				$ttl_minutes = intval( $option_ttl );
+			}
+		}
+
+		if ( null === $ttl_minutes && function_exists( 'get_option' ) ) {
+			$settings = get_option( Plugin::OPTION_SETTINGS, array() );
+			if ( is_array( $settings ) && isset( $settings['draft_ttl_minutes'] ) ) {
+				$ttl_minutes = intval( $settings['draft_ttl_minutes'] );
+			}
+		}
+
+		if ( ! is_int( $ttl_minutes ) || $ttl_minutes <= 0 ) {
+			$ttl_minutes = 10;
+		}
+
+		$minute_seconds = defined( 'MINUTE_IN_SECONDS' ) ? MINUTE_IN_SECONDS : 60;
+
+		return $ttl_minutes * $minute_seconds;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @param array  $draft Draft payload.
+	 * @param int    $ttl_seconds Expiration seconds.
+	 * @return bool
+	 */
+	private function store_draft( $draft_id, array $draft, $ttl_seconds ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return false;
+		}
+
+		return set_transient( $this->build_draft_key( $draft_id ), $draft, $ttl_seconds );
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return array|null
+	 */
+	private function load_draft( $draft_id ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$draft = get_transient( $this->build_draft_key( $draft_id ) );
+		if ( false === $draft || ! is_array( $draft ) ) {
+			return null;
+		}
+
+		return $draft;
+	}
+
+	/**
+	 * @param string $draft_id Draft identifier.
+	 * @return void
+	 */
+	private function delete_draft( $draft_id ) {
+		if ( function_exists( 'delete_transient' ) ) {
+			delete_transient( $this->build_draft_key( $draft_id ) );
+		}
+	}
+}

tokens used
119,913
