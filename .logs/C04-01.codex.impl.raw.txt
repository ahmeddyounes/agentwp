Status: DONE  
Bound the hooks/user interfaces to the WPFunctions singleton and removed IntentServiceProvider fallbacks so it resolves hooks purely from the container.

Summary of changes:
- Added bindings for `HooksInterface` and `WPUserFunctionsInterface` to the `WPFunctions` singleton in `src/Providers/CoreServiceProvider.php`.
- Switched IntentServiceProvider hook resolution to container-only and removed WPFunctions fallbacks in `src/Providers/IntentServiceProvider.php`.
- Updated unit setup to register `HooksInterface` in `tests/Unit/Intent/MemoryStoreConfigTest.php`.

How to verify (exact commands):
- No verification commands provided (format/lint/test entries were empty).

Risks / follow-ups:
- Tests not run (no commands provided).
- IntentServiceProvider now assumes a HooksInterface binding is present; ensure that binding is registered when using it outside CoreServiceProvider.

OpenAI Codex v0.87.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/agentwp
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019bd207-5d93-7371-b239-fb14e62c0252
--------
user
You are implementing task C04-01 in this git repository.

1) Read the spec: .plans/C04-01.md
2) Read handoff/context: .t2/handoff/C04-01.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: 
- test: 

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers
exec
/bin/zsh -lc ls in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 41ms:
agentwp.php
assets
composer.json
composer.lock
docker
docker-compose.demo.yml
docker-compose.yml
docs
includes
languages
node_modules
package-lock.json
package.json
phpcs.xml
phpstan
phpstan.neon
phpunit.xml.dist
plan_tasks.csv
playwright.config.cjs
react

thinking
**Preparing to read key planning files**
exec
/bin/zsh -lc "sed -n '1,200p' .plans/C04-01.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 65ms:
# C04-01 — Bind HooksInterface and WPUserFunctionsInterface in DI

In `src/Providers/CoreServiceProvider.php`, bind `AgentWP\\Contracts\\HooksInterface` and `AgentWP\\Contracts\\WPUserFunctionsInterface` to the `WPFunctions` singleton. Simplify `IntentServiceProvider` to rely on container resolution (remove fallbacks). Validate with PHPStan + PHPUnit.
exec
/bin/zsh -lc "sed -n '1,200p' .t2/handoff/C04-01.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 67ms:
# Handoff: C04-01

Created: 2026-01-18T16:54:16.692854Z

Spec: .plans/C04-01.md

thinking
**Identifying core service providers**

I'm locating CoreServiceProvider and IntentServiceProvider files using ripgrep to prepare for implementation.
exec
/bin/zsh -lc 'rg --line-number "CoreServiceProvider|IntentServiceProvider|HooksInterface|WPUserFunctionsInterface" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 71ms:
src/Providers/IntentServiceProvider.php:28:use AgentWP\Contracts\HooksInterface;
src/Providers/IntentServiceProvider.php:75:final class IntentServiceProvider extends ServiceProvider {
src/Providers/IntentServiceProvider.php:373:				$hooks = $this->container->has( HooksInterface::class )
src/Providers/IntentServiceProvider.php:374:					? $this->container->get( HooksInterface::class )
src/Providers/CoreServiceProvider.php:27:final class CoreServiceProvider extends ServiceProvider {
src/Infrastructure/CurrentUserContext.php:11:use AgentWP\Contracts\WPUserFunctionsInterface;
src/Infrastructure/CurrentUserContext.php:24:	 * @var WPUserFunctionsInterface
src/Infrastructure/CurrentUserContext.php:26:	private WPUserFunctionsInterface $wp;
src/Infrastructure/CurrentUserContext.php:31:	 * @param WPUserFunctionsInterface $wp WordPress functions wrapper.
src/Infrastructure/CurrentUserContext.php:33:	public function __construct( WPUserFunctionsInterface $wp ) {
src/Contracts/WPUserFunctionsInterface.php:17:interface WPUserFunctionsInterface {
src/Plugin.php:14:use AgentWP\Providers\CoreServiceProvider;
src/Plugin.php:16:use AgentWP\Providers\IntentServiceProvider;
src/Plugin.php:137:			new CoreServiceProvider( $this->container ),
src/Plugin.php:141:			new IntentServiceProvider( $this->container ),
src/Intent/Handlers/EmailDraftHandler.php:50:		// Tools are pre-registered via IntentServiceProvider::registerToolDispatcher().
src/Intent/Handlers/CustomerLookupHandler.php:50:		// Tools are pre-registered via IntentServiceProvider::registerToolDispatcher().
src/Intent/Handlers/AnalyticsQueryHandler.php:50:		// Tools are pre-registered via IntentServiceProvider::registerToolDispatcher().
src/Intent/Handlers/OrderStatusHandler.php:51:		// Tools are pre-registered via IntentServiceProvider::registerToolDispatcher().
src/Infrastructure/WPFunctions.php:10:use AgentWP\Contracts\HooksInterface;

thinking
**Preparing to inspect providers**
exec
/bin/zsh -lc "sed -n '1,220p' src/Providers/CoreServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 94ms:
<?php
/**
 * Core service provider.
 *
 * @package AgentWP\Providers
 */

namespace AgentWP\Providers;

use AgentWP\Container\ServiceProvider;
use AgentWP\Contracts\OptionsInterface;
use AgentWP\Infrastructure\WordPressOptions;
use AgentWP\Infrastructure\WPFunctions;
use AgentWP\Intent\HandlerRegistry;
use AgentWP\Intent\ContextProviders\UserContextProvider;
use AgentWP\Intent\ContextProviders\OrderContextProvider;
use AgentWP\Intent\ContextProviders\StoreContextProvider;
use AgentWP\Plugin\AdminMenuManager;
use AgentWP\Plugin\AssetManager;
use AgentWP\Plugin\SettingsManager;

thinking
**Reviewing singleton bindings**

I'm checking the WPFunctions singleton and related interfaces to bind HooksInterface and WPUserFunctionsInterface correctly.
exec
/bin/zsh -lc "sed -n '1,220p' src/Infrastructure/WPFunctions.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 45ms:
<?php
/**
 * WordPress functions wrapper.
 *
 * @package AgentWP\Infrastructure
 */

namespace AgentWP\Infrastructure;

use AgentWP\Contracts\HooksInterface;
use AgentWP\Contracts\WPUserFunctionsInterface;
use DateTimeZone;

/**
 * Wrapper for WordPress functions to enable testability.
 *
 * This class wraps WordPress core and WooCommerce functions,
 * allowing them to be mocked in unit tests. Use this wrapper
 * instead of calling WordPress functions directly in business logic.
 *

thinking
**Targeting IntentServiceProvider fallback removal**
exec
/bin/zsh -lc "sed -n '1,240p' src/Providers/IntentServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 32ms:
<?php
/**
 * Intent service provider.
 *
 * @package AgentWP\Providers
 */

namespace AgentWP\Providers;

use AgentWP\AI\Functions\ConfirmRefund;
use AgentWP\AI\Functions\ConfirmStatusUpdate;
use AgentWP\AI\Functions\ConfirmStockUpdate;
use AgentWP\AI\Functions\DraftEmail;
use AgentWP\AI\Functions\GetCustomerProfile;
use AgentWP\AI\Functions\GetSalesReport;
use AgentWP\AI\Functions\PrepareBulkStatusUpdate;
use AgentWP\AI\Functions\PrepareRefund;
use AgentWP\AI\Functions\PrepareStatusUpdate;
use AgentWP\AI\Functions\PrepareStockUpdate;
use AgentWP\AI\Functions\SearchOrders;
exec
/bin/zsh -lc "sed -n '240,520p' src/Providers/IntentServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 68ms:

		$this->container->singleton(
			ToolRegistryInterface::class,
			function () {
				$registry = new ToolRegistry();

				// Register all function schemas.
				$registry->register( new SearchOrders() );
				$registry->register( new PrepareRefund() );
				$registry->register( new ConfirmRefund() );
				$registry->register( new PrepareStatusUpdate() );
				$registry->register( new PrepareBulkStatusUpdate() );
				$registry->register( new ConfirmStatusUpdate() );
				$registry->register( new SearchProduct() );
				$registry->register( new PrepareStockUpdate() );
				$registry->register( new ConfirmStockUpdate() );
				$registry->register( new DraftEmail() );
				$registry->register( new GetSalesReport() );
				$registry->register( new GetCustomerProfile() );

exec
/bin/zsh -lc "sed -n '520,1040p' src/Providers/IntentServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 59ms:
	private function registerAnalyticsQueryHandler(): void {
		if ( ! class_exists( AnalyticsQueryHandler::class ) ) {
			return;
		}

		$this->container->singleton(
			AnalyticsQueryHandler::class,
			fn( $c ) => new AnalyticsQueryHandler(
				$c->get( AIClientFactoryInterface::class ),
				$c->get( ToolRegistryInterface::class ),
				$c->get( ToolDispatcherInterface::class )
			)
		);
		$this->container->tag( AnalyticsQueryHandler::class, 'intent.handler' );
	}

	/**
	 * Register customer lookup handler.
	 *
	 * @return void

thinking
**Switching to container singleton for WPFunctions**

I'm removing the fallback to new WPFunctions instantiation and instead relying on the dependency injection container to resolve and bind WPFunctions as a singleton via the CoreServiceProvider. Next, I'll verify the container binding method to ensure proper interface-to-implementation binding.
exec
/bin/zsh -lc "rg --line-number \"class Container|function singleton|bind\\(\" src" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
src/Container/ServiceProvider.php:65:	protected function bind( string $id, callable|string $resolver ): void {
src/Container/ServiceProvider.php:66:		$this->container->bind( $id, $resolver );
src/Container/ServiceProvider.php:76:	protected function singleton( string $id, callable|string $resolver ): void {
src/Container/ContainerInterface.php:40:	public function bind( string $id, callable|string $resolver ): void;
src/Container/ContainerInterface.php:49:	public function singleton( string $id, callable|string $resolver ): void;
src/Container/ContainerException.php:15:class ContainerException extends Exception {
src/Providers/RestServiceProvider.php:147:				$this->container->bind(
src/Container/Container.php:19:class Container implements ContainerInterface {
src/Container/Container.php:107:	public function bind( string $id, callable|string $resolver ): void {
src/Container/Container.php:120:	public function singleton( string $id, callable|string $resolver ): void {
exec
/bin/zsh -lc "sed -n '1,220p' src/Container/Container.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 38ms:
<?php
/**
 * Dependency injection container.
 *
 * @package AgentWP\Container
 */

namespace AgentWP\Container;

/**
 * Lightweight dependency injection container.
 *
 * Supports:
 * - Transient and singleton bindings
 * - Lazy resolution via callables
 * - Service tagging for group retrieval
 * - Instance registration
 */
class Container implements ContainerInterface {



thinking
**Planning interface binding and fallback removal**

I'm deciding to bind the interfaces to the WPFunctions singleton in CoreServiceProvider to ensure consistent singleton use. I'll simplify IntentServiceProvider's registerEngine by removing fallback logic and rely solely on container resolution, but I'll verify whether to remove fallbacks elsewhere like in registerMemoryStore and registerIntentClassifier.
thinking
**Considering broader fallback removals and interface use**

I'm evaluating removing all fallback checks for WPFunctions in IntentServiceProvider methods, as the spec encourages relying on container resolution. I'll also check if registerMemoryStore and registerIntentClassifier should use HooksInterface instead of WPFunctions for applying filters to align with the new interface binding.
exec
/bin/zsh -lc "sed -n '1,200p' src/Contracts/HooksInterface.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 37ms:
<?php
/**
 * WordPress hooks interface.
 *
 * @package AgentWP\Contracts
 */

namespace AgentWP\Contracts;

/**
 * Contract for WordPress filter and action hooks.
 *
 * This interface enables testability by abstracting WordPress's global
 * apply_filters() and do_action() functions. Business logic should depend
 * on this interface rather than calling WordPress functions directly.
 */
interface HooksInterface {

	/**
	 * Apply WordPress filters.

thinking
**Considering interface implementation**

Noticing WPFunctions implements HooksInterface, I’m checking whether it also implements WPUserFunctionsInterface or if that should be added. This will clarify its role and responsibilities.
exec
/bin/zsh -lc "sed -n '1,200p' src/Contracts/WPUserFunctionsInterface.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 39ms:
<?php
/**
 * WordPress user functions interface.
 *
 * @package AgentWP\Contracts
 */

namespace AgentWP\Contracts;

/**
 * Contract for WordPress user-related functions.
 *
 * This interface enables testability by abstracting WordPress's global
 * user functions. Business logic should depend on this interface rather
 * than calling WordPress functions directly.
 */
interface WPUserFunctionsInterface {

	/**
	 * Get the current user ID.

thinking
**Tracing HooksInterface usage**

I'm searching where HooksInterface is used beyond Intent\Engine optional params to understand its broader application and impact.
exec
/bin/zsh -lc 'rg --line-number "HooksInterface|WPUserFunctionsInterface" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 61ms:
src/Providers/IntentServiceProvider.php:28:use AgentWP\Contracts\HooksInterface;
src/Providers/IntentServiceProvider.php:373:				$hooks = $this->container->has( HooksInterface::class )
src/Providers/IntentServiceProvider.php:374:					? $this->container->get( HooksInterface::class )
src/Contracts/WPUserFunctionsInterface.php:17:interface WPUserFunctionsInterface {
src/Infrastructure/WPFunctions.php:10:use AgentWP\Contracts\HooksInterface;
src/Infrastructure/WPFunctions.php:11:use AgentWP\Contracts\WPUserFunctionsInterface;
src/Infrastructure/WPFunctions.php:40:final class WPFunctions implements HooksInterface, WPUserFunctionsInterface {
src/Contracts/HooksInterface.php:17:interface HooksInterface {
src/Infrastructure/CurrentUserContext.php:11:use AgentWP\Contracts\WPUserFunctionsInterface;
src/Infrastructure/CurrentUserContext.php:24:	 * @var WPUserFunctionsInterface
src/Infrastructure/CurrentUserContext.php:26:	private WPUserFunctionsInterface $wp;
src/Infrastructure/CurrentUserContext.php:31:	 * @param WPUserFunctionsInterface $wp WordPress functions wrapper.
src/Infrastructure/CurrentUserContext.php:33:	public function __construct( WPUserFunctionsInterface $wp ) {
src/Intent/Engine.php:12:use AgentWP\Contracts\HooksInterface;
src/Intent/Engine.php:55:	 * @var HooksInterface
src/Intent/Engine.php:77:	 * @param HooksInterface|null       $hooks             Hooks adapter (optional for backward compatibility).
src/Intent/Engine.php:89:		?HooksInterface $hooks = null,

thinking
**Checking user context dependency**

I'm verifying if CurrentUserContext injects WPUserFunctionsInterface and where it's bound in the container to understand scope and update needs.
exec
/bin/zsh -lc 'rg --line-number "CurrentUserContext" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/Rest/SettingsController.php:13:use AgentWP\Contracts\CurrentUserContextInterface;
src/Rest/SettingsController.php:333:	 * @return CurrentUserContextInterface|null
src/Rest/SettingsController.php:335:	private function getCurrentUserContext(): ?CurrentUserContextInterface {
src/Rest/SettingsController.php:336:		$context = $this->resolve( CurrentUserContextInterface::class );
src/Rest/SettingsController.php:337:		return $context instanceof CurrentUserContextInterface ? $context : null;
src/Rest/SettingsController.php:346:		$context = $this->getCurrentUserContext();
src/Services/ProductStockService.php:11:use AgentWP\Contracts\CurrentUserContextInterface;
src/Services/ProductStockService.php:25:	private ?CurrentUserContextInterface $userContext;
src/Services/ProductStockService.php:34:	 * @param CurrentUserContextInterface|null $userContext  User context for audit logging (optional).
src/Services/ProductStockService.php:41:		?CurrentUserContextInterface $userContext = null
src/Services/OrderRefundService.php:11:use AgentWP\Contracts\CurrentUserContextInterface;
src/Services/OrderRefundService.php:25:	private ?CurrentUserContextInterface $userContext;
src/Services/OrderRefundService.php:32:	 * @param CurrentUserContextInterface|null  $userContext   User context for audit logging (optional).
src/Services/OrderRefundService.php:39:		?CurrentUserContextInterface $userContext = null
src/Services/OrderStatusService.php:12:use AgentWP\Contracts\CurrentUserContextInterface;
src/Services/OrderStatusService.php:37:	private ?CurrentUserContextInterface $userContext;
src/Services/OrderStatusService.php:46:	 * @param CurrentUserContextInterface|null $userContext  User context for audit logging (optional).
src/Services/OrderStatusService.php:53:		?CurrentUserContextInterface $userContext = null
src/Infrastructure/CurrentUserContext.php:10:use AgentWP\Contracts\CurrentUserContextInterface;
src/Infrastructure/CurrentUserContext.php:19:final class CurrentUserContext implements CurrentUserContextInterface {

thinking
**Checking service provider bindings**
exec
/bin/zsh -lc "sed -n '240,340p' src/Providers/InfrastructureServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
	private function registerDemoCredentials(): void {
		$this->container->singleton(
			DemoCredentials::class,
			fn( $c ) => new DemoCredentials( $c->get( SettingsManager::class ) )
		);
	}

	/**
	 * Register AI client factory.
	 *
	 * @return void
	 */
	private function registerAIClientFactory(): void {
		$this->container->singleton(
			AIClientFactory::class,
			function ( $c ) {
				$settings = $c->get( SettingsManager::class );
				// Get model from settings, or fall back to centralized config.
				$default_model = $settings->get( 'model' )
					?: AgentWPConfig::get( 'openai.default_model', AgentWPConfig::OPENAI_DEFAULT_MODEL );


thinking
**Assessing interface binding for WPFunctions**

Binding the interface ensures container support if other classes request the interface, though CurrentUserContext currently injects WPFunctions directly and works without change; updating the provider to bind the interface now prepares for future DI flexibility.
thinking
**Implementing interface bindings and removing fallbacks**

I'll add interface singleton bindings to CoreServiceProvider, mapping interfaces to the existing WPFunctions instance to ensure container resolution. Then, I'll simplify IntentServiceProvider by removing WPFunctions fallback constructions and relying solely on container->get calls for WPFunctions and HooksInterface in relevant methods.
exec
/bin/zsh -lc 'rg --line-number "applyFilters|doAction" -n src/Infrastructure/WPFunctions.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 60ms:
288:	public function applyFilters( string $hook_name, $value, ...$args ) {
303:	public function doAction( string $hook_name, ...$args ): void {
exec
/bin/zsh -lc "sed -n '260,340p' src/Infrastructure/WPFunctions.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 28ms:
		}

		return wp_cache_set( $key, $value, $group, $expire ); // phpcs:ignore WordPressVIPMinimum.Performance.LowExpiryCacheTime.CacheTimeUndetermined -- Expiry is controlled by the caller; 0 means no expiration.
	}

	/**
	 * Delete object cache value.
	 *
	 * @param string $key   Cache key.
	 * @param string $group Cache group.
	 * @return bool True if deleted.
	 */
	public function deleteCache( string $key, string $group = '' ): bool {
		if ( ! function_exists( 'wp_cache_delete' ) ) {
			return false;
		}

		return wp_cache_delete( $key, $group );
	}



thinking
**Considering hooks interface adoption**

I'm weighing replacing WPFunctions usage with HooksInterface in IntentServiceProvider for filter operations to better align with container resolution and generalize hooks access, but WPFunctions still provides specific methods; I'll likely standardize on HooksInterface for applyFilters while keeping WPFunctions if its unique methods are necessary.
thinking
**Planning hooks interface integration**

I’m planning to replace WPFunctions usage with HooksInterface in IntentServiceProvider to rely fully on container resolution and remove fallbacks, ensuring HooksInterface is always bound in CoreServiceProvider. I’ll add necessary use statements and bindings there, keep SettingsManager fallbacks intact for safety, then implement these small patches in both providers and run tests afterward.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Providers/CoreServiceProvider.php
@@ -10,3 +10,5 @@
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
@@ -132,2 +134,4 @@
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M src/Providers/CoreServiceProvider.php
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );

file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );


thinking
**Refactoring provider to replace WPFunctions with HooksInterface**

I'm updating the service provider to use HooksInterface instead of WPFunctions where possible, starting with registerMemoryStore and registerIntentClassifier. I'll verify ScorerRegistry's dependencies to confirm if it can accept HooksInterface instead of WPFunctions.
exec
/bin/zsh -lc 'rg --line-number "class ScorerRegistry|__construct" -n src/Intent/Classifier/ScorerRegistry.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
27:final class ScorerRegistry implements IntentClassifierInterface {
59:	public function __construct( $wp = null ) {
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );

exec
/bin/zsh -lc "sed -n '1,120p' src/Intent/Classifier/ScorerRegistry.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 67ms:
<?php
/**
 * Scorer registry for intent classification.
 *
 * @package AgentWP\Intent\Classifier
 */

namespace AgentWP\Intent\Classifier;

use AgentWP\Config\AgentWPConfig;
use AgentWP\Contracts\IntentClassifierInterface;
use AgentWP\Infrastructure\WPFunctions;
use AgentWP\Intent\Intent;

/**
 * Manages and executes intent scorers.
 *
 * This registry is the canonical intent classification mechanism per ADR 0003.
 * It implements IntentClassifierInterface and supports extensibility via the
 * 'agentwp_intent_scorers' filter for third-party scorers.
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );


thinking
**Confirming hook interface usage**

ScorerRegistry accepts any object with doAction, so using HooksInterface is appropriate; I'll verify usage in fireClassifiedAction next.
exec
/bin/zsh -lc 'rg --line-number "doAction|applyFilters" src/Intent/Classifier/ScorerRegistry.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 71ms:
47:	 * Accepts any object with doAction() method for testability.
57:	 *                                    Accepts any object with doAction() method for testability.
140:		$this->wp->doAction( 'agentwp_intent_classified', $intent, $scores, $input, $context );
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );


thinking
**Confirming HooksInterface usage**

HooksInterface supports necessary hook functions like doAction and applyFilters, so I can rely on it in registerMemoryStore and registerEngine, allowing the removal of WPFunctions except for fallback cases. I'll verify no other WPFunctions uses, then proceed with patching.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Providers/IntentServiceProvider.php
@@ -69,3 +69,2 @@
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
@@ -114,6 +113,4 @@
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
@@ -130,4 +127,4 @@
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
@@ -181,8 +178,6 @@
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
@@ -200,3 +195,3 @@
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
@@ -371,8 +366,4 @@
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
apply_patch(auto_approved=true) exited 0 in 39ms:
Success. Updated the following files:
M src/Providers/IntentServiceProvider.php
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,

file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,


thinking
**Verifying import cleanup and service provider order**

I'm confirming removal of the unused import and checking that HooksInterface remains used with no leftover unused imports. Next, I'll verify the plugin's service provider registration order to ensure HooksInterface binding exists before IntentServiceProvider loads.
exec
/bin/zsh -lc "sed -n '110,190p' src/Plugin.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
	private function __construct() {
		$this->container = new Container();
		$this->registerProviders();
		$this->bootProviders();

		add_action( 'init', array( $this, 'load_textdomain' ) );

		if ( class_exists( 'AgentWP\\Billing\\UsageTracker' ) ) {
			Billing\UsageTracker::init();
		}

		if ( class_exists( 'AgentWP\\Search\\Index' ) ) {
			Search\Index::init();
		}

		if ( class_exists( 'AgentWP\\Demo\\Manager' ) ) {
			Demo\Manager::init();
		}
	}

file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,



thinking
**Considering interface usage consistency**

The container currently builds CurrentUserContext with the WPFunctions class despite expecting the interface, which works but could be improved by switching to WPUserFunctionsInterface for consistency. This change is optional and requires minimal updates, possibly including tests and ensuring no phpstan import issues.
thinking
**Confirming no direct usage of implementation class**

There's no direct usage of the WPFunctions class in the IntentServiceProvider, aligning with the idea to prefer interface-based injection; test and static analysis commands are missing, so full validation is skipped.
exec
/bin/zsh -lc 'rg --line-number "WPFunctions" src/Providers/IntentServiceProvider.php' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 40ms:

file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,



thinking
**Preparing final response details**

The import removal is confirmed with no fallback impacts, ordering in providers is correct, and no syntax checks or tests are run due to empty or missing commands. I'll summarize changes with affected files and note no verification commands or tests executed.
thinking
**Analyzing fallback removals and interface bindings**

Removing fallback for HooksInterface risks breaking plugins or tests not binding CoreServiceProvider, so I'll flag this potential risk. Bindings for HooksInterface and WPUserFunctionsInterface are confirmed, and IntentServiceProvider now fully relies on container resolution without fallback. I'll check tests for container usage to confirm safety.
exec
/bin/zsh -lc "rg --line-number \"IntentServiceProvider|CoreServiceProvider|Container\\(\" tests src" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 69ms:
src/Providers/IntentServiceProvider.php:74:final class IntentServiceProvider extends ServiceProvider {
src/Providers/RestServiceProvider.php:129:			fn() => RestRouteRegistrar::fromContainer( $this->container )
src/Providers/CoreServiceProvider.php:29:final class CoreServiceProvider extends ServiceProvider {
tests/Integration/Container/ContainerWiringTest.php:65:use AgentWP\Providers\CoreServiceProvider;
tests/Integration/Container/ContainerWiringTest.php:67:use AgentWP\Providers\IntentServiceProvider;
tests/Integration/Container/ContainerWiringTest.php:90:		$this->container = new Container();
tests/Integration/Container/ContainerWiringTest.php:103:			new CoreServiceProvider( $this->container ),
tests/Integration/Container/ContainerWiringTest.php:106:			new IntentServiceProvider( $this->container ),
tests/Integration/Container/ContainerWiringTest.php:119:	 * Test that CoreServiceProvider registers expected bindings.
tests/Integration/Container/ContainerWiringTest.php:122:		$provider = new CoreServiceProvider( $this->container );
tests/Integration/Container/ContainerWiringTest.php:134:				sprintf( 'CoreServiceProvider should register %s', $binding )
tests/Integration/Container/ContainerWiringTest.php:144:		$core = new CoreServiceProvider( $this->container );
tests/Integration/Container/ContainerWiringTest.php:178:		$core = new CoreServiceProvider( $this->container );
tests/Integration/Container/ContainerWiringTest.php:207:	 * Test that IntentServiceProvider registers Engine and handler bindings.
tests/Integration/Container/ContainerWiringTest.php:215:			'IntentServiceProvider should register Engine'
tests/Integration/Container/ContainerWiringTest.php:221:			'IntentServiceProvider should register FunctionRegistry'
tests/Integration/Container/ContainerWiringTest.php:227:			'IntentServiceProvider should register ToolRegistryInterface'
tests/Integration/Container/ContainerWiringTest.php:233:			'IntentServiceProvider should register HandlerRegistry'
tests/Integration/Container/ContainerWiringTest.php:239:			'IntentServiceProvider should register MemoryStoreInterface'
tests/Integration/Container/ContainerWiringTest.php:244:			'IntentServiceProvider should register ContextBuilderInterface'
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,


thinking
**Inspecting test assumptions on service bindings**

I'll review MemoryStoreConfigTest to verify how it registers IntentServiceProvider and if it relies on WPFunctions bindings or fallbacks, since missing HooksInterface binding now risks NotFoundException and test failures.
exec
/bin/zsh -lc "sed -n '1,220p' tests/Unit/Intent/MemoryStoreConfigTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 66ms:
<?php
/**
 * Memory store configuration unit tests.
 */

namespace AgentWP\Tests\Unit\Intent;

use AgentWP\Container\Container;
use AgentWP\Contracts\MemoryStoreInterface;
use AgentWP\Contracts\OptionsInterface;
use AgentWP\Infrastructure\WPFunctions;
use AgentWP\Intent\MemoryStore;
use AgentWP\Plugin\SettingsManager;
use AgentWP\Providers\IntentServiceProvider;
use AgentWP\Tests\Fakes\FakeOptions;
use AgentWP\Tests\Fakes\FakeWPFunctions;
use AgentWP\Tests\TestCase;

class MemoryStoreConfigTest extends TestCase {

file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,



thinking
**Identifying test binding gaps**

Tests use WPFunctions binding but not HooksInterface, causing failures with new HooksInterface dependency; updating tests to bind HooksInterface (pointing to WPFunctions) is needed to align with CoreServiceProvider changes.
thinking
**Assessing test dependencies**

Noticed some tests may intentionally avoid registering CoreServiceProvider to isolate IntentServiceProvider; inspecting ContainerWiringTest to confirm if dependency-related failures are expected before deciding how to update test bindings.
exec
/bin/zsh -lc "sed -n '780,900p' tests/Integration/Container/ContainerWiringTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
	 *
	 * This tests the pattern used by RestController::resolveRequired()
	 * for the new adapter services.
	 */
	public function test_adapter_services_available_for_controllers(): void {
		$this->registerProvidersWithoutRest();

		$adapter_services = array(
			UsageTrackerInterface::class => 'Usage tracker adapter',
			SearchIndexInterface::class  => 'Search index adapter',
		);

		foreach ( $adapter_services as $service_id => $service_name ) {
			$this->assertTrue(
				$this->container->has( $service_id ),
				sprintf( '%s should be registered for controllers', $service_name )
			);

			$service = $this->container->get( $service_id );
			$this->assertNotNull(
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,



thinking
**Analyzing registration failure timings**

The change causes earlier failure on missing HooksInterface when resolving Engine or MemoryStore, which matches expected Throwable outcomes. Tests registering only WPFunctions without HooksInterface will fail now, so updating tests to bind HooksInterface to WPFunctions is likely needed to align with the new binding behavior.
thinking
**Considering adding bindings in tests**

Since CoreServiceProvider binds HooksInterface but some tests register only WPFunctions, it's clearer to add HooksInterface binding directly in tests rather than register CoreServiceProvider to avoid extra dependencies. Next, I'll search other tests using related interfaces to identify where similar adjustments may be needed.
exec
/bin/zsh -lc 'rg --line-number "HooksInterface" tests' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 66ms:
tests/Fakes/FakeWPFunctions.php:10:use AgentWP\Contracts\HooksInterface;
tests/Fakes/FakeWPFunctions.php:16: * This class implements HooksInterface and WPUserFunctionsInterface for use in unit tests.
tests/Fakes/FakeWPFunctions.php:19:class FakeWPFunctions implements HooksInterface, WPUserFunctionsInterface {
tests/Unit/Intent/EngineHooksTest.php:24: * Tests that Engine uses injected HooksInterface instead of WordPress globals.
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,


thinking
**Reviewing EngineHooksTest**
exec
/bin/zsh -lc "sed -n '1,200p' tests/Unit/Intent/EngineHooksTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
<?php
/**
 * Unit tests for Engine hooks injection.
 *
 * @package AgentWP\Tests\Unit\Intent
 */

namespace AgentWP\Tests\Unit\Intent;

use AgentWP\AI\Response;
use AgentWP\Intent\ContextBuilder;
use AgentWP\Intent\Engine;
use AgentWP\Intent\FunctionRegistry;
use AgentWP\Intent\Handler;
use AgentWP\Intent\HandlerRegistry;
use AgentWP\Intent\Handlers\FallbackHandler;
use AgentWP\Intent\Intent;
use AgentWP\Contracts\IntentClassifierInterface;
use AgentWP\Tests\Fakes\FakeMemoryStore;
use AgentWP\Tests\Fakes\FakeWPFunctions;
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,



thinking
**Evaluating interface binding options**

I'm weighing whether to keep using WPFunctions directly in IntentServiceProvider to avoid test changes or to bind HooksInterface to WPFunctions as the spec suggests; using container resolution without fallbacks remains a priority, and switching to container->get(WPFunctions) may best satisfy the simplification goal while keeping tests stable.
thinking
**Confirming interface bindings per spec**

The spec requires binding HooksInterface and WPUserFunctionsInterface in CoreServiceProvider for consistent resolution, so updating tests to register HooksInterface like the container makes sense and aligns with removing fallback in IntentServiceProvider.
exec
/bin/zsh -lc 'rg --line-number "WPFunctions::class" tests' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 82ms:
tests/Unit/Intent/MemoryStoreConfigTest.php:32:		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
tests/Unit/Intent/MemoryStoreConfigTest.php:45:		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
tests/Unit/Intent/MemoryStoreConfigTest.php:64:		$container->singleton( WPFunctions::class, fn() => $wp );
tests/Unit/Intent/MemoryStoreConfigTest.php:82:		$container->singleton( WPFunctions::class, fn() => $wp );
tests/Unit/Intent/MemoryStoreConfigTest.php:105:		$container->singleton( WPFunctions::class, fn() => $wp );
tests/Unit/Intent/MemoryStoreConfigTest.php:136:		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,


thinking
**Aligning test bindings with core provider**

Tests currently use only memory store; updating them to register HooksInterface via WPFunctions aligns with the CoreServiceProvider setup and leverages the existing WPFunctions binding for consistency. I'll also check if WPUserFunctionsInterface registration is needed by other tests.
exec
/bin/zsh -lc 'rg --line-number "WPUserFunctionsInterface" tests' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
tests/Fakes/FakeWPFunctions.php:11:use AgentWP\Contracts\WPUserFunctionsInterface;
tests/Fakes/FakeWPFunctions.php:16: * This class implements HooksInterface and WPUserFunctionsInterface for use in unit tests.
tests/Fakes/FakeWPFunctions.php:19:class FakeWPFunctions implements HooksInterface, WPUserFunctionsInterface {
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,


thinking
**Planning HooksInterface bindings in tests**

HooksInterface binding will be added manually in MemoryStoreConfigTest since it uses IntentServiceProvider without Core provider, while integration tests likely get it from Core provider registration; I'll also search for other tests resolving MemoryStore or IntentClassifier to add bindings as needed.
exec
/bin/zsh -lc 'rg --line-number "IntentClassifierInterface|MemoryStoreInterface" tests' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 73ms:
tests/Fakes/FakeMemoryStore.php:10:use AgentWP\Contracts\MemoryStoreInterface;
tests/Fakes/FakeMemoryStore.php:15:final class FakeMemoryStore implements MemoryStoreInterface {
tests/Integration/Intent/EngineTest.php:16:use AgentWP\Contracts\IntentClassifierInterface;
tests/Integration/Intent/EngineTest.php:37:		$classifier = new class() implements IntentClassifierInterface {
tests/Integration/Intent/EngineTest.php:75:		$classifier = new class() implements IntentClassifierInterface {
tests/Integration/Intent/EngineTest.php:130:		$classifier = new class() implements IntentClassifierInterface {
tests/Integration/Intent/ToolExecutionPathTest.php:18:use AgentWP\Contracts\IntentClassifierInterface;
tests/Integration/Intent/ToolExecutionPathTest.php:134:		$classifier = new class() implements IntentClassifierInterface {
tests/Integration/Intent/ToolExecutionPathTest.php:280:		$classifier = new class() implements IntentClassifierInterface {
tests/Integration/Intent/ToolExecutionPathTest.php:425:		$classifier = new class() implements IntentClassifierInterface {
tests/Integration/Container/ContainerWiringTest.php:27:use AgentWP\Contracts\IntentClassifierInterface;
tests/Integration/Container/ContainerWiringTest.php:29:use AgentWP\Contracts\MemoryStoreInterface;
tests/Integration/Container/ContainerWiringTest.php:238:			$this->container->has( MemoryStoreInterface::class ),
tests/Integration/Container/ContainerWiringTest.php:239:			'IntentServiceProvider should register MemoryStoreInterface'
tests/Integration/Container/ContainerWiringTest.php:248:			$this->container->has( IntentClassifierInterface::class ),
tests/Integration/Container/ContainerWiringTest.php:249:			'IntentServiceProvider should register IntentClassifierInterface'
tests/Integration/Container/ContainerWiringTest.php:557:			MemoryStoreInterface::class,
tests/Integration/Container/ContainerWiringTest.php:559:			IntentClassifierInterface::class,
tests/Integration/Container/ContainerWiringTest.php:637:	 * Test that IntentClassifierInterface is wired to ScorerRegistry per ADR 0003.
tests/Integration/Container/ContainerWiringTest.php:642:		$classifier = $this->container->get( IntentClassifierInterface::class );
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,


thinking
**Verifying test container dependencies**

I confirmed tests of the intent classifier rely on a container setup that registers necessary providers including Core, so they are properly wired; only MemoryStoreConfigTest uses IntentServiceProvider alone, requiring an added HooksInterface binding.
exec
/bin/zsh -lc 'rg --line-number "registerProvidersWithoutRest" -n tests/Integration/Container/ContainerWiringTest.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 64ms:
101:	private function registerProvidersWithoutRest(): void {
210:		$this->registerProvidersWithoutRest();
257:		$this->registerProvidersWithoutRest();
296:		$this->registerProvidersWithoutRest();
307:		$this->registerProvidersWithoutRest();
324:		$this->registerProvidersWithoutRest();
336:		$this->registerProvidersWithoutRest();
348:		$this->registerProvidersWithoutRest();
360:		$this->registerProvidersWithoutRest();
378:		$this->registerProvidersWithoutRest();
396:		$this->registerProvidersWithoutRest();
424:		$this->registerProvidersWithoutRest();
485:		$this->registerProvidersWithoutRest();
510:		$this->registerProvidersWithoutRest();
553:		$this->registerProvidersWithoutRest();
589:		$this->registerProvidersWithoutRest();
640:		$this->registerProvidersWithoutRest();
655:		$this->registerProvidersWithoutRest();
680:		$this->registerProvidersWithoutRest();
695:		$this->registerProvidersWithoutRest();
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,

exec
/bin/zsh -lc "sed -n '90,130p' tests/Integration/Container/ContainerWiringTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 61ms:
		$this->container = new Container();
	}

	/**
	 * Helper to register providers without REST (which requires WordPress).
	 *
	 * This skips RestServiceProvider because it depends on WP_REST_Controller
	 * which is not available in unit tests.
	 *
	 * @return void
	 */
	private function registerProvidersWithoutRest(): void {
		$providers = array(
			new CoreServiceProvider( $this->container ),
			new InfrastructureServiceProvider( $this->container ),
			new ServicesServiceProvider( $this->container ),
			new IntentServiceProvider( $this->container ),
		);

		foreach ( $providers as $provider ) {
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,


thinking
**Updating MemoryStore tests with HooksInterface**

I'm preparing to add HooksInterface binding to tests/Unit/Intent/MemoryStoreConfigTest.php, importing it and registering it in the container singleton alongside WPFunctions to ensure correct integration; aiming to keep the change simple without introducing new abstractions.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/tests/Unit/Intent/MemoryStoreConfigTest.php
@@ -8,2 +8,3 @@
 use AgentWP\Container\Container;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\MemoryStoreInterface;
@@ -32,2 +33,3 @@
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
@@ -45,2 +47,3 @@
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
@@ -64,2 +67,3 @@
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
@@ -82,2 +86,3 @@
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
@@ -105,2 +110,3 @@
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
@@ -136,2 +142,3 @@
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
apply_patch(auto_approved=true) exited 0 in 43ms:
Success. Updated the following files:
M tests/Unit/Intent/MemoryStoreConfigTest.php
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,
diff --git a/tests/Unit/Intent/MemoryStoreConfigTest.php b/tests/Unit/Intent/MemoryStoreConfigTest.php
index 0430854cada03c5b2e2978ebfde3ed11f5f69ef6..0510ab9c2b07db1c02994a82ecfc3282411e0f43
--- a/tests/Unit/Intent/MemoryStoreConfigTest.php
+++ b/tests/Unit/Intent/MemoryStoreConfigTest.php
@@ -6,6 +6,7 @@
 namespace AgentWP\Tests\Unit\Intent;
 
 use AgentWP\Container\Container;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\MemoryStoreInterface;
 use AgentWP\Contracts\OptionsInterface;
 use AgentWP\Infrastructure\WPFunctions;
@@ -30,6 +31,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -43,6 +45,7 @@
 	public function test_memory_store_uses_defaults_without_settings_manager(): void {
 		$container = new Container();
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -62,6 +65,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -80,6 +84,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -103,6 +108,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -134,6 +140,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();

file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,
diff --git a/tests/Unit/Intent/MemoryStoreConfigTest.php b/tests/Unit/Intent/MemoryStoreConfigTest.php
index 0430854cada03c5b2e2978ebfde3ed11f5f69ef6..0510ab9c2b07db1c02994a82ecfc3282411e0f43
--- a/tests/Unit/Intent/MemoryStoreConfigTest.php
+++ b/tests/Unit/Intent/MemoryStoreConfigTest.php
@@ -6,6 +6,7 @@
 namespace AgentWP\Tests\Unit\Intent;
 
 use AgentWP\Container\Container;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\MemoryStoreInterface;
 use AgentWP\Contracts\OptionsInterface;
 use AgentWP\Infrastructure\WPFunctions;
@@ -30,6 +31,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -43,6 +45,7 @@
 	public function test_memory_store_uses_defaults_without_settings_manager(): void {
 		$container = new Container();
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -62,6 +65,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -80,6 +84,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -103,6 +108,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -134,6 +140,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();


thinking
**Reviewing test coverage for new interface bindings**

I'm verifying if existing tests cover HooksInterface and WPUserFunctionsInterface bindings and considering updating ContainerWiringTest expectations accordingly. Next, I'll search tests for HooksInterface usage to decide if additions are needed.
exec
/bin/zsh -lc 'rg --line-number "HooksInterface" tests/Integration/Container/ContainerWiringTest.php' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 35ms:

file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,
diff --git a/tests/Unit/Intent/MemoryStoreConfigTest.php b/tests/Unit/Intent/MemoryStoreConfigTest.php
index 0430854cada03c5b2e2978ebfde3ed11f5f69ef6..0510ab9c2b07db1c02994a82ecfc3282411e0f43
--- a/tests/Unit/Intent/MemoryStoreConfigTest.php
+++ b/tests/Unit/Intent/MemoryStoreConfigTest.php
@@ -6,6 +6,7 @@
 namespace AgentWP\Tests\Unit\Intent;
 
 use AgentWP\Container\Container;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\MemoryStoreInterface;
 use AgentWP\Contracts\OptionsInterface;
 use AgentWP\Infrastructure\WPFunctions;
@@ -30,6 +31,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -43,6 +45,7 @@
 	public function test_memory_store_uses_defaults_without_settings_manager(): void {
 		$container = new Container();
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -62,6 +65,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -80,6 +84,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -103,6 +108,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -134,6 +140,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();


thinking
**Checking provider bindings for interface usage**
exec
/bin/zsh -lc 'rg --line-number "HooksInterface::class" src/Providers' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 75ms:
src/Providers/CoreServiceProvider.php:135:		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
src/Providers/IntentServiceProvider.php:115:				$hooks = $this->container->get( HooksInterface::class );
src/Providers/IntentServiceProvider.php:180:				$hooks = $this->container->get( HooksInterface::class );
src/Providers/IntentServiceProvider.php:368:				$hooks = $this->container->get( HooksInterface::class );
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,
diff --git a/tests/Unit/Intent/MemoryStoreConfigTest.php b/tests/Unit/Intent/MemoryStoreConfigTest.php
index 0430854cada03c5b2e2978ebfde3ed11f5f69ef6..0510ab9c2b07db1c02994a82ecfc3282411e0f43
--- a/tests/Unit/Intent/MemoryStoreConfigTest.php
+++ b/tests/Unit/Intent/MemoryStoreConfigTest.php
@@ -6,6 +6,7 @@
 namespace AgentWP\Tests\Unit\Intent;
 
 use AgentWP\Container\Container;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\MemoryStoreInterface;
 use AgentWP\Contracts\OptionsInterface;
 use AgentWP\Infrastructure\WPFunctions;
@@ -30,6 +31,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -43,6 +45,7 @@
 	public function test_memory_store_uses_defaults_without_settings_manager(): void {
 		$container = new Container();
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -62,6 +65,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -80,6 +84,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -103,6 +108,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -134,6 +140,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();



thinking
**Preparing final summary and notes**

I'm noting that tests were not run and that updating the HooksInterface binding could risk conflicts if the Core provider isn't used. I'll mention file changes, the lack of verification commands, and caution on potential container registration issues as follow-ups.
thinking
**Finalizing summary structure and details**

I'm settling on a concise quick explanation after the status line, followed by a "Summary of changes:" section with precise file references and changes. For verification, I'll state no commands were provided, and list risks including unrun tests and binding requirements when IntentServiceProvider is used without CoreServiceProvider.
codex
Status: DONE  
Bound the hooks/user interfaces to the WPFunctions singleton and removed IntentServiceProvider fallbacks so it resolves hooks purely from the container.

Summary of changes:
- Added bindings for `HooksInterface` and `WPUserFunctionsInterface` to the `WPFunctions` singleton in `src/Providers/CoreServiceProvider.php`.
- Switched IntentServiceProvider hook resolution to container-only and removed WPFunctions fallbacks in `src/Providers/IntentServiceProvider.php`.
- Updated unit setup to register `HooksInterface` in `tests/Unit/Intent/MemoryStoreConfigTest.php`.

How to verify (exact commands):
- No verification commands provided (format/lint/test entries were empty).

Risks / follow-ups:
- Tests not run (no commands provided).
- IntentServiceProvider now assumes a HooksInterface binding is present; ensure that binding is registered when using it outside CoreServiceProvider.
file update:
diff --git a/src/Providers/CoreServiceProvider.php b/src/Providers/CoreServiceProvider.php
index 490b38f01c32e9c18faf164867fe1a372aa01576..f54edcbb8e8cba81af36dafcfeb38923db6c1c72
--- a/src/Providers/CoreServiceProvider.php
+++ b/src/Providers/CoreServiceProvider.php
@@ -8,7 +8,9 @@
 namespace AgentWP\Providers;
 
 use AgentWP\Container\ServiceProvider;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\OptionsInterface;
+use AgentWP\Contracts\WPUserFunctionsInterface;
 use AgentWP\Infrastructure\WordPressOptions;
 use AgentWP\Infrastructure\WPFunctions;
 use AgentWP\Intent\HandlerRegistry;
@@ -130,6 +132,8 @@
 	private function registerInfrastructure(): void {
 		// WordPress functions wrapper for testability.
 		$this->container->singleton( WPFunctions::class, fn() => new WPFunctions() );
+		$this->container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
+		$this->container->singleton( WPUserFunctionsInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		// Handler registry for O(1) intent resolution.
 		$this->container->singleton( HandlerRegistry::class, fn() => new HandlerRegistry() );
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index aa4fbecc3180cb1396c58661b9d5647f504867dd..3f073bb826b64edf8a8a023e025a3463ff0c8b61
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -67,7 +67,6 @@
 use AgentWP\Intent\MemoryStore;
 use AgentWP\Intent\Handlers\ProductStockHandler;
 use AgentWP\Intent\ToolRegistry;
-use AgentWP\Infrastructure\WPFunctions;
 
 /**
  * Registers intent-related services.
@@ -112,10 +111,8 @@
 		$this->container->singleton(
 			MemoryStoreInterface::class,
 			function () {
-				// Get WPFunctions for filter hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				// Read from settings or use safe defaults.
 				$limit = SettingsManager::DEFAULT_MEMORY_LIMIT;
@@ -128,8 +125,8 @@
 				}
 
 				// Apply filters for customization.
-				$limit = (int) $wp->applyFilters( 'agentwp_memory_limit', $limit );
-				$ttl   = (int) $wp->applyFilters( 'agentwp_memory_ttl', $ttl );
+				$limit = (int) $hooks->applyFilters( 'agentwp_memory_limit', $limit );
+				$ttl   = (int) $hooks->applyFilters( 'agentwp_memory_ttl', $ttl );
 
 				return new MemoryStore( $limit, $ttl );
 			}
@@ -179,12 +176,10 @@
 		$this->container->singleton(
 			IntentClassifierInterface::class,
 			function () {
-				// Get WPFunctions for filter/action hooks.
-				$wp = $this->container->has( WPFunctions::class )
-					? $this->container->get( WPFunctions::class )
-					: new WPFunctions();
+				// Get hooks adapter for filter/action hooks.
+				$hooks = $this->container->get( HooksInterface::class );
 
-				$registry = new ScorerRegistry( $wp );
+				$registry = new ScorerRegistry( $hooks );
 
 				// Register default scorers.
 				$default_scorers = array(
@@ -198,7 +193,7 @@
 				);
 
 				// Apply filter for third-party scorers.
-				$scorers = $wp->applyFilters( 'agentwp_intent_scorers', $default_scorers );
+				$scorers = $hooks->applyFilters( 'agentwp_intent_scorers', $default_scorers );
 
 				// Validate that filter returned an array.
 				if ( ! is_array( $scorers ) ) {
@@ -369,12 +364,8 @@
 			function () {
 				$handlers = $this->container->tagged( 'intent.handler' );
 
-				// Get hooks adapter - use WPFunctions if registered, fallback to new instance.
-				$hooks = $this->container->has( HooksInterface::class )
-					? $this->container->get( HooksInterface::class )
-					: ( $this->container->has( WPFunctions::class )
-						? $this->container->get( WPFunctions::class )
-						: new WPFunctions() );
+				// Get hooks adapter from the container.
+				$hooks = $this->container->get( HooksInterface::class );
 
 				return new Engine(
 					$handlers,
diff --git a/tests/Unit/Intent/MemoryStoreConfigTest.php b/tests/Unit/Intent/MemoryStoreConfigTest.php
index 0430854cada03c5b2e2978ebfde3ed11f5f69ef6..0510ab9c2b07db1c02994a82ecfc3282411e0f43
--- a/tests/Unit/Intent/MemoryStoreConfigTest.php
+++ b/tests/Unit/Intent/MemoryStoreConfigTest.php
@@ -6,6 +6,7 @@
 namespace AgentWP\Tests\Unit\Intent;
 
 use AgentWP\Container\Container;
+use AgentWP\Contracts\HooksInterface;
 use AgentWP\Contracts\MemoryStoreInterface;
 use AgentWP\Contracts\OptionsInterface;
 use AgentWP\Infrastructure\WPFunctions;
@@ -30,6 +31,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -43,6 +45,7 @@
 	public function test_memory_store_uses_defaults_without_settings_manager(): void {
 		$container = new Container();
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -62,6 +65,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -80,6 +84,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -103,6 +108,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => $wp );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();
@@ -134,6 +140,7 @@
 		$container->singleton( OptionsInterface::class, fn() => $options );
 		$container->singleton( SettingsManager::class, fn( $c ) => new SettingsManager( $c->get( OptionsInterface::class ) ) );
 		$container->singleton( WPFunctions::class, fn() => new FakeWPFunctions() );
+		$container->singleton( HooksInterface::class, fn( $c ) => $c->get( WPFunctions::class ) );
 
 		$provider = new IntentServiceProvider( $container );
 		$provider->register();

tokens used
52,161
