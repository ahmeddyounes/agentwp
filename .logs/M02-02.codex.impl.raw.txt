Status: DONE

Summary of changes:
- Added natural language order search execution with caching, date parsing, and simplified order output in `src/Handlers/OrderSearchHandler.php`.
- Wired intent order search to return real results via the new handler in `src/Intent/Handlers/OrderSearchHandler.php`.
- Clarified the tool schema email description in `src/AI/Functions/SearchOrders.php`.

How to verify (exact commands):
- No verification commands provided.

Risks / follow-ups:
- Relative date ranges interpret “last week” as the previous 7 days ending yesterday; confirm this matches product expectations.
- Shipping email matching depends on `_shipping_email` meta, which may be absent on some stores.

OpenAI Codex v0.77.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/agentwp
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019b94d2-b1f1-73e1-abde-c8c38b4e583f
--------
user
You are implementing task M02-02 in this git repository.

1) Read the spec: .plans/M02-02.md
2) Read handoff/context: .t2/handoff/M02-02.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: 
- test: 

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers

thinking
**Deciding how to review specifications**
exec
/bin/zsh -lc ls in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 41ms:
agentwp.php
assets
composer.json
docker
docker-compose.yml
docs
includes
languages
react
README.md
scripts
setup.sh
src
tasks.csv
uninstall.php
exec
/bin/zsh -lc 'cat .plans/M02-02.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
# M02-02 — Order Search and Retrieval

Implement natural language order search: 1) Create AgentWP\Handlers\OrderSearchHandler class. 2) OpenAI function schema: search_orders(query?: string, order_id?: int, email?: string, status?: string, date_range?: {start: string, end: string}, limit?: int). 3) Translate natural language to WC_Order_Query parameters: 'last order' → limit 1 + orderby date DESC, 'orders from john@...' → customer email filter, 'pending orders' → status filter. 4) Return simplified order objects: id, status, total, customer_name, customer_email, date_created, items_summary, shipping_address. 5) Cache recent queries in transients (1 hour TTL). 6) Support relative dates: 'yesterday', 'last week', 'this month'. Acceptance Criteria: 'Show me the last order' returns most recent order within 500ms, email search finds orders by billing/shipping email, date parsing handles common formats, cache reduces DB queries by 50%+ for repeated searches.
exec
/bin/zsh -lc 'cat .t2/handoff/M02-02.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
# Handoff: M02-02

Created: 2026-01-06T19:39:54.693014Z

Spec: .plans/M02-02.md

thinking
**Searching for similar handlers**
exec
/bin/zsh -lc 'rg "Handler" -n src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
src/Intent/Handlers/FallbackHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/FallbackHandler.php:13:class FallbackHandler extends BaseHandler {
src/Intent/Handlers/CustomerLookupHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/CustomerLookupHandler.php:13:class CustomerLookupHandler extends BaseHandler {
src/Intent/Handlers/OrderRefundHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderRefundHandler.php:13:class OrderRefundHandler extends BaseHandler {
src/Intent/Handlers/ProductStockHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/ProductStockHandler.php:13:class ProductStockHandler extends BaseHandler {
src/Intent/FunctionRegistry.php:12:	 * @var array<string, Handler>
src/Intent/FunctionRegistry.php:18:	 * @param Handler $handler Handler instance.
src/Intent/FunctionRegistry.php:21:	public function register( $function_name, Handler $handler ) {
src/Intent/FunctionRegistry.php:32:	 * @return Handler|null
src/Intent/Handlers/BaseHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/BaseHandler.php:11:use AgentWP\Intent\Handler;
src/Intent/Handlers/BaseHandler.php:14:abstract class BaseHandler implements Handler {
src/Intent/Handlers/OrderSearchHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderSearchHandler.php:13:class OrderSearchHandler extends BaseHandler {
src/Intent/Handler.php:12:interface Handler {
src/Intent/Handlers/EmailDraftHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/EmailDraftHandler.php:13:class EmailDraftHandler extends BaseHandler {

thinking
**Checking existing OrderSearchHandler**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
<?php
/**
 * Handle order search intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Intent;

class OrderSearchHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_SEARCH );
	}

	/**
	 * @param array $context Context data.
	 * @return Response

thinking
**Reviewing handler class placement**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/OrderStatusHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
<?php
/**
 * Handle order status intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Intent;

class OrderStatusHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_STATUS );
	}

	/**
	 * @param array $context Context data.
	 * @return Response

thinking
**Checking for actual function implementations**
exec
/bin/zsh -lc 'rg "function" -n src/Intent src/AI includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
src/Intent/IntentClassifier.php:16:	public function classify( $input, array $context = array() ) {
src/Intent/IntentClassifier.php:56:	private function score_refund( $text ) {
src/Intent/IntentClassifier.php:73:	private function score_status( $text ) {
src/Intent/IntentClassifier.php:93:	private function score_stock( $text ) {
src/Intent/IntentClassifier.php:111:	private function score_email( $text ) {
src/Intent/IntentClassifier.php:134:	private function score_analytics( $text ) {
src/Intent/IntentClassifier.php:154:	private function score_customer( $text ) {
src/Intent/IntentClassifier.php:171:	private function score_search( $text ) {
src/Intent/IntentClassifier.php:191:	private function match_score( $text, array $phrases ) {
src/Intent/IntentClassifier.php:207:	private function contains_phrase( $text, $phrase ) {
src/AI/Functions/GetSalesReport.php:11:	public function get_name() {
src/AI/Functions/GetSalesReport.php:15:	public function get_description() {
src/AI/Functions/GetSalesReport.php:19:	public function get_parameters() {
src/AI/Functions/SearchOrders.php:11:	public function get_name() {
src/AI/Functions/SearchOrders.php:15:	public function get_description() {
src/AI/Functions/SearchOrders.php:19:	public function get_parameters() {
src/Intent/Handlers/FallbackHandler.php:14:	public function __construct() {
src/Intent/Handlers/FallbackHandler.php:22:	public function handle( array $context ): Response {
src/AI/Functions/PrepareBulkStatusUpdate.php:11:	public function get_name() {
src/AI/Functions/PrepareBulkStatusUpdate.php:15:	public function get_description() {

thinking
**Opening AI Functions file**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/SearchOrders.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
<?php
/**
 * Function schema for order search.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class SearchOrders extends AbstractFunction {
	public function get_name() {
		return 'search_orders';
	}

	public function get_description() {
		return 'Search for orders by query, ID, customer email, status, or date range.';
	}

	public function get_parameters() {
		return array(

thinking
**Checking schema against spec**
exec
/bin/zsh -lc 'rg "search_orders" -n' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
src/AI/Functions/SearchOrders.php:12:		return 'search_orders';
src/Intent/Engine.php:176:			Intent::ORDER_SEARCH    => array( 'search_orders', 'select_orders' ),
tasks.csv:12:M02-02,"Order Search and Retrieval","Implement natural language order search: 1) Create AgentWP\Handlers\OrderSearchHandler class. 2) OpenAI function schema: search_orders(query?: string, order_id?: int, email?: string, status?: string, date_range?: {start: string, end: string}, limit?: int). 3) Translate natural language to WC_Order_Query parameters: 'last order' → limit 1 + orderby date DESC, 'orders from john@...' → customer email filter, 'pending orders' → status filter. 4) Return simplified order objects: id, status, total, customer_name, customer_email, date_created, items_summary, shipping_address. 5) Cache recent queries in transients (1 hour TTL). 6) Support relative dates: 'yesterday', 'last week', 'this month'. Acceptance Criteria: 'Show me the last order' returns most recent order within 500ms, email search finds orders by billing/shipping email, date parsing handles common formats, cache reduces DB queries by 50%+ for repeated searches."

thinking
**Searching for order Handlers**
exec
/bin/zsh -lc "rg \"namespace AgentWP\\\\Handlers\" -n" in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 53ms:
rg: regex parse error:
    (?:namespace AgentWP\Handlers)
                        ^^
error: unrecognized escape sequence

thinking
**Adjusting search pattern for namespace**
exec
/bin/zsh -lc "rg \"namespace AgentWP\\\\Handlers\" -n src includes" in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 51ms:
rg: regex parse error:
    (?:namespace AgentWP\Handlers)
                        ^^
error: unrecognized escape sequence

thinking
**Testing rg command with literal string search**
exec
/bin/zsh -lc "rg -F \"namespace AgentWP\\\\Handlers\" -n src includes" in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 50ms:


thinking
**Exploring handlers directory**
exec
/bin/zsh -lc 'ls src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 41ms:
AI
API
index.php
Intent
Plugin.php
Rest
Security

thinking
**Investigating handler locations**
exec
/bin/zsh -lc 'rg "Order" -n src/Rest src/API src/AI src/Intent' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 61ms:
src/Intent/Intent.php:40:			self::ORDER_SEARCH    => 'Order search',
src/Intent/Intent.php:41:			self::ORDER_REFUND    => 'Order refund',
src/Intent/Intent.php:42:			self::ORDER_STATUS    => 'Order status',
src/Intent/Engine.php:15:use AgentWP\Intent\Handlers\OrderRefundHandler;
src/Intent/Engine.php:16:use AgentWP\Intent\Handlers\OrderSearchHandler;
src/Intent/Engine.php:17:use AgentWP\Intent\Handlers\OrderStatusHandler;
src/Intent/Engine.php:130:			new OrderSearchHandler(),
src/Intent/Engine.php:131:			new OrderRefundHandler(),
src/Intent/Engine.php:132:			new OrderStatusHandler(),
src/Intent/Handlers/OrderRefundHandler.php:13:class OrderRefundHandler extends BaseHandler {
src/AI/Functions/SearchOrders.php:10:class SearchOrders extends AbstractFunction {
src/Intent/Handlers/OrderStatusHandler.php:13:class OrderStatusHandler extends BaseHandler {
src/Intent/Handlers/OrderSearchHandler.php:13:class OrderSearchHandler extends BaseHandler {
src/AI/Functions/PrepareRefund.php:27:					'description' => 'Order ID to refund.',
src/AI/Functions/SelectOrders.php:10:class SelectOrders extends AbstractFunction {
src/AI/Functions/SelectOrders.php:31:							'description' => 'Order status filter.',
src/AI/Functions/BulkUpdate.php:27:					'description' => 'Order IDs to update.',
src/AI/Functions/DraftEmail.php:27:					'description' => 'Order ID for context.',
src/AI/Functions/PrepareStatusUpdate.php:27:					'description' => 'Order ID to update.',

thinking
**Searching for tool call handlers**
exec
/bin/zsh -lc 'rg "function_suggestions|tool" -n src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
src/AI/Functions/FunctionSchema.php:29:	public function to_tool_definition();
src/AI/Functions/AbstractFunction.php:3: * Base class for tool definitions.
src/AI/Functions/AbstractFunction.php:14:	public function to_tool_definition() {
src/AI/TokenCounter.php:20:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:24:	public function count_request_tokens( array $messages, array $tools, $model ) {
src/AI/TokenCounter.php:28:			+ $this->count_tool_tokens( $tools, $model );
src/AI/TokenCounter.php:67:	 * Count tokens for tool definitions.
src/AI/TokenCounter.php:69:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:73:	public function count_tool_tokens( array $tools, $model ) {
src/AI/TokenCounter.php:74:		if ( empty( $tools ) ) {
src/AI/TokenCounter.php:78:		$payload = wp_json_encode( $tools );
src/AI/OpenAIClient.php:99:		$tools = $this->normalize_tools( $functions );
src/AI/OpenAIClient.php:106:		if ( ! empty( $tools ) ) {
src/AI/OpenAIClient.php:107:			$payload['tools']       = $tools;
src/AI/OpenAIClient.php:108:			$payload['tool_choice'] = 'auto';
src/AI/OpenAIClient.php:116:		$input_tokens = $this->token_counter->count_request_tokens( $messages, $tools, $this->model );
src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:296:	private function normalize_tools( array $functions ) {
src/AI/OpenAIClient.php:297:		$tools = array();
src/AI/OpenAIClient.php:301:				$tools[] = $function->to_tool_definition();

thinking
**Investigating function execution paths**
exec
/bin/zsh -lc 'rg "FunctionRegistry" -n src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
src/Intent/FunctionRegistry.php:10:class FunctionRegistry {
src/Intent/Engine.php:37:	 * @var FunctionRegistry
src/Intent/Engine.php:53:	 * @param FunctionRegistry|null $function_registry Optional registry.
src/Intent/Engine.php:60:		FunctionRegistry $function_registry = null,
src/Intent/Engine.php:68:		$this->function_registry = $function_registry ? $function_registry : new FunctionRegistry();
src/Intent/Engine.php:112:	 * @return FunctionRegistry

thinking
**Checking React folder for functions**
exec
/bin/zsh -lc 'rg "search_orders" -n react src/includes' in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 58ms:
rg: src/includes: No such file or directory (os error 2)

thinking
**Adjusting search path to React**
exec
/bin/zsh -lc 'rg "search_orders" -n react includes' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 49ms:


thinking
**Checking for search handler usage**
exec
/bin/zsh -lc 'ls src/Rest' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 44ms:
HealthController.php
IntentController.php
SettingsController.php

thinking
**Opening IntentController file**
exec
/bin/zsh -lc "sed -n '1,240p' src/Rest/IntentController.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Intent REST controller.
 *
 * @package AgentWP
 */

namespace AgentWP\Rest;

use AgentWP\API\RestController;
use AgentWP\Intent\Engine;
use WP_REST_Server;

class IntentController extends RestController {
	/**
	 * Register REST routes.
	 *
	 * @return void
	 */
	public function register_routes() {

thinking
**Searching for function usage in Rest controllers**
exec
/bin/zsh -lc 'rg "function" -n src/Rest src/API' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 41ms:
src/API/RestController.php:21:	public function __construct() {
src/API/RestController.php:31:	public function permissions_check( $request ) {
src/API/RestController.php:56:	protected function validate_request( $request, array $schema, $source = 'json' ) {
src/API/RestController.php:77:	protected function response_success( $data, $status = 200 ) {
src/API/RestController.php:100:	protected function response_error( $code, $message, $status = 400 ) {
src/API/RestController.php:125:	public static function check_rate_limit( $request ) {
src/API/RestController.php:180:	public static function log_request( $request, $status, $error_code = '' ) {
src/Rest/HealthController.php:19:	public function register_routes() {
src/Rest/HealthController.php:37:	public function get_health( $request ) {
src/Rest/IntentController.php:20:	public function register_routes() {
src/Rest/IntentController.php:38:	public function create_intent( $request ) {
src/Rest/IntentController.php:84:	private function get_intent_schema() {
src/Rest/SettingsController.php:23:	public function register_routes() {
src/Rest/SettingsController.php:68:	public function get_settings( $request ) {
src/Rest/SettingsController.php:91:	public function update_settings( $request ) {
src/Rest/SettingsController.php:118:	public function update_api_key( $request ) {
src/Rest/SettingsController.php:173:	public function get_usage( $request ) {
src/Rest/SettingsController.php:207:	private function read_settings() {
src/Rest/SettingsController.php:221:	private function apply_settings_updates( array $settings, array $payload ) {
src/Rest/SettingsController.php:271:	private function validate_openai_api_key( $api_key ) {

thinking
**Checking React for tool calls**
exec
/bin/zsh -lc 'rg "tool" -n react' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 55ms:


thinking
**Checking React directory**
exec
/bin/zsh -lc 'ls react' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
index.html
package.json
postcss.config.js
src
tailwind.config.js
vite.config.js
exec
/bin/zsh -lc 'rg "intent" -n react/src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 59ms:
react/src/App.jsx:10:const REST_PATH = '/agentwp/v1/intent';
exec
/bin/zsh -lc "sed -n '1,220p' react/src/App.jsx" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 33ms:
import { useCallback, useEffect, useRef, useState } from 'react';
import ReactMarkdown from 'react-markdown';

const OPEN_STATE_KEY = 'agentwp-command-deck-open';
const ADMIN_TRIGGER_SELECTORS = [
  '#wp-admin-bar-agentwp',
  '[data-agentwp-command-deck]',
  '#agentwp-command-deck',
];
const REST_PATH = '/agentwp/v1/intent';
const FOCUSABLE_SELECTORS = [
  'a[href]',
  'button:not([disabled])',
  'textarea:not([disabled])',
  'input:not([disabled])',
  'select:not([disabled])',
  '[tabindex]:not([tabindex="-1"])',
];

const getInitialOpenState = () => {

thinking
**Searching for function_suggestions in React**
exec
/bin/zsh -lc 'rg "function_suggestions" -n react/src' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 57ms:


thinking
**Checking default response behavior**
exec
/bin/zsh -lc "sed -n '1,220p' src/Intent/Engine.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
<?php
/**
 * Intent engine for routing requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

use AgentWP\AI\Response;
use AgentWP\Intent\Handlers\AnalyticsQueryHandler;
use AgentWP\Intent\Handlers\CustomerLookupHandler;
use AgentWP\Intent\Handlers\EmailDraftHandler;
use AgentWP\Intent\Handlers\FallbackHandler;
use AgentWP\Intent\Handlers\OrderRefundHandler;
use AgentWP\Intent\Handlers\OrderSearchHandler;
use AgentWP\Intent\Handlers\OrderStatusHandler;
use AgentWP\Intent\Handlers\ProductStockHandler;

class Engine {

thinking
**Investigating OpenAIClient usage**
exec
/bin/zsh -lc 'rg "OpenAIClient" -n src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 59ms:
src/AI/OpenAIClient.php:12:class OpenAIClient {

thinking
**Searching for 'chat(' calls**
exec
/bin/zsh -lc 'rg "->chat" -n src' in /Users/ahmedyounis/Documents/Projects/agentwp exited 2 in 55ms:
rg: unrecognized flag ->

thinking
**Planning ripgrep usage**
exec
/bin/zsh -lc "rg \"chat\\(\" -n src" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
src/AI/OpenAIClient.php:94:	public function chat( array $messages, array $functions ) {

thinking
**Exploring plugin integration and handler placement**
exec
/bin/zsh -lc 'rg "Handlers" -n src includes' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/Intent/Handlers/FallbackHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/CustomerLookupHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderRefundHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/ProductStockHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/BaseHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderSearchHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/EmailDraftHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/OrderStatusHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Handlers/AnalyticsQueryHandler.php:8:namespace AgentWP\Intent\Handlers;
src/Intent/Engine.php:11:use AgentWP\Intent\Handlers\AnalyticsQueryHandler;
src/Intent/Engine.php:12:use AgentWP\Intent\Handlers\CustomerLookupHandler;
src/Intent/Engine.php:13:use AgentWP\Intent\Handlers\EmailDraftHandler;
src/Intent/Engine.php:14:use AgentWP\Intent\Handlers\FallbackHandler;
src/Intent/Engine.php:15:use AgentWP\Intent\Handlers\OrderRefundHandler;
src/Intent/Engine.php:16:use AgentWP\Intent\Handlers\OrderSearchHandler;
src/Intent/Engine.php:17:use AgentWP\Intent\Handlers\OrderStatusHandler;
src/Intent/Engine.php:18:use AgentWP\Intent\Handlers\ProductStockHandler;

thinking
**Evaluating handler class location**
exec
/bin/zsh -lc 'rg "tool" -n src/API src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
src/AI/Functions/FunctionSchema.php:29:	public function to_tool_definition();
src/AI/Functions/AbstractFunction.php:3: * Base class for tool definitions.
src/AI/Functions/AbstractFunction.php:14:	public function to_tool_definition() {
src/AI/TokenCounter.php:20:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:24:	public function count_request_tokens( array $messages, array $tools, $model ) {
src/AI/TokenCounter.php:28:			+ $this->count_tool_tokens( $tools, $model );
src/AI/TokenCounter.php:67:	 * Count tokens for tool definitions.
src/AI/TokenCounter.php:69:	 * @param array  $tools Tool definitions.
src/AI/TokenCounter.php:73:	public function count_tool_tokens( array $tools, $model ) {
src/AI/TokenCounter.php:74:		if ( empty( $tools ) ) {
src/AI/TokenCounter.php:78:		$payload = wp_json_encode( $tools );
src/AI/OpenAIClient.php:99:		$tools = $this->normalize_tools( $functions );
src/AI/OpenAIClient.php:106:		if ( ! empty( $tools ) ) {
src/AI/OpenAIClient.php:107:			$payload['tools']       = $tools;
src/AI/OpenAIClient.php:108:			$payload['tool_choice'] = 'auto';
src/AI/OpenAIClient.php:116:		$input_tokens = $this->token_counter->count_request_tokens( $messages, $tools, $this->model );
src/AI/OpenAIClient.php:167:				'tool_calls' => $parsed['tool_calls'],
src/AI/OpenAIClient.php:296:	private function normalize_tools( array $functions ) {
src/AI/OpenAIClient.php:297:		$tools = array();
src/AI/OpenAIClient.php:301:				$tools[] = $function->to_tool_definition();

thinking
**Investigating backend order search implementation**
exec
/bin/zsh -lc 'ls .plans' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
M00-01.md
M00-02.md
M00-03.md
M01-01.md
M01-02.md
M01-03.md
M01-04.md
M01-05.md
M01-06.md
M02-01.md
M02-02.md

thinking
**Inspecting related handler classes**
exec
/bin/zsh -lc 'cat .plans/M02-01.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
# M02-01 — Intent Engine Core

Build the intent classification and routing system in PHP: 1) AgentWP\Intent\Engine class that receives natural language input and routes to appropriate handler. 2) Define intent categories: ORDER_SEARCH, ORDER_REFUND, ORDER_STATUS, PRODUCT_STOCK, EMAIL_DRAFT, ANALYTICS_QUERY, CUSTOMER_LOOKUP. 3) Create AgentWP\Intent\Handler interface with methods: canHandle(string $intent): bool, handle(array $context): Response. 4) Context builder that enriches requests with: current user, recent orders (last 5), store timezone, currency. 5) Function registry mapping OpenAI function names to PHP handlers. 6) Implement conversation memory within session (last 5 exchanges). 7) Fallback handler for unrecognized intents with helpful suggestions. Acceptance Criteria: Correct intent identified >95% of test cases, context includes relevant store data, handlers receive properly structured input, unhandled intents suggest alternatives.

thinking
**Exploring handler patterns and search functions**
exec
/bin/zsh -lc 'rg "prepare_refund|confirm_refund|prepare_status_update|prepare_bulk_status_update|bulk_update|search_product|get_sales_report|get_customer_profile|select_orders" -n src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
src/AI/Functions/GetSalesReport.php:12:		return 'get_sales_report';
src/AI/Functions/PrepareBulkStatusUpdate.php:12:		return 'prepare_bulk_status_update';
src/AI/Functions/SelectOrders.php:12:		return 'select_orders';
src/AI/Functions/ConfirmRefund.php:12:		return 'confirm_refund';
src/AI/Functions/SearchProduct.php:12:		return 'search_product';
src/AI/Functions/GetCustomerProfile.php:12:		return 'get_customer_profile';
src/AI/Functions/PrepareRefund.php:12:		return 'prepare_refund';
src/AI/Functions/BulkUpdate.php:12:		return 'bulk_update';
src/AI/Functions/PrepareStatusUpdate.php:12:		return 'prepare_status_update';
src/Intent/Engine.php:176:			Intent::ORDER_SEARCH    => array( 'search_orders', 'select_orders' ),
src/Intent/Engine.php:177:			Intent::ORDER_REFUND    => array( 'prepare_refund', 'confirm_refund' ),
src/Intent/Engine.php:178:			Intent::ORDER_STATUS    => array( 'prepare_status_update', 'prepare_bulk_status_update', 'bulk_update' ),
src/Intent/Engine.php:179:			Intent::PRODUCT_STOCK   => array( 'prepare_stock_update', 'search_product' ),
src/Intent/Engine.php:181:			Intent::ANALYTICS_QUERY => array( 'get_sales_report' ),
src/Intent/Engine.php:182:			Intent::CUSTOMER_LOOKUP => array( 'get_customer_profile' ),

thinking
**Identifying where to add handlers**
exec
/bin/zsh -lc 'rg "function" -n docs README.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
docs/agentwp-prd.md:31:CodeCanyon's WooCommerce category presents a mature but opportunity-rich environment. The **top-selling plugins** cluster around essential e-commerce functions: Filter Everything ($49, 121 weekly sales), CURCY multi-currency ($34), and Extra Product Options ($69, 1,300+ reviews). These establish the proven price ceiling.
docs/agentwp-prd.md:39:The data shows **98.2% of plugins price under $40**, but top performers consistently price at **$42–69**. AI plugins like MagicAI and Davinci AI successfully command $49–69, validating premium pricing for AI-powered functionality. The "race to bottom" strategy fails—the average plugin price of $18.91 correlates with minimal success, while category leaders demonstrate that merchants pay for genuine value.
docs/agentwp-prd.md:46:- Live demo site showcasing real functionality (essential, not optional)
docs/agentwp-prd.md:62:- Design functions that pass the "intern test"—if the function name and description alone don't make usage obvious, refine them
docs/agentwp-prd.md:63:- Combine functions that are always called sequentially into single operations
docs/agentwp-prd.md:98:- **78–88%** of companies use AI in at least one business function
docs/agentwp-prd.md:196:**Compliance:** Execute OpenAI DPA immediately, build GDPR consent mechanisms into initial release, and implement CCPA opt-out functionality. These cannot be afterthoughts.

thinking
**Analyzing handler implementation requirements**
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Handlers/BaseHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 46ms:
<?php
/**
 * Base handler for intent responses.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Handler;
use AgentWP\Intent\Intent;

abstract class BaseHandler implements Handler {
	/**
	 * @var string
	 */
	protected $intent;

	/**

thinking
**Analyzing order search handler requirements**
exec
/bin/zsh -lc 'cat .plans/M01-03.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
# M01-03 — API Key Encryption System

Implement secure API key storage in PHP: 1) Create AgentWP\Security\Encryption class using AES-256-CTR with WordPress salts (LOGGED_IN_KEY and LOGGED_IN_SALT) as encryption materials. 2) Methods: encrypt(string $plaintext): string, decrypt(string $ciphertext): string, isEncrypted(string $data): bool. 3) Store encrypted key in wp_options table under 'agentwp_api_key'. 4) Create REST endpoint POST /agentwp/v1/settings/api-key that validates key format (sk-*), tests against OpenAI /v1/models endpoint, encrypts and stores on success. 5) Never log or expose plaintext keys. 6) Add key rotation support (re-encrypt with new salts). Acceptance Criteria: Stored key is unreadable without WordPress salts, key validation catches invalid/expired keys, encryption/decryption round-trips correctly, no plaintext keys in logs or database queries.

thinking
**Exploring source structure for handlers**
exec
/bin/zsh -lc 'ls src/Security' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
Encryption.php

thinking
**Planning namespace and folder structure**
exec
/bin/zsh -lc 'cat composer.json' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 43ms:
{
  "name": "agentwp/agentwp",
  "description": "AgentWP WordPress plugin.",
  "type": "wordpress-plugin",
  "license": "GPL-2.0-or-later",
  "autoload": {
    "psr-4": {
      "AgentWP\\": "src/"
    }
  },
  "require": {
    "php": ">=7.4",
    "yethee/tiktoken": "^0.1.2"
  }
}

thinking
**Analyzing handler implementation and integration**
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/AbstractFunction.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
<?php
/**
 * Base class for tool definitions.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

abstract class AbstractFunction implements FunctionSchema {
	/**
	 * @return array
	 */
	public function to_tool_definition() {
		return array(
			'type'     => 'function',
			'function' => array(
				'name'        => $this->get_name(),
				'description' => $this->get_description(),
				'parameters'  => $this->get_parameters(),

thinking
**Designing order search with caching**

I'm planning to implement an order search handler that uses WooCommerce's order query features, supports natural language parsing for dates and email filters, and caches results using transients for efficiency. I'll handle billing and potential shipping email metadata, interpret relative dates like "yesterday" or "last week," and ensure compatible date range queries with WooCommerce's expected formats. The handler will return simplified order data and ideally integrate with the existing Response pattern for consistency. Let's explore how to robustly parse inputs, query orders, and cache results effectively!
exec
/bin/zsh -lc 'rg "Response::" -n src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 57ms:
src/AI/OpenAIClient.php:96:			return Response::error( 'Missing OpenAI API key.', 401 );
src/AI/OpenAIClient.php:120:			return Response::error(
src/AI/OpenAIClient.php:136:			return Response::error(
src/AI/OpenAIClient.php:164:		return Response::success(
src/Intent/Handlers/BaseHandler.php:66:		return Response::success( $payload );
src/Intent/Engine.php:86:			return Response::error( 'Missing intent input.', 400 );

thinking
**Designing order search handler integration**

I'm considering how to build a new OrderSearchHandler class to parse natural language input and execute order queries, then integrate it with the existing Intent handler so it returns structured results in Responses. I’m also thinking about schema compliance, optional parameters, caching with transients, and heuristics for interpreting queries like "last order." It looks like this setup will satisfy the spec while keeping the new logic modular and reusable.
exec
/bin/zsh -lc "sed -n '1,200p' src/AI/Functions/SelectOrders.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 44ms:
<?php
/**
 * Function schema for selecting orders for bulk actions.
 *
 * @package AgentWP
 */

namespace AgentWP\AI\Functions;

class SelectOrders extends AbstractFunction {
	public function get_name() {
		return 'select_orders';
	}

	public function get_description() {
		return 'Select orders matching a set of criteria for bulk actions.';
	}

	public function get_parameters() {
		return array(

thinking
**Preparing to implement order search handler**
exec
/bin/zsh -lc "sed -n '1,220p' src/Plugin.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
<?php
/**
 * Core plugin bootstrap.
 *
 * @package AgentWP
 */

namespace AgentWP;

class Plugin {
	const OPTION_SETTINGS     = 'agentwp_settings';
	const OPTION_API_KEY      = 'agentwp_api_key';
	const OPTION_API_KEY_LAST4 = 'agentwp_api_key_last4';
	const OPTION_BUDGET_LIMIT = 'agentwp_budget_limit';
	const OPTION_DRAFT_TTL    = 'agentwp_draft_ttl_minutes';
	const OPTION_USAGE_STATS  = 'agentwp_usage_stats';
	const TRANSIENT_PREFIX    = 'agentwp_';

	/**
	 * @var Plugin|null

thinking
**Designing OrderSearchHandler class**
exec
/bin/zsh -lc 'rg "TRANSIENT_PREFIX" -n src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 59ms:
src/API/RestController.php:135:		$key    = Plugin::TRANSIENT_PREFIX . 'rate_' . $user_id;
src/API/RestController.php:182:		$key     = Plugin::TRANSIENT_PREFIX . 'rest_log_' . ( $user_id ? $user_id : 'guest' );
src/Plugin.php:17:	const TRANSIENT_PREFIX    = 'agentwp_';
src/Plugin.php:356:		$transient_like = $wpdb->esc_like( self::TRANSIENT_PREFIX ) . '%';

thinking
**Designing query parsing and defaults**

I'm planning to handle relative date parsing with DateTimeImmutable using WordPress timezone if available, otherwise UTC. I'll parse natural language dates like "yesterday" and recognize phrases like "last order." The parsing will extract emails, order statuses with synonyms, and order IDs from queries using regex. Date ranges from text such as "from X to Y" will be supported, with fallback to standard date parsing on inputs. I'll also set a default limit (likely 10) and handle ordering by date descending, especially when "last order" is requested. For email filtering, since WC_Order_Query can't filter by email directly, I'll use meta queries on billing email. I'll review existing code patterns for context. This approach balances flexible input parsing with sensible defaults to accurately build WC_Order_Query arguments.
exec
/bin/zsh -lc "sed -n '1,160p' src/Intent/ContextBuilder.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 46ms:
<?php
/**
 * Build enriched intent context.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

class ContextBuilder {
	/**
	 * Build context with store and user data.
	 *
	 * @param array $context Request context.
	 * @param array $metadata Request metadata.
	 * @return array
	 */
	public function build( array $context = array(), array $metadata = array() ) {
		return array(
			'request'       => $context,


thinking
**Designing order search handler**
thinking
**Coordinating search handler with intent processing**

This chunk involves deciding to implement the order search logic in a dedicated handler class while updating the intent handler to call it; I’m planning how the new `OrderSearchHandler` will return structured results or errors, and how the intent handler will parse input, invoke that class, then build a user-friendly message with contextual data merged cleanly—thinking carefully about argument parsing, caching keys, natural language interpretation, and response structure to keep things maintainable and testable.
exec
/bin/zsh -lc "sed -n '150,220p' src/Intent/IntentClassifier.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
	/**
	 * @param string $text Normalized text.
	 * @return int
	 */
	private function score_customer( $text ) {
		return $this->match_score(
			$text,
			array(
				'customer',
				'profile',
				'buyer',
				'account',
				'loyalty',
			)
		);
	}

	/**
	 * @param string $text Normalized text.
	 * @return int

thinking
**Designing order search implementation**

I'm carefully planning argument normalization, order query building, caching, and formatting order results with sanitized fields and fallback logic for addresses; also mapping status keywords and handling special cases like order_id lookups, all to create a clean, efficient class with careful data handling and WordPress standards compliance.
file update
A /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/OrderSearchHandler.php
<?php
/**
 * Handle order search requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;
use DateTimeImmutable;
use DateTimeZone;
use Exception;

class OrderSearchHandler {
	const DEFAULT_LIMIT = 10;
	const CACHE_TTL     = HOUR_IN_SECONDS;

	/**
	 * Handle an order search request.
	 *
	 * @param array $args Search parameters.
	 * @return Response
	 */
	public function handle( array $args ): Response {
		if ( ! function_exists( 'wc_get_orders' ) ) {
			return Response::error( 'WooCommerce is required to search orders.', 400 );
		}

		$normalized = $this->normalize_args( $args );
		$cache_key  = $this->build_cache_key( $normalized );
		$cached     = $this->read_cache( $cache_key );

		if ( null !== $cached ) {
			return Response::success(
				array(
					'orders' => $cached,
					'count'  => count( $cached ),
					'cached' => true,
					'query'  => $this->public_query_summary( $normalized ),
				)
			);
		}

		$orders = $this->run_query( $normalized );
		$this->write_cache( $cache_key, $orders );

		return Response::success(
			array(
				'orders' => $orders,
				'count'  => count( $orders ),
				'cached' => false,
				'query'  => $this->public_query_summary( $normalized ),
			)
		);
	}

	/**
	 * @param array $args Search parameters.
	 * @return array
	 */
	private function normalize_args( array $args ) {
		$normalized = array(
			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
			'orderby'    => '',
			'order'      => '',
		);

		if ( '' !== $normalized['query'] ) {
			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
		}

		if ( '' !== $normalized['status'] ) {
			$normalized['status'] = $this->normalize_status( $normalized['status'] );
		}

		if ( 0 === $normalized['limit'] ) {
			$normalized['limit'] = self::DEFAULT_LIMIT;
		}

		if ( '' === $normalized['orderby'] ) {
			$normalized['orderby'] = 'date';
		}

		if ( '' === $normalized['order'] ) {
			$normalized['order'] = 'DESC';
		}

		return $normalized;
	}

	/**
	 * @param array  $normalized Current normalized params.
	 * @param string $query Raw query string.
	 * @return array
	 */
	private function apply_query_hints( array $normalized, $query ) {
		$query = trim( (string) $query );
		if ( '' === $query ) {
			return $normalized;
		}

		$lowered = strtolower( $query );

		if ( 0 === $normalized['order_id'] ) {
			$normalized['order_id'] = $this->extract_order_id( $lowered );
		}

		if ( '' === $normalized['email'] ) {
			$normalized['email'] = $this->extract_email( $lowered );
		}

		if ( '' === $normalized['status'] ) {
			$normalized['status'] = $this->detect_status( $lowered );
		}

		if ( null === $normalized['date_range'] ) {
			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
		}

		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
			$normalized['limit']   = 1;
			$normalized['orderby'] = 'date';
			$normalized['order']   = 'DESC';
		}

		return $normalized;
	}

	/**
	 * @param array $date_range Input date range.
	 * @return array|null
	 */
	private function normalize_date_range_input( $date_range ) {
		if ( ! is_array( $date_range ) ) {
			return null;
		}

		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';

		return $this->normalize_date_range_values( $start, $end );
	}

	/**
	 * @param string $status Raw status string.
	 * @return string
	 */
	private function normalize_status( $status ) {
		$status = strtolower( trim( (string) $status ) );
		if ( 0 === strpos( $status, 'wc-' ) ) {
			$status = substr( $status, 3 );
		}

		return $status;
	}

	/**
	 * @param array $normalized Search params.
	 * @return string
	 */
	private function build_cache_key( array $normalized ) {
		$payload = wp_json_encode( $normalized );
		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );

		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
	}

	/**
	 * @param string $cache_key Transient key.
	 * @return array|null
	 */
	private function read_cache( $cache_key ) {
		if ( ! function_exists( 'get_transient' ) ) {
			return null;
		}

		$cached = get_transient( $cache_key );
		if ( false === $cached || ! is_array( $cached ) ) {
			return null;
		}

		return $cached;
	}

	/**
	 * @param string $cache_key Transient key.
	 * @param array  $orders Cached orders.
	 * @return void
	 */
	private function write_cache( $cache_key, array $orders ) {
		if ( ! function_exists( 'set_transient' ) ) {
			return;
		}

		set_transient( $cache_key, $orders, self::CACHE_TTL );
	}

	/**
	 * @param array $normalized Search parameters.
	 * @return array
	 */
	private function run_query( array $normalized ) {
		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
			return array();
		}

		if ( $normalized['order_id'] > 0 ) {
			$order = wc_get_order( $normalized['order_id'] );
			if ( $order ) {
				return array( $this->format_order( $order ) );
			}

			return array();
		}

		$query_args = array(
			'limit'   => $normalized['limit'],
			'orderby' => $normalized['orderby'],
			'order'   => $normalized['order'],
		);

		if ( '' !== $normalized['status'] ) {
			$query_args['status'] = $normalized['status'];
		}

		if ( is_array( $normalized['date_range'] ) ) {
			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
		}

		if ( '' !== $normalized['email'] ) {
			$query_args['meta_query'] = array(
				'relation' => 'OR',
				array(
					'key'     => '_billing_email',
					'value'   => $normalized['email'],
					'compare' => '=',
				),
				array(
					'key'     => '_shipping_email',
					'value'   => $normalized['email'],
					'compare' => '=',
				),
			);
		}

		$orders = wc_get_orders( $query_args );
		if ( ! is_array( $orders ) ) {
			return array();
		}

		$results = array();
		foreach ( $orders as $order ) {
			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
				continue;
			}
			$results[] = $this->format_order( $order );
		}

		return $results;
	}

	/**
	 * @param array $normalized Search params.
	 * @return array
	 */
	private function public_query_summary( array $normalized ) {
		return array(
			'order_id'   => $normalized['order_id'],
			'email'      => $normalized['email'],
			'status'     => $normalized['status'],
			'limit'      => $normalized['limit'],
			'date_range' => $normalized['date_range'],
		);
	}

	/**
	 * @param object $order Order instance.
	 * @return array
	 */
	private function format_order( $order ) {
		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
		$email        = $this->get_customer_email( $order );
		$customer     = $this->get_customer_name( $order );

		return array(
			'id'             => intval( $order->get_id() ),
			'status'         => sanitize_text_field( $order->get_status() ),
			'total'          => $order->get_total(),
			'customer_name'  => sanitize_text_field( $customer ),
			'customer_email' => sanitize_email( $email ),
			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
			'items_summary'  => $this->format_items_summary( $order ),
			'shipping_address' => $this->format_shipping_address( $order ),
		);
	}

	/**
	 * @param object $order Order instance.
	 * @return string
	 */
	private function get_customer_name( $order ) {
		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
		$name  = trim( $first . ' ' . $last );

		if ( '' !== $name ) {
			return $name;
		}

		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';

		return trim( $first . ' ' . $last );
	}

	/**
	 * @param object $order Order instance.
	 * @return string
	 */
	private function get_customer_email( $order ) {
		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
		if ( '' !== $email ) {
			return $email;
		}

		if ( method_exists( $order, 'get_meta' ) ) {
			$email = $order->get_meta( '_shipping_email' );
		}

		return is_string( $email ) ? $email : '';
	}

	/**
	 * @param object $order Order instance.
	 * @return string
	 */
	private function format_items_summary( $order ) {
		if ( ! method_exists( $order, 'get_items' ) ) {
			return '';
		}

		$items = $order->get_items();
		if ( empty( $items ) || ! is_array( $items ) ) {
			return '';
		}

		$summary = array();
		foreach ( $items as $item ) {
			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
				continue;
			}

			$name = sanitize_text_field( $item->get_name() );
			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;

			if ( $qty > 1 ) {
				$summary[] = sprintf( '%dx %s', $qty, $name );
			} else {
				$summary[] = $name;
			}
		}

		return implode( ', ', $summary );
	}

	/**
	 * @param object $order Order instance.
	 * @return array
	 */
	private function format_shipping_address( $order ) {
		if ( ! method_exists( $order, 'get_address' ) ) {
			return array();
		}

		$shipping = $order->get_address( 'shipping' );
		$billing  = $order->get_address( 'billing' );

		if ( ! is_array( $shipping ) ) {
			$shipping = array();
		}

		if ( ! is_array( $billing ) ) {
			$billing = array();
		}

		$fields = array(
			'first_name',
			'last_name',
			'company',
			'address_1',
			'address_2',
			'city',
			'state',
			'postcode',
			'country',
		);

		$address = array();
		foreach ( $fields as $field ) {
			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
			if ( '' === $value && isset( $billing[ $field ] ) ) {
				$value = trim( (string) $billing[ $field ] );
			}
			$address[ $field ] = $value;
		}

		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );

		return array(
			'name'      => sanitize_text_field( $name ),
			'company'   => sanitize_text_field( $address['company'] ),
			'address_1' => sanitize_text_field( $address['address_1'] ),
			'address_2' => sanitize_text_field( $address['address_2'] ),
			'city'      => sanitize_text_field( $address['city'] ),
			'state'     => sanitize_text_field( $address['state'] ),
			'postcode'  => sanitize_text_field( $address['postcode'] ),
			'country'   => sanitize_text_field( $address['country'] ),
		);
	}

	/**
	 * @param string $query Query string.
	 * @return int
	 */
	private function extract_order_id( $query ) {
		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
			return absint( $matches[1] );
		}

		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
			return absint( $matches[1] );
		}

		return 0;
	}

	/**
	 * @param string $query Query string.
	 * @return string
	 */
	private function extract_email( $query ) {
		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
			return sanitize_email( $matches[0] );
		}

		return '';
	}

	/**
	 * @param string $query Query string.
	 * @return string
	 */
	private function detect_status( $query ) {
		$map = array(
			'pending'    => array( 'pending', 'awaiting payment' ),
			'processing' => array( 'processing', 'in progress' ),
			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
			'cancelled'  => array( 'cancelled', 'canceled' ),
			'refunded'   => array( 'refunded', 'refund' ),
			'failed'     => array( 'failed', 'declined' ),
		);

		foreach ( $map as $status => $terms ) {
			foreach ( $terms as $term ) {
				if ( false !== strpos( $query, $term ) ) {
					return $status;
				}
			}
		}

		return '';
	}

	/**
	 * @param string $query Query string.
	 * @return array|null
	 */
	private function parse_date_range_from_query( $query ) {
		if ( false !== strpos( $query, 'yesterday' ) ) {
			return $this->relative_date_range( 'yesterday' );
		}

		if ( false !== strpos( $query, 'last week' ) ) {
			return $this->relative_date_range( 'last week' );
		}

		if ( false !== strpos( $query, 'this month' ) ) {
			return $this->relative_date_range( 'this month' );
		}

		$range = $this->extract_explicit_date_range( $query );
		if ( null !== $range ) {
			return $range;
		}

		return null;
	}

	/**
	 * @param string $phrase Relative date phrase.
	 * @return array|null
	 */
	private function relative_date_range( $phrase ) {
		$timezone = $this->get_timezone();
		$now      = new DateTimeImmutable( 'now', $timezone );
		$start    = null;
		$end      = null;

		switch ( $phrase ) {
			case 'yesterday':
				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
				$end   = $start->setTime( 23, 59, 59 );
				break;
			case 'last week':
				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
				$end   = $now;
				break;
			case 'this month':
				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
				$end   = $now;
				break;
			default:
				return null;
		}

		return $this->format_date_range( $start, $end );
	}

	/**
	 * @param string $query Query string.
	 * @return array|null
	 */
	private function extract_explicit_date_range( $query ) {
		$patterns = array(
			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
		);

		foreach ( $patterns as $pattern ) {
			if ( ! preg_match( $pattern, $query, $matches ) ) {
				continue;
			}

			$start = trim( $matches[1] );
			$end   = trim( $matches[2] );

			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
				continue;
			}

			$range = $this->normalize_date_range_values( $start, $end );
			if ( null !== $range ) {
				return $range;
			}
		}

		return null;
	}

	/**
	 * @param string $start Start date string.
	 * @param string $end End date string.
	 * @return array|null
	 */
	private function normalize_date_range_values( $start, $end ) {
		$start_date = $this->parse_date_string( $start, false );
		$end_date   = $this->parse_date_string( $end, true );

		if ( null === $start_date || null === $end_date ) {
			return null;
		}

		if ( $end_date < $start_date ) {
			$temp       = $start_date;
			$start_date = $end_date;
			$end_date   = $temp;
		}

		return $this->format_date_range( $start_date, $end_date );
	}

	/**
	 * @param string $date_string Input date.
	 * @param bool   $end_of_day Whether to set end of day.
	 * @return DateTimeImmutable|null
	 */
	private function parse_date_string( $date_string, $end_of_day ) {
		$date_string = trim( (string) $date_string );
		if ( '' === $date_string ) {
			return null;
		}

		$timezone = $this->get_timezone();
		$base_ts  = $this->get_base_timestamp();
		$ts       = strtotime( $date_string, $base_ts );

		if ( false === $ts ) {
			return null;
		}

		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
		if ( $end_of_day ) {
			$date = $date->setTime( 23, 59, 59 );
		} else {
			$date = $date->setTime( 0, 0, 0 );
		}

		return $date;
	}

	/**
	 * @param DateTimeImmutable $start Start date.
	 * @param DateTimeImmutable $end End date.
	 * @return array
	 */
	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
		return array(
			'start' => $start->format( 'Y-m-d H:i:s' ),
			'end'   => $end->format( 'Y-m-d H:i:s' ),
		);
	}

	/**
	 * @return DateTimeZone
	 */
	private function get_timezone() {
		if ( function_exists( 'wp_timezone' ) ) {
			return wp_timezone();
		}

		$timezone = '';
		if ( function_exists( 'wp_timezone_string' ) ) {
			$timezone = wp_timezone_string();
		}

		if ( '' === $timezone && function_exists( 'get_option' ) ) {
			$timezone = (string) get_option( 'timezone_string' );
		}

		if ( '' === $timezone ) {
			$timezone = 'UTC';
		}

		try {
			return new DateTimeZone( $timezone );
		} catch ( Exception $exception ) {
			return new DateTimeZone( 'UTC' );
		}
	}

	/**
	 * @return int
	 */
	private function get_base_timestamp() {
		if ( function_exists( 'current_time' ) ) {
			return (int) current_time( 'timestamp' );
		}

		return time();
	}

	/**
	 * @param string $query Query string.
	 * @return bool
	 */
	private function contains_last_order_phrase( $query ) {
		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
	}
}
apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
A src/Handlers/OrderSearchHandler.php
file update:
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..d982064136dfe9c798f96022e01af546af0c8f17
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = HOUR_IN_SECONDS;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'             => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'customer_name'  => sanitize_text_field( $customer ),
+			'customer_email' => sanitize_email( $email ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'  => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}

file update:
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..d982064136dfe9c798f96022e01af546af0c8f17
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = HOUR_IN_SECONDS;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'             => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'customer_name'  => sanitize_text_field( $customer ),
+			'customer_email' => sanitize_email( $email ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'  => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}


thinking
**Updating Intent handler with new class**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Intent/Handlers/OrderSearchHandler.php
@@ -10,2 +10,3 @@
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
@@ -22,4 +23,23 @@
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M src/Intent/Handlers/OrderSearchHandler.php
file update:
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..d982064136dfe9c798f96022e01af546af0c8f17
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = HOUR_IN_SECONDS;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'             => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'customer_name'  => sanitize_text_field( $customer ),
+			'customer_email' => sanitize_email( $email ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'  => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }

file update:
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..d982064136dfe9c798f96022e01af546af0c8f17
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = HOUR_IN_SECONDS;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'             => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'customer_name'  => sanitize_text_field( $customer ),
+			'customer_email' => sanitize_email( $email ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'  => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Refining response structure and updating schema descriptions**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/AI/Functions/SearchOrders.php
@@ -33,3 +33,3 @@
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
apply_patch(auto_approved=true) exited 0 in 38ms:
Success. Updated the following files:
M src/AI/Functions/SearchOrders.php
file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..d982064136dfe9c798f96022e01af546af0c8f17
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = HOUR_IN_SECONDS;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'             => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'customer_name'  => sanitize_text_field( $customer ),
+			'customer_email' => sanitize_email( $email ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'  => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }

file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..d982064136dfe9c798f96022e01af546af0c8f17
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = HOUR_IN_SECONDS;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'             => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'customer_name'  => sanitize_text_field( $customer ),
+			'customer_email' => sanitize_email( $email ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'  => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Reviewing and refining OrderSearchHandler implementation**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/OrderSearchHandler.php
@@ -298,3 +298,3 @@
 			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
-			'items_summary'  => $this->format_items_summary( $order ),
+			'items_summary'    => $this->format_items_summary( $order ),
 			'shipping_address' => $this->format_shipping_address( $order ),
apply_patch(auto_approved=true) exited 0 in 42ms:
Success. Updated the following files:
M src/Handlers/OrderSearchHandler.php
file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..20d19fd1fe780980404046753372390609e9fd85
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = HOUR_IN_SECONDS;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'             => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'customer_name'  => sanitize_text_field( $customer ),
+			'customer_email' => sanitize_email( $email ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }

file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..20d19fd1fe780980404046753372390609e9fd85
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = HOUR_IN_SECONDS;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'             => intval( $order->get_id() ),
+			'status'         => sanitize_text_field( $order->get_status() ),
+			'total'          => $order->get_total(),
+			'customer_name'  => sanitize_text_field( $customer ),
+			'customer_email' => sanitize_email( $email ),
+			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Standardizing key spacing**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/OrderSearchHandler.php
@@ -292,8 +292,8 @@
 		return array(
-			'id'             => intval( $order->get_id() ),
-			'status'         => sanitize_text_field( $order->get_status() ),
-			'total'          => $order->get_total(),
-			'customer_name'  => sanitize_text_field( $customer ),
-			'customer_email' => sanitize_email( $email ),
-			'date_created'   => $date_created ? $date_created->date( 'c' ) : '',
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
 			'items_summary'    => $this->format_items_summary( $order ),
apply_patch(auto_approved=true) exited 0 in 45ms:
Success. Updated the following files:
M src/Handlers/OrderSearchHandler.php
file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..52af2046da6db0cc831b8e0a9d132425f24f8df3
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = HOUR_IN_SECONDS;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }

file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..52af2046da6db0cc831b8e0a9d132425f24f8df3
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = HOUR_IN_SECONDS;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Evaluating constant definition approach**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/OrderSearchHandler.php
@@ -17,3 +17,3 @@
 	const DEFAULT_LIMIT = 10;
-	const CACHE_TTL     = HOUR_IN_SECONDS;
+	const CACHE_TTL     = 3600;
 
apply_patch(auto_approved=true) exited 0 in 45ms:
Success. Updated the following files:
M src/Handlers/OrderSearchHandler.php
file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..5aaf1835eaf6c34d19a8212d546256b02947059b
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = 3600;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }

file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..5aaf1835eaf6c34d19a8212d546256b02947059b
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = 3600;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Reviewing and verifying order search logic and edge cases**
exec
/bin/zsh -lc "sed -n '1,240p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Handle order search requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Handlers;

use AgentWP\AI\Response;
use AgentWP\Plugin;
use DateTimeImmutable;
use DateTimeZone;
use Exception;

class OrderSearchHandler {
	const DEFAULT_LIMIT = 10;
	const CACHE_TTL     = 3600;

	/**
file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..5aaf1835eaf6c34d19a8212d546256b02947059b
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = 3600;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Verifying stability and consistency**
exec
/bin/zsh -lc "sed -n '240,520p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
				array(
					'key'     => '_billing_email',
					'value'   => $normalized['email'],
					'compare' => '=',
				),
				array(
					'key'     => '_shipping_email',
					'value'   => $normalized['email'],
					'compare' => '=',
				),
			);
		}

		$orders = wc_get_orders( $query_args );
		if ( ! is_array( $orders ) ) {
			return array();
		}

		$results = array();
		foreach ( $orders as $order ) {
file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..5aaf1835eaf6c34d19a8212d546256b02947059b
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = 3600;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Continuing process**
exec
/bin/zsh -lc "sed -n '520,880p' src/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 50ms:
				$end   = $start->setTime( 23, 59, 59 );
				break;
			case 'last week':
				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
				$end   = $now;
				break;
			case 'this month':
				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
				$end   = $now;
				break;
			default:
				return null;
		}

		return $this->format_date_range( $start, $end );
	}

	/**
	 * @param string $query Query string.
	 * @return array|null
file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..5aaf1835eaf6c34d19a8212d546256b02947059b
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = 3600;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Verifying unused imports and preparing handler update**
exec
/bin/zsh -lc "sed -n '1,120p' src/Intent/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
<?php
/**
 * Handle order search intents.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
use AgentWP\Intent\Intent;

class OrderSearchHandler extends BaseHandler {
	public function __construct() {
		parent::__construct( Intent::ORDER_SEARCH );
	}

	/**
	 * @param array $context Context data.
file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..5aaf1835eaf6c34d19a8212d546256b02947059b
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = 3600;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now;
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Analyzing caching and date range normalization**

I'm reviewing how the relative date ranges like "yesterday," "last week," and "this month" affect caching effectiveness—since using the exact current time as an end date causes cache misses due to rapid changes. To improve cache hits, I'll normalize these ranges to stable day boundaries (start of day to end of day) so repeated queries within a day use consistent cache keys, especially by adjusting "last week" to cover the previous seven full days excluding today.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Handlers/OrderSearchHandler.php
@@ -523,3 +523,3 @@
 				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
-				$end   = $now;
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
 				break;
@@ -527,3 +527,3 @@
 				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
-				$end   = $now;
+				$end   = $now->setTime( 23, 59, 59 );
 				break;
apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M src/Handlers/OrderSearchHandler.php
file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..58b215343d1dbb80aa39ab5cf2fb8ace45b9dc1e
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = 3600;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }

file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..58b215343d1dbb80aa39ab5cf2fb8ace45b9dc1e
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = 3600;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Reviewing date range logic and query handling**
exec
/bin/zsh -lc 'cat src/index.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
<?php
// Silence is golden.
file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..58b215343d1dbb80aa39ab5cf2fb8ace45b9dc1e
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = 3600;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }


thinking
**Preparing final response with summary and verification details**
codex
Status: DONE

Summary of changes:
- Added natural language order search execution with caching, date parsing, and simplified order output in `src/Handlers/OrderSearchHandler.php`.
- Wired intent order search to return real results via the new handler in `src/Intent/Handlers/OrderSearchHandler.php`.
- Clarified the tool schema email description in `src/AI/Functions/SearchOrders.php`.

How to verify (exact commands):
- No verification commands provided.

Risks / follow-ups:
- Relative date ranges interpret “last week” as the previous 7 days ending yesterday; confirm this matches product expectations.
- Shipping email matching depends on `_shipping_email` meta, which may be absent on some stores.
file update:
diff --git a/src/AI/Functions/SearchOrders.php b/src/AI/Functions/SearchOrders.php
index a1de3cdff6ebd588501dd483230ea079da266217..c4e37c8b8ea8ce8edf04c201dabc4305bb24efa0
--- a/src/AI/Functions/SearchOrders.php
+++ b/src/AI/Functions/SearchOrders.php
@@ -31,7 +31,7 @@
 				),
 				'email'      => array(
 					'type'        => 'string',
-					'description' => 'Customer email address.',
+					'description' => 'Customer billing or shipping email address.',
 				),
 				'status'     => array(
 					'type'        => 'string',
diff --git a/src/Handlers/OrderSearchHandler.php b/src/Handlers/OrderSearchHandler.php
new file mode 100644
index 0000000000000000000000000000000000000000..58b215343d1dbb80aa39ab5cf2fb8ace45b9dc1e
--- /dev/null
+++ b/src/Handlers/OrderSearchHandler.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Handle order search requests.
+ *
+ * @package AgentWP
+ */
+
+namespace AgentWP\Handlers;
+
+use AgentWP\AI\Response;
+use AgentWP\Plugin;
+use DateTimeImmutable;
+use DateTimeZone;
+use Exception;
+
+class OrderSearchHandler {
+	const DEFAULT_LIMIT = 10;
+	const CACHE_TTL     = 3600;
+
+	/**
+	 * Handle an order search request.
+	 *
+	 * @param array $args Search parameters.
+	 * @return Response
+	 */
+	public function handle( array $args ): Response {
+		if ( ! function_exists( 'wc_get_orders' ) ) {
+			return Response::error( 'WooCommerce is required to search orders.', 400 );
+		}
+
+		$normalized = $this->normalize_args( $args );
+		$cache_key  = $this->build_cache_key( $normalized );
+		$cached     = $this->read_cache( $cache_key );
+
+		if ( null !== $cached ) {
+			return Response::success(
+				array(
+					'orders' => $cached,
+					'count'  => count( $cached ),
+					'cached' => true,
+					'query'  => $this->public_query_summary( $normalized ),
+				)
+			);
+		}
+
+		$orders = $this->run_query( $normalized );
+		$this->write_cache( $cache_key, $orders );
+
+		return Response::success(
+			array(
+				'orders' => $orders,
+				'count'  => count( $orders ),
+				'cached' => false,
+				'query'  => $this->public_query_summary( $normalized ),
+			)
+		);
+	}
+
+	/**
+	 * @param array $args Search parameters.
+	 * @return array
+	 */
+	private function normalize_args( array $args ) {
+		$normalized = array(
+			'query'      => isset( $args['query'] ) ? sanitize_text_field( $args['query'] ) : '',
+			'order_id'   => isset( $args['order_id'] ) ? absint( $args['order_id'] ) : 0,
+			'email'      => isset( $args['email'] ) ? sanitize_email( $args['email'] ) : '',
+			'status'     => isset( $args['status'] ) ? sanitize_text_field( $args['status'] ) : '',
+			'limit'      => isset( $args['limit'] ) ? absint( $args['limit'] ) : 0,
+			'date_range' => $this->normalize_date_range_input( isset( $args['date_range'] ) ? $args['date_range'] : null ),
+			'orderby'    => '',
+			'order'      => '',
+		);
+
+		if ( '' !== $normalized['query'] ) {
+			$normalized = $this->apply_query_hints( $normalized, $normalized['query'] );
+		}
+
+		if ( '' !== $normalized['status'] ) {
+			$normalized['status'] = $this->normalize_status( $normalized['status'] );
+		}
+
+		if ( 0 === $normalized['limit'] ) {
+			$normalized['limit'] = self::DEFAULT_LIMIT;
+		}
+
+		if ( '' === $normalized['orderby'] ) {
+			$normalized['orderby'] = 'date';
+		}
+
+		if ( '' === $normalized['order'] ) {
+			$normalized['order'] = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array  $normalized Current normalized params.
+	 * @param string $query Raw query string.
+	 * @return array
+	 */
+	private function apply_query_hints( array $normalized, $query ) {
+		$query = trim( (string) $query );
+		if ( '' === $query ) {
+			return $normalized;
+		}
+
+		$lowered = strtolower( $query );
+
+		if ( 0 === $normalized['order_id'] ) {
+			$normalized['order_id'] = $this->extract_order_id( $lowered );
+		}
+
+		if ( '' === $normalized['email'] ) {
+			$normalized['email'] = $this->extract_email( $lowered );
+		}
+
+		if ( '' === $normalized['status'] ) {
+			$normalized['status'] = $this->detect_status( $lowered );
+		}
+
+		if ( null === $normalized['date_range'] ) {
+			$normalized['date_range'] = $this->parse_date_range_from_query( $lowered );
+		}
+
+		if ( 0 === $normalized['limit'] && $this->contains_last_order_phrase( $lowered ) ) {
+			$normalized['limit']   = 1;
+			$normalized['orderby'] = 'date';
+			$normalized['order']   = 'DESC';
+		}
+
+		return $normalized;
+	}
+
+	/**
+	 * @param array $date_range Input date range.
+	 * @return array|null
+	 */
+	private function normalize_date_range_input( $date_range ) {
+		if ( ! is_array( $date_range ) ) {
+			return null;
+		}
+
+		$start = isset( $date_range['start'] ) ? sanitize_text_field( $date_range['start'] ) : '';
+		$end   = isset( $date_range['end'] ) ? sanitize_text_field( $date_range['end'] ) : '';
+
+		return $this->normalize_date_range_values( $start, $end );
+	}
+
+	/**
+	 * @param string $status Raw status string.
+	 * @return string
+	 */
+	private function normalize_status( $status ) {
+		$status = strtolower( trim( (string) $status ) );
+		if ( 0 === strpos( $status, 'wc-' ) ) {
+			$status = substr( $status, 3 );
+		}
+
+		return $status;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return string
+	 */
+	private function build_cache_key( array $normalized ) {
+		$payload = wp_json_encode( $normalized );
+		$hash    = $payload ? md5( $payload ) : md5( 'order_search' );
+
+		return Plugin::TRANSIENT_PREFIX . 'order_search_' . $hash;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @return array|null
+	 */
+	private function read_cache( $cache_key ) {
+		if ( ! function_exists( 'get_transient' ) ) {
+			return null;
+		}
+
+		$cached = get_transient( $cache_key );
+		if ( false === $cached || ! is_array( $cached ) ) {
+			return null;
+		}
+
+		return $cached;
+	}
+
+	/**
+	 * @param string $cache_key Transient key.
+	 * @param array  $orders Cached orders.
+	 * @return void
+	 */
+	private function write_cache( $cache_key, array $orders ) {
+		if ( ! function_exists( 'set_transient' ) ) {
+			return;
+		}
+
+		set_transient( $cache_key, $orders, self::CACHE_TTL );
+	}
+
+	/**
+	 * @param array $normalized Search parameters.
+	 * @return array
+	 */
+	private function run_query( array $normalized ) {
+		if ( ! function_exists( 'wc_get_order' ) || ! function_exists( 'wc_get_orders' ) ) {
+			return array();
+		}
+
+		if ( $normalized['order_id'] > 0 ) {
+			$order = wc_get_order( $normalized['order_id'] );
+			if ( $order ) {
+				return array( $this->format_order( $order ) );
+			}
+
+			return array();
+		}
+
+		$query_args = array(
+			'limit'   => $normalized['limit'],
+			'orderby' => $normalized['orderby'],
+			'order'   => $normalized['order'],
+		);
+
+		if ( '' !== $normalized['status'] ) {
+			$query_args['status'] = $normalized['status'];
+		}
+
+		if ( is_array( $normalized['date_range'] ) ) {
+			$query_args['date_created'] = $normalized['date_range']['start'] . '...' . $normalized['date_range']['end'];
+		}
+
+		if ( '' !== $normalized['email'] ) {
+			$query_args['meta_query'] = array(
+				'relation' => 'OR',
+				array(
+					'key'     => '_billing_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+				array(
+					'key'     => '_shipping_email',
+					'value'   => $normalized['email'],
+					'compare' => '=',
+				),
+			);
+		}
+
+		$orders = wc_get_orders( $query_args );
+		if ( ! is_array( $orders ) ) {
+			return array();
+		}
+
+		$results = array();
+		foreach ( $orders as $order ) {
+			if ( ! is_object( $order ) || ! method_exists( $order, 'get_id' ) ) {
+				continue;
+			}
+			$results[] = $this->format_order( $order );
+		}
+
+		return $results;
+	}
+
+	/**
+	 * @param array $normalized Search params.
+	 * @return array
+	 */
+	private function public_query_summary( array $normalized ) {
+		return array(
+			'order_id'   => $normalized['order_id'],
+			'email'      => $normalized['email'],
+			'status'     => $normalized['status'],
+			'limit'      => $normalized['limit'],
+			'date_range' => $normalized['date_range'],
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_order( $order ) {
+		$date_created = method_exists( $order, 'get_date_created' ) ? $order->get_date_created() : null;
+		$email        = $this->get_customer_email( $order );
+		$customer     = $this->get_customer_name( $order );
+
+		return array(
+			'id'               => intval( $order->get_id() ),
+			'status'           => sanitize_text_field( $order->get_status() ),
+			'total'            => $order->get_total(),
+			'customer_name'    => sanitize_text_field( $customer ),
+			'customer_email'   => sanitize_email( $email ),
+			'date_created'     => $date_created ? $date_created->date( 'c' ) : '',
+			'items_summary'    => $this->format_items_summary( $order ),
+			'shipping_address' => $this->format_shipping_address( $order ),
+		);
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_name( $order ) {
+		$first = method_exists( $order, 'get_billing_first_name' ) ? $order->get_billing_first_name() : '';
+		$last  = method_exists( $order, 'get_billing_last_name' ) ? $order->get_billing_last_name() : '';
+		$name  = trim( $first . ' ' . $last );
+
+		if ( '' !== $name ) {
+			return $name;
+		}
+
+		$first = method_exists( $order, 'get_shipping_first_name' ) ? $order->get_shipping_first_name() : '';
+		$last  = method_exists( $order, 'get_shipping_last_name' ) ? $order->get_shipping_last_name() : '';
+
+		return trim( $first . ' ' . $last );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function get_customer_email( $order ) {
+		$email = method_exists( $order, 'get_billing_email' ) ? $order->get_billing_email() : '';
+		if ( '' !== $email ) {
+			return $email;
+		}
+
+		if ( method_exists( $order, 'get_meta' ) ) {
+			$email = $order->get_meta( '_shipping_email' );
+		}
+
+		return is_string( $email ) ? $email : '';
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return string
+	 */
+	private function format_items_summary( $order ) {
+		if ( ! method_exists( $order, 'get_items' ) ) {
+			return '';
+		}
+
+		$items = $order->get_items();
+		if ( empty( $items ) || ! is_array( $items ) ) {
+			return '';
+		}
+
+		$summary = array();
+		foreach ( $items as $item ) {
+			if ( ! is_object( $item ) || ! method_exists( $item, 'get_name' ) ) {
+				continue;
+			}
+
+			$name = sanitize_text_field( $item->get_name() );
+			$qty  = method_exists( $item, 'get_quantity' ) ? intval( $item->get_quantity() ) : 1;
+
+			if ( $qty > 1 ) {
+				$summary[] = sprintf( '%dx %s', $qty, $name );
+			} else {
+				$summary[] = $name;
+			}
+		}
+
+		return implode( ', ', $summary );
+	}
+
+	/**
+	 * @param object $order Order instance.
+	 * @return array
+	 */
+	private function format_shipping_address( $order ) {
+		if ( ! method_exists( $order, 'get_address' ) ) {
+			return array();
+		}
+
+		$shipping = $order->get_address( 'shipping' );
+		$billing  = $order->get_address( 'billing' );
+
+		if ( ! is_array( $shipping ) ) {
+			$shipping = array();
+		}
+
+		if ( ! is_array( $billing ) ) {
+			$billing = array();
+		}
+
+		$fields = array(
+			'first_name',
+			'last_name',
+			'company',
+			'address_1',
+			'address_2',
+			'city',
+			'state',
+			'postcode',
+			'country',
+		);
+
+		$address = array();
+		foreach ( $fields as $field ) {
+			$value = isset( $shipping[ $field ] ) ? trim( (string) $shipping[ $field ] ) : '';
+			if ( '' === $value && isset( $billing[ $field ] ) ) {
+				$value = trim( (string) $billing[ $field ] );
+			}
+			$address[ $field ] = $value;
+		}
+
+		$name = trim( $address['first_name'] . ' ' . $address['last_name'] );
+
+		return array(
+			'name'      => sanitize_text_field( $name ),
+			'company'   => sanitize_text_field( $address['company'] ),
+			'address_1' => sanitize_text_field( $address['address_1'] ),
+			'address_2' => sanitize_text_field( $address['address_2'] ),
+			'city'      => sanitize_text_field( $address['city'] ),
+			'state'     => sanitize_text_field( $address['state'] ),
+			'postcode'  => sanitize_text_field( $address['postcode'] ),
+			'country'   => sanitize_text_field( $address['country'] ),
+		);
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return int
+	 */
+	private function extract_order_id( $query ) {
+		if ( preg_match( '/\border\s*#?\s*(\d+)\b/i', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		if ( preg_match( '/#(\d+)/', $query, $matches ) ) {
+			return absint( $matches[1] );
+		}
+
+		return 0;
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function extract_email( $query ) {
+		if ( preg_match( '/[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}/i', $query, $matches ) ) {
+			return sanitize_email( $matches[0] );
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return string
+	 */
+	private function detect_status( $query ) {
+		$map = array(
+			'pending'    => array( 'pending', 'awaiting payment' ),
+			'processing' => array( 'processing', 'in progress' ),
+			'completed'  => array( 'completed', 'complete', 'fulfilled' ),
+			'on-hold'    => array( 'on hold', 'on-hold', 'hold' ),
+			'cancelled'  => array( 'cancelled', 'canceled' ),
+			'refunded'   => array( 'refunded', 'refund' ),
+			'failed'     => array( 'failed', 'declined' ),
+		);
+
+		foreach ( $map as $status => $terms ) {
+			foreach ( $terms as $term ) {
+				if ( false !== strpos( $query, $term ) ) {
+					return $status;
+				}
+			}
+		}
+
+		return '';
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function parse_date_range_from_query( $query ) {
+		if ( false !== strpos( $query, 'yesterday' ) ) {
+			return $this->relative_date_range( 'yesterday' );
+		}
+
+		if ( false !== strpos( $query, 'last week' ) ) {
+			return $this->relative_date_range( 'last week' );
+		}
+
+		if ( false !== strpos( $query, 'this month' ) ) {
+			return $this->relative_date_range( 'this month' );
+		}
+
+		$range = $this->extract_explicit_date_range( $query );
+		if ( null !== $range ) {
+			return $range;
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $phrase Relative date phrase.
+	 * @return array|null
+	 */
+	private function relative_date_range( $phrase ) {
+		$timezone = $this->get_timezone();
+		$now      = new DateTimeImmutable( 'now', $timezone );
+		$start    = null;
+		$end      = null;
+
+		switch ( $phrase ) {
+			case 'yesterday':
+				$start = $now->setTime( 0, 0, 0 )->modify( '-1 day' );
+				$end   = $start->setTime( 23, 59, 59 );
+				break;
+			case 'last week':
+				$start = $now->modify( '-7 days' )->setTime( 0, 0, 0 );
+				$end   = $now->modify( '-1 day' )->setTime( 23, 59, 59 );
+				break;
+			case 'this month':
+				$start = $now->modify( 'first day of this month' )->setTime( 0, 0, 0 );
+				$end   = $now->setTime( 23, 59, 59 );
+				break;
+			default:
+				return null;
+		}
+
+		return $this->format_date_range( $start, $end );
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return array|null
+	 */
+	private function extract_explicit_date_range( $query ) {
+		$patterns = array(
+			'/\bfrom\s+([a-z0-9,\/\-\s]+?)\s+to\s+([a-z0-9,\/\-\s]+)\b/i',
+			'/\bbetween\s+([a-z0-9,\/\-\s]+?)\s+and\s+([a-z0-9,\/\-\s]+)\b/i',
+		);
+
+		foreach ( $patterns as $pattern ) {
+			if ( ! preg_match( $pattern, $query, $matches ) ) {
+				continue;
+			}
+
+			$start = trim( $matches[1] );
+			$end   = trim( $matches[2] );
+
+			if ( false !== strpos( $start, '@' ) || false !== strpos( $end, '@' ) ) {
+				continue;
+			}
+
+			$range = $this->normalize_date_range_values( $start, $end );
+			if ( null !== $range ) {
+				return $range;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * @param string $start Start date string.
+	 * @param string $end End date string.
+	 * @return array|null
+	 */
+	private function normalize_date_range_values( $start, $end ) {
+		$start_date = $this->parse_date_string( $start, false );
+		$end_date   = $this->parse_date_string( $end, true );
+
+		if ( null === $start_date || null === $end_date ) {
+			return null;
+		}
+
+		if ( $end_date < $start_date ) {
+			$temp       = $start_date;
+			$start_date = $end_date;
+			$end_date   = $temp;
+		}
+
+		return $this->format_date_range( $start_date, $end_date );
+	}
+
+	/**
+	 * @param string $date_string Input date.
+	 * @param bool   $end_of_day Whether to set end of day.
+	 * @return DateTimeImmutable|null
+	 */
+	private function parse_date_string( $date_string, $end_of_day ) {
+		$date_string = trim( (string) $date_string );
+		if ( '' === $date_string ) {
+			return null;
+		}
+
+		$timezone = $this->get_timezone();
+		$base_ts  = $this->get_base_timestamp();
+		$ts       = strtotime( $date_string, $base_ts );
+
+		if ( false === $ts ) {
+			return null;
+		}
+
+		$date = ( new DateTimeImmutable( '@' . $ts ) )->setTimezone( $timezone );
+		if ( $end_of_day ) {
+			$date = $date->setTime( 23, 59, 59 );
+		} else {
+			$date = $date->setTime( 0, 0, 0 );
+		}
+
+		return $date;
+	}
+
+	/**
+	 * @param DateTimeImmutable $start Start date.
+	 * @param DateTimeImmutable $end End date.
+	 * @return array
+	 */
+	private function format_date_range( DateTimeImmutable $start, DateTimeImmutable $end ) {
+		return array(
+			'start' => $start->format( 'Y-m-d H:i:s' ),
+			'end'   => $end->format( 'Y-m-d H:i:s' ),
+		);
+	}
+
+	/**
+	 * @return DateTimeZone
+	 */
+	private function get_timezone() {
+		if ( function_exists( 'wp_timezone' ) ) {
+			return wp_timezone();
+		}
+
+		$timezone = '';
+		if ( function_exists( 'wp_timezone_string' ) ) {
+			$timezone = wp_timezone_string();
+		}
+
+		if ( '' === $timezone && function_exists( 'get_option' ) ) {
+			$timezone = (string) get_option( 'timezone_string' );
+		}
+
+		if ( '' === $timezone ) {
+			$timezone = 'UTC';
+		}
+
+		try {
+			return new DateTimeZone( $timezone );
+		} catch ( Exception $exception ) {
+			return new DateTimeZone( 'UTC' );
+		}
+	}
+
+	/**
+	 * @return int
+	 */
+	private function get_base_timestamp() {
+		if ( function_exists( 'current_time' ) ) {
+			return (int) current_time( 'timestamp' );
+		}
+
+		return time();
+	}
+
+	/**
+	 * @param string $query Query string.
+	 * @return bool
+	 */
+	private function contains_last_order_phrase( $query ) {
+		return (bool) preg_match( '/\b(last|latest|most recent)\s+order\b/i', $query );
+	}
+}
diff --git a/src/Intent/Handlers/OrderSearchHandler.php b/src/Intent/Handlers/OrderSearchHandler.php
index 9311b7eaa83edab2ffe20b11b5bd6af2b0ef62f2..d3d69810e8a0e3e216c079ad11ff088e134bb2f6
--- a/src/Intent/Handlers/OrderSearchHandler.php
+++ b/src/Intent/Handlers/OrderSearchHandler.php
@@ -8,6 +8,7 @@
 namespace AgentWP\Intent\Handlers;
 
 use AgentWP\AI\Response;
+use AgentWP\Handlers\OrderSearchHandler as OrderSearchService;
 use AgentWP\Intent\Intent;
 
 class OrderSearchHandler extends BaseHandler {
@@ -20,7 +21,26 @@
 	 * @return Response
 	 */
 	public function handle( array $context ): Response {
-		$message = 'I can search orders. Share an order ID, customer email, or date range.';
-		return $this->build_response( $context, $message );
+		$query = isset( $context['input'] ) ? (string) $context['input'] : '';
+		$query = trim( $query );
+
+		$search = new OrderSearchService();
+		$result = $search->handle(
+			array(
+				'query' => $query,
+			)
+		);
+
+		if ( ! $result->is_success() ) {
+			return $result;
+		}
+
+		$data    = $result->get_data();
+		$count   = isset( $data['count'] ) ? intval( $data['count'] ) : 0;
+		$message = 0 === $count
+			? 'I could not find any orders that match.'
+			: sprintf( 'Found %d order%s matching your request.', $count, 1 === $count ? '' : 's' );
+
+		return $this->build_response( $context, $message, $data );
 	}
 }

tokens used
146,168
