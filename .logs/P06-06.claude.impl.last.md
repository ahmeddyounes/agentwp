---

## Status: DONE

## Summary of Changes

### 1. **`src/API/RateLimiter.php`** - Hardened with fail-open behavior
- **Lines 146-218**: Rewrote `checkAndIncrement()` to implement fail-open design:
  - Wrapped lock acquisition loop in try-catch to handle storage exceptions
  - Changed behavior when lock cannot be acquired after retries from "deny" to "allow" (fail open)
  - Wrapped bucket read/write operations in try-catch to handle storage failures
  - Lock release is now safely wrapped in try-catch and only attempts release if lock was actually acquired
  - Added clear docblock documenting the fail-open design philosophy

### 2. **`tests/Fakes/FakeTransientCache.php`** - Enhanced for failure simulation
- Added `$simulateFailure` and `$simulateLockContention` properties
- `get()`, `set()`, `delete()`, `add()` now throw `RuntimeException` when `simulateFailure` is true
- `add()` returns false (simulating lock contention) when `simulateLockContention` is true
- Added `setSimulateFailure()` and `setSimulateLockContention()` helper methods
- Updated `reset()` to clear simulation flags

### 3. **`tests/Unit/API/RateLimiterTest.php`** - Added concurrency and failure tests
- `test_check_and_increment_fails_open_on_lock_contention()` - verifies fail-open when lock cannot be acquired
- `test_check_and_increment_fails_open_on_storage_failure_during_lock()` - verifies fail-open on cache exception during lock
- `test_check_and_increment_fails_open_on_storage_failure_during_bucket_read()` - verifies fail-open on cache exception during bucket operations
- `test_lock_released_after_rate_limit_check()` - verifies lock is properly released after operation
- `test_lock_released_even_when_at_limit()` - verifies lock is released even when rate limit exceeded
- `test_check_and_increment_handles_window_expiration()` - verifies atomic operation handles window expiration correctly

## How to Verify

```bash
# Run rate limiter tests
./vendor/bin/phpunit tests/Unit/API/RateLimiterTest.php --no-coverage

# Run full test suite
./vendor/bin/phpunit --no-coverage

# Run linting
./vendor/bin/phpcs src/API/RateLimiter.php tests/Unit/API/RateLimiterTest.php tests/Fakes/FakeTransientCache.php
```

## Risks / Follow-ups

1. **Trade-off acknowledged**: Fail-open design prioritizes availability over strict rate limiting. Under extreme load or cache failures, some requests may exceed rate limits. This is intentional - for most applications, allowing occasional extra requests is preferable to incorrectly blocking legitimate traffic.

2. **Monitoring consideration**: In production, consider logging when fail-open triggers (cache failures/lock contention) so operations can monitor for persistent storage issues.

3. **No changes to non-atomic methods**: The `check()`, `increment()`, `getRemaining()`, `getRetryAfter()` methods do not have fail-open behavior - they will still throw if the cache is unavailable. Consider whether these also need hardening based on how they're used in the application.
