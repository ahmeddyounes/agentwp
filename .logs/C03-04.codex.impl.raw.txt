Status: DONE
Summary of changes:
- Standardized unknown-tool failure responses and added safe logging/audit logging in `src/Intent/ToolDispatcher.php`.
- Wired logger/audit logger into the dispatcher registration in `src/Providers/IntentServiceProvider.php`.
- Added `tests/Fakes/FakeAuditLogger.php`, expanded unit coverage in `tests/Unit/Intent/ToolDispatcherTest.php`, added unknown-tool integration coverage in `tests/Integration/Intent/ToolExecutionPathTest.php`, and aligned `tests/Fakes/FakeToolDispatcher.php` error shape.

How to verify (exact commands):
- No verification commands provided.

Risks / follow-ups:
- Tests not run (no commands provided).

OpenAI Codex v0.87.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/agentwp
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019bd1ff-955c-70c1-b8d5-068b5a561c5c
--------
user
You are implementing task C03-04 in this git repository.

1) Read the spec: .plans/C03-04.md
2) Read handoff/context: .t2/handoff/C03-04.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: 
- test: 

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers
exec
/bin/zsh -lc ls in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
agentwp.php
assets
composer.json
composer.lock
docker
docker-compose.demo.yml
docker-compose.yml
docs
includes
languages
node_modules
package-lock.json
package.json
phpcs.xml
phpstan
phpstan.neon
phpunit.xml.dist
plan_tasks.csv
playwright.config.cjs
react

thinking
**Planning spec file review**
exec
/bin/zsh -lc "sed -n '1,200p' .plans/C03-04.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 38ms:
# C03-04 — Improve unknown-tool failure handling

Ensure `ToolDispatcher::dispatch()` failures (unknown tool, schema validation errors) produce consistent, user-safe results and are logged via `LoggerInterface`/`AuditLoggerInterface` without leaking secrets. Add unit/integration tests for unknown tool + invalid args.
exec
/bin/zsh -lc "sed -n '1,200p' .t2/handoff/C03-04.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
# Handoff: C03-04

Created: 2026-01-18T16:45:46.701825Z

Spec: .plans/C03-04.md

thinking
**Searching for ToolDispatcher implementation**
exec
/bin/zsh -lc 'rg "ToolDispatcher" -n src includes tests' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 65ms:
tests/Integration/Intent/ToolExecutionPathTest.php:118:			protected function registerToolExecutors( \AgentWP\Contracts\ToolDispatcherInterface $dispatcher ): void {
tests/Integration/Intent/ToolExecutionPathTest.php:267:			protected function registerToolExecutors( \AgentWP\Contracts\ToolDispatcherInterface $dispatcher ): void {
src/Providers/IntentServiceProvider.php:35:use AgentWP\Contracts\ToolDispatcherInterface;
src/Providers/IntentServiceProvider.php:37:use AgentWP\Intent\ToolDispatcher;
src/Providers/IntentServiceProvider.php:86:		$this->registerToolDispatcher();
src/Providers/IntentServiceProvider.php:271:	private function registerToolDispatcher(): void {
src/Providers/IntentServiceProvider.php:272:		if ( ! class_exists( ToolDispatcher::class ) ) {
src/Providers/IntentServiceProvider.php:277:			ToolDispatcherInterface::class,
src/Providers/IntentServiceProvider.php:279:				$dispatcher = new ToolDispatcher(
src/Providers/IntentServiceProvider.php:384:					$this->container->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:420:				$c->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:441:				$c->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:462:				$c->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:483:				$c->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:504:				$c->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:525:				$c->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:546:				$c->get( ToolDispatcherInterface::class )
tests/Fakes/FakeToolDispatcher.php:9:use AgentWP\Contracts\ToolDispatcherInterface;
tests/Fakes/FakeToolDispatcher.php:12: * Fake implementation of ToolDispatcherInterface for testing.
tests/Fakes/FakeToolDispatcher.php:16:class FakeToolDispatcher implements ToolDispatcherInterface {

thinking
**No actionable update**
exec
/bin/zsh -lc "sed -n '1,240p' src/Intent/ToolDispatcher.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
<?php
/**
 * Tool dispatcher service implementation.
 *
 * Centralizes tool execution that was previously duplicated across
 * handler `execute_tool()` implementations.
 *
 * @package AgentWP\Intent
 */

namespace AgentWP\Intent;

use AgentWP\Contracts\ExecutableToolInterface;
use AgentWP\Contracts\ToolDispatcherInterface;
use AgentWP\Contracts\ToolRegistryInterface;
use AgentWP\Validation\ToolArgumentValidator;

/**
 * Dispatches tool execution calls to registered executors.
 *

thinking
**Searching for logger interfaces**
exec
/bin/zsh -lc 'rg "LoggerInterface|AuditLoggerInterface" -n src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 54ms:
src/Rest/SettingsController.php:12:use AgentWP\Contracts\AuditLoggerInterface;
src/Rest/SettingsController.php:307:	 * @return AuditLoggerInterface|null
src/Rest/SettingsController.php:309:	private function getAuditLogger(): ?AuditLoggerInterface {
src/Rest/SettingsController.php:310:		$logger = $this->resolve( AuditLoggerInterface::class );
src/Rest/SettingsController.php:311:		return $logger instanceof AuditLoggerInterface ? $logger : null;
src/Services/ProductStockService.php:10:use AgentWP\Contracts\AuditLoggerInterface;
src/Services/ProductStockService.php:24:	private ?AuditLoggerInterface $auditLogger;
src/Services/ProductStockService.php:33:	 * @param AuditLoggerInterface|null        $auditLogger  Audit logger (optional).
src/Services/ProductStockService.php:40:		?AuditLoggerInterface $auditLogger = null,
src/Services/OrderRefundService.php:10:use AgentWP\Contracts\AuditLoggerInterface;
src/Services/OrderRefundService.php:24:	private ?AuditLoggerInterface $auditLogger;
src/Services/OrderRefundService.php:31:	 * @param AuditLoggerInterface|null         $auditLogger   Audit logger (optional).
src/Services/OrderRefundService.php:38:		?AuditLoggerInterface $auditLogger = null,
src/Services/OrderStatusService.php:11:use AgentWP\Contracts\AuditLoggerInterface;
src/Services/OrderStatusService.php:36:	private ?AuditLoggerInterface $auditLogger;
src/Services/OrderStatusService.php:45:	 * @param AuditLoggerInterface|null        $auditLogger  Audit logger (optional).
src/Services/OrderStatusService.php:52:		?AuditLoggerInterface $auditLogger = null,
src/Infrastructure/AuditLogger.php:10:use AgentWP\Contracts\AuditLoggerInterface;
src/Infrastructure/AuditLogger.php:12:use AgentWP\Contracts\LoggerInterface;
src/Infrastructure/AuditLogger.php:15: * Audit logger that uses the underlying LoggerInterface.

thinking
**Reviewing ToolDispatcher interface**
exec
/bin/zsh -lc "sed -n '1,200p' src/Contracts/ToolDispatcherInterface.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 43ms:
<?php
/**
 * Interface for centralized tool execution dispatch.
 *
 * The ToolDispatcher resolves tools by name, validates arguments against
 * their schemas, executes them, and returns JSON-safe results.
 *
 * @package AgentWP\Contracts
 */

namespace AgentWP\Contracts;

/**
 * Dispatches tool execution calls to registered executors.
 *
 * This interface centralizes the tool execution logic that was previously
 * duplicated across handler `execute_tool()` implementations. It provides:
 * - Tool registration with callable executors or ExecutableTool instances
 * - Argument validation against JSON schemas
 * - Execution with JSON-safe result handling

thinking
**Reviewing logger usage and service registration**

I'm checking how logging is currently implemented and how the ServiceProvider registers the ToolDispatcher, focusing on the IntentServiceProvider's registerToolDispatcher method.
exec
/bin/zsh -lc "sed -n '250,360p' src/Providers/IntentServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 67ms:
				$registry->register( new ConfirmStatusUpdate() );
				$registry->register( new SearchProduct() );
				$registry->register( new PrepareStockUpdate() );
				$registry->register( new ConfirmStockUpdate() );
				$registry->register( new DraftEmail() );
				$registry->register( new GetSalesReport() );
				$registry->register( new GetCustomerProfile() );

				return $registry;
			}
		);
	}

	/**
	 * Register tool dispatcher with all executable tools.
	 *
	 * Pre-registers order tools centrally so handlers can use them
	 * without defining inline executors.
	 *
	 * @return void

thinking
**Considering logger injection**

I'm checking if the logger should be injected into ToolDispatcher via the infrastructure layer by reviewing the LoggerInterface.
exec
/bin/zsh -lc "sed -n '1,200p' src/Contracts/LoggerInterface.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Logger interface.
 *
 * @package AgentWP\Contracts
 */

namespace AgentWP\Contracts;

/**
 * Contract for logging services.
 *
 * Provides a minimal PSR-3 inspired interface for logging at various levels.
 * Implementations should sanitize messages to prevent leaking secrets.
 */
interface LoggerInterface {

	/**
	 * Log an emergency message.
	 *

thinking
**Considering logging interface**

I'm checking for an existing logging interface to understand how audit logging fits in or if a new interface should be defined.
exec
/bin/zsh -lc "sed -n '1,200p' src/Contracts/AuditLoggerInterface.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 49ms:
<?php
/**
 * Audit logger interface.
 *
 * @package AgentWP\Contracts
 */

namespace AgentWP\Contracts;

/**
 * Contract for audit logging services.
 *
 * Provides structured audit logging for sensitive actions.
 * All audit events are logged at 'notice' level for traceability.
 */
interface AuditLoggerInterface {

	/**
	 * Log an API key update event.
	 *

thinking
**Clarifying logging strategy**

I'm evaluating how to use LoggerInterface and AuditLoggerInterface for error and sensitive action logging, considering that tool failures might require both warning/error logs and audit logs via logSensitiveAction; next I'll inspect the AuditLogger class for clearer guidance.
exec
/bin/zsh -lc "sed -n '1,200p' src/Infrastructure/AuditLogger.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 48ms:
<?php
/**
 * Audit logger implementation.
 *
 * @package AgentWP\Infrastructure
 */

namespace AgentWP\Infrastructure;

use AgentWP\Contracts\AuditLoggerInterface;
use AgentWP\Contracts\ClockInterface;
use AgentWP\Contracts\LoggerInterface;

/**
 * Audit logger that uses the underlying LoggerInterface.
 *
 * Provides structured audit logging for sensitive actions with:
 * - Consistent message formatting
 * - Timestamp and user attribution
 * - Action categorization

thinking
**Considering logger injection**

I'm planning to have the dispatcher accept logger(s), reviewing NullLogger and related implementations to decide on the best integration approach.
exec
/bin/zsh -lc "sed -n '1,200p' src/Infrastructure/NullLogger.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 51ms:
<?php
/**
 * Null logger implementation.
 *
 * @package AgentWP\Infrastructure
 */

namespace AgentWP\Infrastructure;

use AgentWP\Contracts\LoggerInterface;

/**
 * Logger that discards all messages.
 *
 * Use this when logging is not needed or to satisfy dependency injection
 * without actual logging behavior.
 */
final class NullLogger implements LoggerInterface {

	/**

thinking
**Planning logger injection**

I'm checking if ToolDispatcher can accept optional logger and audit logger, considering injecting them through the provider and reviewing InfrastructureServiceProvider for logger handling.
exec
/bin/zsh -lc "sed -n '350,460p' src/Providers/InfrastructureServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 55ms:
			fn( $c ) => new DemoAwareKeyValidator(
				$c->get( DemoCredentials::class ),
				$c->get( OpenAIKeyValidator::class )
			)
		);
	}

	/**
	 * Register policy interface.
	 *
	 * The policy layer abstracts capability checks so that domain services
	 * don't need to call current_user_can() directly.
	 *
	 * @return void
	 */
	private function registerPolicy(): void {
		$this->container->singleton(
			PolicyInterface::class,
			fn( $c ) => new WooCommercePolicy(
				$c->get( WPFunctions::class )

thinking
**Planning logger integration**

Considering adding optional LoggerInterface and AuditLoggerInterface to ToolDispatcher, using NullLogger if absent; next steps include updating service provider and modifying tests to handle these new dependencies.
exec
/bin/zsh -lc "sed -n '1,220p' tests/Unit/Intent/ToolDispatcherTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
<?php
/**
 * ToolDispatcher unit tests.
 */

namespace AgentWP\Tests\Unit\Intent;

use AgentWP\AI\Functions\FunctionSchema;
use AgentWP\Intent\ToolDispatcher;
use AgentWP\Tests\Fakes\FakeToolRegistry;
use AgentWP\Tests\TestCase;
use AgentWP\Validation\ToolArgumentValidator;

class ToolDispatcherTest extends TestCase {

	/**
	 * @var FakeToolRegistry
	 */
	private FakeToolRegistry $toolRegistry;


thinking
**Considering error message safety and consistency**

I'm evaluating whether unknown tool error messages should be generic to avoid leaking tool names, balancing user clarity and security. Next, I'll inspect ToolArgumentValidator to understand error arrays and determine how to sanitize logs while keeping results user-safe.
exec
/bin/zsh -lc "sed -n '1,220p' src/Validation/ToolArgumentValidator.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 32ms:
<?php
/**
 * Validates tool arguments against their JSON schemas.
 *
 * @package AgentWP\Validation
 */

namespace AgentWP\Validation;

use AgentWP\AI\Functions\FunctionSchema;
use WP_Error;

/**
 * Validator for AI tool call arguments.
 *
 * Uses WordPress REST API schema validation to ensure tool arguments
 * conform to their defined JSON schemas before execution.
 */
class ToolArgumentValidator {


thinking
**Checking error array generation**

I'm examining how error arrays are created in ToolArgumentValidationResult to understand their structure and usage.
exec
/bin/zsh -lc "sed -n '1,200p' src/Validation/ToolArgumentValidationResult.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
<?php
/**
 * Value object for tool argument validation results.
 *
 * @package AgentWP\Validation
 */

namespace AgentWP\Validation;

/**
 * Encapsulates the result of tool argument validation.
 *
 * Provides a consistent structure for both valid and invalid results,
 * enabling handlers to properly respond to the AI with validation errors.
 */
class ToolArgumentValidationResult {

	/**
	 * Tool name that was validated.
	 *


thinking
**Planning consistent, safe error responses**

I'm deciding to unify unknown tool and validation errors into a consistent, user-safe error format that excludes sensitive data and includes success false plus error codes, while adding logging via LoggerInterface and AuditLoggerInterface in ToolDispatcher which currently lacks loggers.
thinking
**Designing optional logger injection**

I'm planning to extend ToolDispatcher's constructor with optional LoggerInterface and AuditLoggerInterface parameters after the validator to maintain backward compatibility, while noting that usage sites and tests will need updating accordingly.
exec
/bin/zsh -lc 'rg "new ToolDispatcher" -n src tests' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 38ms:
src/Providers/IntentServiceProvider.php:279:				$dispatcher = new ToolDispatcher(
src/Intent/Handlers/AbstractAgenticHandler.php:74:		$this->toolDispatcher = $toolDispatcher ?? new ToolDispatcher( $toolRegistry );
tests/Unit/Intent/ToolDispatcherTest.php:29:		$this->dispatcher   = new ToolDispatcher( $this->toolRegistry );

thinking
**Investigating logging support in core handlers**

I'm checking the container in AbstractAgenticHandler to verify how to update logging and audit passing in the identified handler classes.
exec
/bin/zsh -lc "sed -n '1,220p' src/Intent/Handlers/AbstractAgenticHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 35ms:
<?php
/**
 * Abstract base class for agentic intent handlers.
 *
 * Encapsulates the common agentic loop pattern used by all AI-powered handlers.
 *
 * @package AgentWP\Intent\Handlers
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Config\AgentWPConfig;
use AgentWP\Contracts\AIClientFactoryInterface;
use AgentWP\Contracts\OpenAIClientInterface;
use AgentWP\Contracts\ToolDispatcherInterface;
use AgentWP\Contracts\ToolRegistryInterface;
use AgentWP\Intent\ToolDispatcher;
use AgentWP\Intent\ToolSuggestionProvider;


thinking
**Searching for logging usage patterns**
exec
/bin/zsh -lc 'rg "logSensitiveAction|audit" -n src/Intent' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 57ms:


thinking
**Planning audit logging with user ID**

Considering logging tool dispatch failures via LoggerInterface and AuditLoggerInterface using the current user ID from WordPress, while ensuring no sensitive argument values are logged by limiting details and checking WooCommerceLogger's sanitization.
exec
/bin/zsh -lc "sed -n '1,240p' src/Infrastructure/WooCommerceLogger.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 64ms:
<?php
/**
 * WooCommerce logger adapter.
 *
 * @package AgentWP\Infrastructure
 */

namespace AgentWP\Infrastructure;

use AgentWP\Contracts\LoggerInterface;

/**
 * Logger implementation using WooCommerce logger with error_log fallback.
 *
 * Uses WooCommerce's logging system when available, otherwise falls back
 * to PHP's error_log. All messages are sanitized to prevent leaking secrets.
 */
final class WooCommerceLogger implements LoggerInterface {

	/**


thinking
**Planning secure error handling and logging**

I'm outlining how to handle unknown tool and argument validation errors by returning consistent, user-safe error responses and logging them without leaking secrets, including deciding whether to expose the tool name in error responses for AI clarity. Next, I'll adjust dispatch to catch exceptions and add constants and helper methods for error responses.
thinking
**Refining error responses and logging strategy**

I'm deciding to respond with generic error messages for invalid arguments while including sanitized validation error details, avoiding raw argument values to ensure user safety. Logging will record only safe metadata—tool names, error codes, and validation fields—using optional loggers with fallback to NullLogger, and tests will verify consistent error shapes and proper logging without exposing secrets.
exec
/bin/zsh -lc 'rg "FakeLogger|TestLogger|Logger" -n tests' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 41ms:
tests/Fakes/FakeLogger.php:10:use AgentWP\Contracts\LoggerInterface;
tests/Fakes/FakeLogger.php:13: * Logger that captures all messages for test assertions.
tests/Fakes/FakeLogger.php:15:final class FakeLogger implements LoggerInterface {
tests/Integration/Container/ContainerWiringTest.php:28:use AgentWP\Contracts\LoggerInterface;
tests/Integration/Container/ContainerWiringTest.php:46:use AgentWP\Infrastructure\WooCommerceLogger;
tests/Integration/Container/ContainerWiringTest.php:162:			LoggerInterface::class,
tests/Integration/Container/ContainerWiringTest.php:903:	// Logger Resolution Tests
tests/Integration/Container/ContainerWiringTest.php:907:	 * Test that LoggerInterface resolves to WooCommerceLogger.
tests/Integration/Container/ContainerWiringTest.php:912:		$logger = $this->container->get( LoggerInterface::class );
tests/Integration/Container/ContainerWiringTest.php:915:			WooCommerceLogger::class,
tests/Integration/Container/ContainerWiringTest.php:917:			'LoggerInterface should resolve to WooCommerceLogger'
tests/Integration/Container/ContainerWiringTest.php:922:	 * Test that LoggerInterface is a singleton.
tests/Integration/Container/ContainerWiringTest.php:927:		$logger1 = $this->container->get( LoggerInterface::class );
tests/Integration/Container/ContainerWiringTest.php:928:		$logger2 = $this->container->get( LoggerInterface::class );
tests/Integration/Container/ContainerWiringTest.php:933:			'LoggerInterface should be a singleton'
tests/Integration/Container/ContainerWiringTest.php:938:	 * Test that controllers can resolve LoggerInterface.
tests/Integration/Container/ContainerWiringTest.php:944:			$this->container->has( LoggerInterface::class ),
tests/Integration/Container/ContainerWiringTest.php:945:			'Container should have LoggerInterface binding'
tests/Integration/Container/ContainerWiringTest.php:948:		$logger = $this->container->get( LoggerInterface::class );
tests/Integration/Container/ContainerWiringTest.php:950:		$this->assertNotNull( $logger, 'LoggerInterface should not resolve to null' );

thinking
**Identifying logging mocks**

I'm noting the presence of FakeLogger and possibly FakeAuditLogger as mock implementations for testing or placeholder use. Next, I'll confirm their locations and roles.
exec
/bin/zsh -lc 'rg "AuditLogger" -n tests' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 38ms:


thinking
**Inspecting FakeLogger for insights**
exec
/bin/zsh -lc "sed -n '1,200p' tests/Fakes/FakeLogger.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 38ms:
<?php
/**
 * Fake logger for testing.
 *
 * @package AgentWP\Tests\Fakes
 */

namespace AgentWP\Tests\Fakes;

use AgentWP\Contracts\LoggerInterface;

/**
 * Logger that captures all messages for test assertions.
 */
final class FakeLogger implements LoggerInterface {

	/**
	 * Log entries.
	 *
	 * @var array<int, array{level: string, message: string, context: array<string, mixed>}>


thinking
**Planning test audit logger and error handling**

I'm deciding to implement a minimal FakeAuditLogger for tests to capture and verify audit entries, handling user IDs safely by checking `get_current_user_id` existence. Next, I'll update ToolDispatcher to log errors on unknown tools and invalid args, aligning error responses with the existing validation error format.
thinking
**Designing unified error response format**

I'm considering a consistent error structure with `success: false`, error code, message, and optional details for unknown tools and validation errors, possibly via a dispatchError helper. Next, I'll review existing error usage to finalize this approach.
exec
/bin/zsh -lc 'rg "invalid_tool_arguments|unknown_tool" -n src tests' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 44ms:
src/Validation/ToolArgumentValidationResult.php:99:			'code'              => 'invalid_tool_arguments',
tests/Integration/Intent/ToolExecutionPathTest.php:320:		$this->assertSame( 'invalid_tool_arguments', $decoded['code'] );
tests/Unit/Validation/ToolArgumentValidatorTest.php:203:		$this->assertSame( 'invalid_tool_arguments', $errorArray['code'] );
tests/Unit/Validation/ToolArgumentValidationIntegrationTest.php:167:	public function test_unknown_tool_bypasses_validation(): void {
tests/Unit/Validation/ToolArgumentValidationIntegrationTest.php:169:		// Service won't be called because unknown_tool doesn't match.
tests/Unit/Validation/ToolArgumentValidationIntegrationTest.php:183:									'name'      => 'unknown_tool',
tests/Unit/Intent/FunctionRegistryTest.php:83:				return array( 'search_orders', 'unknown_tool' );
tests/Unit/Intent/ToolDispatcherTest.php:63:	public function test_dispatch_returns_error_for_unknown_tool(): void {
tests/Unit/Intent/ToolDispatcherTest.php:64:		$result = $this->dispatcher->dispatch( 'unknown_tool', array() );
tests/Unit/Intent/ToolDispatcherTest.php:121:		$this->assertSame( 'invalid_tool_arguments', $result['code'] );

thinking
**Inspecting integration test error format**
exec
/bin/zsh -lc "sed -n '280,360p' tests/Integration/Intent/ToolExecutionPathTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 59ms:
		$classifier = new class() implements IntentClassifierInterface {
			public function classify( string $input, array $context = array() ): string {
				unset( $input, $context );
				return Intent::ORDER_STATUS;
			}
		};

		$builder = new class() extends ContextBuilder {
			public function build( array $context = array(), array $metadata = array() ): array {
				return $context;
			}
		};

		$memory = new FakeMemoryStore();
		$handler_registry = new HandlerRegistry();
		$handler_registry->register( Intent::ORDER_STATUS, $handler );

		$engine = new Engine(
			array(),
			new FunctionRegistry(),

thinking
**Checking error response consistency**

I'm verifying if unknown tools also return 'success' false to unify error handling and inspecting other tests like ToolArgumentValidatorTest for expected error shapes.
exec
/bin/zsh -lc "sed -n '150,260p' tests/Unit/Validation/ToolArgumentValidatorTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 70ms:
				),
			)
		);

		// Valid nested object.
		$result = $this->validator->validate(
			$schema,
			array(
				'date_range' => array(
					'start' => '2024-01-01',
					'end'   => '2024-01-31',
				),
			)
		);
		$this->assertTrue( $result->isValid );

		// Missing required nested field.
		$result = $this->validator->validate(
			$schema,
			array(


thinking
**Defining consistent error responses**

Decided to keep validation error responses as arrays with success false and code for consistency; updating unknown tool errors to match this shape with safe messages, preserving tool names in user-visible errors but ensuring no sensitive details leak.
thinking
**Designing consistent error logging and responses**

Planning to add logger and audit logger dependencies with safe defaults, logging unknown tool and validation failures without argument values but including field names and codes; error responses will uniformly include success false and error codes. I'll implement user ID retrieval for audit logs and update tests to reflect consistent error shapes and logging behavior.
exec
/bin/zsh -lc "sed -n '1,200p' tests/Integration/Intent/ToolExecutionPathTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 64ms:
<?php
/**
 * Integration tests covering the full Engine → handler → tool dispatcher execution path.
 */

namespace AgentWP\Tests\Integration\Intent;

use AgentWP\AI\Functions\AbstractFunction;
use AgentWP\AI\Response;
use AgentWP\Contracts\OpenAIClientInterface;
use AgentWP\Intent\ContextBuilder;
use AgentWP\Intent\Engine;
use AgentWP\Intent\FunctionRegistry;
use AgentWP\Intent\HandlerRegistry;
use AgentWP\Intent\Handlers\AbstractAgenticHandler;
use AgentWP\Intent\Handlers\FallbackHandler;
use AgentWP\Intent\Intent;
use AgentWP\Contracts\IntentClassifierInterface;
use AgentWP\Tests\Fakes\FakeAIClientFactory;
use AgentWP\Tests\Fakes\FakeMemoryStore;

thinking
**Planning tests for unknown tool handling**

The existing unit test covers unknown tools but lacks checks for consistent response shape and logging; I'll enhance it and add integration tests for unknown tools and invalid arguments.
exec
/bin/zsh -lc "sed -n '200,400p' tests/Integration/Intent/ToolExecutionPathTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 68ms:
							'type' => 'integer',
						),
					),
					'required'             => array( 'order_id' ),
					'additionalProperties' => false,
				);
			}
		};

		$registry = new FakeToolRegistry();
		$registry->register( $schema );

		$client = new class() implements OpenAIClientInterface {
			/** @var Response[] */
			public array $responses;
			public array $calls = array();

			public function __construct() {
				$this->responses = array(
					Response::success(


thinking
**Designing tests and logging for unknown tools**

Planning to add an unknown tool integration test and adjust existing tests to assert logs and audit entries for unknown tool and invalid argument errors, using warning level logs and audit logs with minimal context that avoids leaking secrets.
thinking
**Planning safe logging helper and test updates**

Decided to log only safe context like tool name, reason, argument count, and validation fields—excluding argument keys to avoid revealing sensitive info. I'll implement a unified logging helper that warns and calls audit log with safe context, then update dispatch logic to use it and design tests with FakeLogger and new FakeAuditLogger to assert proper logging and audit recording for unknown tools and invalid arguments.
exec
/bin/zsh -lc 'rg "new .*Handler" -n src/Providers/IntentServiceProvider.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 72ms:
330:			fn() => new HandlerRegistry()
346:			fn() => new FallbackHandler()
417:			fn( $c ) => new OrderSearchHandler(
438:			fn( $c ) => new OrderRefundHandler(
459:			fn( $c ) => new OrderStatusHandler(
480:			fn( $c ) => new ProductStockHandler(
501:			fn( $c ) => new EmailDraftHandler(
522:			fn( $c ) => new AnalyticsQueryHandler(
543:			fn( $c ) => new CustomerLookupHandler(
exec
/bin/zsh -lc "sed -n '400,560p' src/Providers/IntentServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 47ms:
		$this->registerEmailDraftHandler();
		$this->registerAnalyticsQueryHandler();
		$this->registerCustomerLookupHandler();
	}

	/**
	 * Register order search handler.
	 *
	 * @return void
	 */
	private function registerOrderSearchHandler(): void {
		if ( ! class_exists( OrderSearchHandler::class ) ) {
			return;
		}

		$this->container->singleton(
			OrderSearchHandler::class,
			fn( $c ) => new OrderSearchHandler(
				$c->get( AIClientFactoryInterface::class ),
				$c->get( ToolRegistryInterface::class ),


thinking
**Assessing logger usage in handler tests**

The handler's ToolDispatcher defaults to a NullLogger, ensuring logger methods are called even if no output occurs. This likely satisfies the spec's logging requirement without needing explicit logger passing in tests.
thinking
**Planning robust unknown tool error handling**

I'm designing private helpers in ToolDispatcher to build and log structured unknown tool and validation errors, ensuring consistent error shapes with codes. I'll update `dispatch` to handle validation failures as errors, add integration tests simulating unknown tools, and confirm error responses propagate correctly through the execution engine.
exec
/bin/zsh -lc "rg \"dispatch\\(\" -n src/Intent" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 63ms:
src/Intent/Handlers/AbstractAgenticHandler.php:267:			$result = $this->toolDispatcher->dispatch( $name, $args );
src/Intent/ToolDispatcher.php:132:	public function dispatch( string $name, array $arguments ): array {
exec
/bin/zsh -lc "sed -n '240,340p' src/Intent/Handlers/AbstractAgenticHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 67ms:
			'I got stuck in a loop while processing your request. Please try again.',
			500
		);
	}

	/**
	 * Execute tool calls and add results to messages.
	 *
	 * Delegates to the ToolDispatcher for validation and execution.
	 *
	 * @param array $messages Current messages.
	 * @param array $tool_calls Tool calls from AI response.
	 * @return array Updated messages with tool results.
	 */
	protected function executeToolCalls( array $messages, array $tool_calls ): array {
		foreach ( $tool_calls as $call ) {
			// Safely extract function data with defensive checks.
			$function  = isset( $call['function'] ) && is_array( $call['function'] ) ? $call['function'] : array();
			$name      = isset( $function['name'] ) ? (string) $function['name'] : '';
			$args_json = isset( $function['arguments'] ) ? (string) $function['arguments'] : '{}';

thinking
**Planning logger integration and test updates**

I'm preparing to update ToolDispatcher to use the logger and add a FakeAuditLogger for tests, plus extend integration and unit tests to cover the new logging behavior and unknown tool cases.
exec
/bin/zsh -lc "sed -n '140,220p' tests/Unit/Validation/ToolArgumentValidationIntegrationTest.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 63ms:
				),
				Response::success(
					array(
						'content'    => 'No orders found.',
						'tool_calls' => array(),
					)
				),
			)
		);

		$factory = new FakeAIClientFactory( $client, true );

		// Create tool dispatcher with pre-registered search tool.
		$toolDispatcher = new FakeToolDispatcher();
		$toolDispatcher->registerTool( new SearchOrdersTool( $service ) );

		$handler = new OrderSearchHandler( $factory, $toolRegistry, $toolDispatcher );

		$response = $handler->handle( array( 'input' => 'Search orders' ) );


thinking
**Checking test fake dispatcher**

This test uses a FakeToolDispatcher from the test fakes, which may not reflect actual dispatch behavior but might not need changes. I'll verify the FakeToolDispatcher implementation next.
exec
/bin/zsh -lc "sed -n '1,200p' tests/Fakes/FakeToolDispatcher.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 60ms:
<?php
/**
 * Fake tool dispatcher for testing.
 */

namespace AgentWP\Tests\Fakes;

use AgentWP\Contracts\ExecutableToolInterface;
use AgentWP\Contracts\ToolDispatcherInterface;

/**
 * Fake implementation of ToolDispatcherInterface for testing.
 *
 * Can have executors pre-registered either as callables or via ExecutableToolInterface.
 */
class FakeToolDispatcher implements ToolDispatcherInterface {

	/**
	 * @var array<string, callable>
	 */

thinking
**Updating fake dispatcher error shape for consistency**

Planning to update the fake dispatcher to use the new standardized error shape for unknown tools, including success false and code 'unknown_tool', to align with the real dispatcher behavior while checking tests relying on the old error string for necessary adjustments.
exec
/bin/zsh -lc 'rg "Unknown tool" -n tests' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 77ms:
tests/Fakes/FakeToolDispatcher.php:100:			return array( 'error' => "Unknown tool: {$name}" );
tests/Unit/Validation/ToolArgumentValidationIntegrationTest.php:192:						'content'    => 'Unknown tool error handled.',
tests/Unit/Intent/ToolDispatcherTest.php:67:		$this->assertStringContainsString( 'Unknown tool', $result['error'] );


thinking
**Planning tests for unknown tool and invalid args**

I'm updating tests to reflect the new error shape for unknown tools and adding unit tests in ToolDispatcherTest for logging and error details on unknown tools and invalid args. I'll also add an integration test covering unknown tool scenarios.
thinking
**Updating ToolDispatcher with logging and error shape helpers**

I'm adding logger properties with NullLogger fallback, helper methods for consistent unknown tool error structure, logging dispatch failures, and user ID extraction. I'll update dispatch to log invalid argument validation errors and ensure unknown tool errors include success false and code while careful to preserve existing error handling for JSON encoding.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Intent/ToolDispatcher.php
@@ -12,5 +12,8 @@
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
@@ -49,6 +52,22 @@
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
@@ -56,3 +75,5 @@
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
@@ -60,2 +81,4 @@
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
@@ -134,3 +157,11 @@
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
@@ -140,2 +171,8 @@
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
@@ -233,2 +270,87 @@
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
M src/Intent/ToolDispatcher.php
file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }

file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }


thinking
**Updating IntentServiceProvider with logger and audit**

Planning to update IntentServiceProvider to pass logger and audit services using `$c->has` checks; also verifying existing use statements to avoid duplication.
exec
/bin/zsh -lc "sed -n '1,120p' src/Providers/IntentServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 67ms:
<?php
/**
 * Intent service provider.
 *
 * @package AgentWP\Providers
 */

namespace AgentWP\Providers;

use AgentWP\AI\Functions\ConfirmRefund;
use AgentWP\AI\Functions\ConfirmStatusUpdate;
use AgentWP\AI\Functions\ConfirmStockUpdate;
use AgentWP\AI\Functions\DraftEmail;
use AgentWP\AI\Functions\GetCustomerProfile;
use AgentWP\AI\Functions\GetSalesReport;
use AgentWP\AI\Functions\PrepareBulkStatusUpdate;
use AgentWP\AI\Functions\PrepareRefund;
use AgentWP\AI\Functions\PrepareStatusUpdate;
use AgentWP\AI\Functions\PrepareStockUpdate;
use AgentWP\AI\Functions\SearchOrders;
file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }


thinking
**Adding logger use statements and injection**

I'm preparing to add use statements for LoggerInterface and AuditLoggerInterface, update the registry method to pass these loggers, and retrieve them conditionally from the container before applying the patch.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/src/Providers/IntentServiceProvider.php
@@ -34,2 +34,4 @@
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
@@ -279,3 +281,6 @@
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M src/Providers/IntentServiceProvider.php
file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.

file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.


thinking
**Confirming logger handling strategy**

Decided no constructor signature changes needed for logger passing since AbstractAgenticHandler uses NullLogger by default, which satisfies logging interface requirements even if it discards output. Next, planning to update FakeToolDispatcher to produce the new error shape.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/tests/Fakes/FakeToolDispatcher.php
@@ -99,3 +99,7 @@
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
apply_patch(auto_approved=true) exited 0 in 50ms:
Success. Updated the following files:
M tests/Fakes/FakeToolDispatcher.php
file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );

file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );


thinking
**Adding fake audit logger**
file update
A /Users/ahmedyounis/Documents/Projects/agentwp/tests/Fakes/FakeAuditLogger.php
<?php
/**
 * Fake audit logger for testing.
 *
 * @package AgentWP\Tests\Fakes
 */

namespace AgentWP\Tests\Fakes;

use AgentWP\Contracts\AuditLoggerInterface;

/**
 * Audit logger that captures events for assertions.
 */
final class FakeAuditLogger implements AuditLoggerInterface {

	/**
	 * Captured audit events.
	 *
	 * @var array<int, array<string, mixed>>
	 */
	private array $logs = array();

	/**
	 * {@inheritDoc}
	 */
	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
		$this->logs[] = array(
			'type'      => 'api_key',
			'action'    => $action,
			'user_id'   => $user_id,
			'key_last4' => $key_last4,
			'context'   => $extra,
		);
	}

	/**
	 * {@inheritDoc}
	 */
	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
		$this->logs[] = array(
			'type'       => 'draft_confirm',
			'draft_type' => $draft_type,
			'draft_id'   => $draft_id,
			'user_id'    => $user_id,
			'context'    => $details,
		);
	}

	/**
	 * {@inheritDoc}
	 */
	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
		$this->logs[] = array(
			'type'    => 'sensitive',
			'action'  => $action,
			'user_id' => $user_id,
			'context' => $context,
		);
	}

	/**
	 * Get all audit events.
	 *
	 * @return array<int, array<string, mixed>>
	 */
	public function getLogs(): array {
		return $this->logs;
	}

	/**
	 * Get last audit event.
	 *
	 * @return array<string, mixed>|null
	 */
	public function getLastLog(): ?array {
		if ( empty( $this->logs ) ) {
			return null;
		}

		return $this->logs[ count( $this->logs ) - 1 ];
	}
}
apply_patch(auto_approved=true) exited 0 in 46ms:
Success. Updated the following files:
A tests/Fakes/FakeAuditLogger.php
file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeAuditLogger.php b/tests/Fakes/FakeAuditLogger.php
new file mode 100644
index 0000000000000000000000000000000000000000..e64af09dbfee4807d086ea29730b81f584c8dac0
--- /dev/null
+++ b/tests/Fakes/FakeAuditLogger.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Fake audit logger for testing.
+ *
+ * @package AgentWP\Tests\Fakes
+ */
+
+namespace AgentWP\Tests\Fakes;
+
+use AgentWP\Contracts\AuditLoggerInterface;
+
+/**
+ * Audit logger that captures events for assertions.
+ */
+final class FakeAuditLogger implements AuditLoggerInterface {
+
+	/**
+	 * Captured audit events.
+	 *
+	 * @var array<int, array<string, mixed>>
+	 */
+	private array $logs = array();
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
+		$this->logs[] = array(
+			'type'      => 'api_key',
+			'action'    => $action,
+			'user_id'   => $user_id,
+			'key_last4' => $key_last4,
+			'context'   => $extra,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
+		$this->logs[] = array(
+			'type'       => 'draft_confirm',
+			'draft_type' => $draft_type,
+			'draft_id'   => $draft_id,
+			'user_id'    => $user_id,
+			'context'    => $details,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
+		$this->logs[] = array(
+			'type'    => 'sensitive',
+			'action'  => $action,
+			'user_id' => $user_id,
+			'context' => $context,
+		);
+	}
+
+	/**
+	 * Get all audit events.
+	 *
+	 * @return array<int, array<string, mixed>>
+	 */
+	public function getLogs(): array {
+		return $this->logs;
+	}
+
+	/**
+	 * Get last audit event.
+	 *
+	 * @return array<string, mixed>|null
+	 */
+	public function getLastLog(): ?array {
+		if ( empty( $this->logs ) ) {
+			return null;
+		}
+
+		return $this->logs[ count( $this->logs ) - 1 ];
+	}
+}
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );

file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeAuditLogger.php b/tests/Fakes/FakeAuditLogger.php
new file mode 100644
index 0000000000000000000000000000000000000000..e64af09dbfee4807d086ea29730b81f584c8dac0
--- /dev/null
+++ b/tests/Fakes/FakeAuditLogger.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Fake audit logger for testing.
+ *
+ * @package AgentWP\Tests\Fakes
+ */
+
+namespace AgentWP\Tests\Fakes;
+
+use AgentWP\Contracts\AuditLoggerInterface;
+
+/**
+ * Audit logger that captures events for assertions.
+ */
+final class FakeAuditLogger implements AuditLoggerInterface {
+
+	/**
+	 * Captured audit events.
+	 *
+	 * @var array<int, array<string, mixed>>
+	 */
+	private array $logs = array();
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
+		$this->logs[] = array(
+			'type'      => 'api_key',
+			'action'    => $action,
+			'user_id'   => $user_id,
+			'key_last4' => $key_last4,
+			'context'   => $extra,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
+		$this->logs[] = array(
+			'type'       => 'draft_confirm',
+			'draft_type' => $draft_type,
+			'draft_id'   => $draft_id,
+			'user_id'    => $user_id,
+			'context'    => $details,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
+		$this->logs[] = array(
+			'type'    => 'sensitive',
+			'action'  => $action,
+			'user_id' => $user_id,
+			'context' => $context,
+		);
+	}
+
+	/**
+	 * Get all audit events.
+	 *
+	 * @return array<int, array<string, mixed>>
+	 */
+	public function getLogs(): array {
+		return $this->logs;
+	}
+
+	/**
+	 * Get last audit event.
+	 *
+	 * @return array<string, mixed>|null
+	 */
+	public function getLastLog(): ?array {
+		if ( empty( $this->logs ) ) {
+			return null;
+		}
+
+		return $this->logs[ count( $this->logs ) - 1 ];
+	}
+}
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );



thinking
**Updating tests to include fake loggers**

Planning to modify ToolDispatcherTest setup to use FakeLogger and FakeAuditLogger, allowing logging verification without relying on external functions, while ensuring existing behavior tests remain unaffected.
thinking
**Adding focused tests for logging failures**

Planning to keep default logger as silent in setUp but add targeted tests that instantiate ToolDispatcher with FakeLogger and FakeAuditLogger to verify logging on unknown tool and validation failure scenarios, including asserting log contents and audit entries.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/tests/Unit/Intent/ToolDispatcherTest.php
@@ -9,2 +9,4 @@
 use AgentWP\Intent\ToolDispatcher;
+use AgentWP\Tests\Fakes\FakeAuditLogger;
+use AgentWP\Tests\Fakes\FakeLogger;
 use AgentWP\Tests\Fakes\FakeToolRegistry;
@@ -66,2 +68,6 @@
 		$this->assertArrayHasKey( 'error', $result );
+		$this->assertArrayHasKey( 'success', $result );
+		$this->assertArrayHasKey( 'code', $result );
+		$this->assertFalse( $result['success'] );
+		$this->assertSame( 'unknown_tool', $result['code'] );
 		$this->assertStringContainsString( 'Unknown tool', $result['error'] );
@@ -123,2 +129,82 @@
 
+	public function test_dispatch_logs_unknown_tool_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$dispatcher->dispatch( 'missing_tool', array( 'secret' => 'value' ) );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'Tool dispatch failed.', $log['message'] );
+		$this->assertSame( 'missing_tool', $log['context']['tool'] );
+		$this->assertSame( 'unknown_tool', $log['context']['reason'] );
+		$this->assertArrayHasKey( 'argument_count', $log['context'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'unknown_tool', $audit['context']['reason'] );
+	}
+
+	public function test_dispatch_logs_validation_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$schema = new class() implements FunctionSchema {
+			public function get_name(): string {
+				return 'strict_tool';
+			}
+
+			public function get_description(): string {
+				return 'A tool with strict validation';
+			}
+
+			public function get_parameters(): array {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'name' => array(
+							'type'        => 'string',
+							'description' => 'The name',
+						),
+					),
+					'required'   => array( 'name' ),
+				);
+			}
+
+			public function to_tool_definition(): array {
+				return array(
+					'type'     => 'function',
+					'function' => array(
+						'name'        => $this->get_name(),
+						'description' => $this->get_description(),
+						'parameters'  => $this->get_parameters(),
+					),
+				);
+			}
+		};
+
+		$this->toolRegistry->register( $schema );
+		$dispatcher->register( 'strict_tool', fn( array $args ) => array( 'ok' => true ) );
+
+		$dispatcher->dispatch( 'strict_tool', array() );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'invalid_tool_arguments', $log['context']['reason'] );
+		$this->assertSame( 'strict_tool', $log['context']['tool'] );
+		$this->assertNotEmpty( $log['context']['validation_fields'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'invalid_tool_arguments', $audit['context']['reason'] );
+	}
+
 	public function test_dispatch_skips_validation_when_no_schema(): void {
apply_patch(auto_approved=true) exited 0 in 60ms:
Success. Updated the following files:
M tests/Unit/Intent/ToolDispatcherTest.php
file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeAuditLogger.php b/tests/Fakes/FakeAuditLogger.php
new file mode 100644
index 0000000000000000000000000000000000000000..e64af09dbfee4807d086ea29730b81f584c8dac0
--- /dev/null
+++ b/tests/Fakes/FakeAuditLogger.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Fake audit logger for testing.
+ *
+ * @package AgentWP\Tests\Fakes
+ */
+
+namespace AgentWP\Tests\Fakes;
+
+use AgentWP\Contracts\AuditLoggerInterface;
+
+/**
+ * Audit logger that captures events for assertions.
+ */
+final class FakeAuditLogger implements AuditLoggerInterface {
+
+	/**
+	 * Captured audit events.
+	 *
+	 * @var array<int, array<string, mixed>>
+	 */
+	private array $logs = array();
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
+		$this->logs[] = array(
+			'type'      => 'api_key',
+			'action'    => $action,
+			'user_id'   => $user_id,
+			'key_last4' => $key_last4,
+			'context'   => $extra,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
+		$this->logs[] = array(
+			'type'       => 'draft_confirm',
+			'draft_type' => $draft_type,
+			'draft_id'   => $draft_id,
+			'user_id'    => $user_id,
+			'context'    => $details,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
+		$this->logs[] = array(
+			'type'    => 'sensitive',
+			'action'  => $action,
+			'user_id' => $user_id,
+			'context' => $context,
+		);
+	}
+
+	/**
+	 * Get all audit events.
+	 *
+	 * @return array<int, array<string, mixed>>
+	 */
+	public function getLogs(): array {
+		return $this->logs;
+	}
+
+	/**
+	 * Get last audit event.
+	 *
+	 * @return array<string, mixed>|null
+	 */
+	public function getLastLog(): ?array {
+		if ( empty( $this->logs ) ) {
+			return null;
+		}
+
+		return $this->logs[ count( $this->logs ) - 1 ];
+	}
+}
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );
diff --git a/tests/Unit/Intent/ToolDispatcherTest.php b/tests/Unit/Intent/ToolDispatcherTest.php
index 737128019af6d5ca62e93a62fedc3df3604051e7..950d2a8a69551c5af76381c54bebe912b238c60a
--- a/tests/Unit/Intent/ToolDispatcherTest.php
+++ b/tests/Unit/Intent/ToolDispatcherTest.php
@@ -7,6 +7,8 @@
 
 use AgentWP\AI\Functions\FunctionSchema;
 use AgentWP\Intent\ToolDispatcher;
+use AgentWP\Tests\Fakes\FakeAuditLogger;
+use AgentWP\Tests\Fakes\FakeLogger;
 use AgentWP\Tests\Fakes\FakeToolRegistry;
 use AgentWP\Tests\TestCase;
 use AgentWP\Validation\ToolArgumentValidator;
@@ -64,6 +66,10 @@
 		$result = $this->dispatcher->dispatch( 'unknown_tool', array() );
 
 		$this->assertArrayHasKey( 'error', $result );
+		$this->assertArrayHasKey( 'success', $result );
+		$this->assertArrayHasKey( 'code', $result );
+		$this->assertFalse( $result['success'] );
+		$this->assertSame( 'unknown_tool', $result['code'] );
 		$this->assertStringContainsString( 'Unknown tool', $result['error'] );
 	}
 
@@ -121,6 +127,86 @@
 		$this->assertSame( 'invalid_tool_arguments', $result['code'] );
 	}
 
+	public function test_dispatch_logs_unknown_tool_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$dispatcher->dispatch( 'missing_tool', array( 'secret' => 'value' ) );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'Tool dispatch failed.', $log['message'] );
+		$this->assertSame( 'missing_tool', $log['context']['tool'] );
+		$this->assertSame( 'unknown_tool', $log['context']['reason'] );
+		$this->assertArrayHasKey( 'argument_count', $log['context'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'unknown_tool', $audit['context']['reason'] );
+	}
+
+	public function test_dispatch_logs_validation_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$schema = new class() implements FunctionSchema {
+			public function get_name(): string {
+				return 'strict_tool';
+			}
+
+			public function get_description(): string {
+				return 'A tool with strict validation';
+			}
+
+			public function get_parameters(): array {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'name' => array(
+							'type'        => 'string',
+							'description' => 'The name',
+						),
+					),
+					'required'   => array( 'name' ),
+				);
+			}
+
+			public function to_tool_definition(): array {
+				return array(
+					'type'     => 'function',
+					'function' => array(
+						'name'        => $this->get_name(),
+						'description' => $this->get_description(),
+						'parameters'  => $this->get_parameters(),
+					),
+				);
+			}
+		};
+
+		$this->toolRegistry->register( $schema );
+		$dispatcher->register( 'strict_tool', fn( array $args ) => array( 'ok' => true ) );
+
+		$dispatcher->dispatch( 'strict_tool', array() );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'invalid_tool_arguments', $log['context']['reason'] );
+		$this->assertSame( 'strict_tool', $log['context']['tool'] );
+		$this->assertNotEmpty( $log['context']['validation_fields'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'invalid_tool_arguments', $audit['context']['reason'] );
+	}
+
 	public function test_dispatch_skips_validation_when_no_schema(): void {
 		// Register tool without schema in registry.
 		$this->dispatcher->register(

file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeAuditLogger.php b/tests/Fakes/FakeAuditLogger.php
new file mode 100644
index 0000000000000000000000000000000000000000..e64af09dbfee4807d086ea29730b81f584c8dac0
--- /dev/null
+++ b/tests/Fakes/FakeAuditLogger.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Fake audit logger for testing.
+ *
+ * @package AgentWP\Tests\Fakes
+ */
+
+namespace AgentWP\Tests\Fakes;
+
+use AgentWP\Contracts\AuditLoggerInterface;
+
+/**
+ * Audit logger that captures events for assertions.
+ */
+final class FakeAuditLogger implements AuditLoggerInterface {
+
+	/**
+	 * Captured audit events.
+	 *
+	 * @var array<int, array<string, mixed>>
+	 */
+	private array $logs = array();
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
+		$this->logs[] = array(
+			'type'      => 'api_key',
+			'action'    => $action,
+			'user_id'   => $user_id,
+			'key_last4' => $key_last4,
+			'context'   => $extra,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
+		$this->logs[] = array(
+			'type'       => 'draft_confirm',
+			'draft_type' => $draft_type,
+			'draft_id'   => $draft_id,
+			'user_id'    => $user_id,
+			'context'    => $details,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
+		$this->logs[] = array(
+			'type'    => 'sensitive',
+			'action'  => $action,
+			'user_id' => $user_id,
+			'context' => $context,
+		);
+	}
+
+	/**
+	 * Get all audit events.
+	 *
+	 * @return array<int, array<string, mixed>>
+	 */
+	public function getLogs(): array {
+		return $this->logs;
+	}
+
+	/**
+	 * Get last audit event.
+	 *
+	 * @return array<string, mixed>|null
+	 */
+	public function getLastLog(): ?array {
+		if ( empty( $this->logs ) ) {
+			return null;
+		}
+
+		return $this->logs[ count( $this->logs ) - 1 ];
+	}
+}
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );
diff --git a/tests/Unit/Intent/ToolDispatcherTest.php b/tests/Unit/Intent/ToolDispatcherTest.php
index 737128019af6d5ca62e93a62fedc3df3604051e7..950d2a8a69551c5af76381c54bebe912b238c60a
--- a/tests/Unit/Intent/ToolDispatcherTest.php
+++ b/tests/Unit/Intent/ToolDispatcherTest.php
@@ -7,6 +7,8 @@
 
 use AgentWP\AI\Functions\FunctionSchema;
 use AgentWP\Intent\ToolDispatcher;
+use AgentWP\Tests\Fakes\FakeAuditLogger;
+use AgentWP\Tests\Fakes\FakeLogger;
 use AgentWP\Tests\Fakes\FakeToolRegistry;
 use AgentWP\Tests\TestCase;
 use AgentWP\Validation\ToolArgumentValidator;
@@ -64,6 +66,10 @@
 		$result = $this->dispatcher->dispatch( 'unknown_tool', array() );
 
 		$this->assertArrayHasKey( 'error', $result );
+		$this->assertArrayHasKey( 'success', $result );
+		$this->assertArrayHasKey( 'code', $result );
+		$this->assertFalse( $result['success'] );
+		$this->assertSame( 'unknown_tool', $result['code'] );
 		$this->assertStringContainsString( 'Unknown tool', $result['error'] );
 	}
 
@@ -121,6 +127,86 @@
 		$this->assertSame( 'invalid_tool_arguments', $result['code'] );
 	}
 
+	public function test_dispatch_logs_unknown_tool_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$dispatcher->dispatch( 'missing_tool', array( 'secret' => 'value' ) );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'Tool dispatch failed.', $log['message'] );
+		$this->assertSame( 'missing_tool', $log['context']['tool'] );
+		$this->assertSame( 'unknown_tool', $log['context']['reason'] );
+		$this->assertArrayHasKey( 'argument_count', $log['context'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'unknown_tool', $audit['context']['reason'] );
+	}
+
+	public function test_dispatch_logs_validation_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$schema = new class() implements FunctionSchema {
+			public function get_name(): string {
+				return 'strict_tool';
+			}
+
+			public function get_description(): string {
+				return 'A tool with strict validation';
+			}
+
+			public function get_parameters(): array {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'name' => array(
+							'type'        => 'string',
+							'description' => 'The name',
+						),
+					),
+					'required'   => array( 'name' ),
+				);
+			}
+
+			public function to_tool_definition(): array {
+				return array(
+					'type'     => 'function',
+					'function' => array(
+						'name'        => $this->get_name(),
+						'description' => $this->get_description(),
+						'parameters'  => $this->get_parameters(),
+					),
+				);
+			}
+		};
+
+		$this->toolRegistry->register( $schema );
+		$dispatcher->register( 'strict_tool', fn( array $args ) => array( 'ok' => true ) );
+
+		$dispatcher->dispatch( 'strict_tool', array() );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'invalid_tool_arguments', $log['context']['reason'] );
+		$this->assertSame( 'strict_tool', $log['context']['tool'] );
+		$this->assertNotEmpty( $log['context']['validation_fields'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'invalid_tool_arguments', $audit['context']['reason'] );
+	}
+
 	public function test_dispatch_skips_validation_when_no_schema(): void {
 		// Register tool without schema in registry.
 		$this->dispatcher->register(


thinking
**Checking unused imports**

I'm verifying that ToolArgumentValidator is imported but unused in the file, confirming it may be leftover and could potentially be removed.
exec
/bin/zsh -lc 'rg "ToolArgumentValidator" -n tests/Unit/Intent/ToolDispatcherTest.php' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 73ms:
14:use AgentWP\Validation\ToolArgumentValidator;
file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeAuditLogger.php b/tests/Fakes/FakeAuditLogger.php
new file mode 100644
index 0000000000000000000000000000000000000000..e64af09dbfee4807d086ea29730b81f584c8dac0
--- /dev/null
+++ b/tests/Fakes/FakeAuditLogger.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Fake audit logger for testing.
+ *
+ * @package AgentWP\Tests\Fakes
+ */
+
+namespace AgentWP\Tests\Fakes;
+
+use AgentWP\Contracts\AuditLoggerInterface;
+
+/**
+ * Audit logger that captures events for assertions.
+ */
+final class FakeAuditLogger implements AuditLoggerInterface {
+
+	/**
+	 * Captured audit events.
+	 *
+	 * @var array<int, array<string, mixed>>
+	 */
+	private array $logs = array();
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
+		$this->logs[] = array(
+			'type'      => 'api_key',
+			'action'    => $action,
+			'user_id'   => $user_id,
+			'key_last4' => $key_last4,
+			'context'   => $extra,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
+		$this->logs[] = array(
+			'type'       => 'draft_confirm',
+			'draft_type' => $draft_type,
+			'draft_id'   => $draft_id,
+			'user_id'    => $user_id,
+			'context'    => $details,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
+		$this->logs[] = array(
+			'type'    => 'sensitive',
+			'action'  => $action,
+			'user_id' => $user_id,
+			'context' => $context,
+		);
+	}
+
+	/**
+	 * Get all audit events.
+	 *
+	 * @return array<int, array<string, mixed>>
+	 */
+	public function getLogs(): array {
+		return $this->logs;
+	}
+
+	/**
+	 * Get last audit event.
+	 *
+	 * @return array<string, mixed>|null
+	 */
+	public function getLastLog(): ?array {
+		if ( empty( $this->logs ) ) {
+			return null;
+		}
+
+		return $this->logs[ count( $this->logs ) - 1 ];
+	}
+}
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );
diff --git a/tests/Unit/Intent/ToolDispatcherTest.php b/tests/Unit/Intent/ToolDispatcherTest.php
index 737128019af6d5ca62e93a62fedc3df3604051e7..950d2a8a69551c5af76381c54bebe912b238c60a
--- a/tests/Unit/Intent/ToolDispatcherTest.php
+++ b/tests/Unit/Intent/ToolDispatcherTest.php
@@ -7,6 +7,8 @@
 
 use AgentWP\AI\Functions\FunctionSchema;
 use AgentWP\Intent\ToolDispatcher;
+use AgentWP\Tests\Fakes\FakeAuditLogger;
+use AgentWP\Tests\Fakes\FakeLogger;
 use AgentWP\Tests\Fakes\FakeToolRegistry;
 use AgentWP\Tests\TestCase;
 use AgentWP\Validation\ToolArgumentValidator;
@@ -64,6 +66,10 @@
 		$result = $this->dispatcher->dispatch( 'unknown_tool', array() );
 
 		$this->assertArrayHasKey( 'error', $result );
+		$this->assertArrayHasKey( 'success', $result );
+		$this->assertArrayHasKey( 'code', $result );
+		$this->assertFalse( $result['success'] );
+		$this->assertSame( 'unknown_tool', $result['code'] );
 		$this->assertStringContainsString( 'Unknown tool', $result['error'] );
 	}
 
@@ -121,6 +127,86 @@
 		$this->assertSame( 'invalid_tool_arguments', $result['code'] );
 	}
 
+	public function test_dispatch_logs_unknown_tool_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$dispatcher->dispatch( 'missing_tool', array( 'secret' => 'value' ) );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'Tool dispatch failed.', $log['message'] );
+		$this->assertSame( 'missing_tool', $log['context']['tool'] );
+		$this->assertSame( 'unknown_tool', $log['context']['reason'] );
+		$this->assertArrayHasKey( 'argument_count', $log['context'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'unknown_tool', $audit['context']['reason'] );
+	}
+
+	public function test_dispatch_logs_validation_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$schema = new class() implements FunctionSchema {
+			public function get_name(): string {
+				return 'strict_tool';
+			}
+
+			public function get_description(): string {
+				return 'A tool with strict validation';
+			}
+
+			public function get_parameters(): array {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'name' => array(
+							'type'        => 'string',
+							'description' => 'The name',
+						),
+					),
+					'required'   => array( 'name' ),
+				);
+			}
+
+			public function to_tool_definition(): array {
+				return array(
+					'type'     => 'function',
+					'function' => array(
+						'name'        => $this->get_name(),
+						'description' => $this->get_description(),
+						'parameters'  => $this->get_parameters(),
+					),
+				);
+			}
+		};
+
+		$this->toolRegistry->register( $schema );
+		$dispatcher->register( 'strict_tool', fn( array $args ) => array( 'ok' => true ) );
+
+		$dispatcher->dispatch( 'strict_tool', array() );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'invalid_tool_arguments', $log['context']['reason'] );
+		$this->assertSame( 'strict_tool', $log['context']['tool'] );
+		$this->assertNotEmpty( $log['context']['validation_fields'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'invalid_tool_arguments', $audit['context']['reason'] );
+	}
+
 	public function test_dispatch_skips_validation_when_no_schema(): void {
 		// Register tool without schema in registry.
 		$this->dispatcher->register(


thinking
**Removing unused import to clean code**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/tests/Unit/Intent/ToolDispatcherTest.php
@@ -13,3 +13,2 @@
 use AgentWP\Tests\TestCase;
-use AgentWP\Validation\ToolArgumentValidator;
 
apply_patch(auto_approved=true) exited 0 in 74ms:
Success. Updated the following files:
M tests/Unit/Intent/ToolDispatcherTest.php
file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeAuditLogger.php b/tests/Fakes/FakeAuditLogger.php
new file mode 100644
index 0000000000000000000000000000000000000000..e64af09dbfee4807d086ea29730b81f584c8dac0
--- /dev/null
+++ b/tests/Fakes/FakeAuditLogger.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Fake audit logger for testing.
+ *
+ * @package AgentWP\Tests\Fakes
+ */
+
+namespace AgentWP\Tests\Fakes;
+
+use AgentWP\Contracts\AuditLoggerInterface;
+
+/**
+ * Audit logger that captures events for assertions.
+ */
+final class FakeAuditLogger implements AuditLoggerInterface {
+
+	/**
+	 * Captured audit events.
+	 *
+	 * @var array<int, array<string, mixed>>
+	 */
+	private array $logs = array();
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
+		$this->logs[] = array(
+			'type'      => 'api_key',
+			'action'    => $action,
+			'user_id'   => $user_id,
+			'key_last4' => $key_last4,
+			'context'   => $extra,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
+		$this->logs[] = array(
+			'type'       => 'draft_confirm',
+			'draft_type' => $draft_type,
+			'draft_id'   => $draft_id,
+			'user_id'    => $user_id,
+			'context'    => $details,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
+		$this->logs[] = array(
+			'type'    => 'sensitive',
+			'action'  => $action,
+			'user_id' => $user_id,
+			'context' => $context,
+		);
+	}
+
+	/**
+	 * Get all audit events.
+	 *
+	 * @return array<int, array<string, mixed>>
+	 */
+	public function getLogs(): array {
+		return $this->logs;
+	}
+
+	/**
+	 * Get last audit event.
+	 *
+	 * @return array<string, mixed>|null
+	 */
+	public function getLastLog(): ?array {
+		if ( empty( $this->logs ) ) {
+			return null;
+		}
+
+		return $this->logs[ count( $this->logs ) - 1 ];
+	}
+}
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );
diff --git a/tests/Unit/Intent/ToolDispatcherTest.php b/tests/Unit/Intent/ToolDispatcherTest.php
index 737128019af6d5ca62e93a62fedc3df3604051e7..f0a758d6e3f763a7cfe0a8055ecaaeccfc7e4244
--- a/tests/Unit/Intent/ToolDispatcherTest.php
+++ b/tests/Unit/Intent/ToolDispatcherTest.php
@@ -7,9 +7,10 @@
 
 use AgentWP\AI\Functions\FunctionSchema;
 use AgentWP\Intent\ToolDispatcher;
+use AgentWP\Tests\Fakes\FakeAuditLogger;
+use AgentWP\Tests\Fakes\FakeLogger;
 use AgentWP\Tests\Fakes\FakeToolRegistry;
 use AgentWP\Tests\TestCase;
-use AgentWP\Validation\ToolArgumentValidator;
 
 class ToolDispatcherTest extends TestCase {
 
@@ -64,6 +65,10 @@
 		$result = $this->dispatcher->dispatch( 'unknown_tool', array() );
 
 		$this->assertArrayHasKey( 'error', $result );
+		$this->assertArrayHasKey( 'success', $result );
+		$this->assertArrayHasKey( 'code', $result );
+		$this->assertFalse( $result['success'] );
+		$this->assertSame( 'unknown_tool', $result['code'] );
 		$this->assertStringContainsString( 'Unknown tool', $result['error'] );
 	}
 
@@ -121,6 +126,86 @@
 		$this->assertSame( 'invalid_tool_arguments', $result['code'] );
 	}
 
+	public function test_dispatch_logs_unknown_tool_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$dispatcher->dispatch( 'missing_tool', array( 'secret' => 'value' ) );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'Tool dispatch failed.', $log['message'] );
+		$this->assertSame( 'missing_tool', $log['context']['tool'] );
+		$this->assertSame( 'unknown_tool', $log['context']['reason'] );
+		$this->assertArrayHasKey( 'argument_count', $log['context'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'unknown_tool', $audit['context']['reason'] );
+	}
+
+	public function test_dispatch_logs_validation_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$schema = new class() implements FunctionSchema {
+			public function get_name(): string {
+				return 'strict_tool';
+			}
+
+			public function get_description(): string {
+				return 'A tool with strict validation';
+			}
+
+			public function get_parameters(): array {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'name' => array(
+							'type'        => 'string',
+							'description' => 'The name',
+						),
+					),
+					'required'   => array( 'name' ),
+				);
+			}
+
+			public function to_tool_definition(): array {
+				return array(
+					'type'     => 'function',
+					'function' => array(
+						'name'        => $this->get_name(),
+						'description' => $this->get_description(),
+						'parameters'  => $this->get_parameters(),
+					),
+				);
+			}
+		};
+
+		$this->toolRegistry->register( $schema );
+		$dispatcher->register( 'strict_tool', fn( array $args ) => array( 'ok' => true ) );
+
+		$dispatcher->dispatch( 'strict_tool', array() );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'invalid_tool_arguments', $log['context']['reason'] );
+		$this->assertSame( 'strict_tool', $log['context']['tool'] );
+		$this->assertNotEmpty( $log['context']['validation_fields'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'invalid_tool_arguments', $audit['context']['reason'] );
+	}
+
 	public function test_dispatch_skips_validation_when_no_schema(): void {
 		// Register tool without schema in registry.
 		$this->dispatcher->register(

file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeAuditLogger.php b/tests/Fakes/FakeAuditLogger.php
new file mode 100644
index 0000000000000000000000000000000000000000..e64af09dbfee4807d086ea29730b81f584c8dac0
--- /dev/null
+++ b/tests/Fakes/FakeAuditLogger.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Fake audit logger for testing.
+ *
+ * @package AgentWP\Tests\Fakes
+ */
+
+namespace AgentWP\Tests\Fakes;
+
+use AgentWP\Contracts\AuditLoggerInterface;
+
+/**
+ * Audit logger that captures events for assertions.
+ */
+final class FakeAuditLogger implements AuditLoggerInterface {
+
+	/**
+	 * Captured audit events.
+	 *
+	 * @var array<int, array<string, mixed>>
+	 */
+	private array $logs = array();
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
+		$this->logs[] = array(
+			'type'      => 'api_key',
+			'action'    => $action,
+			'user_id'   => $user_id,
+			'key_last4' => $key_last4,
+			'context'   => $extra,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
+		$this->logs[] = array(
+			'type'       => 'draft_confirm',
+			'draft_type' => $draft_type,
+			'draft_id'   => $draft_id,
+			'user_id'    => $user_id,
+			'context'    => $details,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
+		$this->logs[] = array(
+			'type'    => 'sensitive',
+			'action'  => $action,
+			'user_id' => $user_id,
+			'context' => $context,
+		);
+	}
+
+	/**
+	 * Get all audit events.
+	 *
+	 * @return array<int, array<string, mixed>>
+	 */
+	public function getLogs(): array {
+		return $this->logs;
+	}
+
+	/**
+	 * Get last audit event.
+	 *
+	 * @return array<string, mixed>|null
+	 */
+	public function getLastLog(): ?array {
+		if ( empty( $this->logs ) ) {
+			return null;
+		}
+
+		return $this->logs[ count( $this->logs ) - 1 ];
+	}
+}
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );
diff --git a/tests/Unit/Intent/ToolDispatcherTest.php b/tests/Unit/Intent/ToolDispatcherTest.php
index 737128019af6d5ca62e93a62fedc3df3604051e7..f0a758d6e3f763a7cfe0a8055ecaaeccfc7e4244
--- a/tests/Unit/Intent/ToolDispatcherTest.php
+++ b/tests/Unit/Intent/ToolDispatcherTest.php
@@ -7,9 +7,10 @@
 
 use AgentWP\AI\Functions\FunctionSchema;
 use AgentWP\Intent\ToolDispatcher;
+use AgentWP\Tests\Fakes\FakeAuditLogger;
+use AgentWP\Tests\Fakes\FakeLogger;
 use AgentWP\Tests\Fakes\FakeToolRegistry;
 use AgentWP\Tests\TestCase;
-use AgentWP\Validation\ToolArgumentValidator;
 
 class ToolDispatcherTest extends TestCase {
 
@@ -64,6 +65,10 @@
 		$result = $this->dispatcher->dispatch( 'unknown_tool', array() );
 
 		$this->assertArrayHasKey( 'error', $result );
+		$this->assertArrayHasKey( 'success', $result );
+		$this->assertArrayHasKey( 'code', $result );
+		$this->assertFalse( $result['success'] );
+		$this->assertSame( 'unknown_tool', $result['code'] );
 		$this->assertStringContainsString( 'Unknown tool', $result['error'] );
 	}
 
@@ -121,6 +126,86 @@
 		$this->assertSame( 'invalid_tool_arguments', $result['code'] );
 	}
 
+	public function test_dispatch_logs_unknown_tool_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$dispatcher->dispatch( 'missing_tool', array( 'secret' => 'value' ) );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'Tool dispatch failed.', $log['message'] );
+		$this->assertSame( 'missing_tool', $log['context']['tool'] );
+		$this->assertSame( 'unknown_tool', $log['context']['reason'] );
+		$this->assertArrayHasKey( 'argument_count', $log['context'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'unknown_tool', $audit['context']['reason'] );
+	}
+
+	public function test_dispatch_logs_validation_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$schema = new class() implements FunctionSchema {
+			public function get_name(): string {
+				return 'strict_tool';
+			}
+
+			public function get_description(): string {
+				return 'A tool with strict validation';
+			}
+
+			public function get_parameters(): array {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'name' => array(
+							'type'        => 'string',
+							'description' => 'The name',
+						),
+					),
+					'required'   => array( 'name' ),
+				);
+			}
+
+			public function to_tool_definition(): array {
+				return array(
+					'type'     => 'function',
+					'function' => array(
+						'name'        => $this->get_name(),
+						'description' => $this->get_description(),
+						'parameters'  => $this->get_parameters(),
+					),
+				);
+			}
+		};
+
+		$this->toolRegistry->register( $schema );
+		$dispatcher->register( 'strict_tool', fn( array $args ) => array( 'ok' => true ) );
+
+		$dispatcher->dispatch( 'strict_tool', array() );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'invalid_tool_arguments', $log['context']['reason'] );
+		$this->assertSame( 'strict_tool', $log['context']['tool'] );
+		$this->assertNotEmpty( $log['context']['validation_fields'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'invalid_tool_arguments', $audit['context']['reason'] );
+	}
+
 	public function test_dispatch_skips_validation_when_no_schema(): void {
 		// Register tool without schema in registry.
 		$this->dispatcher->register(



thinking
**Planning unknown tool integration test**

I'm planning an integration test that simulates the AI calling an unregistered tool by having the handler subclass exclude it from the tool list, ensuring the dispatcher returns an unknown tool error and the response shows failure with the correct error code.
thinking
**Designing unknown tool test with real tool registry**

I'm planning to create an integration test using a tool registry that includes a registered tool but simulating the AI calling an unregistered tool to trigger the unknown tool error. The test will verify that the handler handles this case by asserting the failure and error code in the tool message.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/tests/Integration/Intent/ToolExecutionPathTest.php
@@ -322,2 +322,147 @@
 	}
+
+	public function test_engine_agentic_handler_returns_unknown_tool_error_for_unregistered_tool(): void {
+		$tool_name = 'test_tool';
+
+		$schema = new class( $tool_name ) extends AbstractFunction {
+			private string $name;
+
+			public function __construct( string $name ) {
+				$this->name = $name;
+			}
+
+			public function get_name() {
+				return $this->name;
+			}
+
+			public function get_description() {
+				return 'Test tool for unknown tool handling.';
+			}
+
+			public function get_parameters() {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'order_id' => array(
+							'type' => 'integer',
+						),
+					),
+				);
+			}
+		};
+
+		$registry = new FakeToolRegistry();
+		$registry->register( $schema );
+
+		$client = new class() implements OpenAIClientInterface {
+			/** @var Response[] */
+			public array $responses;
+			public array $calls = array();
+
+			public function __construct() {
+				$this->responses = array(
+					Response::success(
+						array(
+							'content'    => '',
+							'tool_calls' => array(
+								array(
+									'id'       => 'call_1',
+									'type'     => 'function',
+									'function' => array(
+										'name'      => 'unknown_tool',
+										'arguments' => '{}',
+									),
+								),
+							),
+						)
+					),
+					Response::success(
+						array(
+							'content'    => 'Done',
+							'tool_calls' => array(),
+						)
+					),
+				);
+			}
+
+			public function chat( array $messages, array $functions ): Response {
+				$this->calls[] = array(
+					'messages'  => $messages,
+					'functions' => $functions,
+				);
+
+				if ( empty( $this->responses ) ) {
+					return Response::error( 'No fake responses queued.', 500 );
+				}
+
+				return array_shift( $this->responses );
+			}
+
+			public function validateKey( string $key ): bool {
+				unset( $key );
+				return true;
+			}
+		};
+
+		$handler = new class( new FakeAIClientFactory( $client, true ), $registry ) extends AbstractAgenticHandler {
+			public function __construct( FakeAIClientFactory $clientFactory, FakeToolRegistry $toolRegistry ) {
+				parent::__construct( Intent::ORDER_STATUS, $clientFactory, $toolRegistry );
+			}
+
+			protected function registerToolExecutors( \AgentWP\Contracts\ToolDispatcherInterface $dispatcher ): void {
+				$dispatcher->register( 'test_tool', fn( array $args ) => array( 'ok' => true ) );
+			}
+
+			protected function getSystemPrompt(): string {
+				return 'Test.';
+			}
+
+			protected function getToolNames(): array {
+				return array( 'test_tool' );
+			}
+		};
+
+		$classifier = new class() implements IntentClassifierInterface {
+			public function classify( string $input, array $context = array() ): string {
+				unset( $input, $context );
+				return Intent::ORDER_STATUS;
+			}
+		};
+
+		$builder = new class() extends ContextBuilder {
+			public function build( array $context = array(), array $metadata = array() ): array {
+				return $context;
+			}
+		};
+
+		$memory = new FakeMemoryStore();
+		$handler_registry = new HandlerRegistry();
+		$handler_registry->register( Intent::ORDER_STATUS, $handler );
+
+		$engine = new Engine(
+			array(),
+			new FunctionRegistry(),
+			$builder,
+			$classifier,
+			$memory,
+			$handler_registry,
+			new FallbackHandler()
+		);
+
+		$response = $engine->handle( 'status check' );
+		$this->assertTrue( $response->is_success() );
+		$this->assertSame( 'Done', $response->get_data()['message'] );
+
+		$this->assertCount( 2, $client->calls );
+		$second_call_messages = $client->calls[1]['messages'];
+		$tool_message         = $second_call_messages[ count( $second_call_messages ) - 1 ];
+
+		$this->assertSame( 'tool', $tool_message['role'] );
+		$decoded = json_decode( $tool_message['content'], true );
+
+		$this->assertIsArray( $decoded );
+		$this->assertFalse( $decoded['success'] );
+		$this->assertSame( 'unknown_tool', $decoded['code'] );
+		$this->assertStringContainsString( 'Unknown tool', $decoded['error'] );
+	}
 }
apply_patch(auto_approved=true) exited 0 in 68ms:
Success. Updated the following files:
M tests/Integration/Intent/ToolExecutionPathTest.php
file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeAuditLogger.php b/tests/Fakes/FakeAuditLogger.php
new file mode 100644
index 0000000000000000000000000000000000000000..e64af09dbfee4807d086ea29730b81f584c8dac0
--- /dev/null
+++ b/tests/Fakes/FakeAuditLogger.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Fake audit logger for testing.
+ *
+ * @package AgentWP\Tests\Fakes
+ */
+
+namespace AgentWP\Tests\Fakes;
+
+use AgentWP\Contracts\AuditLoggerInterface;
+
+/**
+ * Audit logger that captures events for assertions.
+ */
+final class FakeAuditLogger implements AuditLoggerInterface {
+
+	/**
+	 * Captured audit events.
+	 *
+	 * @var array<int, array<string, mixed>>
+	 */
+	private array $logs = array();
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
+		$this->logs[] = array(
+			'type'      => 'api_key',
+			'action'    => $action,
+			'user_id'   => $user_id,
+			'key_last4' => $key_last4,
+			'context'   => $extra,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
+		$this->logs[] = array(
+			'type'       => 'draft_confirm',
+			'draft_type' => $draft_type,
+			'draft_id'   => $draft_id,
+			'user_id'    => $user_id,
+			'context'    => $details,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
+		$this->logs[] = array(
+			'type'    => 'sensitive',
+			'action'  => $action,
+			'user_id' => $user_id,
+			'context' => $context,
+		);
+	}
+
+	/**
+	 * Get all audit events.
+	 *
+	 * @return array<int, array<string, mixed>>
+	 */
+	public function getLogs(): array {
+		return $this->logs;
+	}
+
+	/**
+	 * Get last audit event.
+	 *
+	 * @return array<string, mixed>|null
+	 */
+	public function getLastLog(): ?array {
+		if ( empty( $this->logs ) ) {
+			return null;
+		}
+
+		return $this->logs[ count( $this->logs ) - 1 ];
+	}
+}
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );
diff --git a/tests/Integration/Intent/ToolExecutionPathTest.php b/tests/Integration/Intent/ToolExecutionPathTest.php
index 0eddd12986f92ca5638d0b44ffc4ca7548503ac8..9c7464d003b2c9b5f0f80e37cff6a675c1f996b3
--- a/tests/Integration/Intent/ToolExecutionPathTest.php
+++ b/tests/Integration/Intent/ToolExecutionPathTest.php
@@ -320,4 +320,149 @@
 		$this->assertSame( 'invalid_tool_arguments', $decoded['code'] );
 		$this->assertNotEmpty( $decoded['validation_errors'] );
 	}
+
+	public function test_engine_agentic_handler_returns_unknown_tool_error_for_unregistered_tool(): void {
+		$tool_name = 'test_tool';
+
+		$schema = new class( $tool_name ) extends AbstractFunction {
+			private string $name;
+
+			public function __construct( string $name ) {
+				$this->name = $name;
+			}
+
+			public function get_name() {
+				return $this->name;
+			}
+
+			public function get_description() {
+				return 'Test tool for unknown tool handling.';
+			}
+
+			public function get_parameters() {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'order_id' => array(
+							'type' => 'integer',
+						),
+					),
+				);
+			}
+		};
+
+		$registry = new FakeToolRegistry();
+		$registry->register( $schema );
+
+		$client = new class() implements OpenAIClientInterface {
+			/** @var Response[] */
+			public array $responses;
+			public array $calls = array();
+
+			public function __construct() {
+				$this->responses = array(
+					Response::success(
+						array(
+							'content'    => '',
+							'tool_calls' => array(
+								array(
+									'id'       => 'call_1',
+									'type'     => 'function',
+									'function' => array(
+										'name'      => 'unknown_tool',
+										'arguments' => '{}',
+									),
+								),
+							),
+						)
+					),
+					Response::success(
+						array(
+							'content'    => 'Done',
+							'tool_calls' => array(),
+						)
+					),
+				);
+			}
+
+			public function chat( array $messages, array $functions ): Response {
+				$this->calls[] = array(
+					'messages'  => $messages,
+					'functions' => $functions,
+				);
+
+				if ( empty( $this->responses ) ) {
+					return Response::error( 'No fake responses queued.', 500 );
+				}
+
+				return array_shift( $this->responses );
+			}
+
+			public function validateKey( string $key ): bool {
+				unset( $key );
+				return true;
+			}
+		};
+
+		$handler = new class( new FakeAIClientFactory( $client, true ), $registry ) extends AbstractAgenticHandler {
+			public function __construct( FakeAIClientFactory $clientFactory, FakeToolRegistry $toolRegistry ) {
+				parent::__construct( Intent::ORDER_STATUS, $clientFactory, $toolRegistry );
+			}
+
+			protected function registerToolExecutors( \AgentWP\Contracts\ToolDispatcherInterface $dispatcher ): void {
+				$dispatcher->register( 'test_tool', fn( array $args ) => array( 'ok' => true ) );
+			}
+
+			protected function getSystemPrompt(): string {
+				return 'Test.';
+			}
+
+			protected function getToolNames(): array {
+				return array( 'test_tool' );
+			}
+		};
+
+		$classifier = new class() implements IntentClassifierInterface {
+			public function classify( string $input, array $context = array() ): string {
+				unset( $input, $context );
+				return Intent::ORDER_STATUS;
+			}
+		};
+
+		$builder = new class() extends ContextBuilder {
+			public function build( array $context = array(), array $metadata = array() ): array {
+				return $context;
+			}
+		};
+
+		$memory = new FakeMemoryStore();
+		$handler_registry = new HandlerRegistry();
+		$handler_registry->register( Intent::ORDER_STATUS, $handler );
+
+		$engine = new Engine(
+			array(),
+			new FunctionRegistry(),
+			$builder,
+			$classifier,
+			$memory,
+			$handler_registry,
+			new FallbackHandler()
+		);
+
+		$response = $engine->handle( 'status check' );
+		$this->assertTrue( $response->is_success() );
+		$this->assertSame( 'Done', $response->get_data()['message'] );
+
+		$this->assertCount( 2, $client->calls );
+		$second_call_messages = $client->calls[1]['messages'];
+		$tool_message         = $second_call_messages[ count( $second_call_messages ) - 1 ];
+
+		$this->assertSame( 'tool', $tool_message['role'] );
+		$decoded = json_decode( $tool_message['content'], true );
+
+		$this->assertIsArray( $decoded );
+		$this->assertFalse( $decoded['success'] );
+		$this->assertSame( 'unknown_tool', $decoded['code'] );
+		$this->assertStringContainsString( 'Unknown tool', $decoded['error'] );
+	}
 }
diff --git a/tests/Unit/Intent/ToolDispatcherTest.php b/tests/Unit/Intent/ToolDispatcherTest.php
index 737128019af6d5ca62e93a62fedc3df3604051e7..f0a758d6e3f763a7cfe0a8055ecaaeccfc7e4244
--- a/tests/Unit/Intent/ToolDispatcherTest.php
+++ b/tests/Unit/Intent/ToolDispatcherTest.php
@@ -7,9 +7,10 @@
 
 use AgentWP\AI\Functions\FunctionSchema;
 use AgentWP\Intent\ToolDispatcher;
+use AgentWP\Tests\Fakes\FakeAuditLogger;
+use AgentWP\Tests\Fakes\FakeLogger;
 use AgentWP\Tests\Fakes\FakeToolRegistry;
 use AgentWP\Tests\TestCase;
-use AgentWP\Validation\ToolArgumentValidator;
 
 class ToolDispatcherTest extends TestCase {
 
@@ -64,6 +65,10 @@
 		$result = $this->dispatcher->dispatch( 'unknown_tool', array() );
 
 		$this->assertArrayHasKey( 'error', $result );
+		$this->assertArrayHasKey( 'success', $result );
+		$this->assertArrayHasKey( 'code', $result );
+		$this->assertFalse( $result['success'] );
+		$this->assertSame( 'unknown_tool', $result['code'] );
 		$this->assertStringContainsString( 'Unknown tool', $result['error'] );
 	}
 
@@ -121,6 +126,86 @@
 		$this->assertSame( 'invalid_tool_arguments', $result['code'] );
 	}
 
+	public function test_dispatch_logs_unknown_tool_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$dispatcher->dispatch( 'missing_tool', array( 'secret' => 'value' ) );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'Tool dispatch failed.', $log['message'] );
+		$this->assertSame( 'missing_tool', $log['context']['tool'] );
+		$this->assertSame( 'unknown_tool', $log['context']['reason'] );
+		$this->assertArrayHasKey( 'argument_count', $log['context'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'unknown_tool', $audit['context']['reason'] );
+	}
+
+	public function test_dispatch_logs_validation_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$schema = new class() implements FunctionSchema {
+			public function get_name(): string {
+				return 'strict_tool';
+			}
+
+			public function get_description(): string {
+				return 'A tool with strict validation';
+			}
+
+			public function get_parameters(): array {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'name' => array(
+							'type'        => 'string',
+							'description' => 'The name',
+						),
+					),
+					'required'   => array( 'name' ),
+				);
+			}
+
+			public function to_tool_definition(): array {
+				return array(
+					'type'     => 'function',
+					'function' => array(
+						'name'        => $this->get_name(),
+						'description' => $this->get_description(),
+						'parameters'  => $this->get_parameters(),
+					),
+				);
+			}
+		};
+
+		$this->toolRegistry->register( $schema );
+		$dispatcher->register( 'strict_tool', fn( array $args ) => array( 'ok' => true ) );
+
+		$dispatcher->dispatch( 'strict_tool', array() );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'invalid_tool_arguments', $log['context']['reason'] );
+		$this->assertSame( 'strict_tool', $log['context']['tool'] );
+		$this->assertNotEmpty( $log['context']['validation_fields'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'invalid_tool_arguments', $audit['context']['reason'] );
+	}
+
 	public function test_dispatch_skips_validation_when_no_schema(): void {
 		// Register tool without schema in registry.
 		$this->dispatcher->register(

file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeAuditLogger.php b/tests/Fakes/FakeAuditLogger.php
new file mode 100644
index 0000000000000000000000000000000000000000..e64af09dbfee4807d086ea29730b81f584c8dac0
--- /dev/null
+++ b/tests/Fakes/FakeAuditLogger.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Fake audit logger for testing.
+ *
+ * @package AgentWP\Tests\Fakes
+ */
+
+namespace AgentWP\Tests\Fakes;
+
+use AgentWP\Contracts\AuditLoggerInterface;
+
+/**
+ * Audit logger that captures events for assertions.
+ */
+final class FakeAuditLogger implements AuditLoggerInterface {
+
+	/**
+	 * Captured audit events.
+	 *
+	 * @var array<int, array<string, mixed>>
+	 */
+	private array $logs = array();
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
+		$this->logs[] = array(
+			'type'      => 'api_key',
+			'action'    => $action,
+			'user_id'   => $user_id,
+			'key_last4' => $key_last4,
+			'context'   => $extra,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
+		$this->logs[] = array(
+			'type'       => 'draft_confirm',
+			'draft_type' => $draft_type,
+			'draft_id'   => $draft_id,
+			'user_id'    => $user_id,
+			'context'    => $details,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
+		$this->logs[] = array(
+			'type'    => 'sensitive',
+			'action'  => $action,
+			'user_id' => $user_id,
+			'context' => $context,
+		);
+	}
+
+	/**
+	 * Get all audit events.
+	 *
+	 * @return array<int, array<string, mixed>>
+	 */
+	public function getLogs(): array {
+		return $this->logs;
+	}
+
+	/**
+	 * Get last audit event.
+	 *
+	 * @return array<string, mixed>|null
+	 */
+	public function getLastLog(): ?array {
+		if ( empty( $this->logs ) ) {
+			return null;
+		}
+
+		return $this->logs[ count( $this->logs ) - 1 ];
+	}
+}
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );
diff --git a/tests/Integration/Intent/ToolExecutionPathTest.php b/tests/Integration/Intent/ToolExecutionPathTest.php
index 0eddd12986f92ca5638d0b44ffc4ca7548503ac8..9c7464d003b2c9b5f0f80e37cff6a675c1f996b3
--- a/tests/Integration/Intent/ToolExecutionPathTest.php
+++ b/tests/Integration/Intent/ToolExecutionPathTest.php
@@ -320,4 +320,149 @@
 		$this->assertSame( 'invalid_tool_arguments', $decoded['code'] );
 		$this->assertNotEmpty( $decoded['validation_errors'] );
 	}
+
+	public function test_engine_agentic_handler_returns_unknown_tool_error_for_unregistered_tool(): void {
+		$tool_name = 'test_tool';
+
+		$schema = new class( $tool_name ) extends AbstractFunction {
+			private string $name;
+
+			public function __construct( string $name ) {
+				$this->name = $name;
+			}
+
+			public function get_name() {
+				return $this->name;
+			}
+
+			public function get_description() {
+				return 'Test tool for unknown tool handling.';
+			}
+
+			public function get_parameters() {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'order_id' => array(
+							'type' => 'integer',
+						),
+					),
+				);
+			}
+		};
+
+		$registry = new FakeToolRegistry();
+		$registry->register( $schema );
+
+		$client = new class() implements OpenAIClientInterface {
+			/** @var Response[] */
+			public array $responses;
+			public array $calls = array();
+
+			public function __construct() {
+				$this->responses = array(
+					Response::success(
+						array(
+							'content'    => '',
+							'tool_calls' => array(
+								array(
+									'id'       => 'call_1',
+									'type'     => 'function',
+									'function' => array(
+										'name'      => 'unknown_tool',
+										'arguments' => '{}',
+									),
+								),
+							),
+						)
+					),
+					Response::success(
+						array(
+							'content'    => 'Done',
+							'tool_calls' => array(),
+						)
+					),
+				);
+			}
+
+			public function chat( array $messages, array $functions ): Response {
+				$this->calls[] = array(
+					'messages'  => $messages,
+					'functions' => $functions,
+				);
+
+				if ( empty( $this->responses ) ) {
+					return Response::error( 'No fake responses queued.', 500 );
+				}
+
+				return array_shift( $this->responses );
+			}
+
+			public function validateKey( string $key ): bool {
+				unset( $key );
+				return true;
+			}
+		};
+
+		$handler = new class( new FakeAIClientFactory( $client, true ), $registry ) extends AbstractAgenticHandler {
+			public function __construct( FakeAIClientFactory $clientFactory, FakeToolRegistry $toolRegistry ) {
+				parent::__construct( Intent::ORDER_STATUS, $clientFactory, $toolRegistry );
+			}
+
+			protected function registerToolExecutors( \AgentWP\Contracts\ToolDispatcherInterface $dispatcher ): void {
+				$dispatcher->register( 'test_tool', fn( array $args ) => array( 'ok' => true ) );
+			}
+
+			protected function getSystemPrompt(): string {
+				return 'Test.';
+			}
+
+			protected function getToolNames(): array {
+				return array( 'test_tool' );
+			}
+		};
+
+		$classifier = new class() implements IntentClassifierInterface {
+			public function classify( string $input, array $context = array() ): string {
+				unset( $input, $context );
+				return Intent::ORDER_STATUS;
+			}
+		};
+
+		$builder = new class() extends ContextBuilder {
+			public function build( array $context = array(), array $metadata = array() ): array {
+				return $context;
+			}
+		};
+
+		$memory = new FakeMemoryStore();
+		$handler_registry = new HandlerRegistry();
+		$handler_registry->register( Intent::ORDER_STATUS, $handler );
+
+		$engine = new Engine(
+			array(),
+			new FunctionRegistry(),
+			$builder,
+			$classifier,
+			$memory,
+			$handler_registry,
+			new FallbackHandler()
+		);
+
+		$response = $engine->handle( 'status check' );
+		$this->assertTrue( $response->is_success() );
+		$this->assertSame( 'Done', $response->get_data()['message'] );
+
+		$this->assertCount( 2, $client->calls );
+		$second_call_messages = $client->calls[1]['messages'];
+		$tool_message         = $second_call_messages[ count( $second_call_messages ) - 1 ];
+
+		$this->assertSame( 'tool', $tool_message['role'] );
+		$decoded = json_decode( $tool_message['content'], true );
+
+		$this->assertIsArray( $decoded );
+		$this->assertFalse( $decoded['success'] );
+		$this->assertSame( 'unknown_tool', $decoded['code'] );
+		$this->assertStringContainsString( 'Unknown tool', $decoded['error'] );
+	}
 }
diff --git a/tests/Unit/Intent/ToolDispatcherTest.php b/tests/Unit/Intent/ToolDispatcherTest.php
index 737128019af6d5ca62e93a62fedc3df3604051e7..f0a758d6e3f763a7cfe0a8055ecaaeccfc7e4244
--- a/tests/Unit/Intent/ToolDispatcherTest.php
+++ b/tests/Unit/Intent/ToolDispatcherTest.php
@@ -7,9 +7,10 @@
 
 use AgentWP\AI\Functions\FunctionSchema;
 use AgentWP\Intent\ToolDispatcher;
+use AgentWP\Tests\Fakes\FakeAuditLogger;
+use AgentWP\Tests\Fakes\FakeLogger;
 use AgentWP\Tests\Fakes\FakeToolRegistry;
 use AgentWP\Tests\TestCase;
-use AgentWP\Validation\ToolArgumentValidator;
 
 class ToolDispatcherTest extends TestCase {
 
@@ -64,6 +65,10 @@
 		$result = $this->dispatcher->dispatch( 'unknown_tool', array() );
 
 		$this->assertArrayHasKey( 'error', $result );
+		$this->assertArrayHasKey( 'success', $result );
+		$this->assertArrayHasKey( 'code', $result );
+		$this->assertFalse( $result['success'] );
+		$this->assertSame( 'unknown_tool', $result['code'] );
 		$this->assertStringContainsString( 'Unknown tool', $result['error'] );
 	}
 
@@ -121,6 +126,86 @@
 		$this->assertSame( 'invalid_tool_arguments', $result['code'] );
 	}
 
+	public function test_dispatch_logs_unknown_tool_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$dispatcher->dispatch( 'missing_tool', array( 'secret' => 'value' ) );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'Tool dispatch failed.', $log['message'] );
+		$this->assertSame( 'missing_tool', $log['context']['tool'] );
+		$this->assertSame( 'unknown_tool', $log['context']['reason'] );
+		$this->assertArrayHasKey( 'argument_count', $log['context'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'unknown_tool', $audit['context']['reason'] );
+	}
+
+	public function test_dispatch_logs_validation_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$schema = new class() implements FunctionSchema {
+			public function get_name(): string {
+				return 'strict_tool';
+			}
+
+			public function get_description(): string {
+				return 'A tool with strict validation';
+			}
+
+			public function get_parameters(): array {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'name' => array(
+							'type'        => 'string',
+							'description' => 'The name',
+						),
+					),
+					'required'   => array( 'name' ),
+				);
+			}
+
+			public function to_tool_definition(): array {
+				return array(
+					'type'     => 'function',
+					'function' => array(
+						'name'        => $this->get_name(),
+						'description' => $this->get_description(),
+						'parameters'  => $this->get_parameters(),
+					),
+				);
+			}
+		};
+
+		$this->toolRegistry->register( $schema );
+		$dispatcher->register( 'strict_tool', fn( array $args ) => array( 'ok' => true ) );
+
+		$dispatcher->dispatch( 'strict_tool', array() );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'invalid_tool_arguments', $log['context']['reason'] );
+		$this->assertSame( 'strict_tool', $log['context']['tool'] );
+		$this->assertNotEmpty( $log['context']['validation_fields'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'invalid_tool_arguments', $audit['context']['reason'] );
+	}
+
 	public function test_dispatch_skips_validation_when_no_schema(): void {
 		// Register tool without schema in registry.
 		$this->dispatcher->register(



thinking
**Confirming ToolDispatcher updates consistency**
thinking
**Verifying tests handle updated error shape**

I'll confirm no other tests rely on the old unknown tool error format beyond the already updated ToolDispatcherTest to prevent failures.
exec
/bin/zsh -lc 'rg "unknown_tool" -n tests' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 56ms:
tests/Integration/Intent/ToolExecutionPathTest.php:324:	public function test_engine_agentic_handler_returns_unknown_tool_error_for_unregistered_tool(): void {
tests/Integration/Intent/ToolExecutionPathTest.php:372:										'name'      => 'unknown_tool',
tests/Integration/Intent/ToolExecutionPathTest.php:465:		$this->assertSame( 'unknown_tool', $decoded['code'] );
tests/Fakes/FakeToolDispatcher.php:103:				'code'    => 'unknown_tool',
tests/Unit/Validation/ToolArgumentValidationIntegrationTest.php:167:	public function test_unknown_tool_bypasses_validation(): void {
tests/Unit/Validation/ToolArgumentValidationIntegrationTest.php:169:		// Service won't be called because unknown_tool doesn't match.
tests/Unit/Validation/ToolArgumentValidationIntegrationTest.php:183:									'name'      => 'unknown_tool',
tests/Unit/Intent/ToolDispatcherTest.php:64:	public function test_dispatch_returns_error_for_unknown_tool(): void {
tests/Unit/Intent/ToolDispatcherTest.php:65:		$result = $this->dispatcher->dispatch( 'unknown_tool', array() );
tests/Unit/Intent/ToolDispatcherTest.php:71:		$this->assertSame( 'unknown_tool', $result['code'] );
tests/Unit/Intent/ToolDispatcherTest.php:129:	public function test_dispatch_logs_unknown_tool_failure(): void {
tests/Unit/Intent/ToolDispatcherTest.php:141:		$this->assertSame( 'unknown_tool', $log['context']['reason'] );
tests/Unit/Intent/ToolDispatcherTest.php:148:		$this->assertSame( 'unknown_tool', $audit['context']['reason'] );
tests/Unit/Intent/FunctionRegistryTest.php:83:				return array( 'search_orders', 'unknown_tool' );
file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeAuditLogger.php b/tests/Fakes/FakeAuditLogger.php
new file mode 100644
index 0000000000000000000000000000000000000000..e64af09dbfee4807d086ea29730b81f584c8dac0
--- /dev/null
+++ b/tests/Fakes/FakeAuditLogger.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Fake audit logger for testing.
+ *
+ * @package AgentWP\Tests\Fakes
+ */
+
+namespace AgentWP\Tests\Fakes;
+
+use AgentWP\Contracts\AuditLoggerInterface;
+
+/**
+ * Audit logger that captures events for assertions.
+ */
+final class FakeAuditLogger implements AuditLoggerInterface {
+
+	/**
+	 * Captured audit events.
+	 *
+	 * @var array<int, array<string, mixed>>
+	 */
+	private array $logs = array();
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
+		$this->logs[] = array(
+			'type'      => 'api_key',
+			'action'    => $action,
+			'user_id'   => $user_id,
+			'key_last4' => $key_last4,
+			'context'   => $extra,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
+		$this->logs[] = array(
+			'type'       => 'draft_confirm',
+			'draft_type' => $draft_type,
+			'draft_id'   => $draft_id,
+			'user_id'    => $user_id,
+			'context'    => $details,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
+		$this->logs[] = array(
+			'type'    => 'sensitive',
+			'action'  => $action,
+			'user_id' => $user_id,
+			'context' => $context,
+		);
+	}
+
+	/**
+	 * Get all audit events.
+	 *
+	 * @return array<int, array<string, mixed>>
+	 */
+	public function getLogs(): array {
+		return $this->logs;
+	}
+
+	/**
+	 * Get last audit event.
+	 *
+	 * @return array<string, mixed>|null
+	 */
+	public function getLastLog(): ?array {
+		if ( empty( $this->logs ) ) {
+			return null;
+		}
+
+		return $this->logs[ count( $this->logs ) - 1 ];
+	}
+}
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );
diff --git a/tests/Integration/Intent/ToolExecutionPathTest.php b/tests/Integration/Intent/ToolExecutionPathTest.php
index 0eddd12986f92ca5638d0b44ffc4ca7548503ac8..9c7464d003b2c9b5f0f80e37cff6a675c1f996b3
--- a/tests/Integration/Intent/ToolExecutionPathTest.php
+++ b/tests/Integration/Intent/ToolExecutionPathTest.php
@@ -320,4 +320,149 @@
 		$this->assertSame( 'invalid_tool_arguments', $decoded['code'] );
 		$this->assertNotEmpty( $decoded['validation_errors'] );
 	}
+
+	public function test_engine_agentic_handler_returns_unknown_tool_error_for_unregistered_tool(): void {
+		$tool_name = 'test_tool';
+
+		$schema = new class( $tool_name ) extends AbstractFunction {
+			private string $name;
+
+			public function __construct( string $name ) {
+				$this->name = $name;
+			}
+
+			public function get_name() {
+				return $this->name;
+			}
+
+			public function get_description() {
+				return 'Test tool for unknown tool handling.';
+			}
+
+			public function get_parameters() {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'order_id' => array(
+							'type' => 'integer',
+						),
+					),
+				);
+			}
+		};
+
+		$registry = new FakeToolRegistry();
+		$registry->register( $schema );
+
+		$client = new class() implements OpenAIClientInterface {
+			/** @var Response[] */
+			public array $responses;
+			public array $calls = array();
+
+			public function __construct() {
+				$this->responses = array(
+					Response::success(
+						array(
+							'content'    => '',
+							'tool_calls' => array(
+								array(
+									'id'       => 'call_1',
+									'type'     => 'function',
+									'function' => array(
+										'name'      => 'unknown_tool',
+										'arguments' => '{}',
+									),
+								),
+							),
+						)
+					),
+					Response::success(
+						array(
+							'content'    => 'Done',
+							'tool_calls' => array(),
+						)
+					),
+				);
+			}
+
+			public function chat( array $messages, array $functions ): Response {
+				$this->calls[] = array(
+					'messages'  => $messages,
+					'functions' => $functions,
+				);
+
+				if ( empty( $this->responses ) ) {
+					return Response::error( 'No fake responses queued.', 500 );
+				}
+
+				return array_shift( $this->responses );
+			}
+
+			public function validateKey( string $key ): bool {
+				unset( $key );
+				return true;
+			}
+		};
+
+		$handler = new class( new FakeAIClientFactory( $client, true ), $registry ) extends AbstractAgenticHandler {
+			public function __construct( FakeAIClientFactory $clientFactory, FakeToolRegistry $toolRegistry ) {
+				parent::__construct( Intent::ORDER_STATUS, $clientFactory, $toolRegistry );
+			}
+
+			protected function registerToolExecutors( \AgentWP\Contracts\ToolDispatcherInterface $dispatcher ): void {
+				$dispatcher->register( 'test_tool', fn( array $args ) => array( 'ok' => true ) );
+			}
+
+			protected function getSystemPrompt(): string {
+				return 'Test.';
+			}
+
+			protected function getToolNames(): array {
+				return array( 'test_tool' );
+			}
+		};
+
+		$classifier = new class() implements IntentClassifierInterface {
+			public function classify( string $input, array $context = array() ): string {
+				unset( $input, $context );
+				return Intent::ORDER_STATUS;
+			}
+		};
+
+		$builder = new class() extends ContextBuilder {
+			public function build( array $context = array(), array $metadata = array() ): array {
+				return $context;
+			}
+		};
+
+		$memory = new FakeMemoryStore();
+		$handler_registry = new HandlerRegistry();
+		$handler_registry->register( Intent::ORDER_STATUS, $handler );
+
+		$engine = new Engine(
+			array(),
+			new FunctionRegistry(),
+			$builder,
+			$classifier,
+			$memory,
+			$handler_registry,
+			new FallbackHandler()
+		);
+
+		$response = $engine->handle( 'status check' );
+		$this->assertTrue( $response->is_success() );
+		$this->assertSame( 'Done', $response->get_data()['message'] );
+
+		$this->assertCount( 2, $client->calls );
+		$second_call_messages = $client->calls[1]['messages'];
+		$tool_message         = $second_call_messages[ count( $second_call_messages ) - 1 ];
+
+		$this->assertSame( 'tool', $tool_message['role'] );
+		$decoded = json_decode( $tool_message['content'], true );
+
+		$this->assertIsArray( $decoded );
+		$this->assertFalse( $decoded['success'] );
+		$this->assertSame( 'unknown_tool', $decoded['code'] );
+		$this->assertStringContainsString( 'Unknown tool', $decoded['error'] );
+	}
 }
diff --git a/tests/Unit/Intent/ToolDispatcherTest.php b/tests/Unit/Intent/ToolDispatcherTest.php
index 737128019af6d5ca62e93a62fedc3df3604051e7..f0a758d6e3f763a7cfe0a8055ecaaeccfc7e4244
--- a/tests/Unit/Intent/ToolDispatcherTest.php
+++ b/tests/Unit/Intent/ToolDispatcherTest.php
@@ -7,9 +7,10 @@
 
 use AgentWP\AI\Functions\FunctionSchema;
 use AgentWP\Intent\ToolDispatcher;
+use AgentWP\Tests\Fakes\FakeAuditLogger;
+use AgentWP\Tests\Fakes\FakeLogger;
 use AgentWP\Tests\Fakes\FakeToolRegistry;
 use AgentWP\Tests\TestCase;
-use AgentWP\Validation\ToolArgumentValidator;
 
 class ToolDispatcherTest extends TestCase {
 
@@ -64,6 +65,10 @@
 		$result = $this->dispatcher->dispatch( 'unknown_tool', array() );
 
 		$this->assertArrayHasKey( 'error', $result );
+		$this->assertArrayHasKey( 'success', $result );
+		$this->assertArrayHasKey( 'code', $result );
+		$this->assertFalse( $result['success'] );
+		$this->assertSame( 'unknown_tool', $result['code'] );
 		$this->assertStringContainsString( 'Unknown tool', $result['error'] );
 	}
 
@@ -121,6 +126,86 @@
 		$this->assertSame( 'invalid_tool_arguments', $result['code'] );
 	}
 
+	public function test_dispatch_logs_unknown_tool_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$dispatcher->dispatch( 'missing_tool', array( 'secret' => 'value' ) );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'Tool dispatch failed.', $log['message'] );
+		$this->assertSame( 'missing_tool', $log['context']['tool'] );
+		$this->assertSame( 'unknown_tool', $log['context']['reason'] );
+		$this->assertArrayHasKey( 'argument_count', $log['context'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'unknown_tool', $audit['context']['reason'] );
+	}
+
+	public function test_dispatch_logs_validation_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$schema = new class() implements FunctionSchema {
+			public function get_name(): string {
+				return 'strict_tool';
+			}
+
+			public function get_description(): string {
+				return 'A tool with strict validation';
+			}
+
+			public function get_parameters(): array {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'name' => array(
+							'type'        => 'string',
+							'description' => 'The name',
+						),
+					),
+					'required'   => array( 'name' ),
+				);
+			}
+
+			public function to_tool_definition(): array {
+				return array(
+					'type'     => 'function',
+					'function' => array(
+						'name'        => $this->get_name(),
+						'description' => $this->get_description(),
+						'parameters'  => $this->get_parameters(),
+					),
+				);
+			}
+		};
+
+		$this->toolRegistry->register( $schema );
+		$dispatcher->register( 'strict_tool', fn( array $args ) => array( 'ok' => true ) );
+
+		$dispatcher->dispatch( 'strict_tool', array() );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'invalid_tool_arguments', $log['context']['reason'] );
+		$this->assertSame( 'strict_tool', $log['context']['tool'] );
+		$this->assertNotEmpty( $log['context']['validation_fields'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'invalid_tool_arguments', $audit['context']['reason'] );
+	}
+
 	public function test_dispatch_skips_validation_when_no_schema(): void {
 		// Register tool without schema in registry.
 		$this->dispatcher->register(


thinking
**Verifying autoload settings**

I'm checking composer.json to confirm whether the new test file uses PSR-4 autoloading and if it's properly included in the autoload-dev section for the test suite.
exec
/bin/zsh -lc 'cat composer.json' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
{
  "name": "agentwp/agentwp",
  "description": "AgentWP WordPress plugin.",
  "type": "wordpress-plugin",
  "license": "GPL-2.0-or-later",
  "autoload": {
    "psr-4": {
      "AgentWP\\": "src/"
    }
  },
  "require": {
    "php": ">=8.0",
    "yethee/tiktoken": "^0.1.2"
  },
  "require-dev": {
    "10up/wp_mock": "^1.0",
    "automattic/vipwpcs": "^3.0",
    "dealerdirect/phpcodesniffer-composer-installer": "^1.0",
    "mockery/mockery": "^1.6",
    "phpstan/phpstan": "^1.10",
file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeAuditLogger.php b/tests/Fakes/FakeAuditLogger.php
new file mode 100644
index 0000000000000000000000000000000000000000..e64af09dbfee4807d086ea29730b81f584c8dac0
--- /dev/null
+++ b/tests/Fakes/FakeAuditLogger.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Fake audit logger for testing.
+ *
+ * @package AgentWP\Tests\Fakes
+ */
+
+namespace AgentWP\Tests\Fakes;
+
+use AgentWP\Contracts\AuditLoggerInterface;
+
+/**
+ * Audit logger that captures events for assertions.
+ */
+final class FakeAuditLogger implements AuditLoggerInterface {
+
+	/**
+	 * Captured audit events.
+	 *
+	 * @var array<int, array<string, mixed>>
+	 */
+	private array $logs = array();
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
+		$this->logs[] = array(
+			'type'      => 'api_key',
+			'action'    => $action,
+			'user_id'   => $user_id,
+			'key_last4' => $key_last4,
+			'context'   => $extra,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
+		$this->logs[] = array(
+			'type'       => 'draft_confirm',
+			'draft_type' => $draft_type,
+			'draft_id'   => $draft_id,
+			'user_id'    => $user_id,
+			'context'    => $details,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
+		$this->logs[] = array(
+			'type'    => 'sensitive',
+			'action'  => $action,
+			'user_id' => $user_id,
+			'context' => $context,
+		);
+	}
+
+	/**
+	 * Get all audit events.
+	 *
+	 * @return array<int, array<string, mixed>>
+	 */
+	public function getLogs(): array {
+		return $this->logs;
+	}
+
+	/**
+	 * Get last audit event.
+	 *
+	 * @return array<string, mixed>|null
+	 */
+	public function getLastLog(): ?array {
+		if ( empty( $this->logs ) ) {
+			return null;
+		}
+
+		return $this->logs[ count( $this->logs ) - 1 ];
+	}
+}
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );
diff --git a/tests/Integration/Intent/ToolExecutionPathTest.php b/tests/Integration/Intent/ToolExecutionPathTest.php
index 0eddd12986f92ca5638d0b44ffc4ca7548503ac8..9c7464d003b2c9b5f0f80e37cff6a675c1f996b3
--- a/tests/Integration/Intent/ToolExecutionPathTest.php
+++ b/tests/Integration/Intent/ToolExecutionPathTest.php
@@ -320,4 +320,149 @@
 		$this->assertSame( 'invalid_tool_arguments', $decoded['code'] );
 		$this->assertNotEmpty( $decoded['validation_errors'] );
 	}
+
+	public function test_engine_agentic_handler_returns_unknown_tool_error_for_unregistered_tool(): void {
+		$tool_name = 'test_tool';
+
+		$schema = new class( $tool_name ) extends AbstractFunction {
+			private string $name;
+
+			public function __construct( string $name ) {
+				$this->name = $name;
+			}
+
+			public function get_name() {
+				return $this->name;
+			}
+
+			public function get_description() {
+				return 'Test tool for unknown tool handling.';
+			}
+
+			public function get_parameters() {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'order_id' => array(
+							'type' => 'integer',
+						),
+					),
+				);
+			}
+		};
+
+		$registry = new FakeToolRegistry();
+		$registry->register( $schema );
+
+		$client = new class() implements OpenAIClientInterface {
+			/** @var Response[] */
+			public array $responses;
+			public array $calls = array();
+
+			public function __construct() {
+				$this->responses = array(
+					Response::success(
+						array(
+							'content'    => '',
+							'tool_calls' => array(
+								array(
+									'id'       => 'call_1',
+									'type'     => 'function',
+									'function' => array(
+										'name'      => 'unknown_tool',
+										'arguments' => '{}',
+									),
+								),
+							),
+						)
+					),
+					Response::success(
+						array(
+							'content'    => 'Done',
+							'tool_calls' => array(),
+						)
+					),
+				);
+			}
+
+			public function chat( array $messages, array $functions ): Response {
+				$this->calls[] = array(
+					'messages'  => $messages,
+					'functions' => $functions,
+				);
+
+				if ( empty( $this->responses ) ) {
+					return Response::error( 'No fake responses queued.', 500 );
+				}
+
+				return array_shift( $this->responses );
+			}
+
+			public function validateKey( string $key ): bool {
+				unset( $key );
+				return true;
+			}
+		};
+
+		$handler = new class( new FakeAIClientFactory( $client, true ), $registry ) extends AbstractAgenticHandler {
+			public function __construct( FakeAIClientFactory $clientFactory, FakeToolRegistry $toolRegistry ) {
+				parent::__construct( Intent::ORDER_STATUS, $clientFactory, $toolRegistry );
+			}
+
+			protected function registerToolExecutors( \AgentWP\Contracts\ToolDispatcherInterface $dispatcher ): void {
+				$dispatcher->register( 'test_tool', fn( array $args ) => array( 'ok' => true ) );
+			}
+
+			protected function getSystemPrompt(): string {
+				return 'Test.';
+			}
+
+			protected function getToolNames(): array {
+				return array( 'test_tool' );
+			}
+		};
+
+		$classifier = new class() implements IntentClassifierInterface {
+			public function classify( string $input, array $context = array() ): string {
+				unset( $input, $context );
+				return Intent::ORDER_STATUS;
+			}
+		};
+
+		$builder = new class() extends ContextBuilder {
+			public function build( array $context = array(), array $metadata = array() ): array {
+				return $context;
+			}
+		};
+
+		$memory = new FakeMemoryStore();
+		$handler_registry = new HandlerRegistry();
+		$handler_registry->register( Intent::ORDER_STATUS, $handler );
+
+		$engine = new Engine(
+			array(),
+			new FunctionRegistry(),
+			$builder,
+			$classifier,
+			$memory,
+			$handler_registry,
+			new FallbackHandler()
+		);
+
+		$response = $engine->handle( 'status check' );
+		$this->assertTrue( $response->is_success() );
+		$this->assertSame( 'Done', $response->get_data()['message'] );
+
+		$this->assertCount( 2, $client->calls );
+		$second_call_messages = $client->calls[1]['messages'];
+		$tool_message         = $second_call_messages[ count( $second_call_messages ) - 1 ];
+
+		$this->assertSame( 'tool', $tool_message['role'] );
+		$decoded = json_decode( $tool_message['content'], true );
+
+		$this->assertIsArray( $decoded );
+		$this->assertFalse( $decoded['success'] );
+		$this->assertSame( 'unknown_tool', $decoded['code'] );
+		$this->assertStringContainsString( 'Unknown tool', $decoded['error'] );
+	}
 }
diff --git a/tests/Unit/Intent/ToolDispatcherTest.php b/tests/Unit/Intent/ToolDispatcherTest.php
index 737128019af6d5ca62e93a62fedc3df3604051e7..f0a758d6e3f763a7cfe0a8055ecaaeccfc7e4244
--- a/tests/Unit/Intent/ToolDispatcherTest.php
+++ b/tests/Unit/Intent/ToolDispatcherTest.php
@@ -7,9 +7,10 @@
 
 use AgentWP\AI\Functions\FunctionSchema;
 use AgentWP\Intent\ToolDispatcher;
+use AgentWP\Tests\Fakes\FakeAuditLogger;
+use AgentWP\Tests\Fakes\FakeLogger;
 use AgentWP\Tests\Fakes\FakeToolRegistry;
 use AgentWP\Tests\TestCase;
-use AgentWP\Validation\ToolArgumentValidator;
 
 class ToolDispatcherTest extends TestCase {
 
@@ -64,6 +65,10 @@
 		$result = $this->dispatcher->dispatch( 'unknown_tool', array() );
 
 		$this->assertArrayHasKey( 'error', $result );
+		$this->assertArrayHasKey( 'success', $result );
+		$this->assertArrayHasKey( 'code', $result );
+		$this->assertFalse( $result['success'] );
+		$this->assertSame( 'unknown_tool', $result['code'] );
 		$this->assertStringContainsString( 'Unknown tool', $result['error'] );
 	}
 
@@ -121,6 +126,86 @@
 		$this->assertSame( 'invalid_tool_arguments', $result['code'] );
 	}
 
+	public function test_dispatch_logs_unknown_tool_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$dispatcher->dispatch( 'missing_tool', array( 'secret' => 'value' ) );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'Tool dispatch failed.', $log['message'] );
+		$this->assertSame( 'missing_tool', $log['context']['tool'] );
+		$this->assertSame( 'unknown_tool', $log['context']['reason'] );
+		$this->assertArrayHasKey( 'argument_count', $log['context'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'unknown_tool', $audit['context']['reason'] );
+	}
+
+	public function test_dispatch_logs_validation_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$schema = new class() implements FunctionSchema {
+			public function get_name(): string {
+				return 'strict_tool';
+			}
+
+			public function get_description(): string {
+				return 'A tool with strict validation';
+			}
+
+			public function get_parameters(): array {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'name' => array(
+							'type'        => 'string',
+							'description' => 'The name',
+						),
+					),
+					'required'   => array( 'name' ),
+				);
+			}
+
+			public function to_tool_definition(): array {
+				return array(
+					'type'     => 'function',
+					'function' => array(
+						'name'        => $this->get_name(),
+						'description' => $this->get_description(),
+						'parameters'  => $this->get_parameters(),
+					),
+				);
+			}
+		};
+
+		$this->toolRegistry->register( $schema );
+		$dispatcher->register( 'strict_tool', fn( array $args ) => array( 'ok' => true ) );
+
+		$dispatcher->dispatch( 'strict_tool', array() );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'invalid_tool_arguments', $log['context']['reason'] );
+		$this->assertSame( 'strict_tool', $log['context']['tool'] );
+		$this->assertNotEmpty( $log['context']['validation_fields'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'invalid_tool_arguments', $audit['context']['reason'] );
+	}
+
 	public function test_dispatch_skips_validation_when_no_schema(): void {
 		// Register tool without schema in registry.
 		$this->dispatcher->register(



thinking
**Verifying logging safety in dispatcher**

I've confirmed `ToolDispatcher` logs only safe data like argument counts, field names, codes, and tool names without leaking secrets. The audit logger uses a sanitizer via its underlying logger, ensuring sensitive context is protected.
thinking
**Standardizing error shape and logging**

ToolDispatcher now returns consistent error responses with success=false and code for unknown tool and validation errors, logging these safely using both logger and audit logger. Tests and fakes were updated accordingly, and dispatcher dependencies wired in the provider.
codex
Status: DONE
Summary of changes:
- Standardized unknown-tool failure responses and added safe logging/audit logging in `src/Intent/ToolDispatcher.php`.
- Wired logger/audit logger into the dispatcher registration in `src/Providers/IntentServiceProvider.php`.
- Added `tests/Fakes/FakeAuditLogger.php`, expanded unit coverage in `tests/Unit/Intent/ToolDispatcherTest.php`, added unknown-tool integration coverage in `tests/Integration/Intent/ToolExecutionPathTest.php`, and aligned `tests/Fakes/FakeToolDispatcher.php` error shape.

How to verify (exact commands):
- No verification commands provided.

Risks / follow-ups:
- Tests not run (no commands provided).
file update:
diff --git a/src/Intent/ToolDispatcher.php b/src/Intent/ToolDispatcher.php
index 02215352bdd464f365222abe26509941af82c513..d26e5f0e860e927736abb45cff5209757adf34ea
--- a/src/Intent/ToolDispatcher.php
+++ b/src/Intent/ToolDispatcher.php
@@ -10,9 +10,12 @@
 
 namespace AgentWP\Intent;
 
+use AgentWP\Contracts\AuditLoggerInterface;
 use AgentWP\Contracts\ExecutableToolInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
+use AgentWP\Infrastructure\NullLogger;
 use AgentWP\Validation\ToolArgumentValidator;
 
 /**
@@ -47,17 +50,37 @@
 	private ToolArgumentValidator $validator;
 
 	/**
+	 * Logger for tool dispatch failures.
+	 *
+	 * @var LoggerInterface
+	 */
+	private LoggerInterface $logger;
+
+	/**
+	 * Audit logger for sensitive tool dispatch failures.
+	 *
+	 * @var AuditLoggerInterface|null
+	 */
+	private ?AuditLoggerInterface $auditLogger;
+
+	/**
 	 * Initialize the dispatcher.
 	 *
-	 * @param ToolRegistryInterface      $toolRegistry Tool registry for schema lookup.
-	 * @param ToolArgumentValidator|null $validator    Argument validator (optional).
+	 * @param ToolRegistryInterface       $toolRegistry Tool registry for schema lookup.
+	 * @param ToolArgumentValidator|null  $validator    Argument validator (optional).
+	 * @param LoggerInterface|null        $logger       Logger for tool dispatch failures (optional).
+	 * @param AuditLoggerInterface|null   $auditLogger  Audit logger for tool dispatch failures (optional).
 	 */
 	public function __construct(
 		ToolRegistryInterface $toolRegistry,
-		?ToolArgumentValidator $validator = null
+		?ToolArgumentValidator $validator = null,
+		?LoggerInterface $logger = null,
+		?AuditLoggerInterface $auditLogger = null
 	) {
 		$this->toolRegistry = $toolRegistry;
 		$this->validator    = $validator ?? new ToolArgumentValidator();
+		$this->logger       = $logger ?? new NullLogger();
+		$this->auditLogger  = $auditLogger;
 	}
 
 	/**
@@ -132,12 +155,26 @@
 	public function dispatch( string $name, array $arguments ): array {
 		// Check if executor is registered.
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			$this->logDispatchFailure(
+				'unknown_tool',
+				$name,
+				array(
+					'argument_count' => count( $arguments ),
+				)
+			);
+
+			return $this->unknownToolError( $name );
 		}
 
 		// Validate arguments against schema if available.
 		$validation_error = $this->validateArguments( $name, $arguments );
 		if ( null !== $validation_error ) {
+			$this->logDispatchFailure(
+				'invalid_tool_arguments',
+				$name,
+				$this->extractValidationContext( $validation_error )
+			);
+
 			return $validation_error;
 		}
 
@@ -231,4 +268,89 @@
 
 		return array( 'result' => $value );
 	}
+
+	/**
+	 * Build a consistent error response for unknown tools.
+	 *
+	 * @param string $name Tool name.
+	 * @return array{success: false, error: string, code: string}
+	 */
+	private function unknownToolError( string $name ): array {
+		return array(
+			'success' => false,
+			'error'   => sprintf( 'Unknown tool "%s".', $name ),
+			'code'    => 'unknown_tool',
+		);
+	}
+
+	/**
+	 * Log tool dispatch failures without leaking sensitive data.
+	 *
+	 * @param string $reason  Failure reason.
+	 * @param string $tool    Tool name.
+	 * @param array  $context Additional safe context.
+	 * @return void
+	 */
+	private function logDispatchFailure( string $reason, string $tool, array $context = array() ): void {
+		$payload = array_merge(
+			array(
+				'tool'   => $tool,
+				'reason' => $reason,
+			),
+			$context
+		);
+
+		$this->logger->warning( 'Tool dispatch failed.', $payload );
+
+		if ( null !== $this->auditLogger ) {
+			$this->auditLogger->logSensitiveAction(
+				'tool_dispatch_failure',
+				$this->getCurrentUserId(),
+				$payload
+			);
+		}
+	}
+
+	/**
+	 * Extract safe validation context for logging.
+	 *
+	 * @param array $validation_error Validation error array.
+	 * @return array<string, mixed>
+	 */
+	private function extractValidationContext( array $validation_error ): array {
+		$errors = isset( $validation_error['validation_errors'] ) && is_array( $validation_error['validation_errors'] )
+			? $validation_error['validation_errors']
+			: array();
+
+		$fields = array();
+		$codes  = array();
+
+		foreach ( $errors as $error ) {
+			if ( isset( $error['field'] ) && '' !== $error['field'] ) {
+				$fields[] = $error['field'];
+			}
+			if ( isset( $error['code'] ) && '' !== $error['code'] ) {
+				$codes[] = $error['code'];
+			}
+		}
+
+		return array(
+			'validation_count'  => count( $errors ),
+			'validation_fields' => array_values( array_unique( $fields ) ),
+			'validation_codes'  => array_values( array_unique( $codes ) ),
+		);
+	}
+
+	/**
+	 * Get the current user ID in a safe way.
+	 *
+	 * @return int
+	 */
+	private function getCurrentUserId(): int {
+		if ( function_exists( 'get_current_user_id' ) ) {
+			return (int) get_current_user_id();
+		}
+
+		return 0;
+	}
 }
diff --git a/src/Providers/IntentServiceProvider.php b/src/Providers/IntentServiceProvider.php
index 01dbcc413348bc72b3ba5a9f3a2054286536ad00..aa4fbecc3180cb1396c58661b9d5647f504867dd
--- a/src/Providers/IntentServiceProvider.php
+++ b/src/Providers/IntentServiceProvider.php
@@ -32,6 +32,8 @@
 use AgentWP\Contracts\OrderSearchServiceInterface;
 use AgentWP\Contracts\OrderStatusServiceInterface;
 use AgentWP\Contracts\ProductStockServiceInterface;
+use AgentWP\Contracts\AuditLoggerInterface;
+use AgentWP\Contracts\LoggerInterface;
 use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\ToolDispatcher;
@@ -277,7 +279,10 @@
 			ToolDispatcherInterface::class,
 			function ( $c ) {
 				$dispatcher = new ToolDispatcher(
-					$c->get( ToolRegistryInterface::class )
+					$c->get( ToolRegistryInterface::class ),
+					null,
+					$c->has( LoggerInterface::class ) ? $c->get( LoggerInterface::class ) : null,
+					$c->has( AuditLoggerInterface::class ) ? $c->get( AuditLoggerInterface::class ) : null
 				);
 
 				// Register order-related executable tools.
diff --git a/tests/Fakes/FakeAuditLogger.php b/tests/Fakes/FakeAuditLogger.php
new file mode 100644
index 0000000000000000000000000000000000000000..e64af09dbfee4807d086ea29730b81f584c8dac0
--- /dev/null
+++ b/tests/Fakes/FakeAuditLogger.php
@@ -0,0 +1,83 @@
+<?php
+/**
+ * Fake audit logger for testing.
+ *
+ * @package AgentWP\Tests\Fakes
+ */
+
+namespace AgentWP\Tests\Fakes;
+
+use AgentWP\Contracts\AuditLoggerInterface;
+
+/**
+ * Audit logger that captures events for assertions.
+ */
+final class FakeAuditLogger implements AuditLoggerInterface {
+
+	/**
+	 * Captured audit events.
+	 *
+	 * @var array<int, array<string, mixed>>
+	 */
+	private array $logs = array();
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logApiKeyUpdate( string $action, int $user_id, string $key_last4 = '', array $extra = array() ): void {
+		$this->logs[] = array(
+			'type'      => 'api_key',
+			'action'    => $action,
+			'user_id'   => $user_id,
+			'key_last4' => $key_last4,
+			'context'   => $extra,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logDraftConfirmation( string $draft_type, string $draft_id, int $user_id, array $details = array() ): void {
+		$this->logs[] = array(
+			'type'       => 'draft_confirm',
+			'draft_type' => $draft_type,
+			'draft_id'   => $draft_id,
+			'user_id'    => $user_id,
+			'context'    => $details,
+		);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public function logSensitiveAction( string $action, int $user_id, array $context = array() ): void {
+		$this->logs[] = array(
+			'type'    => 'sensitive',
+			'action'  => $action,
+			'user_id' => $user_id,
+			'context' => $context,
+		);
+	}
+
+	/**
+	 * Get all audit events.
+	 *
+	 * @return array<int, array<string, mixed>>
+	 */
+	public function getLogs(): array {
+		return $this->logs;
+	}
+
+	/**
+	 * Get last audit event.
+	 *
+	 * @return array<string, mixed>|null
+	 */
+	public function getLastLog(): ?array {
+		if ( empty( $this->logs ) ) {
+			return null;
+		}
+
+		return $this->logs[ count( $this->logs ) - 1 ];
+	}
+}
diff --git a/tests/Fakes/FakeToolDispatcher.php b/tests/Fakes/FakeToolDispatcher.php
index ca3504d3a69cd6aaa33135c5ebaad14933ef4c6d..1109ef2505b91bb701a9dc034b6d2ad25a025ed6
--- a/tests/Fakes/FakeToolDispatcher.php
+++ b/tests/Fakes/FakeToolDispatcher.php
@@ -97,7 +97,11 @@
 		);
 
 		if ( ! $this->has( $name ) ) {
-			return array( 'error' => "Unknown tool: {$name}" );
+			return array(
+				'success' => false,
+				'error'   => sprintf( 'Unknown tool "%s".', $name ),
+				'code'    => 'unknown_tool',
+			);
 		}
 
 		$result = $this->executors[ $name ]( $arguments );
diff --git a/tests/Integration/Intent/ToolExecutionPathTest.php b/tests/Integration/Intent/ToolExecutionPathTest.php
index 0eddd12986f92ca5638d0b44ffc4ca7548503ac8..9c7464d003b2c9b5f0f80e37cff6a675c1f996b3
--- a/tests/Integration/Intent/ToolExecutionPathTest.php
+++ b/tests/Integration/Intent/ToolExecutionPathTest.php
@@ -320,4 +320,149 @@
 		$this->assertSame( 'invalid_tool_arguments', $decoded['code'] );
 		$this->assertNotEmpty( $decoded['validation_errors'] );
 	}
+
+	public function test_engine_agentic_handler_returns_unknown_tool_error_for_unregistered_tool(): void {
+		$tool_name = 'test_tool';
+
+		$schema = new class( $tool_name ) extends AbstractFunction {
+			private string $name;
+
+			public function __construct( string $name ) {
+				$this->name = $name;
+			}
+
+			public function get_name() {
+				return $this->name;
+			}
+
+			public function get_description() {
+				return 'Test tool for unknown tool handling.';
+			}
+
+			public function get_parameters() {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'order_id' => array(
+							'type' => 'integer',
+						),
+					),
+				);
+			}
+		};
+
+		$registry = new FakeToolRegistry();
+		$registry->register( $schema );
+
+		$client = new class() implements OpenAIClientInterface {
+			/** @var Response[] */
+			public array $responses;
+			public array $calls = array();
+
+			public function __construct() {
+				$this->responses = array(
+					Response::success(
+						array(
+							'content'    => '',
+							'tool_calls' => array(
+								array(
+									'id'       => 'call_1',
+									'type'     => 'function',
+									'function' => array(
+										'name'      => 'unknown_tool',
+										'arguments' => '{}',
+									),
+								),
+							),
+						)
+					),
+					Response::success(
+						array(
+							'content'    => 'Done',
+							'tool_calls' => array(),
+						)
+					),
+				);
+			}
+
+			public function chat( array $messages, array $functions ): Response {
+				$this->calls[] = array(
+					'messages'  => $messages,
+					'functions' => $functions,
+				);
+
+				if ( empty( $this->responses ) ) {
+					return Response::error( 'No fake responses queued.', 500 );
+				}
+
+				return array_shift( $this->responses );
+			}
+
+			public function validateKey( string $key ): bool {
+				unset( $key );
+				return true;
+			}
+		};
+
+		$handler = new class( new FakeAIClientFactory( $client, true ), $registry ) extends AbstractAgenticHandler {
+			public function __construct( FakeAIClientFactory $clientFactory, FakeToolRegistry $toolRegistry ) {
+				parent::__construct( Intent::ORDER_STATUS, $clientFactory, $toolRegistry );
+			}
+
+			protected function registerToolExecutors( \AgentWP\Contracts\ToolDispatcherInterface $dispatcher ): void {
+				$dispatcher->register( 'test_tool', fn( array $args ) => array( 'ok' => true ) );
+			}
+
+			protected function getSystemPrompt(): string {
+				return 'Test.';
+			}
+
+			protected function getToolNames(): array {
+				return array( 'test_tool' );
+			}
+		};
+
+		$classifier = new class() implements IntentClassifierInterface {
+			public function classify( string $input, array $context = array() ): string {
+				unset( $input, $context );
+				return Intent::ORDER_STATUS;
+			}
+		};
+
+		$builder = new class() extends ContextBuilder {
+			public function build( array $context = array(), array $metadata = array() ): array {
+				return $context;
+			}
+		};
+
+		$memory = new FakeMemoryStore();
+		$handler_registry = new HandlerRegistry();
+		$handler_registry->register( Intent::ORDER_STATUS, $handler );
+
+		$engine = new Engine(
+			array(),
+			new FunctionRegistry(),
+			$builder,
+			$classifier,
+			$memory,
+			$handler_registry,
+			new FallbackHandler()
+		);
+
+		$response = $engine->handle( 'status check' );
+		$this->assertTrue( $response->is_success() );
+		$this->assertSame( 'Done', $response->get_data()['message'] );
+
+		$this->assertCount( 2, $client->calls );
+		$second_call_messages = $client->calls[1]['messages'];
+		$tool_message         = $second_call_messages[ count( $second_call_messages ) - 1 ];
+
+		$this->assertSame( 'tool', $tool_message['role'] );
+		$decoded = json_decode( $tool_message['content'], true );
+
+		$this->assertIsArray( $decoded );
+		$this->assertFalse( $decoded['success'] );
+		$this->assertSame( 'unknown_tool', $decoded['code'] );
+		$this->assertStringContainsString( 'Unknown tool', $decoded['error'] );
+	}
 }
diff --git a/tests/Unit/Intent/ToolDispatcherTest.php b/tests/Unit/Intent/ToolDispatcherTest.php
index 737128019af6d5ca62e93a62fedc3df3604051e7..f0a758d6e3f763a7cfe0a8055ecaaeccfc7e4244
--- a/tests/Unit/Intent/ToolDispatcherTest.php
+++ b/tests/Unit/Intent/ToolDispatcherTest.php
@@ -7,9 +7,10 @@
 
 use AgentWP\AI\Functions\FunctionSchema;
 use AgentWP\Intent\ToolDispatcher;
+use AgentWP\Tests\Fakes\FakeAuditLogger;
+use AgentWP\Tests\Fakes\FakeLogger;
 use AgentWP\Tests\Fakes\FakeToolRegistry;
 use AgentWP\Tests\TestCase;
-use AgentWP\Validation\ToolArgumentValidator;
 
 class ToolDispatcherTest extends TestCase {
 
@@ -64,6 +65,10 @@
 		$result = $this->dispatcher->dispatch( 'unknown_tool', array() );
 
 		$this->assertArrayHasKey( 'error', $result );
+		$this->assertArrayHasKey( 'success', $result );
+		$this->assertArrayHasKey( 'code', $result );
+		$this->assertFalse( $result['success'] );
+		$this->assertSame( 'unknown_tool', $result['code'] );
 		$this->assertStringContainsString( 'Unknown tool', $result['error'] );
 	}
 
@@ -121,6 +126,86 @@
 		$this->assertSame( 'invalid_tool_arguments', $result['code'] );
 	}
 
+	public function test_dispatch_logs_unknown_tool_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$dispatcher->dispatch( 'missing_tool', array( 'secret' => 'value' ) );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'Tool dispatch failed.', $log['message'] );
+		$this->assertSame( 'missing_tool', $log['context']['tool'] );
+		$this->assertSame( 'unknown_tool', $log['context']['reason'] );
+		$this->assertArrayHasKey( 'argument_count', $log['context'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'unknown_tool', $audit['context']['reason'] );
+	}
+
+	public function test_dispatch_logs_validation_failure(): void {
+		$logger      = new FakeLogger();
+		$auditLogger = new FakeAuditLogger();
+		$dispatcher  = new ToolDispatcher( $this->toolRegistry, null, $logger, $auditLogger );
+
+		$schema = new class() implements FunctionSchema {
+			public function get_name(): string {
+				return 'strict_tool';
+			}
+
+			public function get_description(): string {
+				return 'A tool with strict validation';
+			}
+
+			public function get_parameters(): array {
+				return array(
+					'type'       => 'object',
+					'properties' => array(
+						'name' => array(
+							'type'        => 'string',
+							'description' => 'The name',
+						),
+					),
+					'required'   => array( 'name' ),
+				);
+			}
+
+			public function to_tool_definition(): array {
+				return array(
+					'type'     => 'function',
+					'function' => array(
+						'name'        => $this->get_name(),
+						'description' => $this->get_description(),
+						'parameters'  => $this->get_parameters(),
+					),
+				);
+			}
+		};
+
+		$this->toolRegistry->register( $schema );
+		$dispatcher->register( 'strict_tool', fn( array $args ) => array( 'ok' => true ) );
+
+		$dispatcher->dispatch( 'strict_tool', array() );
+
+		$log = $logger->getLastLog();
+		$this->assertNotNull( $log );
+		$this->assertSame( 'warning', $log['level'] );
+		$this->assertSame( 'invalid_tool_arguments', $log['context']['reason'] );
+		$this->assertSame( 'strict_tool', $log['context']['tool'] );
+		$this->assertNotEmpty( $log['context']['validation_fields'] );
+
+		$audit = $auditLogger->getLastLog();
+		$this->assertNotNull( $audit );
+		$this->assertSame( 'sensitive', $audit['type'] );
+		$this->assertSame( 'tool_dispatch_failure', $audit['action'] );
+		$this->assertSame( 'invalid_tool_arguments', $audit['context']['reason'] );
+	}
+
 	public function test_dispatch_skips_validation_when_no_schema(): void {
 		// Register tool without schema in registry.
 		$this->dispatcher->register(

tokens used
71,507
