Clarified tools vs functions terminology across the architecture, developer, and extension docs to align with ToolRegistry/ToolDispatcher and executable tools.

Status: DONE

Summary of changes:
- `docs/ARCHITECTURE.md` added tools-vs-functions definitions, expanded the diagram, updated key components and tool onboarding steps.
- `docs/DEVELOPER.md` updated handler/tool guidance to use `registerToolExecutors()` and ToolDispatcher, plus clarified legacy function-suggestion hooks.
- `docs/EXTENSIONS.md` added a tools-vs-functions section and clarified that “function” hooks are suggestions only.

How to verify (exact commands):
- No verification commands provided.

Risks / follow-ups:
- None.

OpenAI Codex v0.87.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/agentwp
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019bd1e0-3e52-7ea2-957c-2dadc0a3acfe
--------
user
You are implementing task C03-01 in this git repository.

1) Read the spec: .plans/C03-01.md
2) Read handoff/context: .t2/handoff/C03-01.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: 
- test: 

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers

thinking
**Preparing to read files using shell command**
exec
/bin/zsh -lc ls in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 60ms:
agentwp.php
assets
composer.json
composer.lock
docker
docker-compose.demo.yml
docker-compose.yml
docs
includes
languages
node_modules
package-lock.json
package.json
phpcs.xml
phpstan
phpstan.neon
phpunit.xml.dist
plan_tasks.csv
playwright.config.cjs
react
exec
/bin/zsh -lc 'cat .plans/C03-01.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 69ms:
# C03-01 — Document tools vs functions terminology

Update docs (`docs/DEVELOPER.md`, `docs/EXTENSIONS.md`, `docs/ARCHITECTURE.md`) to clearly define: tool schemas (`src/AI/Functions/*`), tool executors (`src/Intent/Tools/*`), tool dispatch (`ToolDispatcher`), and handler exposure via `getToolNames()`.
exec
/bin/zsh -lc 'cat .t2/handoff/C03-01.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 66ms:
# Handoff: C03-01

Created: 2026-01-18T16:11:32.792479Z

Spec: .plans/C03-01.md

thinking
**Inspecting existing docs for edits**
exec
/bin/zsh -lc 'rg -n "tool|function|ToolDispatcher|getToolNames|tool schema|executor|dispatch" docs/DEVELOPER.md docs/EXTENSIONS.md docs/ARCHITECTURE.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 58ms:
docs/ARCHITECTURE.md:135:   - `ResponseFormatter` normalizes response envelope on `rest_post_dispatch`
docs/ARCHITECTURE.md:158:- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes + handler executors for OpenAI function calling
docs/ARCHITECTURE.md:216:The policy layer (`src/Security/Policy/`) centralizes all capability checks, keeping domain services free of direct WordPress function calls:
docs/ARCHITECTURE.md:233:public function prepare_refund( int $order_id, ... ): ServiceResult {
docs/ARCHITECTURE.md:283:Services do not call WooCommerce functions directly. Instead, gateway interfaces (`src/Contracts/`) abstract all WooCommerce operations:
docs/ARCHITECTURE.md:299:AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
docs/ARCHITECTURE.md:325:    OAI -->|tool_calls| Handlers
docs/ARCHITECTURE.md:332:| `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
docs/ARCHITECTURE.md:343:       public function get_name(): string { return 'my_tool'; }
docs/ARCHITECTURE.md:344:       public function get_parameters(): string { /* JSON schema */ }
docs/ARCHITECTURE.md:353:3. **Declare in handler** via `getToolNames()`:
docs/ARCHITECTURE.md:355:   protected function getToolNames(): array {
docs/ARCHITECTURE.md:356:       return ['my_tool'];
docs/ARCHITECTURE.md:360:4. **Implement execution** in `execute_tool()`:
docs/ARCHITECTURE.md:362:   public function execute_tool(string $name, array $args) {
docs/ARCHITECTURE.md:364:           'my_tool' => $this->service->doSomething($args),
docs/ARCHITECTURE.md:369:See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
docs/ARCHITECTURE.md:830:    public function isExpired( ?int $now = null ): bool;
docs/ARCHITECTURE.md:831:    public function getRemainingSeconds( ?int $now = null ): int;
docs/ARCHITECTURE.md:924:| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + handler executors for tools |

thinking
**Reviewing documentation targets**
exec
/bin/zsh -lc "sed -n '260,420p' docs/ARCHITECTURE.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 41ms:
|------|----------|-------------|
| `success` | `CODE_SUCCESS` | 200 |
| `permission_denied` | `CODE_PERMISSION_DENIED` | 403 |
| `not_found` | `CODE_NOT_FOUND` | 404 |
| `invalid_input` | `CODE_INVALID_INPUT` | 400 |
| `invalid_state` | `CODE_INVALID_STATE` | 409 |
| `draft_expired` | `CODE_DRAFT_EXPIRED` | 410 |
| `operation_failed` | `CODE_OPERATION_FAILED` | 500 |

Controllers map `ServiceResult` to REST responses:

```php
$result = $this->service->prepare_refund( $order_id, $amount );

if ( $result->isFailure() ) {
    return new WP_REST_Response( $result->toArray(), $result->httpStatus );
}

return new WP_REST_Response( array( 'success' => true, 'data' => $result->data ), 200 );
```

thinking
**Reviewing tool terminology in docs**
exec
/bin/zsh -lc "sed -n '560,720p' docs/DEVELOPER.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 71ms:

This action fires during AgentWP's initialization, before providers are booted.

### 3) Add a custom scorer (optional)

To enable intent classification for your custom intent, add a scorer via the `agentwp_intent_scorers` filter:

```php
namespace MyPlugin\AgentWP;

use AgentWP\Intent\Classifier\AbstractScorer;

class ShipmentDelayScorer extends AbstractScorer {

	private const PHRASES = array(
		'shipment delay',
		'shipping delayed',
		'late delivery',
		'package delayed',
	);

thinking
**Checking custom function registration location**
exec
/bin/zsh -lc "sed -n '80,160p' docs/EXTENSIONS.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 64ms:
| **File** | `src/Intent/Engine.php:75` |
| **When** | During engine construction |

**Parameters:**
- `array $handlers` — Current array of handler instances
- `Engine $engine` — The intent engine instance

**Returns:** Array of handler instances

**Example:**
```php
add_filter( 'agentwp_intent_handlers', function( $handlers, $engine ) {
    $handlers[] = new MyCustomHandler();
    return $handlers;
}, 10, 2 );
```

---

### `agentwp_register_intent_functions` (Action)

thinking
**Clarifying function vs tool terminology**

I'm aligning docs to reflect that "AI functions" correspond to tool schemas in src/AI/Functions, distinct from tool executors and dispatchers, and planning updates across key documentation files for consistent terminology.
exec
/bin/zsh -lc 'rg -n "class ToolDispatcher|ToolDispatcher" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 80ms:
src/Providers/IntentServiceProvider.php:35:use AgentWP\Contracts\ToolDispatcherInterface;
src/Providers/IntentServiceProvider.php:37:use AgentWP\Intent\ToolDispatcher;
src/Providers/IntentServiceProvider.php:86:		$this->registerToolDispatcher();
src/Providers/IntentServiceProvider.php:271:	private function registerToolDispatcher(): void {
src/Providers/IntentServiceProvider.php:272:		if ( ! class_exists( ToolDispatcher::class ) ) {
src/Providers/IntentServiceProvider.php:277:			ToolDispatcherInterface::class,
src/Providers/IntentServiceProvider.php:279:				$dispatcher = new ToolDispatcher(
src/Providers/IntentServiceProvider.php:418:				$c->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:439:				$c->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:460:				$c->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:481:				$c->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:502:				$c->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:523:				$c->get( ToolDispatcherInterface::class )
src/Providers/IntentServiceProvider.php:544:				$c->get( ToolDispatcherInterface::class )
src/Contracts/ToolDispatcherInterface.php:5: * The ToolDispatcher resolves tools by name, validates arguments against
src/Contracts/ToolDispatcherInterface.php:22:interface ToolDispatcherInterface {
src/Contracts/ExecutableToolInterface.php:15: * Contract for tools that can be executed by the ToolDispatcher.
src/Intent/ToolDispatcher.php:14:use AgentWP\Contracts\ToolDispatcherInterface;
src/Intent/ToolDispatcher.php:26:class ToolDispatcher implements ToolDispatcherInterface {
src/Intent/Handlers/OrderStatusHandler.php:11:use AgentWP\Contracts\ToolDispatcherInterface;

thinking
**Confirming tool executors location**
exec
/bin/zsh -lc 'ls src/Intent/Tools' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 74ms:
ConfirmRefundTool.php
ConfirmStatusUpdateTool.php
ConfirmStockUpdateTool.php
DraftEmailTool.php
GetCustomerProfileTool.php
GetSalesReportTool.php
PrepareBulkStatusUpdateTool.php
PrepareRefundTool.php
PrepareStatusUpdateTool.php
PrepareStockUpdateTool.php
SearchOrdersTool.php
SearchProductTool.php

thinking
**Reviewing tool executor details**

I'm checking the ToolDispatcher class to understand how tool executors work for accurate documentation.
exec
/bin/zsh -lc "sed -n '1,220p' src/Intent/ToolDispatcher.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 71ms:
<?php
/**
 * Tool dispatcher service implementation.
 *
 * Centralizes tool execution that was previously duplicated across
 * handler `execute_tool()` implementations.
 *
 * @package AgentWP\Intent
 */

namespace AgentWP\Intent;

use AgentWP\Contracts\ExecutableToolInterface;
use AgentWP\Contracts\ToolDispatcherInterface;
use AgentWP\Contracts\ToolRegistryInterface;
use AgentWP\Validation\ToolArgumentValidator;

/**
 * Dispatches tool execution calls to registered executors.
 *

thinking
**Confirming tool executor interface**

Found that tool executors in src/Intent/Tools likely implement ExecutableToolInterface, which clarifies their expected behavior and contract.
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/Tools/SearchOrdersTool.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 67ms:
<?php
/**
 * Executable tool for searching orders.
 *
 * @package AgentWP\Intent\Tools
 */

namespace AgentWP\Intent\Tools;

use AgentWP\Contracts\ExecutableToolInterface;
use AgentWP\Contracts\OrderSearchServiceInterface;

/**
 * Executes order search operations.
 *
 * Calls the OrderSearchService and returns a stable result payload
 * suitable for AI consumption.
 */
class SearchOrdersTool implements ExecutableToolInterface {


thinking
**Reviewing handler and dispatcher linkage**

I see that tool dispatch uses ToolDispatcher and getToolNames is part of handlers. Next, I'll inspect AbstractAgenticHandler docs to clarify their relationship.
exec
/bin/zsh -lc "sed -n '1,220p' src/Intent/Handlers/AbstractAgenticHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 71ms:
<?php
/**
 * Abstract base class for agentic intent handlers.
 *
 * Encapsulates the common agentic loop pattern used by all AI-powered handlers.
 *
 * @package AgentWP\Intent\Handlers
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Config\AgentWPConfig;
use AgentWP\Contracts\AIClientFactoryInterface;
use AgentWP\Contracts\OpenAIClientInterface;
use AgentWP\Contracts\ToolDispatcherInterface;
use AgentWP\Contracts\ToolRegistryInterface;
use AgentWP\Intent\ToolDispatcher;

/**

thinking
**Reviewing tool schema and registry concepts**

I'm exploring how tool schemas and executors are defined in the code, noting that tool executors implement an interface and dispatch is handled via a dispatcher. There's overlap or confusion between ToolRegistry and FunctionRegistry, and documentation should clarify the distinctions and possibly align naming.
exec
/bin/zsh -lc 'rg -n "FunctionRegistry|ToolRegistry|intent_functions" src docs' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 80ms:
src/Providers/IntentServiceProvider.php:36:use AgentWP\Contracts\ToolRegistryInterface;
src/Providers/IntentServiceProvider.php:62:use AgentWP\Intent\FunctionRegistry;
src/Providers/IntentServiceProvider.php:67:use AgentWP\Intent\ToolRegistry;
src/Providers/IntentServiceProvider.php:84:		$this->registerFunctionRegistry();
src/Providers/IntentServiceProvider.php:85:		$this->registerToolRegistry();
src/Providers/IntentServiceProvider.php:218:	private function registerFunctionRegistry(): void {
src/Providers/IntentServiceProvider.php:219:		if ( ! class_exists( FunctionRegistry::class ) ) {
src/Providers/IntentServiceProvider.php:224:			FunctionRegistry::class,
src/Providers/IntentServiceProvider.php:225:			fn() => new FunctionRegistry()
src/Providers/IntentServiceProvider.php:234:	private function registerToolRegistry(): void {
src/Providers/IntentServiceProvider.php:235:		if ( ! class_exists( ToolRegistry::class ) ) {
src/Providers/IntentServiceProvider.php:240:			ToolRegistryInterface::class,
src/Providers/IntentServiceProvider.php:242:				$registry = new ToolRegistry();
src/Providers/IntentServiceProvider.php:280:					$c->get( ToolRegistryInterface::class )
src/Providers/IntentServiceProvider.php:376:					$this->container->get( FunctionRegistry::class ),
src/Providers/IntentServiceProvider.php:417:				$c->get( ToolRegistryInterface::class ),
src/Providers/IntentServiceProvider.php:438:				$c->get( ToolRegistryInterface::class ),
src/Providers/IntentServiceProvider.php:459:				$c->get( ToolRegistryInterface::class ),
src/Providers/IntentServiceProvider.php:480:				$c->get( ToolRegistryInterface::class ),
src/Providers/IntentServiceProvider.php:501:				$c->get( ToolRegistryInterface::class ),

thinking
**Planning docs update for functions vs tools**

I’m clarifying the distinction between legacy function hooks and current tool schemas in the docs, covering key classes in AI/Functions, Intent/Tools, and ToolDispatcher, plus getToolNames usage. I’ll also check FunctionRegistry internals to accurately contrast it with ToolRegistry and reflect that in docs per the spec.
exec
/bin/zsh -lc "sed -n '1,200p' src/Intent/FunctionRegistry.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 72ms:
<?php
/**
 * OpenAI function registry for intent handlers.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

class FunctionRegistry {
	/**
	 * @var array<string, Handler>
	 */
	private $map = array();

	/**
	 * @param string  $function_name OpenAI function name.
	 * @param Handler $handler Handler instance.
	 * @return void
	 */

thinking
**Checking function registry usage**

FunctionRegistry maps function names to handlers and may be used in the Engine to resolve functions for intents; next step is to verify this connection.
exec
/bin/zsh -lc "sed -n '1,260p' src/Intent/Engine.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 71ms:
<?php
/**
 * Intent engine for routing requests.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent;

use AgentWP\AI\Response;
use AgentWP\Contracts\ContextBuilderInterface;
use AgentWP\Contracts\HooksInterface;
use AgentWP\Contracts\IntentClassifierInterface;
use AgentWP\Contracts\MemoryStoreInterface;

class Engine {
	/**
	 * @var IntentClassifierInterface
	 */
	private $classifier;
exec
/bin/zsh -lc "sed -n '260,520p' src/Intent/Engine.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
		}

		foreach ( $mapping as $intent => $functions ) {
			// Only register functions if a handler is explicitly registered for the intent.
			if ( ! $this->handler_registry->has( $intent ) ) {
				continue;
			}

			$handler = $this->handler_registry->get( $intent );
			foreach ( $functions as $function_name ) {
				$this->function_registry->register( $function_name, $handler );
			}
		}
	}
}


thinking
**Clarifying tool vs function terminology**

I've identified that the "function registry" refers to legacy function suggestions distinct from current tool schemas, executors, and dispatch mechanisms, prompting a planned update to documentation to clearly differentiate these concepts and detail how tools are exposed and executed via ToolDispatcher and getToolNames.
thinking
**Verifying tool execution method**

I'm confirming that AbstractAgenticHandler uses ToolDispatcher for executing tools and will search for an explicit execute_tool method to understand its usage or overrides.
exec
/bin/zsh -lc 'rg -n "execute_tool" src/Intent/Handlers' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 74ms:


thinking
**Searching for tool call handling**

I'm looking for where tool calls are handled, focusing on AbstractAgenticHandler and its methods like handle tool calls or dispatch.
exec
/bin/zsh -lc "rg -n \"tool_calls|dispatch\\(\" src/Intent/Handlers/AbstractAgenticHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 75ms:
206:			$tool_calls = $data['tool_calls'] ?? array();
214:			if ( ! empty( $tool_calls ) ) {
215:				$assistant_msg['tool_calls'] = $tool_calls;
221:			if ( empty( $tool_calls ) ) {
226:			$messages = $this->executeToolCalls( $messages, $tool_calls );
241:	 * @param array $tool_calls Tool calls from AI response.
244:	protected function executeToolCalls( array $messages, array $tool_calls ): array {
245:		foreach ( $tool_calls as $call ) {
257:			$result = $this->toolDispatcher->dispatch( $name, $args );
exec
/bin/zsh -lc "sed -n '220,330p' src/Intent/Handlers/AbstractAgenticHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 75ms:
			// If no tool calls, the assistant is done - return the response.
			if ( empty( $tool_calls ) ) {
				return $this->build_response( $context, $content );
			}

			// Execute each tool call via the dispatcher.
			$messages = $this->executeToolCalls( $messages, $tool_calls );
		}

		return Response::error(
			'I got stuck in a loop while processing your request. Please try again.',
			500
		);
	}

	/**
	 * Execute tool calls and add results to messages.
	 *
	 * Delegates to the ToolDispatcher for validation and execution.
	 *


thinking
**Planning docs update for tool execution**

The existing docs use the outdated execute_tool method, so I'll update them to reflect current concepts like tool schemas, executors, dispatch, and registration. I'll add a terminology section in ARCHITECTURE and clarify tool versus function distinctions in DEVELOPER and EXTENSIONS to improve contributor clarity.
thinking
**Reviewing docs for tool terminology update**

I'm verifying EXTENSIONS and DEVELOPER docs to replace outdated execute_tool references and clarify the distinction between tools and functions, ensuring doc consistency without changing code. I'll also search the codebase for any remaining execute_tool usage.
exec
/bin/zsh -lc 'rg -n "execute_tool" src docs' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 62ms:
docs/DEVELOPER.md:434:- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
docs/DEVELOPER.md:485:	public function execute_tool( string $name, array $arguments ) {
docs/DEVELOPER.md:611:- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
src/Contracts/ToolDispatcherInterface.php:17: * duplicated across handler `execute_tool()` implementations. It provides:
src/Contracts/ToolExecutorInterface.php:18:	public function execute_tool( string $name, array $arguments );
src/Intent/ToolDispatcher.php:6: * handler `execute_tool()` implementations.
docs/ARCHITECTURE.md:360:4. **Implement execution** in `execute_tool()`:
docs/ARCHITECTURE.md:362:   public function execute_tool(string $name, array $args) {
docs/adr/0008-tool-execution-architecture.md:53:    public function execute_tool(string $name, array $args) {
docs/adr/0008-tool-execution-architecture.md:111:│  │               executeToolCalls() → execute_tool($name, $args) │  │
docs/adr/0008-tool-execution-architecture.md:116:│  │ ConcreteHandler::execute_tool(string $name, array $args)      │  │
docs/adr/0008-tool-execution-architecture.md:193:public function execute_tool(string $name, array $arguments) {
docs/adr/0008-tool-execution-architecture.md:236:- **Dispatch boilerplate**: Each handler needs a switch/match in `execute_tool()`

thinking
**Checking current usage of executor interfaces**

Planning to search for ToolExecutorInterface to verify if it’s still used and whether the docs/adr need updating to align with the new architecture.
exec
/bin/zsh -lc 'rg -n "ToolExecutorInterface|ExecutableToolInterface" src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 88ms:
src/Contracts/ExecutableToolInterface.php:24:interface ExecutableToolInterface {
src/Contracts/ToolDispatcherInterface.php:44:	 * @param ExecutableToolInterface $tool Executable tool instance.
src/Contracts/ToolDispatcherInterface.php:47:	public function registerTool( ExecutableToolInterface $tool ): void;
src/Contracts/ToolDispatcherInterface.php:52:	 * @param array<ExecutableToolInterface> $tools Array of executable tool instances.
src/Contracts/ToolExecutorInterface.php:10:interface ToolExecutorInterface {
src/Intent/ToolDispatcher.php:13:use AgentWP\Contracts\ExecutableToolInterface;
src/Intent/ToolDispatcher.php:89:	 * @param ExecutableToolInterface $tool Executable tool instance.
src/Intent/ToolDispatcher.php:92:	public function registerTool( ExecutableToolInterface $tool ): void {
src/Intent/ToolDispatcher.php:102:	 * @param array<ExecutableToolInterface> $tools Array of executable tool instances.
src/Intent/Tools/SearchProductTool.php:10:use AgentWP\Contracts\ExecutableToolInterface;
src/Intent/Tools/SearchProductTool.php:19:class SearchProductTool implements ExecutableToolInterface {
src/Intent/Tools/GetSalesReportTool.php:11:use AgentWP\Contracts\ExecutableToolInterface;
src/Intent/Tools/GetSalesReportTool.php:19:class GetSalesReportTool implements ExecutableToolInterface {
src/Intent/Tools/PrepareRefundTool.php:10:use AgentWP\Contracts\ExecutableToolInterface;
src/Intent/Tools/PrepareRefundTool.php:18:class PrepareRefundTool implements ExecutableToolInterface {
src/Intent/Tools/ConfirmRefundTool.php:10:use AgentWP\Contracts\ExecutableToolInterface;
src/Intent/Tools/ConfirmRefundTool.php:18:class ConfirmRefundTool implements ExecutableToolInterface {
src/Intent/Tools/PrepareStatusUpdateTool.php:10:use AgentWP\Contracts\ExecutableToolInterface;
src/Intent/Tools/PrepareStatusUpdateTool.php:18:class PrepareStatusUpdateTool implements ExecutableToolInterface {
src/Intent/Tools/ConfirmStockUpdateTool.php:10:use AgentWP\Contracts\ExecutableToolInterface;

thinking
**Noticing possibly unused interface**
exec
/bin/zsh -lc "sed -n '1,120p' src/Contracts/ToolExecutorInterface.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 72ms:
<?php
/**
 * Interface for handlers that can execute AI tools.
 *
 * @package AgentWP\Contracts
 */

namespace AgentWP\Contracts;

interface ToolExecutorInterface {
	/**
	 * Execute a named tool with arguments.
	 *
	 * @param string $name      Tool name.
	 * @param array  $arguments Tool arguments.
	 * @return mixed Tool execution result.
	 */
	public function execute_tool( string $name, array $arguments );
}


thinking
**Planning docs update for tool execution**

I'm focusing on updating developer and architecture docs to reflect current tool execution using ToolDispatcher and registerToolExecutors, clarifying the distinction from legacy ToolExecutorInterface and function registration, and adding terminology notes on tools versus functions for clearer guidance.
thinking
**Identifying legacy function mapping role**

I'm noting that "function mapping" supports legacy function name-to-handler linking for scoring and suggestions tied to `function_suggestions` context, prompting a search to confirm its current usage and impact when adding new tool schemas.
exec
/bin/zsh -lc 'rg -n "function_suggestions" -S src' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 42ms:
src/Intent/Handlers/BaseHandler.php:59:		if ( isset( $context['function_suggestions'] ) ) {
src/Intent/Handlers/BaseHandler.php:60:			$payload['function_suggestions'] = $context['function_suggestions'];
src/Intent/Engine.php:173:		$enriched['function_suggestions'] = $this->function_registry->get_functions_for_intent( $enriched['intent'] );
exec
/bin/zsh -lc "sed -n '1,120p' src/Intent/Handlers/BaseHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 73ms:
<?php
/**
 * Base handler for intent responses.
 *
 * @package AgentWP
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\AI\Response;
use AgentWP\Intent\Handler;
use AgentWP\Intent\Intent;

abstract class BaseHandler implements Handler {
	protected string $intent;

	/**
	 * @param string $intent Intent identifier.
	 */
	public function __construct( string $intent ) {


thinking
**Clarifying tool vs function schema in docs**

I'm updating the architecture docs to clarify that "FunctionSchema" is the interface used by tool schema classes in src/AI/Functions for OpenAI tools requests, while "tool executors" in src/Intent/Tools implement execution and register with ToolDispatcher. I'll also revise handler docs to reflect registering executors via ToolDispatcher instead of older patterns, updating samples accordingly.
thinking
**Detailing contributor steps and extension docs**

I'm drafting a final contributor checklist covering adding schema and executor classes, registering them in service providers, and updating handlers. I'll also enhance extension docs with a new "tools vs functions" glossary and clarify how legacy function hooks relate to newer tool registries, noting current lack of explicit hooks for tool registration but pointing to 'agentwp_register_providers' for provider additions.
exec
/bin/zsh -lc "sed -n '200,340p' src/Providers/IntentServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 72ms:

				// Validate that filter returned an array.
				if ( ! is_array( $scorers ) ) {
					$scorers = $default_scorers;
				}

				$registry->registerMany( $scorers );

				return $registry;
			}
		);
	}

	/**
	 * Register function registry.
	 *
	 * @return void
	 */
	private function registerFunctionRegistry(): void {
		if ( ! class_exists( FunctionRegistry::class ) ) {


thinking
**Planning documentation updates**

I'm preparing to clarify tool registration with IntentServiceProvider in the docs, adding terminology distinctions and updating the architecture section with key components like ToolDispatcher and ExecutableTool for better clarity.
thinking
**Extending tool addition docs**

I'm updating the "Adding a New Tool" and developer docs to include executor and dispatcher steps, refining terminology for exposing tools and aligning examples with the new ToolDispatcher pattern.
exec
/bin/zsh -lc "sed -n '400,520p' docs/DEVELOPER.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 71ms:
  'agentwp_intent_scorers',
  array $scorers
);
```

Example:
```php
add_filter( 'agentwp_intent_scorers', function( array $scorers ): array {
	$scorers[] = new MyCustomScorer();
	return $scorers;
} );
```

### `agentwp_intent_classified`
Fired after intent classification completes. Useful for analytics, logging, or debugging.

Signature:
```
do_action(
  'agentwp_intent_classified',

thinking
**Planning comprehensive docs updates**

I'm updating references from execute_tool to registerToolExecutors and ToolDispatcher across contributor checklists and architecture docs, clarifying tool vs function terminology especially in docs/EXTENSIONS near the top for extension authors.
exec
/bin/zsh -lc "sed -n '1,120p' docs/EXTENSIONS.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 71ms:
# AgentWP Extension Points

This document is the **single source of truth** for all supported actions, filters, and extension points in AgentWP. Extension developers should reference this document when building integrations.

> **Maintenance note:** When adding new hooks to the codebase, document them here with their file location, parameters, and purpose.

## Table of Contents

- [Core Plugin Hooks](#core-plugin-hooks)
- [Intent System Hooks](#intent-system-hooks)
- [Intent Classification Hooks](#intent-classification-hooks)
- [Error Handling Hooks](#error-handling-hooks)
- [Configuration Hooks](#configuration-hooks)
- [Customer Service Hooks](#customer-service-hooks)
- [Encryption Hooks](#encryption-hooks)
- [Notification Hooks](#notification-hooks)
- [Extension Patterns](#extension-patterns)
  - [Custom Service Provider](#registering-a-custom-service-provider)
  - [Custom Intent Handler](#adding-a-custom-intent-handler)
  - [Custom Intent Scorer](#creating-a-custom-intent-scorer)

thinking
**Planning "Tools vs Functions" section**

I'm planning to insert a new "Tools vs Functions" section near the top, possibly after the table of contents, and will update the ToC accordingly. I'll also locate and plan adjustments to the "Custom AI Functions" section later.
exec
/bin/zsh -lc 'rg -n "Custom AI Functions|registering-custom-ai-functions" docs/EXTENSIONS.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 53ms:
21:  - [Custom AI Functions](#registering-custom-ai-functions)
562:### Registering Custom AI Functions
exec
/bin/zsh -lc "sed -n '540,640p' docs/EXTENSIONS.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 67ms:
        'late delivery',
        'package delayed',
    );

    public function getIntent(): string {
        return 'shipment_delay';
    }

    public function score( string $text, array $context = array() ): int {
        return $this->matchScore( $text, self::PHRASES );
    }
}

// Register the scorer
add_filter( 'agentwp_intent_scorers', function( $scorers ) {
    $scorers[] = new ShipmentDelayScorer();
    return $scorers;
} );
```



thinking
**Planning documentation clarifications**

I'm preparing to clarify that "function suggestions" are legacy and distinct from actual tool schemas and executors, adding notes to the FunctionRegistry section, hook docs, DEVELOPER guide, and Architecture overview to reflect this distinction clearly.
thinking
**Detailing tool architecture and docs updates**

I've defined clear terminology distinguishing tool schemas, executors, dispatchers, and handler exposure, planning comprehensive doc updates across ARCHITECTURE, DEVELOPER, EXTENSIONS to reflect this and clarify legacy FunctionRegistry's role; also updating flowcharts, key components, examples, and contributor checklists accordingly.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/ARCHITECTURE.md
@@ -300,2 +300,10 @@
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
@@ -312,2 +320,12 @@
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
@@ -325,2 +343,4 @@
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
@@ -334,3 +354,5 @@
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
@@ -352,6 +374,10 @@
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
@@ -359,8 +385,11 @@
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
@@ -368,2 +397,6 @@
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
apply_patch(auto_approved=true) exited 0 in 32ms:
Success. Updated the following files:
M docs/ARCHITECTURE.md
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---

file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---


thinking
**Updating contributor docs with tooling details**

I'm refining the contributor checklist to include required methods and ToolDispatcher for agentic handlers and planning to update example handler code to better show ToolDispatcherInterface injection based on patterns in existing handlers like OrderSearchHandler.
exec
/bin/zsh -lc "sed -n '1,140p' src/Intent/Handlers/OrderSearchHandler.php" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 77ms:
<?php
/**
 * Handle order search intents.
 *
 * @package AgentWP\Intent\Handlers
 */

namespace AgentWP\Intent\Handlers;

use AgentWP\Contracts\AIClientFactoryInterface;
use AgentWP\Contracts\ToolDispatcherInterface;
use AgentWP\Contracts\ToolRegistryInterface;
use AgentWP\Intent\Attributes\HandlesIntent;
use AgentWP\Intent\Intent;

/**
 * Handles order search intents using the agentic loop.
 *
 * Uses the centrally-registered SearchOrdersTool for execution.
 */
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---


thinking
**Updating example with tool registration**

I'm adding ToolDispatcherInterface injection and showing how external plugins can register tools via registerToolExecutors, including a sample with DraftDelayEmailTool. I'll also update the docs and checklist to reflect these new steps.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/DEVELOPER.md
@@ -433,3 +433,4 @@
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
@@ -454,2 +455,3 @@
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
@@ -466,5 +468,6 @@
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
@@ -472,2 +475,6 @@
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
@@ -484,8 +491,3 @@
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
@@ -606,2 +608,9 @@
 
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
+
 ### Contributor checklist (tool)
@@ -610,4 +619,7 @@
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
apply_patch(auto_approved=true) exited 0 in 38ms:
Success. Updated the following files:
M docs/DEVELOPER.md
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..69ac9f2096133ce347f8299c89331f62360012f7
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -431,7 +431,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,6 +453,7 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
@@ -464,12 +466,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +489,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -604,12 +606,22 @@
 
 AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
 
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
+
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer

file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..69ac9f2096133ce347f8299c89331f62360012f7
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -431,7 +431,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,6 +453,7 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
@@ -464,12 +466,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +489,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -604,12 +606,22 @@
 
 AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
 
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
+
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer



thinking
**Updating docs with tools terminology and DraftDelayEmailTool note**

I'll add a new "Tools vs Functions Terminology" section near the top of the extensions docs and update relevant sections to clarify intent functions and tools. I'll also insert a comment in the example about DraftDelayEmailTool being a custom executable tool implemented in the extension.
thinking
**Clarifying custom AI functions vs tools in docs**

I'll update the "Registering Custom AI Functions" section to clarify it covers function_suggestions only, and explain the separate process required to add tools—including schema, executor, registration, and handler updates—with references to developer docs.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/EXTENSIONS.md
@@ -8,2 +8,3 @@
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
@@ -27,2 +28,15 @@
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
@@ -100,3 +114,4 @@
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
@@ -122,3 +137,4 @@
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
@@ -563,2 +579,5 @@
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
apply_patch(auto_approved=true) exited 0 in 49ms:
Success. Updated the following files:
M docs/EXTENSIONS.md
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..69ac9f2096133ce347f8299c89331f62360012f7
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -431,7 +431,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,6 +453,7 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
@@ -464,12 +466,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +489,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -604,12 +606,22 @@
 
 AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
 
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
+
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );

file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..69ac9f2096133ce347f8299c89331f62360012f7
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -431,7 +431,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,6 +453,7 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
@@ -464,12 +466,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +489,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -604,12 +606,22 @@
 
 AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
 
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
+
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );


thinking
**Updating developer docs for function suggestions**

I'll search the docs/DEVELOPER file around line 360 for sections on intent function registration and default mappings to add clarifying notes about function suggestions versus actual tools, then apply patches to update those texts accordingly.
exec
/bin/zsh -lc "sed -n '340,420p' docs/DEVELOPER.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 69ms:
```
array $thresholds = apply_filters(
  'agentwp_customer_health_thresholds',
  array $thresholds
);
```

### `agentwp_encryption_rotation_materials`
Provide additional key material for API key rotation.

Signature:
```
array $rotations = apply_filters(
  'agentwp_encryption_rotation_materials',
  array $rotations
);
```

### `agentwp_intent_handlers`
Extend the intent handler list (see extension guide below).
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..69ac9f2096133ce347f8299c89331f62360012f7
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -431,7 +431,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,6 +453,7 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
@@ -464,12 +466,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +489,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -604,12 +606,22 @@
 
 AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
 
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
+
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );


thinking
**Adding notes to default function mapping**

I'm planning to insert a short explanation before or after the function signature noting these as legacy function suggestions and clarifying not to register tool schemas or executors.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/DEVELOPER.md
@@ -370,3 +370,4 @@
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
@@ -382,3 +383,4 @@
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M docs/DEVELOPER.md
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..32df227fd5d257af6b5ef02bf6bd9075cce5b00a
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,6 +455,7 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
@@ -464,12 +468,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +491,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -604,12 +608,22 @@
 
 AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
 
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
+
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );

file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..32df227fd5d257af6b5ef02bf6bd9075cce5b00a
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,6 +455,7 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
@@ -464,12 +468,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +491,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -604,12 +608,22 @@
 
 AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
 
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
+
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );


thinking
**Adding import for example clarity**

I’ll update the example to include the import statement for the DraftDelayEmailTool class to ensure it’s clearly defined and easy to follow.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/DEVELOPER.md
@@ -461,2 +461,3 @@
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
apply_patch(auto_approved=true) exited 0 in 90ms:
Success. Updated the following files:
M docs/DEVELOPER.md
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..c4430488e1f243b4931f30e60a1607e723d77b7b
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -604,12 +609,22 @@
 
 AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
 
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
+
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );

file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..c4430488e1f243b4931f30e60a1607e723d77b7b
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -604,12 +609,22 @@
 
 AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
 
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
+
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );


thinking
**Checking execute_tool references in docs**

I'm verifying all mentions of execute_tool in docs/ARCHITECTURE and docs/DEVELOPER to ensure updates align with recent changes around ToolDispatcher and custom namespaces.
exec
/bin/zsh -lc 'rg -n "execute_tool" docs/ARCHITECTURE.md docs/DEVELOPER.md' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 37ms:

file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..c4430488e1f243b4931f30e60a1607e723d77b7b
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -604,12 +609,22 @@
 
 AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
 
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
+
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );



thinking
**Updating docs for tool executor changes**

I'm aligning architecture and developer docs with the replacement of the tool executor interface by ExecutableToolInterface and ToolDispatcher, clarifying terminology around custom AI functions, and ensuring consistent examples and flow across EXTENSIONS and DEVELOPER guides.
thinking
**Correcting tool execution description**

I'm updating the introduction in "Adding a new tool" to reflect that tools are executed via ToolDispatcher and tool executors instead of handlers, ensuring accuracy with the current architecture.
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/DEVELOPER.md
@@ -609,3 +609,3 @@
 
-AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
+AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).
 
apply_patch(auto_approved=true) exited 0 in 69ms:
Success. Updated the following files:
M docs/DEVELOPER.md
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..f48cd9efc02754af7ce0c091cf6fba58633ebaaf
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -602,14 +607,24 @@
 
 ## Adding a new tool (Phase 4 decision)
 
-AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
+AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).
+
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
 
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );

file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..f48cd9efc02754af7ce0c091cf6fba58633ebaaf
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -602,14 +607,24 @@
 
 ## Adding a new tool (Phase 4 decision)
 
-AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
+AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).
+
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
 
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );


thinking
**Reviewing doc references to executors**

I'm scanning docs/ARCHITECTURE around ADR references to update mentions from "handler executors" to "tool executors" for clarity, aligning with execution logic wording without going beyond requested docs.
exec
/bin/zsh -lc "sed -n '140,180p' docs/ARCHITECTURE.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 69ms:
|-----------|----------|---------|
| Container | `src/Container/Container.php` | PSR-11 style DI container |
| ServiceProvider | `src/Container/ServiceProvider.php` | Base class for providers |
| RestRouteRegistrar | `src/Plugin/RestRouteRegistrar.php` | Collects and registers controllers |
| ResponseFormatter | `src/Plugin/ResponseFormatter.php` | Normalizes REST responses |
| SettingsManager | `src/Plugin/SettingsManager.php` | Centralized settings access |

### Architecture Decision Records

The following ADRs document key architectural decisions:

- **[ADR 0001: REST Controller Dependency Resolution](adr/0001-rest-controller-dependency-resolution.md)** — Controllers resolve dependencies via container, not direct instantiation
- **[ADR 0002: Intent Handler Registration](adr/0002-intent-handler-registration.md)** — `#[HandlesIntent]` attributes and container tagging for handler discovery
- **[ADR 0003: Intent Classification Strategy](adr/0003-intent-classification-strategy.md)** — `ScorerRegistry` as the canonical classifier with pluggable scorers
- **[ADR 0004: OpenAI Client Architecture](adr/0004-openai-client-architecture.md)** — Monolithic client with infrastructure abstractions for HTTP/retry
- **[ADR 0005: REST Rate Limiting](adr/0005-rest-rate-limiting.md)** — Injected `RateLimiterInterface` for testable rate limiting
- **[ADR 0006: Search Index Architecture](adr/0006-search-index-architecture.md)** — Static class design for MySQL fulltext search index
- **[ADR 0007: Request DTO Validation](adr/0007-request-dto-validation.md)** — DTO-based request validation
- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes + handler executors for OpenAI function calling

file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..d4e7335f827696fb8147215b54f621384810a90c
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..f48cd9efc02754af7ce0c091cf6fba58633ebaaf
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -602,14 +607,24 @@
 
 ## Adding a new tool (Phase 4 decision)
 
-AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
+AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).
+
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
 
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );


thinking
**Updating architecture docs for tool executors**
file update
M /Users/ahmedyounis/Documents/Projects/agentwp/docs/ARCHITECTURE.md
@@ -157,3 +157,3 @@
 - **[ADR 0007: Request DTO Validation](adr/0007-request-dto-validation.md)** — DTO-based request validation
-- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes + handler executors for OpenAI function calling
+- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes, tool executors, and dispatcher flow for OpenAI function calling
 
@@ -956,2 +956,2 @@
 | [ADR 0007](adr/0007-request-dto-validation.md) | DTO-based request validation |
-| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + handler executors for tools |
+| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + tool executors for tools |
apply_patch(auto_approved=true) exited 0 in 70ms:
Success. Updated the following files:
M docs/ARCHITECTURE.md
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..40c5385d535468a4ba3f2649675fd96fe9d09bb9
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -155,7 +155,7 @@
 - **[ADR 0005: REST Rate Limiting](adr/0005-rest-rate-limiting.md)** — Injected `RateLimiterInterface` for testable rate limiting
 - **[ADR 0006: Search Index Architecture](adr/0006-search-index-architecture.md)** — Static class design for MySQL fulltext search index
 - **[ADR 0007: Request DTO Validation](adr/0007-request-dto-validation.md)** — DTO-based request validation
-- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes + handler executors for OpenAI function calling
+- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes, tool executors, and dispatcher flow for OpenAI function calling
 
 For the improvement roadmap, see [ARCHITECTURE-IMPROVEMENT-PLAN.md](ARCHITECTURE-IMPROVEMENT-PLAN.md).
 
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
@@ -921,4 +954,4 @@
 | [ADR 0005](adr/0005-rest-rate-limiting.md) | Injected `RateLimiterInterface` for rate limiting |
 | [ADR 0006](adr/0006-search-index-architecture.md) | Static search index design |
 | [ADR 0007](adr/0007-request-dto-validation.md) | DTO-based request validation |
-| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + handler executors for tools |
+| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + tool executors for tools |
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..f48cd9efc02754af7ce0c091cf6fba58633ebaaf
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -602,14 +607,24 @@
 
 ## Adding a new tool (Phase 4 decision)
 
-AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
+AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).
+
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
 
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );

file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..40c5385d535468a4ba3f2649675fd96fe9d09bb9
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -155,7 +155,7 @@
 - **[ADR 0005: REST Rate Limiting](adr/0005-rest-rate-limiting.md)** — Injected `RateLimiterInterface` for testable rate limiting
 - **[ADR 0006: Search Index Architecture](adr/0006-search-index-architecture.md)** — Static class design for MySQL fulltext search index
 - **[ADR 0007: Request DTO Validation](adr/0007-request-dto-validation.md)** — DTO-based request validation
-- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes + handler executors for OpenAI function calling
+- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes, tool executors, and dispatcher flow for OpenAI function calling
 
 For the improvement roadmap, see [ARCHITECTURE-IMPROVEMENT-PLAN.md](ARCHITECTURE-IMPROVEMENT-PLAN.md).
 
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
@@ -921,4 +954,4 @@
 | [ADR 0005](adr/0005-rest-rate-limiting.md) | Injected `RateLimiterInterface` for rate limiting |
 | [ADR 0006](adr/0006-search-index-architecture.md) | Static search index design |
 | [ADR 0007](adr/0007-request-dto-validation.md) | DTO-based request validation |
-| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + handler executors for tools |
+| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + tool executors for tools |
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..f48cd9efc02754af7ce0c091cf6fba58633ebaaf
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -602,14 +607,24 @@
 
 ## Adding a new tool (Phase 4 decision)
 
-AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
+AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).
+
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
 
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );


thinking
**Searching architecture docs for handler references**
exec
/bin/zsh -lc 'rg -n "handler executors|function registry|FunctionRegistry|function suggestions" docs/ARCHITECTURE.md' in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 52ms:
307:- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
398:6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..40c5385d535468a4ba3f2649675fd96fe9d09bb9
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -155,7 +155,7 @@
 - **[ADR 0005: REST Rate Limiting](adr/0005-rest-rate-limiting.md)** — Injected `RateLimiterInterface` for testable rate limiting
 - **[ADR 0006: Search Index Architecture](adr/0006-search-index-architecture.md)** — Static class design for MySQL fulltext search index
 - **[ADR 0007: Request DTO Validation](adr/0007-request-dto-validation.md)** — DTO-based request validation
-- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes + handler executors for OpenAI function calling
+- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes, tool executors, and dispatcher flow for OpenAI function calling
 
 For the improvement roadmap, see [ARCHITECTURE-IMPROVEMENT-PLAN.md](ARCHITECTURE-IMPROVEMENT-PLAN.md).
 
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
@@ -921,4 +954,4 @@
 | [ADR 0005](adr/0005-rest-rate-limiting.md) | Injected `RateLimiterInterface` for rate limiting |
 | [ADR 0006](adr/0006-search-index-architecture.md) | Static search index design |
 | [ADR 0007](adr/0007-request-dto-validation.md) | DTO-based request validation |
-| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + handler executors for tools |
+| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + tool executors for tools |
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..f48cd9efc02754af7ce0c091cf6fba58633ebaaf
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -602,14 +607,24 @@
 
 ## Adding a new tool (Phase 4 decision)
 
-AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
+AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).
+
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
 
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );


thinking
**Updating extensions documentation**

I'm planning to revise the "Tools vs Functions Terminology" section and check the note on "FunctionRegistry" for flow and clarity, keeping new content concise. Next, I'll review and refine the docs accordingly.
exec
/bin/zsh -lc "sed -n '1,120p' docs/EXTENSIONS.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 67ms:
# AgentWP Extension Points

This document is the **single source of truth** for all supported actions, filters, and extension points in AgentWP. Extension developers should reference this document when building integrations.

> **Maintenance note:** When adding new hooks to the codebase, document them here with their file location, parameters, and purpose.

## Table of Contents

- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
- [Core Plugin Hooks](#core-plugin-hooks)
- [Intent System Hooks](#intent-system-hooks)
- [Intent Classification Hooks](#intent-classification-hooks)
- [Error Handling Hooks](#error-handling-hooks)
- [Configuration Hooks](#configuration-hooks)
- [Customer Service Hooks](#customer-service-hooks)
- [Encryption Hooks](#encryption-hooks)
- [Notification Hooks](#notification-hooks)
- [Extension Patterns](#extension-patterns)
  - [Custom Service Provider](#registering-a-custom-service-provider)
  - [Custom Intent Handler](#adding-a-custom-intent-handler)
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..40c5385d535468a4ba3f2649675fd96fe9d09bb9
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -155,7 +155,7 @@
 - **[ADR 0005: REST Rate Limiting](adr/0005-rest-rate-limiting.md)** — Injected `RateLimiterInterface` for testable rate limiting
 - **[ADR 0006: Search Index Architecture](adr/0006-search-index-architecture.md)** — Static class design for MySQL fulltext search index
 - **[ADR 0007: Request DTO Validation](adr/0007-request-dto-validation.md)** — DTO-based request validation
-- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes + handler executors for OpenAI function calling
+- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes, tool executors, and dispatcher flow for OpenAI function calling
 
 For the improvement roadmap, see [ARCHITECTURE-IMPROVEMENT-PLAN.md](ARCHITECTURE-IMPROVEMENT-PLAN.md).
 
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
@@ -921,4 +954,4 @@
 | [ADR 0005](adr/0005-rest-rate-limiting.md) | Injected `RateLimiterInterface` for rate limiting |
 | [ADR 0006](adr/0006-search-index-architecture.md) | Static search index design |
 | [ADR 0007](adr/0007-request-dto-validation.md) | DTO-based request validation |
-| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + handler executors for tools |
+| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + tool executors for tools |
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..f48cd9efc02754af7ce0c091cf6fba58633ebaaf
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -602,14 +607,24 @@
 
 ## Adding a new tool (Phase 4 decision)
 
-AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
+AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).
+
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
 
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );



thinking
**Updating documentation for handler and tools**

I'm aligning the DEVELOPER guide example with the new AbstractAgenticHandler interface by adding registerToolExecutors and adjusting getToolNames, removing execute_tool, and clarifying handler exposure and tool dispatching. I'm also revising architecture docs to match the updated terminology, confirming no lingering ToolExecutorInterface mentions, and ensuring new notes on function suggestions and legacy FunctionRegistry appear in the guidance.
thinking
**Verifying removal of execute_tool in docs**

I'm confirming all references to execute_tool have been removed from DEVELOPER docs and deciding not to reintroduce ToolExecutorInterface in ARCHITECTURE since it’s unused in the new flow.
exec
/bin/zsh -lc 'rg -n "execute_tool" docs/DEVELOPER.md docs/EXTENSIONS.md docs/ARCHITECTURE.md' in /Users/ahmedyounis/Documents/Projects/agentwp exited 1 in 73ms:

file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..40c5385d535468a4ba3f2649675fd96fe9d09bb9
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -155,7 +155,7 @@
 - **[ADR 0005: REST Rate Limiting](adr/0005-rest-rate-limiting.md)** — Injected `RateLimiterInterface` for testable rate limiting
 - **[ADR 0006: Search Index Architecture](adr/0006-search-index-architecture.md)** — Static class design for MySQL fulltext search index
 - **[ADR 0007: Request DTO Validation](adr/0007-request-dto-validation.md)** — DTO-based request validation
-- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes + handler executors for OpenAI function calling
+- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes, tool executors, and dispatcher flow for OpenAI function calling
 
 For the improvement roadmap, see [ARCHITECTURE-IMPROVEMENT-PLAN.md](ARCHITECTURE-IMPROVEMENT-PLAN.md).
 
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
@@ -921,4 +954,4 @@
 | [ADR 0005](adr/0005-rest-rate-limiting.md) | Injected `RateLimiterInterface` for rate limiting |
 | [ADR 0006](adr/0006-search-index-architecture.md) | Static search index design |
 | [ADR 0007](adr/0007-request-dto-validation.md) | DTO-based request validation |
-| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + handler executors for tools |
+| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + tool executors for tools |
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..f48cd9efc02754af7ce0c091cf6fba58633ebaaf
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -602,14 +607,24 @@
 
 ## Adding a new tool (Phase 4 decision)
 
-AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
+AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).
+
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
 
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );


thinking
**Reviewing doc updates for tool registration**

I'm verifying the "Adding a new tool" section in docs/DEVELOPER to see if it should mention the new `registerToolExecutors` method for clarity and accurate flow.
exec
/bin/zsh -lc "sed -n '600,680p' docs/DEVELOPER.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 65ms:
```

### 4) Test the prompt
Call the `/intent` endpoint or use the Command Deck to test:
```
Draft a shipment delay email for order 1234
```

## Adding a new tool (Phase 4 decision)

AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).

### Terminology

- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.

### Contributor checklist (tool)
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..40c5385d535468a4ba3f2649675fd96fe9d09bb9
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -155,7 +155,7 @@
 - **[ADR 0005: REST Rate Limiting](adr/0005-rest-rate-limiting.md)** — Injected `RateLimiterInterface` for testable rate limiting
 - **[ADR 0006: Search Index Architecture](adr/0006-search-index-architecture.md)** — Static class design for MySQL fulltext search index
 - **[ADR 0007: Request DTO Validation](adr/0007-request-dto-validation.md)** — DTO-based request validation
-- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes + handler executors for OpenAI function calling
+- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes, tool executors, and dispatcher flow for OpenAI function calling
 
 For the improvement roadmap, see [ARCHITECTURE-IMPROVEMENT-PLAN.md](ARCHITECTURE-IMPROVEMENT-PLAN.md).
 
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
@@ -921,4 +954,4 @@
 | [ADR 0005](adr/0005-rest-rate-limiting.md) | Injected `RateLimiterInterface` for rate limiting |
 | [ADR 0006](adr/0006-search-index-architecture.md) | Static search index design |
 | [ADR 0007](adr/0007-request-dto-validation.md) | DTO-based request validation |
-| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + handler executors for tools |
+| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + tool executors for tools |
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..f48cd9efc02754af7ce0c091cf6fba58633ebaaf
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -602,14 +607,24 @@
 
 ## Adding a new tool (Phase 4 decision)
 
-AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
+AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).
+
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
 
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );


thinking
**Checking architecture docs for tool flow**
exec
/bin/zsh -lc "sed -n '290,420p' docs/ARCHITECTURE.md" in /Users/ahmedyounis/Documents/Projects/agentwp succeeded in 67ms:
| `WooCommerceUserGatewayInterface` | `WooCommerceUserGateway` | Customer data access |

This abstraction enables:
- **Unit testing** with fakes/mocks (no WooCommerce runtime required)
- **Consistent error handling** across all WooCommerce operations
- **Clear boundaries** between domain logic and infrastructure

## 1.2) Tool Execution Architecture

AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.

### Terminology (tools vs functions)

- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.

```mermaid
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..40c5385d535468a4ba3f2649675fd96fe9d09bb9
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -155,7 +155,7 @@
 - **[ADR 0005: REST Rate Limiting](adr/0005-rest-rate-limiting.md)** — Injected `RateLimiterInterface` for testable rate limiting
 - **[ADR 0006: Search Index Architecture](adr/0006-search-index-architecture.md)** — Static class design for MySQL fulltext search index
 - **[ADR 0007: Request DTO Validation](adr/0007-request-dto-validation.md)** — DTO-based request validation
-- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes + handler executors for OpenAI function calling
+- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes, tool executors, and dispatcher flow for OpenAI function calling
 
 For the improvement roadmap, see [ARCHITECTURE-IMPROVEMENT-PLAN.md](ARCHITECTURE-IMPROVEMENT-PLAN.md).
 
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
@@ -921,4 +954,4 @@
 | [ADR 0005](adr/0005-rest-rate-limiting.md) | Injected `RateLimiterInterface` for rate limiting |
 | [ADR 0006](adr/0006-search-index-architecture.md) | Static search index design |
 | [ADR 0007](adr/0007-request-dto-validation.md) | DTO-based request validation |
-| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + handler executors for tools |
+| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + tool executors for tools |
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..f48cd9efc02754af7ce0c091cf6fba58633ebaaf
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -602,14 +607,24 @@
 
 ## Adding a new tool (Phase 4 decision)
 
-AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
+AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).
+
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
 
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );


thinking
**Preparing final response instructions**

I'm drafting the final message per the instructions: it will confirm the docs update to use DraftDelayEmailTool example without redefining it, state no code or test changes occurred, note no verification commands were provided, list the three updated docs, and assess risk as low since it's doc-only. Tests were not run due to no code changes. The final response will follow the requested format with status, summary, how to verify, and risks.
codex
Clarified tools vs functions terminology across the architecture, developer, and extension docs to align with ToolRegistry/ToolDispatcher and executable tools.

Status: DONE

Summary of changes:
- `docs/ARCHITECTURE.md` added tools-vs-functions definitions, expanded the diagram, updated key components and tool onboarding steps.
- `docs/DEVELOPER.md` updated handler/tool guidance to use `registerToolExecutors()` and ToolDispatcher, plus clarified legacy function-suggestion hooks.
- `docs/EXTENSIONS.md` added a tools-vs-functions section and clarified that “function” hooks are suggestions only.

How to verify (exact commands):
- No verification commands provided.

Risks / follow-ups:
- None.
file update:
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 9a05372c69fb16fd2a52d7179a6e994ffca079d1..40c5385d535468a4ba3f2649675fd96fe9d09bb9
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -155,7 +155,7 @@
 - **[ADR 0005: REST Rate Limiting](adr/0005-rest-rate-limiting.md)** — Injected `RateLimiterInterface` for testable rate limiting
 - **[ADR 0006: Search Index Architecture](adr/0006-search-index-architecture.md)** — Static class design for MySQL fulltext search index
 - **[ADR 0007: Request DTO Validation](adr/0007-request-dto-validation.md)** — DTO-based request validation
-- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes + handler executors for OpenAI function calling
+- **[ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md)** — Schema classes, tool executors, and dispatcher flow for OpenAI function calling
 
 For the improvement roadmap, see [ARCHITECTURE-IMPROVEMENT-PLAN.md](ARCHITECTURE-IMPROVEMENT-PLAN.md).
 
@@ -298,6 +298,14 @@
 
 AgentWP uses OpenAI function calling (tools) to enable AI-driven workflows. The architecture separates tool schemas from execution logic.
 
+### Terminology (tools vs functions)
+
+- **Tool schema** — PHP classes in `src/AI/Functions/*` implement `FunctionSchema` and define the tool name, description, and JSON schema sent to OpenAI. These are stored in `ToolRegistry`.
+- **Tool executor** — PHP classes in `src/Intent/Tools/*` implement `ExecutableToolInterface` and perform the actual business logic. These are registered with `ToolDispatcher`.
+- **Tool dispatch** — `ToolDispatcher` validates arguments against the registered schema and routes the tool call to the executor, returning a JSON-safe payload.
+- **Handler exposure** — `AbstractAgenticHandler::getToolNames()` controls which tool schemas are exposed to the model for a given intent. A tool is only callable if it is both registered with `ToolDispatcher` and listed in `getToolNames()`.
+- **Function registry (legacy)** — `FunctionRegistry` and the `agentwp_register_intent_functions`/`agentwp_default_function_mapping` hooks provide *function suggestions* in response payloads. They do not register tool schemas or executors.
+
 ```mermaid
 flowchart TB
     subgraph Schema["Tool Schemas (src/AI/Functions/)"]
@@ -310,6 +318,16 @@
         TR[ToolRegistry]
     end
 
+    subgraph Dispatch["Tool Dispatch"]
+        TD[ToolDispatcher]
+    end
+
+    subgraph Executors["Tool Executors (src/Intent/Tools/)"]
+        ST[SearchOrdersTool]
+        PT[PrepareRefundTool]
+        CT[ConfirmRefundTool]
+    end
+
     subgraph Handlers["Intent Handlers"]
         OSH[OrderSearchHandler]
         ORH[OrderRefundHandler]
@@ -323,6 +341,8 @@
     TR --> Handlers
     Handlers --> OAI
     OAI -->|tool_calls| Handlers
+    Handlers --> TD
+    TD --> Executors
 ```
 
 ### Key Components
@@ -332,7 +352,9 @@
 | `FunctionSchema` | `src/Contracts/FunctionSchema.php` | Interface for tool schema |
 | `AbstractFunction` | `src/AI/Functions/AbstractFunction.php` | Base class with OpenAI format |
 | `ToolRegistry` | `src/Intent/ToolRegistry.php` | O(1) schema lookup |
-| `ToolExecutorInterface` | `src/Contracts/ToolExecutorInterface.php` | Execution contract |
+| `ExecutableToolInterface` | `src/Contracts/ExecutableToolInterface.php` | Contract for tool executors |
+| `ToolDispatcher` | `src/Intent/ToolDispatcher.php` | Validates args and dispatches execution |
+| Tool executors | `src/Intent/Tools/*` | Concrete tool execution classes |
 | `AbstractAgenticHandler` | `src/Intent/Handlers/AbstractAgenticHandler.php` | Agentic loop base |
 
 ### Adding a New Tool
@@ -350,22 +372,33 @@
    $registry->register(new MyTool());
    ```
 
-3. **Declare in handler** via `getToolNames()`:
+3. **Create an executor** in `src/Intent/Tools/`:
    ```php
-   protected function getToolNames(): array {
-       return ['my_tool'];
+   class MyToolExecutor implements ExecutableToolInterface {
+       public function __construct(private MyService $service) {}
+       public function getName(): string { return 'my_tool'; }
+       public function execute(array $args): array {
+           return $this->service->doSomething($args);
+       }
    }
    ```
 
-4. **Implement execution** in `execute_tool()`:
+4. **Register executor** with `ToolDispatcher` (typically in `IntentServiceProvider::registerToolDispatcher()` or in your handler's `registerToolExecutors()`):
    ```php
-   public function execute_tool(string $name, array $args) {
-       return match ($name) {
-           'my_tool' => $this->service->doSomething($args),
-       };
+   $dispatcher->registerTool( new MyToolExecutor( $service ) );
+   ```
+
+5. **Declare in handler** via `getToolNames()` to expose the schema to the model:
+   ```php
+   protected function getToolNames(): array {
+       return ['my_tool'];
    }
    ```
 
+6. **(Optional)** Update function suggestions if you want the tool name to appear in responses:
+   - `agentwp_register_intent_functions`
+   - `agentwp_default_function_mapping`
+
 See [ADR 0008: Tool Execution Architecture](adr/0008-tool-execution-architecture.md) for detailed rationale and design principles.
 
 ---
@@ -921,4 +954,4 @@
 | [ADR 0005](adr/0005-rest-rate-limiting.md) | Injected `RateLimiterInterface` for rate limiting |
 | [ADR 0006](adr/0006-search-index-architecture.md) | Static search index design |
 | [ADR 0007](adr/0007-request-dto-validation.md) | DTO-based request validation |
-| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + handler executors for tools |
+| [ADR 0008](adr/0008-tool-execution-architecture.md) | Schema classes + tool executors for tools |
diff --git a/docs/DEVELOPER.md b/docs/DEVELOPER.md
index 88a623a58ee7317397eb35684afd016fbada6057..f48cd9efc02754af7ce0c091cf6fba58633ebaaf
--- a/docs/DEVELOPER.md
+++ b/docs/DEVELOPER.md
@@ -368,7 +368,8 @@
 ```
 
 ### `agentwp_default_function_mapping`
-Override the default intent-to-function mapping.
+Override the default intent-to-function mapping (function suggestions only).
+This does **not** register tool schemas or executors; it only affects `function_suggestions` in responses.
 
 Signature:
 ```
@@ -380,7 +381,8 @@
 ```
 
 ### `agentwp_register_intent_functions`
-Register additional AI functions after defaults are registered.
+Register additional function suggestions after defaults are registered.
+This does **not** create tool schemas or executors; tool definitions live in `src/AI/Functions` and execution in `src/Intent/Tools`.
 
 Signature:
 ```
@@ -431,7 +433,8 @@
 ### Contributor checklist (intent handler)
 
 - [ ] Create a handler in `src/Intent/Handlers` and annotate it with `#[HandlesIntent(...)]` (ADR 0002).
-- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` / `execute_tool()` as appropriate.
+- [ ] Extend `AbstractAgenticHandler` or `BaseHandler` and implement `handle()` as appropriate.
+- [ ] For agentic handlers, implement `getSystemPrompt()`, `getToolNames()`, and `registerToolExecutors()` (ToolDispatcher).
 - [ ] Register the handler in a service provider and tag it with `intent.handler`.
 - [ ] If the handler uses tools, follow the tool checklist below (Phase 4 decision).
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
@@ -452,9 +455,11 @@
 namespace MyPlugin\AgentWP;
 
 use AgentWP\Contracts\AIClientFactoryInterface;
+use AgentWP\Contracts\ToolDispatcherInterface;
 use AgentWP\Contracts\ToolRegistryInterface;
 use AgentWP\Intent\Attributes\HandlesIntent;
 use AgentWP\Intent\Handlers\AbstractAgenticHandler;
+use MyPlugin\AgentWP\Tools\DraftDelayEmailTool;
 
 #[HandlesIntent( 'shipment_delay' )]
 class ShipmentDelayHandler extends AbstractAgenticHandler {
@@ -464,12 +469,17 @@
 	public function __construct(
 		ShipmentServiceInterface $service,
 		AIClientFactoryInterface $clientFactory,
-		ToolRegistryInterface $toolRegistry
+		ToolRegistryInterface $toolRegistry,
+		ToolDispatcherInterface $toolDispatcher
 	) {
-		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry );
+		parent::__construct( 'shipment_delay', $clientFactory, $toolRegistry, $toolDispatcher );
 		$this->service = $service;
 	}
 
+	protected function registerToolExecutors( ToolDispatcherInterface $dispatcher ): void {
+		$dispatcher->registerTool( new DraftDelayEmailTool( $this->service ) );
+	}
+
 	protected function getSystemPrompt(): string {
 		return 'You are a shipment delay assistant. Help draft delay notification emails.';
 	}
@@ -482,12 +492,7 @@
 		return 'Draft a shipment delay notification';
 	}
 
-	public function execute_tool( string $name, array $arguments ) {
-		if ( 'draft_delay_email' === $name ) {
-			return $this->service->draftDelayEmail( $arguments );
-		}
-		return array( 'error' => "Unknown tool: {$name}" );
-	}
+	// Execution lives in DraftDelayEmailTool (src/Intent/Tools/).
 }
 ```
 
@@ -602,14 +607,24 @@
 
 ## Adding a new tool (Phase 4 decision)
 
-AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed by handlers (see ADR 0008).
+AgentWP follows the Phase 4 tooling decision: tools are defined as schema classes and executed via `ToolDispatcher` + tool executors (see ADR 0008).
+
+### Terminology
+
+- **Tool schema**: `src/AI/Functions/*` classes implementing `FunctionSchema` (JSON schema sent to OpenAI).
+- **Tool executor**: `src/Intent/Tools/*` classes implementing `ExecutableToolInterface` (business logic).
+- **Tool dispatch**: `ToolDispatcher` validates arguments and routes tool calls to executors.
+- **Handler exposure**: `getToolNames()` selects which schemas the model can call for a given handler.
 
 ### Contributor checklist (tool)
 
 - [ ] Create a schema class in `src/AI/Functions` extending `AbstractFunction` (name, description, parameters).
 - [ ] Register the schema in `IntentServiceProvider::registerToolRegistry()`.
-- [ ] Add the tool name in the handler's `getToolNames()` and implement execution in `execute_tool()`.
+- [ ] Create an executor in `src/Intent/Tools` implementing `ExecutableToolInterface`.
+- [ ] Register the executor in `IntentServiceProvider::registerToolDispatcher()` or `registerToolExecutors()`.
+- [ ] Add the tool name in the handler's `getToolNames()` to expose the schema.
 - [ ] Cast/validate argument types in execution code (OpenAI returns primitives).
+- [ ] If you want the tool name to appear in response payloads, update `agentwp_register_intent_functions` / `agentwp_default_function_mapping`.
 - [ ] If you introduce or modify hooks, update `docs/EXTENSIONS.md`.
 
 ## Extension guide: custom intent scorer
diff --git a/docs/EXTENSIONS.md b/docs/EXTENSIONS.md
index 5a1a3e7de4477ca0a3a43e7f185ecea89e9f2c68..76de2077a079a77dd27446042efe5da7adef1f79
--- a/docs/EXTENSIONS.md
+++ b/docs/EXTENSIONS.md
@@ -6,6 +6,7 @@
 
 ## Table of Contents
 
+- [Tools vs Functions Terminology](#tools-vs-functions-terminology)
 - [Core Plugin Hooks](#core-plugin-hooks)
 - [Intent System Hooks](#intent-system-hooks)
 - [Intent Classification Hooks](#intent-classification-hooks)
@@ -25,6 +26,19 @@
 
 ---
 
+## Tools vs Functions Terminology
+
+AgentWP uses OpenAI “tools” (function calling) internally, but some hooks still refer to “functions” for historical reasons:
+
+- **Tool schemas** live in `src/AI/Functions/*` and implement `FunctionSchema`. They define the JSON schema sent to OpenAI and are stored in `ToolRegistry`.
+- **Tool executors** live in `src/Intent/Tools/*` and implement `ExecutableToolInterface`. They perform the actual work and are registered with `ToolDispatcher`.
+- **Tool dispatch** is handled by `ToolDispatcher`, which validates arguments and routes tool calls to executors.
+- **Function registry (legacy)** powers `function_suggestions` in response payloads via `FunctionRegistry`. It does **not** register tool schemas or executors.
+
+If you are adding a new tool, you must provide **both** the schema and the executor, register them via a service provider, and ensure the handler exposes the tool via `getToolNames()`. The “function” hooks below only affect suggestions and intent-to-function mapping.
+
+---
+
 ## Core Plugin Hooks
 
 ### `agentwp_register_providers` (Action)
@@ -98,7 +112,8 @@
 
 ### `agentwp_register_intent_functions` (Action)
 
-Register custom AI functions that can be called by intent handlers.
+Register custom function suggestions (legacy) that are surfaced in response payloads.
+This does **not** register tool schemas or executors. To add executable tools, register a tool schema in `ToolRegistry`, a tool executor in `ToolDispatcher`, and expose it via `getToolNames()`.
 
 | Property | Value |
 |----------|-------|
@@ -120,7 +135,8 @@
 
 ### `agentwp_default_function_mapping` (Filter)
 
-Customize which AI functions are associated with each intent.
+Customize which function suggestions are associated with each intent.
+This mapping does **not** affect tool execution; it only populates `function_suggestions` in responses.
 
 | Property | Value |
 |----------|-------|
@@ -561,6 +577,9 @@
 
 ### Registering Custom AI Functions
 
+These hooks register **function suggestions** only. They do not create tool schemas or tool executors.
+To add a callable tool, create a schema in `src/AI/Functions`, an executor in `src/Intent/Tools`, register both in a service provider, and include the tool name in your handler's `getToolNames()`.
+
 ```php
 add_action( 'agentwp_register_intent_functions', function( $registry, $engine ) {
     $registry->register( 'check_shipment_status', new CheckShipmentStatusFunction() );

tokens used
72,624
